<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>jobs_app (jobs) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>jobs_app</h1>
<h2 class="modsummary">Application module for JOBS.</h2>
<div class="description">
<p>Application module for JOBS.
  Normally, JOBS is configured at startup, using a static configuration.
  There is a reconfiguration API <a href="jobs.html" class="seealso">jobs</a>, which is mainly for evolution  
of the system.</p>
 
  <p><em><marker id="Configuring_JOBS">Configuring JOBS</marker></em></p><p>
  A static configuration can be provided via application environment
  variables for the <code>jobs</code> application. The following is a list of  
recognised configuration parameters.</p>
 
  <p><em><marker id="{config,_Filename}">{config, Filename}</marker></em></p><p>
  Evaluate a file using <a href="/home/pete/wefwefwef/docs/other/8445905329/jobs-branch-master/kernel/doc/file.html#script/1" class="seealso">//kernel/file:script/1</a>, treating the data  
returned from the script as a list of configuration options.</p>
 
  <p><em><marker id="{queues,_QueueOptions}">{queues, QueueOptions}</marker></em></p><p>
  Configure a list of queues according to the provided QueueOptions.
  If no queues are specified, a queue named <code>default</code> will be created  
with default characteristics.</p>
 
  <p>Below are the different queue configuration options:</p>
 
  <p><em><marker id="{Name,_Options}">{Name, Options}</marker></em></p><p>
  This is the generic queue configuration pattern.
  <code>Name :: any()</code> is used to identify the queue.</p>
 
  <p>Options:</p>
 
  <p><code>{mod, Module::atom()}</code> provides the name of the queueing module.
  The default module is <code>jobs_queue</code>.</p>
 
  <p><code>{type, fifo | lifo | approve | reject | {producer, F}}</code>
  specifies the semantics of the queue. Note that the specified queue module
  may be limited to only one type (e.g. the <code>jobs_queue_list</code> module only
  supports <code>lifo</code> semantics).</p>
 
  <p>If the type is <code>{producer, F}</code>, it doesn't matter which queue module is
  used, as it is not possible to submit job requests to a producer queue.
  The producer queue will initiate jobs using <code>spawn_monitor(F)</code> at the  
rate given by the regulators for the queue.</p>
 
  <p>If the type is <code>approve</code> or <code>reject</code>, respectively, all other options will  
be irrelevant. Any request to the queue will either be immediately approved  
or immediately rejected.</p>
 
  <p><code>{max_time, integer() | undefined}</code> specifies the longest time that a job
  request may spend in the queue. If <code>undefined</code>, no limit is imposed.</p>
 
  <p><code>{max_size, integer() | undefined}</code> specifies the maximum length (number  
of job requests) of the queue. If the queue has reached the maximum length,  
subsequent job requests will be rejected unless it is possible to remove  
enough requests that have exceeded the maximum allowed time in the queue.</p>
 
  <p><code>{regulators, [{regulator_type(), Opts]}</code> specifies the regulation  
characteristics of the queue.</p>
 
  <p>The following types of regulator are supported:</p>
 
  <p><code>regulator_type() :: rate | counter | group_rate</code></p>
 
  <p>It is possible to combine different types of regulator on the same queue,  
e.g. a queue may have both rate- and counter regulation. It is not possible  
to have two different rate regulators for the same queue.</p>
 
  <p>Common regulator options:</p>
 
  <p><code>{name, term()}</code> names the regulator; by default, a name will be generated.</p>
 
  <p><code>{limit, integer()}</code> defines the limit for the regulator. If it is a rate  
regulator, the value represents the maximum number of jobs/second; if it  
is a counter regulator, it represents the total number of "credits"  
available.</p>
 
  <p><code>{modifiers, [modifier()]}</code></p>
 
  <pre class="sh_erlang">
  modifier() :: {IndicatorName :: any(), unit()}
                | {Indicator, local_unit(), remote_unit()}
                | {Indicator, Fun}
 
  local_unit() :: unit() :: integer()
  remote_unit() :: {avg, unit()} | {max, unit()}
  </pre>
 
  <p>Feedback indicators are sent from the sampler framework. Each indicator
  has the format <code>{IndicatorName, LocalLoadFactor, Remote}</code>.</p>
 
  <p><code>Remote :: [{Node, LoadFactor}]</code></p>
 
  <p><code>IndicatorName</code> defines the type of indicator. It could be e.g. <code>cpu</code>,
  <code>memory</code>, <code>mnesia</code>, or any other name defined by one of the sampler plugins.</p>
 
  <p>The effect of a modifier is calculated as the sum of the effects from local
  and remote load. As the remote load is represented as a list of
  <code>{Node,Factor}</code> it is possible to multiply either the average or the max
  load on the remote nodes with the given factor: <code>{avg,Unit} | {max, Unit}</code>.</p>
 
  <p>For custom interpretation of the feedback indicator, it is possible to
  specify a function <code>F(LocalFactor, Remote) -&gt; Effect</code>, where Effect is a  
positive integer.</p>
 
  <p>The resulting effect value is used to reduce the predefined regulator limit
  with the given number of percentage points, e.g. if a rate regulator has
  a predefined limit of 100 jobs/sec, and <code>Effect = 20</code>, the current rate  
limit will become 80 jobs/sec.</p>
 
  <p><code>{rate, Opts}</code> - rate regulation</p>
 
  <p>Currently, no special options exist for rate regulators.</p>
 
  <p><code>{counter, Opts}</code> - counter regulation</p>
 
  <p>The option <code>{increment, I}</code> can be used to specify how much of the credit  
pool should be assigned to each job. The default increment is 1.</p>
 
  <p><code>{named_counter, Name, Increment}</code> reuses an existing counter regulator.  
This can be used to link multiple queues to a shared credit pool. Note that  
this does not use the existing counter regulator as a template, but actually  
shares the credits with any other queues using the same named counter.</p>
 
  <p>__NOTE__ Currently, if there is no counter corresponding to the alias,  
the entry will simply be ignored during regulation. It is likely that this  
behaviour will change in the future.</p>
 
  <p><em><marker id="{Name,_standard_rate,_R}">{Name, standard_rate, R}</marker></em></p><p>
  A simple rate-regulated queue with throughput rate <code>R</code>, and basic cpu- and  
memory-related feedback compensation.</p>
 
  <p><em><marker id="{Name,_standard_counter,_N}">{Name, standard_counter, N}</marker></em></p><p>
  A simple counter-regulated queue, giving each job a weight of 1, and thus
  allowing at most <code>N</code> jobs to execute concurrently. Basic cpu- and memory-  
related feedback compensation.</p>
 
  <p><em><marker id="{Name,_producer,_F,_Options}">{Name, producer, F, Options}</marker></em>
  A producer queue is not open for incoming jobs, but will rather initiate
  jobs at the given rate.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/2">start(X1, X2) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stop/1">stop(X1) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(X1) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
