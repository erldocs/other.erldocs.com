<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gproc_ps (gproc) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gproc_ps</h1>
<h2 class="modsummary">Gproc Publish/Subscribe patterns  
This module implements a few convenient functions for publish/subscribe.</h2>
<div class="description">
<p>Gproc Publish/Subscribe patterns  
This module implements a few convenient functions for publish/subscribe.</p>
 
  <p>Publish/subscribe with Gproc relies entirely on gproc properties and counters.  
This makes for a very concise implementation, as the monitoring of subscribers and  
removal of subscriptions comes for free with Gproc.</p>
 
  <p>Using this module instead of rolling your own (which is easy enough) brings the
  benefit of consistency, in tracing and debugging.
  The implementation can also serve to illustrate how to use gproc properties and
  counters to good effect.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-event">event() = any()</h3></div>
    <div class="type"><h3 id="type-msg">msg() = any()</h3></div>
    <div class="type"><h3 id="type-scope">scope() = l | g</h3></div>
    <div class="type"><h3 id="type-status">status() = 1 | 0</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="subscribe/1">subscribe(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Subscribe to events of type <code>Event</code></p>
 
  <p>Any messages published with <code>gproc_ps:publish(Scope, Event, Msg)</code> will be delivered to  
the current process, along with all other subscribers.</p>
 
  <p>This function creates a property, <code>{p,Scope,{gproc_ps_event,Event}}</code>, which can be
  searched and displayed for debugging purposes.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Remove subscribtion created using <code>subscribe(Scope, Event)</code></p>
 
  <p>This removes the property created through <code>subscribe/2</code>.</p>
</div></div>
<div class="function">
<h3 id="publish/1">publish(Scope::scope(), Event::event(), Msg::msg()) -&gt; ok</h3>


<div class="description">

<p>Publish the message <code>Msg</code> to all subscribers of <code>Event</code></p>
 
  <p>The message delivered to each subscriber will be of the form:</p>
 
  <p><code>{gproc_ps_event, Event, Msg}</code></p>
 
  <p>The function uses <code>gproc:send/2</code> to send a message to all processes which have a
  property <code>{p,Scope,{gproc_ps_event,Event}}</code>.</p>
</div></div>
<div class="function">
<h3 id="list_subs/1">list_subs(Scope::scope(), Event::event()) -&gt; [pid()]</h3>


<div class="description">

<p>List the pids of all processes subscribing to <code>Event</code></p>
 
  <p>This function uses <code>gproc:select/2</code> to find all properties indicating a subscription.</p>
</div></div>
<div class="function">
<h3 id="create_single/1">create_single(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Creates a single-shot subscription entry for Event</p>
 
  <p>Single-shot subscriptions behave similarly to the <code>{active,once}</code> property of sockets.
  Once a message has been published, the subscription is disabled, and no more messages
  will be delivered to the subscriber unless the subscription is re-enabled using
  <code>enable_single/2</code>.</p>
 
  <p>The function creates a gproc counter entry, <code>{c,Scope,{gproc_ps_event,Event}}</code>, which
  will have either of the values <code>0</code> (disabled) or <code>1</code> (enabled). Initially, the value
  is <code>1</code>, meaning the subscription is enabled.</p>
 
  <p>Counters are used in this case, since they can be atomically updated by both the
  subscriber (owner) and publisher. The publisher sets the counter value to <code>0</code> as soon
  as it has delivered a message.</p>
</div></div>
<div class="function">
<h3 id="delete_single/1">delete_single(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Deletes the single-shot subscription for Event</p>
 
  <p>This function deletes the counter entry representing the single-shot description.
  An exception will be raised if there is no such subscription.</p>
</div></div>
<div class="function">
<h3 id="disable_single/1">disable_single(Scope::scope(), Event::event()) -&gt; integer()</h3>


<div class="description">

<p>Disables the single-shot subscription for Event</p>
 
  <p>This function changes the value of the corresponding gproc counter to <code>0</code> (disabled).</p>
 
  <p>The subscription remains (e.g. for debugging purposes), but with a 'disabled' status.  
This function is insensitive to concurrency, using 'wrapping' ets counter update ops.  
This guarantees that the counter will have either the value 1 or 0, depending on which  
update happened last.</p>
 
  <p>The return value indicates the previous status.</p>
</div></div>
<div class="function">
<h3 id="enable_single/1">enable_single(Scope::scope(), Event::event()) -&gt; integer()</h3>


<div class="description">

<p>Enables the single-shot subscription for Event</p>
 
  <p>This function changes the value of the corresponding gproc counter to <code>1</code> (enabled).</p>
 
  <p>After enabling, the subscriber will receive the next message published for <code>Event</code>,  
after which the subscription is automatically disabled.</p>
 
  <p>This function is insensitive to concurrency, using 'wrapping' ets counter update ops.  
This guarantees that the counter will have either the value 1 or 0, depending on which  
update happened last.</p>
 
  <p>The return value indicates the previous status.</p>
</div></div>
<div class="function">
<h3 id="tell_singles/1">tell_singles(Scope::scope(), Event::event(), Msg::msg()) -&gt; [pid()]</h3>


<div class="description">

<p>Publish <code>Msg</code> to all single-shot subscribers of <code>Event</code></p>
 
  <p>The subscriber status of each active subscriber is changed to <code>0</code> (disabled) before  
delivering the message. This reduces the risk that two different processes will be able  
to both deliver a message before disabling the subscribers. This could happen if the  
context switch happens just after the select operation (finding the active subscribers)  
and before the process is able to update the counters. In this case, it is possible  
that more than one can be delivered.</p>
 
  <p>The way to prevent this from happening is to ensure that only one process publishes
  for <code>Event</code>.</p>
</div></div>
<div class="function">
<h3 id="list_singles/1">list_singles(Scope::scope(), Event::event()) -&gt; [{pid(), status()}]</h3>


<div class="description">

<p>Lists all single-shot subscribers of Event, together with their status</p>
</div></div>
<div class="function">
<h3 id="notify_single_if_true/1">notify_single_if_true(Scope::scope(), Event::event(), F::() -&gt; boolean(), Msg::msg()) -&gt; ok</h3>


<div class="description">

<p>Create/enable a single subscription for event; notify at once if F() -&gt; true</p>
 
  <p>This function is a convenience function, wrapping a single-shot pub/sub around a
  user-provided boolean test. <code>Msg</code> should be what the publisher will send later, if the
  immediate test returns <code>false</code>.</p>
</div></div></div>

<authors>

<aname>Ulf Wiger</aname>
<email>ulf.wiger@feuerlabs.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
