<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>lookup (yxa-cnam) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>lookup</h1>
<h2 class="modsummary">     Varios lookup functions.</h2>
<div class="description">
<p>     Varios lookup functions. Mainly routing logic for our
             three applications incomingproxy, pstnproxy and
             appserver. Most of these functions are called through
             functions in local.erl with the same name, so if you
             want to make them return different values than the
             defaults in this file, make a local.erl specific for
             your domain.
  </p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="lookupregexproute/1">lookupregexproute(Input) -&gt; {proxy, URL} | none</h3>

<ul class="type">
<li><code>Input = string()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    See if we have a regexp that matches Input in the Mnesia
           regexp route table. If we find one, we return a proxy
           tuple with the resulting destination. The regexps in the
           database have a priority field, where higher priority is
           better.</p>
</div></div>
<div class="function">
<h3 id="lookupuser/1">lookupuser(URL) -&gt; {ok, Users, Res} | nomatch</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li><li><code>Users = [string()] | none</code></li><li><code>Res = {proxy, URL} | {proxy, {with_path, URL, Path}} | {relay, URL} | {forward, URL} | {response, Status, Reason} | none</code></li><li><code>URL = #sipurl{}</code></li><li><code>Path = [string()]</code></li><li><code>Status = integer()</code></li><li><code>Reason = string()</code></li></ul>
<div class="description">

<p>    The main 'give me a set of locations for one of our users'
           function that incomingproxy uses, when it determines that
           a request is for one of it's homedomains. Returns
           'nomatch' if no user was found, 'none' if the user(s)
           associated with URL has no registered locations.</p>
</div></div>
<div class="function">
<h3 id="lookupuser_gruu/2">lookupuser_gruu(URL, GRUU) -&gt; {ok, User, Res, Contact}</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li><li><code>GRUU = string()</code></li><li><code>Res = {proxy, URL} | {proxy, {with_path, URL, Path}} | {response, Status, Reason}</code></li><li><code>User = none | string()</code></li><li><code>Contact = #siplocationdb_e{}</code></li></ul>
<div class="description">

<p>    Look up the 'best' contact of a GRUU. Note : used by
           incomingproxy and outgoingproxy</p>
</div></div>
<div class="function">
<h3 id="lookupuser_locations/2">lookupuser_locations(Users, URL) -&gt; Locations</h3>

<ul class="type">
<li><code>Users = [string()]</code></li><li><code>URL = #sipurl{}</code></li><li><code>Locations = [#siplocationdb_e{}]</code></li></ul>
<div class="description">

<p>    Return all locations for a list of users that is suitable
           given a Request-URI. By suitable, we mean that we filter
           out SIP locations if Request-URI was SIPS, unless this
           proxy is configured not to.</p>
</div></div>
<div class="function">
<h3 id="remove_unsuitable_locations/2">remove_unsuitable_locations(Sipurl::URL, Locations) -&gt; [#siplocationdb_e{}]</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li><li><code>Location = [#siplocationdb_e{}]</code></li></ul>
<div class="description">

<p>    Apply local policy for what locations are good to use for
           a particular Request-URI. The default action we do here
           is to remove non-SIPS locations if the Request-URI is
           SIPS, unless we are configured not to.</p>
</div></div>
<div class="function">
<h3 id="lookup_url_to_locations/1">lookup_url_to_locations(URL) -&gt; Locations | nomatch</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li><li><code>Locations = [#siplocationdb_e{}]</code></li></ul>
<div class="description">

<p>    Turn an URL into a set of locations. The URL might map to
           more than one user, in which case the locations for all
           matched users are returned. Locations is sorted according
           to the priority values they have in the location
           database.</p>
</div></div>
<div class="function">
<h3 id="lookup_url_to_addresses/2">lookup_url_to_addresses(Src, Sipurl::URL) -&gt; [string()]</h3>

<ul class="type">
<li><code>Src = atom()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Make up a bunch of possible userdb keys from an URL. Since
           our userdbs store different addresses implicitly
           sometimes, we do this mess to make sure we find one or
           more users for requests destined to an URL.</p>
</div></div>
<div class="function">
<h3 id="lookup_addresses_to_users/1">lookup_addresses_to_users(Addresses) -&gt; [string()]</h3>

<ul class="type">
<li><code>Addresses = [term()]</code></li></ul>
<div class="description">

<p>    Get a list of users that match an input list of addresses.</p>
</div></div>
<div class="function">
<h3 id="lookup_address_to_users/1">lookup_address_to_users(Address) -&gt; [string()]</h3>

<ul class="type">
<li><code>Address = term()</code></li></ul>
<div class="description">

<p>    Get a list of users that match a single address.</p>
</div></div>
<div class="function">
<h3 id="lookupappserver/1">lookupappserver(Key) -&gt; {forward, URL} | {response, Status, Reason}</h3>

<ul class="type">
<li><code>Key = #sipurl{}</code></li><li><code>URL = #sipurl{}</code></li><li><code>Status = integer()</code></li><li><code>Reason = string()</code></li></ul>
<div class="description">

<p>    Get the configured appserver to use for Key. Used in
           incomingproxy.</p>
</div></div>
<div class="function">
<h3 id="lookupdefault/1">lookupdefault(URL) -&gt; {proxy, DefaultRoute} | {response, Status, Reason}</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li><li><code>DefaultRoute = #sipurl{}</code></li><li><code>Status = integer()</code></li><li><code>Reason = string()</code></li></ul>
<div class="description">

<p>    Get the configured default route. Used in incomingproxy.</p>
</div></div>
<div class="function">
<h3 id="lookuppotn/1">lookuppotn(E164::Number) -&gt; {proxy, URL} | {relay, URL} | none</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Look Up Plain Old Telephone Number. Figures out where to
           route a numerical destination. First we try to rewrite it
           to E.164 and do ENUM lookup, and if that fails,
           lookuppstn() on it. Then we try our fallback numerical
           route matching, lookupnumber(). Used in both
           incomingproxy and pstnproxy.</p>
</div></div>
<div class="function">
<h3 id="lookupenum/1">lookupenum(E164::Number) -&gt; {proxy, URL} | {relay, URL} | none</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Does ENUM resolving on an E164 number. If the input number
           is not an E164 number, it is converted first.</p>
</div></div>
<div class="function">
<h3 id="lookuppstn/1">lookuppstn(E164::Number) -&gt; {proxy, URL} | {relay, URL} | none | error</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Rewrites a number to a PSTN URL using the e164_to_pstn
           configuration regexp. If the number is not E164, it is
           converted using rewrite_potn_to_e164() first.</p>
</div></div>
<div class="function">
<h3 id="lookupnumber/1">lookupnumber(Number) -&gt; {proxy, URL} | {relay, URL} | none | error</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Check if there are any numerical matching rules that apply
           (configured regexp 'number_to_pstn'). Called by
           lookuppotn/1 and lookuppstn/1 when the input number is
           not rewriteable to a E164 number.</p>
</div></div>
<div class="function">
<h3 id="rewrite_potn_to_e164/1">rewrite_potn_to_e164(E164::Number) -&gt; Result | error</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>Result = string()</code></li></ul>
<div class="description">

<p>    Rewrite a number to an E164 number using our local
           numbering plan (configured regexp 'internal_to_e164').</p>
</div></div>
<div class="function">
<h3 id="isours/1">isours(URL) -&gt; true | false</h3>

<ul class="type">
<li><code>URL = #sipurl{}</code></li></ul>
<div class="description">

<p>    Check if we have a user matching an URL.</p>
</div></div>
<div class="function">
<h3 id="is_request_to_this_proxy/1">is_request_to_this_proxy(Request) -&gt; true | false</h3>

<ul class="type">
<li><code>Request = #request{}</code></li></ul>
<div class="description">

<p>    Check if a request is destined for this proxy. Not for a
           domain handled by this proxy, but for this proxy itself.</p>
</div></div>
<div class="function">
<h3 id="homedomain/1">homedomain(Domain) -&gt; true | false</h3>

<ul class="type">
<li><code>Domain = string()</code></li></ul>
<div class="description">

<p>    Check if Domain is one of our configured homedomains.</p>
</div></div>
<div class="function">
<h3 id="get_remote_party_number/4">get_remote_party_number(User, Header, URI, DstHost) -&gt; {ok, RPI, Number} | none</h3>

<ul class="type">
<li><code>User = string()</code></li><li><code>Header = #keylist{}</code></li><li><code>URI = #sipurl{}</code></li><li><code>DstHost = term()</code></li><li><code>RPI = #contact{}</code></li><li><code>Number = string()</code></li></ul>
<div class="description">

<p>    This function is used by the pstnproxy to provide a PSTN
           gateway with usefull caller-id information. PSTN networks
           typically gets upset if the "A-number" (calling party) is
           a SIP URL. Different gateways might want the number
           formatted differently, thus the DstHost parameter (a TSP
           gateway to PSTN might only handle E.164 numbers, while a
           PBX might be expecting only a 4-digit extension number).</p>
</div></div>
<div class="function">
<h3 id="format_number_for_remote_party_id/3">format_number_for_remote_party_id(Number, Header, DstHost) -&gt; {ok, Number} | none</h3>

<ul class="type">
<li><code>Number = string()</code></li><li><code>Header = #keylist{}</code></li><li><code>DstHost = term()</code></li><li><code>Number = string()</code></li></ul>
<div class="description">

<p>    Hook for the actual formatting once
           get_remote_party_number/2 has found a number to be
           formatted. This default function simply tries to rewrite
           the number to E.164. If one or more of your PSTN gateways
           wants the Caller-ID information in any other format, then
           override this function in local.erl.</p>
</div></div>
<div class="function">
<h3 id="get_remote_party_name/2">get_remote_party_name(Key, URI) -&gt; {ok, DisplayName} | none</h3>

<ul class="type">
<li><code>Key = string()</code></li><li><code>URI = term()</code></li><li><code>DisplayName = string()</code></li></ul>
<div class="description">

<p>    When pstnproxy receives a request from a PSTN gateway,
           this function is called to see if we can find a nice
           Display Name for the calling party.</p>
</div></div>
<div class="function">
<h3 id="lookup_result_to_str/1">lookup_result_to_str(In) -&gt; string()</h3>

<ul class="type">
<li><code>In = term()</code></li></ul>
<div class="description">

<p>    Pretty-print our various used lookup result values.</p>
</div></div></div>

<authors>

<aname>Magnus Ahltorp</aname>
<email>ahltorp@nada.kth.se</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
