<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gpb_codegen (gpb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gpb_codegen</h1>
<h2 class="modsummary">
  This module is only used internally within the gpb.</h2>
<div class="description">
<p>
  This module is only used internally within the <code>gpb</code>.  
You do not need to use it to compile a protobuf file. You will  
use it indirectly though, since the protobuf compiler uses it heavily.  
Thus, this documentation is mostly for internal use.</p>
 
  <p>This module implements a parse transform, to create syntax trees,  
together with runtime support for subsequent transformation of  
those syntax trees.</p>
 
  <p>Include the file <code>gpb_codegen.hrl</code> or specify
  <code>-compile({parse_transform,gpb_codegen}).</code>  
to activate this parse transform.</p>
 
  <p>The syntax tree operations below are provided. An <code>stree()</code> is a
  syntax tree. Use for example <code>?expr(...)</code> or <code>?case_clause(...)</code> to  
create syntax trees.</p>
 
  <taglist>
    <dt><code>gpb_codegen:mk_fn(FnName, fun(Arg ...) -&gt; Body end) -&gt; stree()</code></dt>
    <item><p>Will be replaced by a parse-tree for a function <code>FnName</code>,
        with <code>Arg</code>s and <code>Body</code> as in the specified fun.
        The <code>FnName</code> is evaluated at run-time, not at compile-time.
    </p></item>
    <dt><code>gpb_codegen:mk_fn(FnName, Fun, RtTransforms) -&gt; stree()</code></dt>
    <item><p>Like <code>gpb_codegen:mk_fn/2</code>, but apply <code>RtTransforms</code> at run-time
          before returning the syntax tree.</p>
        <p>Inside the <code>Fun</code>, a call to <code>call_self</code> is treated specially
          as a recursive call back to the function. NB: It is implemented
          as a simple term replacement, see below, so any occurrences
          of the atom <code>call_self</code> will be replaced regardless of whether
          it is in a function call or not.</p>
        <p>The <code>RtTransforms</code> are applied in the order specified.</p>
        <p>The following <code>RtTransforms</code> are available:</p>
        <taglist>
          <dt><code>{replace_term, Marker::atom(), Replacement::term()}</code></dt>
          <item><p>Replace any occurrences of <code>Marker</code> with the syntax tree
            representing <code>Replacement</code>, which must be something that could
            have occurred as a literal term in some program text,
            thus it must not contain any funs, pids, ports, references or such.
          </p></item>
          <dt><code>{replace_tree, Marker::atom(), Replacement::stree()}</code></dt>
          <item><p>Replace any occurrences of <code>Marker</code> with the syntax tree
            <code>Replacement</code>.
          </p></item>
          <dt><code>{splice_trees, Marker::atom(), Replacements::[stree()]}</code></dt>
          <item><p>For any list that contains <code>Marker</code>, insert the <code>Replacements</code>
            syntax trees instead of the <code>Marker</code>. Such lists are for example
            lists of arguments for a function, lists of elements in a tuple
            and lists of expressions in a function body, but not necessarily
            elements in literal list term, since these may be represented
            as cons elements in the syntax tree.
          </p></item>
          <dt><code>{splice_clauses, Marker::atom(), Replacements::[stree()]}</code></dt>
          <item><p>For case clauses (and function clauses), where the pattern is a
            single atom, <code>Marker</code>, insert the case clauses in <code>Replacements</code>
            instead.
            Use the <code>?case_clause/1</code> macro to create a syntax tree
            for a case clause.
          </p></item>
          <dt><code>{repeat_clauses, Marker::atom, Rep::[[transform()]]}</code></dt>
          <item><p>Repeat template clauses zero or more times: as many times
              as <code>length(Rep)</code>. For each repetition, apply the
              list of transformations to the clause, be it a function clause,
              case clause etc.</p><p>Example: a transformation</p>
              <pre class="sh_erlang">
                 gpb_codegen:format_fn(
                    SomeName,
                    fun(s)     -&gt; v;
                       (Other) -&gt; erlang:error({not_found, Other})
                    end,
                    [{repeat_clauses, s,
                      [[{replace_term, s, Sym}, {replace_term, v, Value}]
                       || {Sym, Value} &lt;- Mapping]}])
              </pre>
          </item>
        </taglist>
    </item>
    <dt><code>gpb_codegen:format_fn(FnName, Fun [, RtTransforms]) -&gt; iolist()</code></dt>
    <item><p>like <code>gpb_codegen:mk_fn/2,3</code>, but format the result into
        an iolist by calling <code>erl_prettypr:format</code>. The resulting
        iolist ends with a newline.</p></item>
    <dt><code>?expr(Expr)</code> or
        <code>gpb_codegen:expr(Expr)</code></dt>
    <item><p>Will be replaced by the syntax tree for a <code>Expr</code>.</p></item>
    <dt><code>?expr(Expr, RtTransforms)</code> or
        <code>gpb_codegen:expr(Expr, RtTransforms)</code></dt>
    <item><p>Like gpb_codegen:expr/1, but apply <code>RtTransforms</code> at run-time.</p></item>
    <dt><code>?exprs(Expr, ..., RtTransforms)</code> or
        <code>gpb_codegen:expr(Expr, ..., RtTransforms)</code></dt>
    <item><p>Like gpb_codegen:expr/1, but create a list of expressions.
        The last parameter must always be a list of run-time transforms.
        The macro form has support only up to some number of params.</p></item>
    <dt><code>?case_clause(Pattern [when Guard] -&gt; Body)</code> or
        <code>gpb_codegen:case_clause(CaseExpression)</code></dt>
    <item><p>Will be replaced with the syntax tree for the case clause.
           Only one case clause, the first, is considered.
           When invoked using the <code>gpb_codegen:case_clause/1</code> function,
           a complete <code>case Expr of Clause end</code>  must be provided;
           the <code>Expr</code> is ignored.</p>
        <p>Examples: <code>?case_clause(1 -&gt; 2)</code> or <code>?case_clause(_ -&gt; other)</code> or
           <code>gpb_codegen:case_clause(case dummy of 1 -&gt; 2 end)</code>.</p>
        <p>In the macro form, some limitations apply:</p>
        <list>
           <item><p>It is only possible to specify one <code>Guard</code>;
               it is _not_ possible to write for example:
                 <code>?case_clause(L when is_list(L), length(L) &gt; 2 -&gt; x)</code>
               This is because the preprocessor will interpret
               it as two macro arguments, delimited by the comma
               in the middle between the two guards.
               This limitation does not apply when using the
               <code>gpb_codegen:case_clause/1</code> approach.</p></item>
           <item><p>It is only possible to specify one <code>Body</code> expression,
               because of the same preprocessor intermingling, but it
               is possible to work around this using <code>begin</code> ... <code>end</code>.
               This limitation does not apply when using the
               <code>gpb_codegen:case_clause/1</code> approach.</p></item>
        </list>
    </item>
    <dt><code>?case_clause(Pattern [when Guard] -&gt; Body, RtTransforms)</code> or
        <code>gpb_codegen:case_clause(CaseExpression, RtTransforms)</code></dt>
    <item><p>Like <code>?case_clause/1</code> or <code>gpb_codegen:case_clause/1</code>
        but apply the RtTransforms to the syntax tree.
    </p></item>
    <dt><code>?if_clause(Guard -&gt; Body[, RtTransforms])</code> or
        <code>gpb_codegen:if_clause(IfExpression[, RtTransforms])</code></dt>
    <item><p>Like <code>?case_clause/1,2</code> but for if-clauses.</p></item>
    <dt><code>?fn_clause(fun(...) -&gt; ... end, [, RtTransforms])</code> or
        <code>gpb_codegen:fn_clause(FunExpression[, RtTransforms])</code></dt>
    <item><p>Like <code>?case_clause/1,2</code> but for function clauses.</p></item>
    <dt><code>?receive_clause(Pattern -&gt; Body, [, RtTransforms])</code> or
        <code>gpb_codegen:receive_clause(receive ... -&gt; ... end[, RtTransforms])</code>
    </dt>
    <item><p>Like <code>?case_clause/1,2</code> but for receive clauses.</p></item>
  </taglist>
 
  <p>Note that there is also a generation-time dependency (ie at
  run-time for the code-generating code) to this module.
  The generated code has no dependency to this module, though.</p></div>


<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
