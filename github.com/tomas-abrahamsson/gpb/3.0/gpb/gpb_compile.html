<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gpb_compile (gpb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gpb_compile</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="file/1">file(File) -&gt; ok | {error, Reason}</h3>


<div class="description">
<p>Equivalent to <a href="#file/2" class="seealso">file(File, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="file/2">file(File, Opts1::Opts) -&gt; CompRet</h3>

<ul class="type">
<li><code>File = string()</code></li><li><code>Opts = [Opt]</code></li><li><code>Opt = {type_specs, boolean()} | type_specs | {verify, optionally | always | never} | {copy_bytes, true | false | auto | integer() | float()} | {strings_as_binaries, boolean()} | strings_as_binaries | {nif, boolean()} | nif | {load_nif, LoadNif} | {i, directory()} | {o, directory()} | {o_erl, directory()} | {o_hrl, directory()} | {o_nif_cc, directory()} | binary | to_msg_defs | return | return_warnings | return_errors | report | report_warnings | report_errors | include_as_lib | use_packages</code></li><li><code>CompRet = ModRet | BinRet | ErrRet</code></li><li><code>ModRet = ok | {ok, Warnings}</code></li><li><code>BinRet = {ok, ModuleName, Code} | {ok, ModuleName, Code, Warnings}</code></li><li><code>ErrRet = {error, Reason} | {error, Reason, Warnings}</code></li><li><code>ModuleName = atom()</code></li><li><code>Code = binary() | ErlAndNifCode</code></li><li><code>ErlAndNifCode = [CodeType]</code></li><li><code>CodeType = {erl, binary()} | {nif, NifCcText}</code></li><li><code>NifCcText = binary()</code></li><li><code>LoadNif = string()</code></li></ul>
<div class="description">

<p>  
Compile a .proto file to a .erl file and to a .hrl file.</p>
 
  <p>The generated .erl file will use the <code>gpb</code> module for runtime  
support for encoding and decoding.</p>
 
  <p>The File must not include path to the .proto file. Example:  
"SomeDefinitions.proto" is ok, while "/path/to/SomeDefinitions.proto"  
is not ok.</p>
 
  <p>The .proto file is expected to be found in a directories specified by an
  <code>{i,directory()}</code> option. It is possible to specify <code>{i,directory()}</code>  
several times, they will be search in the order specified.</p>
 
  <p>The <code>{type_specs,boolean()}</code> option enables or disables <code>::Type()</code>
  annotations in the generated .hrl file. Default is currently
  <code>false</code>. If you set it to <code>true</code>, you may get into troubles for
  messages referencing other messages, when compiling the generated
  files. The <code>type_specs</code> option is equivalent to <code>{type_specs,true}</code>.</p>
 
  <p>The <code>verify</code> option whether or not to generate code for verifying
  that, during encoding, values are of correct type and within range.
  The <code>verify</code> option can have the following values:
  </p><taglist>
     <dt><code>always</code></dt><item><p>Generate code that unconditionally
         verifies values.</p></item>
     <dt><code>never</code></dt><item><p>Generate code that never verifies
         values time. Encoding will fail if a value of the wrong
         type is supplied. This includes forgetting to set a required
         message field. Encoding may silently truncate values out of
         range for some types.</p></item>
     <dt><code>optionally</code></dt><item><p>Generate an <code>encode_msg/2</code> that accepts
         the run-time option <code>verify</code> or <code>{verify,boolean()}</code> for specifying
         whether or not to verify values.</p></item>
  </taglist>
 
  <p>Erlang value verfication either succeeds or crashes with the <code>error</code>
  <code>{gpb_type_error,Reason}</code>. Regardless of the <code>verify</code> option,
  a function, <code>verify_msg/1</code> is always generated.</p>
 
  <p>The <code>copy_bytes</code> option specifies whether when decoding data of
  type <code>bytes</code> (or strings if the <code>strings_as_binaries</code> is set), the
  decoded bytes should be copied or not.  Copying requires the
  <code>binary</code> module, which first appeared in Erlang R14A. When not
  copying decoded bytes, they will become sub binaries of the larger
  input message binary. This may tie up the memory in the input
  message binary longer than necessary after it has been
  decoded. Copying the decoded bytes will avoid creating sub
  binaries, which will in make it possible to free the input message
  binary earlier. The <code>copy_bytes</code> option can have the following values:
  </p><taglist>
    <dt><code>false</code></dt><item><p>Never copy bytes/(sub-)binaries.</p></item>
    <dt><code>true</code></dt><item><p>Always copy bytes/(sub-)binaries.</p></item>
    <dt><code>auto</code></dt><item><p>Copy bytes/(sub-)binaries if the beam vm,
            on which the compiler (this module) is running,
            has the <code>binary:copy/1</code> function. (This is the default)</p></item>
    <dt>integer() | float()</dt><item><p>Copy the bytes/(sub-)binaries if the
            message this many times or more larger than the size of the
            bytes/(sub-)binary.</p></item>
  </taglist>
 
  <p>The <code>strings_as_binaries</code> option specifies whether strings should
  be returned from decoding as strings (list of unicode code points),
  or as binaries (UTF-8 encoded). The <code>copy_bytes</code> option applies
  to strings as well, when the <code>strings_as_binaries</code> option is set.  
Upon encoding, both binaries and lists are accepted.</p>
 
  <p>The <code>{o,directory()}</code> option specifies directory to use for storing
  the generated <code>.erl</code> and <code>.hrl</code> files. Default is the same
  directory as for the proto <code>File</code>.</p>
 
  <p>The <code>{o_erl,directory()}</code>, <code>{o_hrl,directory()}</code>, <code>{o_nif_cc,directory()}</code>,
  options specify output directory for where to generate the <code>.erl</code>
  and <code>.hrl</code> files respectively, and for the NIF C++ file,
  if the <code>nif</code> option is specified. The <code>{o_erl,directory()}</code> option
  overrides any <code>{o,directory()}</code> option, and similarly for the  
other file-type specific output options.</p>
 
  <p>The <code>nif</code> option will cause the compiler to generate nif C++ code
  for that can be linked with the Google protobuf C++ library. The
  purpose for this is speed: the Google protobuf C++ is faster than
  the interpreted Erlang code, but will also lock up an Erlang
  scheduler for as long as it takes for the Google protobuf library
  to complete. This is normally a small amount of time, but can be a
  longer time for huge messages.  The generated nif code can be
  compiled with Erlang R14B or later. The <code>gpb_compile</code> will only
  generate C++ code, it will <i>not</i> compile the generated C++  
code for you. Below is an example of how to generate and compile  
the C++ nif code under Linux. Details may differ from system to  
system.</p>
 
  <pre class="sh_erlang">
       # Use protoc to generate C++ code, and compile it.
       # This will generate x.pb.cc and x.pb.h from x.proto.
       protoc --cpp_out=$PWD x.proto
       g++ -g -fPIC -O3 -I/path/to/protobuf-include -o x.pb.o -c x.pb.cc
       # Generate Erlang code and C++ nif glue code, and compile it.
       # This will generate x.erl, x.hrl and x.nif.cc from x.proto.
       erl -boot start_clean -pa /path/to/gpb/ebin -noshell -noinput +B \
             -I$PWD -nif -s gpb_compile c x.proto
       erlc -Wall x.erl
       g++ -g -fPIC -Wall -O3 -I/path/to/protobuf -o x.nif.o -c x.nif.cc
       # Link all the C++ code together to a shared library.
       g++ -g -fPIC -shared -O3 -Wall -o x.nif.so x.nif.o x.pb.o \
             -L/path/to/protobuf-libs -lprotobuf \
             -Wl,-rpath=/path/to/protobuf-libs
       # Now, if you load x.beam into an Erlang VM, it will
       # automatically load x.nif.so which contains the nif glue C++
       code as well as the protobuf code.
  </pre>
 
  <p>NB: Caveats: Reloading or upgrading code compiled with the <code>nif</code>  
option, might have unexpected behaviour.  The Google protobuf  
library maintains a database of .proto descriptors and will  
complain -- and halt the entire Erlang VM -- if you try to load nif  
code in two different modules that defines a message with the same  
name.  I have also seen cases where protobuf descriptors from old  
versions of the nif code appears to be used even if new code has  
been loaded.  The descriptor database appears to be kept as long as  
the Google C++ protobuf library is loaded, and it is not possible  
to control unloading of a sharerd library in Erlang, at least as of  
R15B01.  Even if the code has been purged and deleted, the shared  
object for the nif, and thus also for the Google protobuf library's  
database, may still be kept in memory.</p>
 
  <p>The <code>load_nif</code> option lets you specify the code to use to load the nif.
  The value to the <code>load_nif</code> must be a text that defines the function
  <code>load_nif/0</code>, that in the end calls <code>erlang:load_nif/2</code>.
  Two special substrings are recognized and substituted in the text:
  </p><taglist>
    <dt><code>{{nifbase}}</code></dt>
    <item><p>The basename of the nif file to be loaded (a string).
        Example: <code>"MyModule.nif"</code> if we are compiling <code>MyModule.proto</code>.
        This is intended to be (part of) the first argument in
        the call to <code>erlang:load_nif/2</code>.</p></item>
    <dt><code>{{loadinfo}}</code></dt>
    <item><p>This is a term that is intended to be the second argument in
        the call to <code>erlang:load_nif/2</code>.</p></item>
  </taglist><p>
  The default for the <code>load_nif</code> is as follows: If the module's
  directory, as returned by<code>code:which/1</code>, is on the form
  <code>/path/to/ebin/Mod.beam</code>, then the nif object code is loaded from
  <code>/path/to/priv/Mod.nif</code>. Otherwise: if <code>code:which/1</code> returns
  <code>/some/path/Mod.beam</code>, then the nif is loaded from
  <code>/some/path/Mod.nif</code>.</p>
 
  <p>The <code>binary</code> option will cause the generated and compiled code be
  returned as a binary. No files will be written. The return value
  will be on the form <code>{ok,Mod,Code}</code> or <code>{ok,Mod,Code,Warnings}</code>
  if the compilation is succesful. This option may be useful
  e.g. when generating test cases. In case the <code>nif</code> option is set,
  the <code>Code</code> will be a list of tuples: <code>{erl,binary()}</code> which
  contains the erlang object byte code, and <code>{nif,binary()}</code> which  
contains the C++ code. You will have to compile the C++ code with a  
C++ compiler, before you can use the erlang code.</p>
 
  <p>The <code>to_msg_defs</code> option will result in <code>{ok,MsgDefs}</code> or
  <code>{ok,MsgDefs,Warns}</code> being returned if the compilation is succesful.
  The returned message definitions can be used with the
  <a href="#msg_defs/2" class="seealso">msg_defs/2</a> or <a href="#msg_defs/3" class="seealso">msg_defs/3</a> functions.</p>
 
  <taglist>
    <dt><code>report_errors</code>/<code>report_warnings</code></dt>
    <item><p>Causes errors/warnings to be printed as they occur.</p></item>
    <dt><code>report</code></dt>
    <item><p>This is a short form for both <code>report_errors</code> and
        <code>report_warnings</code>.</p></item>
    <dt><code>return_errors</code></dt>
    <item><p>If this flag is set, then  <code>{error,ErrorList,WarningList}</code> is
        returned when there are errors.</p></item>
    <dt><code>return_warnings</code></dt>
    <item><p>If  this  flag  is set, then an extra field containing <code>WarningList</code>
        is added to the tuples returned on success.</p></item>
    <dt><code>return</code></dt>
    <item><p>This is a short form for both <code>return_errors</code> and
        <code>return_warnings</code>.</p></item>
  </taglist>
 
  <p>See <a href="#format_error/1" class="seealso">format_error/1</a> for a way to turn an error <i>Reason</i> to  
plain text.</p>
 
  <p>If the <code>include_as_lib</code> option is set, the generated code will include  
gpb.hrl as a library, which is necessary if dependencies are managed with  
Rebar. Otherwise, the header file is included directly and must be located  
in the path, which is default behaviour.</p>
 
  <p>The <code>use_packages</code> option instructs gpb to prepend the name of a package
  to every message it contains. If no package is defined, nothing will be
  prepended. This enables the reference of messages in other packages which
  would otherwise not be possible. However, for reasons of backward
  compatibility, this option is disabled by default.</p>
</div></div>
<div class="function">
<h3 id="msg_defs/2">msg_defs(Mod, Defs) -&gt; CompRet</h3>


<div class="description">
<p>Equivalent to <a href="#msg_defs/3" class="seealso">msg_defs(Mod, Defs, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="msg_defs/3">msg_defs(Mod, Defs0::Defs, Opts0::Opts) -&gt; CompRet</h3>

<ul class="type">
<li><code>Mod = atom()</code></li><li><code>Defs = [Def]</code></li><li><code>Def = {{enum, EnumName}, Enums} | {{msg, MsgName}, MsgFields}</code></li><li><code>EnumName = atom()</code></li><li><code>Enums = [{Name, integer()}]</code></li><li><code>Name = atom()</code></li><li><code>MsgName = atom()</code></li><li><code>MsgFields = [#field{}]</code></li></ul>
<div class="description">

<p>
  Compile a list of pre-parsed definitions to file or to a binary.
  See <a href="#file/2" class="seealso">file/2</a> for information on options and return values.</p>
</div></div>
<div class="function">
<h3 id="format_error/2">format_error(Reason::{error, Reason} | Reason) -&gt; io_list()</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Produce a plain-text error message from a reason returned by
  for instance <a href="#file/2" class="seealso">file/2</a> or <a href="#msg_defs/2" class="seealso">msg_defs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="format_warning/1">format_warning(X::Reason) -&gt; io_list()</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Produce a plain-text error message from a reason returned by
  for instance <a href="#file/2" class="seealso">file/2</a> or <a href="#msg_defs/2" class="seealso">msg_defs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="c/0">c() -&gt; no_return()</h3>


<div class="description">

<p>Command line interface for the compiler.
  With no proto file to compile, print a help message and exit.</p>
</div></div>
<div class="function">
<h3 id="c/1">c(Files::[string() | atom()]) -&gt; no_return()</h3>


<div class="description">

<p>This function is intended as a command line interface for the compiler.
  Call it from the command line as follows:
  </p><pre class="sh_erlang">     erl &lt;erlargs&gt; [gpb-opts] -s gpb_compile c File.proto ...
     erl &lt;erlargs&gt; -s gpb_compile c File.proto ... -extra [gpb-opts]</pre><p>
  The <code>&lt;erlargs&gt;</code> can be <code>-noshell -noinput +B -boot start_clean -pa SomeDir</code></p>
 
  <p>The following options are supported:
  </p><taglist>
    <dt><code>-IDir</code> <code>-I Dir</code></dt>
    <item><p>Specify include directory.
        Option may be specified more than once to specify
        several include directories.</p></item>
    <dt><code>-o Dir</code></dt>
    <item><p>Specify output directory for where to generate
        the <i>ProtoFile</i>.erl and <i>ProtoFile</i>.hrl</p></item>
    <dt><code>-o-erl Dir</code> | <code>-o-hrl Dir</code> | <code>-o-nif-cc Dir</code></dt>
    <item><p>Specify output directory for where to generate
        the <i>ProtoFile</i>.erl and <i>ProtoFile</i>.hrl respectively,
        and for the NIF C++ file, if the <code>-nif</code> option is specified.
        The <code>-o-erl Dir</code> option overrides any <code>-o Dir</code> option, and
        similarly for the other file-type specific output options.</p></item>
    <dt><code>-v optionally | always | never</code></dt>
    <item><p>Specify how the generated encoder should
        verify the message to be encoded.</p></item>
    <dt><code>-nif</code></dt>
    <item><p>Generate nifs for linking with the protobuf C(++) library.</p></item>
    <dt><code>-load_nif FunctionDefinition</code></dt>
    <item><p>Specify <code>FunctionDefinition</code> as the text that defines the
        function <code>load_nif/0</code>.  This is called as the <code>on_load</code>
        hook for loading the NIF.  See also the doc for the <code>load_nif</code>
        option in the <a href="#file/2" class="seealso">file/2</a> function.</p></item>
    <dt><code>-c true | false | auto | integer() | float()</code></dt>
    <item><p>Specify how or when the generated decoder should
        copy fields of type <code>bytes</code>. See the <code>copy_bytes</code> option
        for the function <a href="#file/2" class="seealso">file/2</a> for more info.</p></item>
    <dt><code>-strbin</code></dt>
    <item><p>Specify that decoded strings should be returend as binaries,
        instead of as strings (lists).</p></item>
    <dt><code>-il</code></dt>
    <item><p>Generate code that include gpb.hrl using <code>-include_lib</code>
        instad of <code>-include</code>, which is the default.</p></item>
    <dt><code>--help</code> or <code>-h</code></dt>
    <item><p>Show help.</p></item>
    <dt><code>--version</code> or <code>-V</code></dt>
    <item><p>Show the version number of gpb.</p></item>
  </taglist><p>
  If several files are specified, each is compiled individually, no
  checking is done for instance for multiply defined messages or
  fields across files, such as the <code>protoc</code> does.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
