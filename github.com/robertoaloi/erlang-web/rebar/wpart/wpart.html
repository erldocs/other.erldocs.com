<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>wpart (wpart) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>wpart</h1>
<h2 class="modsummary">An interface to the Wpart application.</h2>
<div class="description">
<p>An interface to the Wpart application.
   Only this module should be used to access the Wpart application
   specific module, because the internal implementation of the
   particular functions could be changed in the future.<br />
   Wpart defines also a behaviour - the set of the functions that
   each of the wpart should implement:
   </p><list>
   <item><p><i>handle_call(XmlElement)</i> - the function that should return
   a Xmerl structure that will replace the specific wpart:something tag.
   </p></item>
   <item><p><i>load_tpl()</i> - if wpart uses the tpls (what is strongly recommended
   for clarity and/or performance reasons) they should be prepared before
   using - it is done during the system start. <i>load_tpl/0</i>
   should insert the prepared tpl into the <i>templates</i> ETS table.
   Moreover it is recommended using the <i>wpart_gen</i> module - it
   implements all necessary functions that handle the tpl splitting,
   building and loading.</p></item>
   <item><p><i>build_html_tag/4</i> - function responsible for building
   part of the form during the automatic form building phase.</p></item>
   </list></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="fget/1">fget(Key::string()) -&gt; Result::term()</h3>


<div class="description">

<p>Retrives the value from the request dictionary.
  The ":" character in key separates the levels of the
  dictionaries: the first part is used to retrive the main
  one, the second is used for obtaining the value from the
  dictionary got in the prior step. <br />
  The example of the usage is accessing the session variables:
  by calling <i>wpart:fget("session:user")</i> we are accesing
  at first the dictionary <i>session</i> and then the value
  <i>user</i> within it.</p>
</div></div>
<div class="function">
<h3 id="fset/1">fset(Key::string(), Value::term()) -&gt; none()</h3>


<div class="description">

<p>Sets the value in the request dictionary.
  The meaning of the key is analogous as in <i>fget/1</i>
  function.</p>
<p><em>See also:</em> <a href="#fget/1" class="seealso">fget/1</a>.</p>
</div></div>
<div class="function">
<h3 id="select/1">select(XPath::string(), XmlStructure::tuple()) -&gt; Result::tuple()</h3>


<div class="description">

<p>Extracts the nodes from the xml tree according to <i>XPath</i>.
 </p>
</div></div>
<div class="function">
<h3 id="has_attribute/1">has_attribute(XPath::string(), XmlStructure::tuple()) -&gt; AttrVal::string() | false</h3>


<div class="description">

<p>Extracts the attribute value according to the <i>XPath</i>.
  If no attribute is found, the <i>false</i> atom is returned.<br />
  The example of the usage: <i>wpart:has_attribute("attribute::name", E)</i>.
 </p>
</div></div>
<div class="function">
<h3 id="has_attribute/1-1">has_attribute(XPath::string(), DefaultVal::term(), XmlStructure::tuple()) -&gt; AttrVal::string() | DefaultVal</h3>


<div class="description">

<p>Extracts the attribute value according to the <i>XPath</i>.
  If no attribute is found, <i>DefaultVal</i> is returned.
 </p>
</div></div>
<div class="function">
<h3 id="eval/1">eval(XMLElement::[tuple()] | tuple()) -&gt; [string()] | string()</h3>


<div class="description">

<p>Expands the XML elements.
  If the element's namespace is set to <i>wpart</i> - it will be expanded.
 </p>
</div></div>
<div class="function">
<h3 id="format/1">format(Value::term(), XMLStructure::tuple()) -&gt; FormattedValue::term()</h3>


<div class="description">

<p>Formats the <i>Value</i>.
  If the <i>XMLStructure</i> has the attribute <i>format</i>
  its value is passed to the formatter. In other case, the passed
  value is returned.
 </p>
</div></div>
<div class="function">
<h3 id="eval_file/1">eval_file(Filename::string(), XPath::string()) -&gt; Result::[string()] | string()</h3>


<div class="description">

<p>Evaluates the part specified by <i>XPath</i> of the file.
  The behaviour is the same as reading the file, applying <i>select/2</i>
  and calling <i>eval/1</i> by hand.
 </p>
</div></div>
<div class="function">
<h3 id="expand_string/1">expand_string(String::string()) -&gt; ExpandedString::string()</h3>


<div class="description">

<p>Expands the string basing on the formatting conventions.
  The text between the curly brackets ({}) will be replaced with
  the corresponding value fetched from the request dictionary
  (the key to the value is the text itself). It is also possible to
  specify formatter for the value.<br />
  For example:
  </p><list>
  <item><p>"{this_is_a_key}" will be changed to the value fetched
  from the request dictionary, stored under the key "this_is_the_key".</p></item>
  <item><p>"{[my_formatter(formatting_rule)]this_is_a_key}" - will retrive the
  value from the request dictionary (key = "this_is_a_key") and format that value
  by calling <i>wtype_my_formatter:handle_call("formatting_rule", Value)</i></p></item>
  </list><p>
 </p>
</div></div>
<div class="function">
<h3 id="search/2">search(Value, Tokens) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="finsert/1">finsert(Key::string(), Value::term()) -&gt; any()</h3>


<div class="description">

<p>Inserts the value to the request dictionary.
  The passed key must contain a colon (:) that separates
  the two level ditionaries.
 </p>
</div></div>
<div class="function">
<h3 id="xml2proplist/1">xml2proplist(XML::[tuple()]) -&gt; Proplist::[tuple()]</h3>


<div class="description">

<p>Transforms the list of the attributes stored as #xmlAttribute records
  to the proplist format: [{"attribute_name", "attribute_value"}].
 </p>
</div></div>
<div class="function">
<h3 id="proplist2html/1">proplist2html(AttributesProplist::[tuple()]) -&gt; HTML::string()</h3>


<div class="description">

<p>Transforms a proplist of attributes to the string that could be inserted into the HTML tag.
  This functions allows to insert the proplist of attributes straight to the
  tpl file. <br />
  Note that the proplist must be in a proper format (both keys and values
  must be strings),</p>
<p><em>See also:</em> <a href="#normalize_html_attrs/1" class="seealso">normalize_html_attrs/1</a>.</p>
</div></div>
<div class="function">
<h3 id="getValue/1">getValue(Proplist::[tuple()]) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="normalize_html_attrs/1">normalize_html_attrs(AttributesProplist::[tuple()]) -&gt; NormalizedProplist::[tuple()]</h3>


<div class="description">

<p>Converts all the attributes to the one - proplist2html compatible format.
  Each key and value are transformed to the strings, so it is possible to
  use that type of list in proplist2html function.
 </p>
</div></div>
<div class="function">
<h3 id="fdelete/1">fdelete(Key0::string()) -&gt; ok</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Martin Carlson</aname>
<email>martin@erlang-consulting.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
