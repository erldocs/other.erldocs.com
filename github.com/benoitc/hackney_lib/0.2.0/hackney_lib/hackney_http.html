<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>hackney_http (hackney_lib) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>hackney_http</h1>
<h2 class="modsummary">HTTP parser in pure Erlang   
This parser is able to parse HTTP responses and requests in a   
streaming fashion.</h2>
<div class="description">
<p>HTTP parser in pure Erlang   
This parser is able to parse HTTP responses and requests in a   
streaming fashion. If not set it will be autodetect the type of   
binary parsed, if it's a request or a response.</p>
  
   <p>Internally it is keeping a buffer for intermediary steps but don't   
keep any state in memory.</p>
  
  
   <p>The first time you initialise a parser using <code>hackney_http:parser/0</code>
   or <code>hackney_http:parser/1</code> you will receive an opaque record You can
   then process it using the function <code>hackney_http:execute/2</code>.</p>
  
   <p>Each steps will return the status, some data and the new parser that
   you can process later with <code>hackney_http:execute/2</code> when
   <code>{more, ...}</code>  is returnned or <code>hackney_http:execute/1</code> in other   
cases:</p>
  
   - <code>{response, http_version(), status(), http_reason(), parser()}</code>:
   when the first line of a response is parsed
   - <code>{request, http_version(), http_method(), uri(), parser()}</code>:
   when the first line of a request (on servers) is parsed
   - <code>{more, parser()}</code>: when the parser need more
   data. The new data should be passed to <code>hackney_http:execute/2</code> with
   the new parser() state received.
   - <code>{header, {Name :: binary(), Value :: binary()}, parser()}</code>:
   when an header has been parsed. To continue the parsing you must
   call the given <code>parser()</code> with <code>hackney_http:execute/1</code>.
   - <code>{headers_complete, parser()}</code> : when all headers have been parsed.
   To continue the parsing you must call the given <code>parser()</code> state
   with <code>hackney_http:execute/1</code>.
   - <code>{more, parser(), binary()}</code>: on body, when
   the parser need more data. The new data should be passed to
   <code>hackney_http:execute/2</code> (with <code>parser()</code> ) when received. The binary at the end of the
   tuple correspond to the actual buffer of the parser. It may be used
   for other purpose, like start to parse a new request on pipeline
   connections, for a proxy...
   - <code>{ok, binary(), parser()}</code>: on body, when a chunk has been
   parsed. To continue the parsing you must call
   <code>hackney_http:execute/1</code> with the given <code>parser()</code>.
   - <code>{done, binary()}</code>: when the parsing is done. The binary
   given correpond to the non parsed part of the internal buffer.
   - <code>{error, term{}}</code>: when an error happen</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-body_result">body_result() = {more, <a href="#type-parser" class="seealso">parser()</a>, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {ok, binary(), <a href="#type-parser" class="seealso">parser()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {done, binary()}</h3></div>
    <div class="type"><h3 id="type-http_method">http_method() = binary()</h3></div>
    <div class="type"><h3 id="type-http_reason">http_reason() = binary()</h3></div>
    <div class="type"><h3 id="type-http_version">http_version() = {integer(), integer()}</h3></div>
    <div class="type"><h3 id="type-parser">parser()</h3></div>
    <div class="type"><h3 id="type-parser_option">parser_option() = request<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| response<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| auto<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {max_empty_lines, integer()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {max_line_length, integer()}</h3></div>
    <div class="type"><h3 id="type-parser_options">parser_options() = [<a href="#type-parser_option" class="seealso">parser_option()</a>]</h3></div>
    <div class="type"><h3 id="type-parser_result">parser_result() = {response,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-http_version" class="seealso">http_version()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-status" class="seealso">status()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-http_reason" class="seealso">http_reason()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-parser" class="seealso">parser()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {request,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-http_version" class="seealso">http_version()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-http_method" class="seealso">http_method()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-uri" class="seealso">uri()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-parser" class="seealso">parser()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {more, <a href="#type-parser" class="seealso">parser()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-body_result" class="seealso">body_result()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {error, term()}</h3></div>
    <div class="type"><h3 id="type-status">status() = integer()</h3></div>
    <div class="type"><h3 id="type-uri">uri() = binary()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="parser/0">parser() -&gt; parser()</h3>


<div class="description">

<p>Create a new HTTP parser. The parser will autodetect if the parded
  binary is a response or a request.</p>
</div></div>
<div class="function">
<h3 id="parser/1">parser(Options::parser_options()) -&gt; parser()</h3>


<div class="description">

<p>create a new HTTP parser with options. By default the type of  
parsed binary will be detected.</p>
 
  <p>Available options:
  </p><list>
    <item><p><code>auto</code> : autodetect if the binary parsed is a response or a
    request (default).</p></item>
    <item><p><code>response</code>: set the parser to parse a response</p></item>
    <item><p><code>request</code>: set the parser to parse a request (server)</p></item>
    <item><p><code>{max_line_lenght, Max}</code>: set the maximum size of a line parsed
    before we give up.</p></item>
    <item><p><code>{max_lines_empty, Max}</code>: the maximum number of empty line we
    accept before the first line happen</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="get/1">get(Parser::parser(), Props::atom() | [atom()]) -&gt; any()</h3>


<div class="description">

<p>retrieve a parser property.
  Properties are:
   - <code>buffer</code>: internal buffer of the parser (non parsed)
   - <code>state</code>: the current state (on_status, on_header, on_body, done)
   - <code>version</code>: HTTP version
   - <code>content_length</code>: content length header if any
   - <code>transfer_encoding</code>: transfer encoding header if any
   - <code>content_type</code>: content type header if any
   - <code>location</code>: location header if any
   - <code>connection</code>: connection header if any.</p>
</div></div>
<div class="function">
<h3 id="execute/1">execute(Hparser::#hparser{}) -&gt; parser_result()</h3>


<div class="description">

<p>Execute the parser with the current buffer.</p>
</div></div>
<div class="function">
<h3 id="execute/2">execute(Hparser::#hparser{}, Bin::binary()) -&gt; parser_result()</h3>


<div class="description">

<p>Execute the parser with the new buffer</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
