<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>hackney (hackney) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>hackney</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-client">client()</h3></div>
    <div class="type"><h3 id="type-client_ref">client_ref() = term()</h3></div>
    <div class="type"><h3 id="type-url">url() = #hackney_url{}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/0">start() -&gt; term()
</h3>


<div class="description">

<p>Start the hackney process. Useful when testing using the shell.</p>
</div></div>
<div class="function">
<h3 id="start/1">start(PoolHandler) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; term()
</h3>


<div class="description">

<p>Stop the hackney process. Useful when testing using the shell.</p>
</div></div>
<div class="function">
<h3 id="connect/1">connect(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="connect/2">connect(Hackney_url, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="connect/3">connect(Transport, Host, Port) -&gt; term()
</h3>


<div class="description">

<p>connect a socket and create a client state.</p>
</div></div>
<div class="function">
<h3 id="connect/4">connect(Transport, Host, Port, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="controlling_process/1">controlling_process(Ref::client_ref(), Pid::pid()) -&gt; ok | {error, closed | not_owner | atom()}</h3>


<div class="description">

<p>Assign a new controlling process <em>Pid</em> to <em>Client</em>.</p>
</div></div>
<div class="function">
<h3 id="cancel_request/1">cancel_request(Ref::client_ref()) -&gt; {ok, {atom(), socket() (see module inet), binary(), response_state() (see module hackney_response)}} | {error, term()}</h3>


<div class="description">

<p>Extract raw informations from the client context  
This feature can be useful when you want to create a simple proxy, rerouting on the headers and the status line and continue to forward the connection for example.</p>
 
  <p>return: <code>{ResponseState, Transport, Socket, Buffer} | {error, Reason}</code>
  </p><list>
  <item><p><code>Response</code>: waiting_response, on_status, on_headers, on_body</p></item>
  <item><p><code>Transport</code>: The current transport module</p></item>
  <item><p><code>Socket</code>: the current socket</p></item>
  <item><p><code>Buffer</code>: Data fetched but not yet processed</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="setopts/1">setopts(Ref::client_ref(), Options::list()) -&gt; ok</h3>


<div class="description">

<p>set client options.
  Options are:
  - <code>async</code>: to fetch the response asynchronously
  - <code>{async, once}</code>: to receive the response asynchronosly once time.
  To receive the next message use the function <code>hackney:stream_next/1</code>.
  - <code>{stream_to, pid()}</code>: to set the pid where the messages of an
  asynchronous response will be sent.
  - <code>{follow_redirect, bool()}</code> : if true a redirection will be
  followed when the response is received synchronously
  - <code>{force_redirect, bool()}</code> : if true a 301/302 redirection will be
  followed even on POST.
  - <code>{max_redirect, integer()}</code> the maximum number of redirections that
  will be followed</p>
</div></div>
<div class="function">
<h3 id="close/1">close(Ref) -&gt; term()
</h3>


<div class="description">

<p>close the client</p>
</div></div>
<div class="function">
<h3 id="request_info/1">request_info(Ref::client_ref()) -&gt; list()</h3>


<div class="description">

<p>get request info</p>
</div></div>
<div class="function">
<h3 id="location/1">location(Ref::client_ref()) -&gt; binary()</h3>


<div class="description">

<p>return the requested location</p>
</div></div>
<div class="function">
<h3 id="request/1">request(URL::binary() | list()) -&gt; {ok, integer(), list(), client_ref()} | {ok, integer(), list()} | {error, term()}</h3>


<div class="description">

<p>make a request</p>
</div></div>
<div class="function">
<h3 id="request/1-1">request(Method::term(), URL::binary() | list()) -&gt; {ok, integer(), list(), client_ref()} | {ok, integer(), list()} | {error, term()}</h3>


<div class="description">

<p>make a request</p>
</div></div>
<div class="function">
<h3 id="request/1-2">request(Method::term(), URL::binary() | list(), Headers::list()) -&gt; {ok, integer(), list(), client_ref()} | {ok, integer(), list()} | {error, term()}</h3>


<div class="description">

<p>make a request</p>
</div></div>
<div class="function">
<h3 id="request/1-3">request(Method::term(), URL::binary() | list(), Headers::list(), Body::term()) -&gt; {ok, integer(), list(), client_ref()} | {ok, integer(), list()} | {error, term()}</h3>


<div class="description">

<p>make a request</p>
</div></div>
<div class="function">
<h3 id="request/1-4">request(Method::term(), Hackney_url::url() | binary(), Headers::list(), Body::term(), Options0::list()) -&gt; {ok, integer(), list(), client_ref()} | {ok, client_ref()} | {error, term()}</h3>


<div class="description">

<p>make a request</p>
 
  <p>Args:
  </p><list>
  <item><p><em>Method</em>&gt;: method used for the request (get, post,
  ...)</p></item>
  <item><p><em>Url</em>: full url of the request</p></item>
  <item><p><em>Headers</em> Proplists </p></item>
  <item><p><em>Body</em>:
       </p><list>
       <item><p>{form, [{K, V}, ...]}: send a form url encoded</p></item>
       <item><p>{multipart, [{K, V}, ...]}: send a form using multipart</p></item>
       <item><p>{file, "/path/to/file"}: to send a file</p></item>
       <item><p>Bin: binary or iolist</p></item>
       </list><p>
   </p></item>
   <item><p><em>Options:</em> <code>[{connect_options, connect_options(),
   {ssl_options, ssl_options()}, Others]</code></p></item>
       <item><p><code>connect_options()</code>: The default connect_options are
       <code>[binary, {active, false}, {packet, raw}])</code> . Vor valid options
       see the gen_tcp options.</p></item>
 
       <item><p><code>ssl_options()</code>: See the ssl options from the ssl
       module.</p></item>
 
       <item><p><code>async</code>: receive the response asynchronously
       The function return {ok, StreamRef}.
       When {async, once} is used the response will be received only once. To
       receive the other messages use the function
       <code>hackney:stream_next/1</code>
       </p></item>
 
       <item><p><code>{stream_to, pid()}</code>: If async is true or once, the response
       messages will be sent to this PID.</p></item>
 
       <item><p><code>{cookie, list() | binary()}</code> : to set a cookie or a
       list of cookies.</p></item>
 
       <item><p><em>Others options are</em>:
       </p><list>
           <item><p><code>{follow_redirect, boolean}</code>: false by default, follow a
           redirection</p></item>
           <item><p><code>{max_redirect, integer}</code>: 5 by default, the maximum of
           redirection for a request</p></item>
           <item><p><code>{force_redirect, boolean}</code>: false by default, to force the
           redirection even on POST</p></item>
           <item><p><code>{proxy, proxy_options()}</code>: to connect via a proxy.</p></item>
           <item><p><code>insecure</code>: to perform "insecure" SSL connections and
           transfers without checking the certificate</p></item>
           <item><p><code>{connect_timeout, infinity | integer()}</code>: timeout used when
           estabilishing a connection, in milliseconds. Default is 8000</p></item>
           <item><p><code>{recv_timeout, infinity | integer()}</code>: timeout used when
           receiving a connection. Default is infinity</p></item>
       </list><p>
 
       </p><p><blocquote>Note: if the response is async, only
       <code>follow_redirect</code> is take in consideration for the redirection.
       If a valid redirection happen you receive the messages:
       <list>
         <item><code>{redirect, To, Headers</code>}</item>
         <item><code>{see_other, To, Headers}</code> for status 303 POST requests.</item>
       </list></blocquote></p>
 
       </item>
 
       <item><p><code>proxy_options()</code>:  options to connect by a proxy:
       </p><list>
           <item><p>binary(): url to use for the proxy. Used for basic HTTP
           proxy</p></item>
           <item><p>{Host::binary(), Port::binary}: Host and port to connect,
           for HTTP proxy</p></item>
           <item><p>{socks5, Host::binary(), Port::binary()}: Host and Port
           to connect to a socks5 proxt.</p></item>
           <item><p>{connect, Host::binary(), Port::binary()}: Host and Port
           to connect to an HTTP tunnel.</p></item>
       </list>
       </item>
   </list>
 
   <p><bloquote>Note: instead of doing <code>hackney:request(Method, ...)</code> you can
   also do <code>hackney:Method(...)</code> if you prefer to use the REST
   syntax.</bloquote></p>
 
   <p>Return:
   </p><list>
   <item><p><code>{ok, ResponseStatus, ResponseHeaders}</code>: On HEAD
   request if the response succeded.</p></item>
   <item><p><code>{ok, ResponseStatus, ResponseHeaders, Ref}</code>: when
   the response succeded. The request reference is used later to
   retrieve the body.</p></item>
   <item><p><code>{ok, Ref}</code> Return the request reference when you
   decide to stream the requet. You can use the returned reference to
   stream the request body and continue to handle the response.</p></item>
   <item><p><code>{error, {closed, PartialBody}}</code> A body was expected but
   instead the remote closed the response after sending the headers.
   Equivalent to the curl  message <code>no chunk, no close, no size.
   Assume close to signal end</code>. </p></item>
   <item><p><code>{error, term()}</code> other errors.</p></item>
   </list>
</div></div>
<div class="function">
<h3 id="send_request/3">send_request(Ref, Req, Options) -&gt; term()
</h3>


<div class="description">

<p>send a request using the current client state and pass new
  options to it.</p>
</div></div>
<div class="function">
<h3 id="send_request/2">send_request(Ref, Req) -&gt; term()
</h3>


<div class="description">

<p>send a request using the current client state</p>
</div></div>
<div class="function">
<h3 id="send_body/1">send_body(Ref::client_ref(), Body::term()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>send the request body until eob. It's issued after sending a request using
  the <code>request</code> and <code>send_request</code> functions.</p>
</div></div>
<div class="function">
<h3 id="finish_send_body/1">finish_send_body(Ref) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="send_multipart_body/1">send_multipart_body(Ref::client_ref(), Body::term()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>send a multipart body until eof
  Possible value are :
  </p><list>
  <item><p><code>eof</code>: end the multipart request</p></item>
  <item><p><code>{file, Path}</code>: to stream a file</p></item>
  <item><p><code>{file, Path, ExtraHeaders}</code>: to stream a file</p></item>
  <item><p><code>{data, Name, Content}</code>: to send a full part</p></item>
  <item><p><code>{data, Name, Content, ExtraHeaders}</code>: to send a full part</p></item>
  <item><p><code>{part, Name, Len}</code>: to start sending a part with a known length in a streaming
  fashion</p></item>
  <item><p><code>{part, Name, Len, ExtraHeader}</code>: to start sending a part in a streaming
  fashion</p></item>
  <item><p><code>{part, Name}</code>: to start sending a part without length in a streaming
  fashion</p></item>
  <item><p><code>{part, Name, ExtraHeader}</code>: to start sending a part without
  lengthin a streaming  fashion</p></item>
  <item><p><code>{part_bin, Bin}</code>: To send part of part</p></item>
  <item><p><code>{part, eof}</code>: To notify the end of the part </p></item>
  <item><p><code>{mp_mixed, Name, MixedBoundary}</code>: To notify we start a part with a a mixed
  multipart content</p></item>
  <item><p><code>{mp_mixed_eof, MixedBoundary}</code>: To notify we end a part with a a mixed
  multipart content</p></item>
  </list><p>
 
  Note: You can calculate the full length of a multipart stream using
  the function <code>hackney_multipart:len_mp_stream/2</code> .</p>
</div></div>
<div class="function">
<h3 id="start_response/1">start_response(Ref::client_ref()) -&gt; {ok, integer(), list(), client_ref()} | {ok, client_ref()} | {error, term()}</h3>


<div class="description">

<p>start a response.
  Useful if you stream the body by yourself. It will fetch the status
  and headers of the response. and return</p>
</div></div>
<div class="function">
<h3 id="cookies/1">cookies(Headers::list()) -&gt; list()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stream_body/1">stream_body(Ref::client_ref()) -&gt; {ok, binary()} | done | {error, term()}</h3>


<div class="description">

<p>Stream the response body.</p>
</div></div>
<div class="function">
<h3 id="stream_multipart/1">stream_multipart(Ref::client_ref()) -&gt; {headers, list()} | {body, binary()} | eof | end_of_part | {error, term()}</h3>


<div class="description">

<p>Stream the response body.</p>
 
  <p>Return:
  </p><list>
  <item><p><code>{headers, Headers}</code>: the part headers</p></item>
  <item><p><code>{body, Bin}</code>: part of the content</p></item>
  <item><p><code>end_of_part</code> : end of part</p></item>
  <item><p><code>mp_mixed</code>: notify the begininning of a mixed multipart part</p></item>
  <item><p><code>mp_mixed_eof</code>: notify the end  of a mixed multipart part</p></item>
  <item><p><code>eof</code>: notify the end of the nultipart request</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="skip_multipart/1">skip_multipart(Ref::client_ref()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Stream the response body.</p>
</div></div>
<div class="function">
<h3 id="body/1">body(Ref::client_ref()) -&gt; {ok, binary()} | {error, atom()}</h3>


<div class="description">

<p>Return the full body sent with the response.</p>
</div></div>
<div class="function">
<h3 id="body/1-1">body(Ref::client_ref(), MaxLength::non_neg_integer() | infinity) -&gt; {ok, binary()} | {error, atom()}</h3>


<div class="description">

<p>Return the full body sent with the response as long as the body
  length doesn't go over MaxLength.</p>
</div></div>
<div class="function">
<h3 id="skip_body/1">skip_body(Ref::client_ref()) -&gt; ok | {error, atom()}</h3>


<div class="description">

<p>skip the full body. (read all the body if needed).</p>
</div></div>
<div class="function">
<h3 id="stream_next/1">stream_next(Ref::client_ref()) -&gt; ok | {error, req_not_found}</h3>


<div class="description">

<p>continue to the next stream message. Only use it when
  <code>{async, once}</code> is set in the client options.</p>
</div></div>
<div class="function">
<h3 id="pause_stream/1">pause_stream(Ref::client_ref()) -&gt; ok | {error, req_not_found}</h3>


<div class="description">

<p>pause a response stream, the stream process will hibernate and
  be woken later by the resume function</p>
</div></div>
<div class="function">
<h3 id="resume_stream/1">resume_stream(Ref::client_ref()) -&gt; ok | {error, req_not_found}</h3>


<div class="description">

<p>resume a paused response stream, the stream process will be
  awoken</p>
</div></div>
<div class="function">
<h3 id="stop_async/1">stop_async(Ref::client_ref()) -&gt; ok | {error, req_not_found} | {error, term()}</h3>


<div class="description">

<p>stop to receive asynchronously.</p>
</div></div>
<div class="function">
<h3 id="redirect_location/1">redirect_location(Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/1">delete(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get/1">get(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="head/1">head(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="post/1">post(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="put/1">put(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="options/1">options(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="trace/1">trace(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="copy/1">copy(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lock/1">lock(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkcol/1">mkcol(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="move/1">move(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="propfind/1">propfind(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="proppatch/1">proppatch(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="search/1">search(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unlock/1">unlock(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="report/1">report(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkactivity/1">mkactivity(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="checkout/1">checkout(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/1">merge(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="msearch/1">msearch(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="notify/1">notify(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="patch/1">patch(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="purge/1">purge(URL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/2">delete(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get/2">get(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="head/2">head(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="post/2">post(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="put/2">put(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="options/2">options(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="trace/2">trace(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="copy/2">copy(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lock/2">lock(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkcol/2">mkcol(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="move/2">move(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="propfind/2">propfind(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="proppatch/2">proppatch(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="search/2">search(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unlock/2">unlock(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="report/2">report(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkactivity/2">mkactivity(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="checkout/2">checkout(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/2">merge(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="msearch/2">msearch(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="notify/2">notify(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/2">subscribe(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unsubscribe/2">unsubscribe(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="patch/2">patch(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="purge/2">purge(URL, Headers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/3">delete(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get/3">get(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="head/3">head(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="post/3">post(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="put/3">put(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="options/3">options(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="trace/3">trace(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="copy/3">copy(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lock/3">lock(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkcol/3">mkcol(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="move/3">move(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="propfind/3">propfind(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="proppatch/3">proppatch(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="search/3">search(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unlock/3">unlock(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="report/3">report(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkactivity/3">mkactivity(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="checkout/3">checkout(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/3">merge(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="msearch/3">msearch(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="notify/3">notify(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/3">subscribe(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unsubscribe/3">unsubscribe(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="patch/3">patch(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="purge/3">purge(URL, Headers, Body) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/4">delete(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get/4">get(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="head/4">head(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="post/4">post(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="put/4">put(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="options/4">options(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="trace/4">trace(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="copy/4">copy(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lock/4">lock(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkcol/4">mkcol(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="move/4">move(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="propfind/4">propfind(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="proppatch/4">proppatch(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="search/4">search(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unlock/4">unlock(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="report/4">report(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mkactivity/4">mkactivity(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="checkout/4">checkout(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/4">merge(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="msearch/4">msearch(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="notify/4">notify(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/4">subscribe(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unsubscribe/4">unsubscribe(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="patch/4">patch(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="purge/4">purge(URL, Headers, Body, Options) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
