<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>moka_mod_utils (the-mayas) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>moka_mod_utils</h1>
<h2 class="modsummary">Functions to manipulate loaded code.</h2>
<div class="description">
<p>Functions to manipulate loaded code</p>
  
   <p>The functions in this module will not kill any process with dangling old
   code. If there are such processes, functions will fail with
   <code>{processes_using_old_code, Module}</code>. This is because the alternative   
behaviour of killing those dangling processes can lead to very difficult to   
debug situations. If you see these failures, find the reason there are   
processes dangling with old code and fix it.</p>
  
   Current representation of the code is a list of <code>erl_parse:form()</code> terms,
   but that is subject to change in the future
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-abstract_code">abstract_code()</h3></div>
    <div class="type"><h3 id="type-remote_call">remote_call() = {module(), atom(), [term()]}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="get_object_code/1">get_object_code(Module::module()) -&gt; binary()</h3>


<div class="description">

<p>Returns the object code of a loadable module</p>
 
  <p>Independently of whether the module is loaded, this function fails if the
  object module cannot be loaded again (i.e. if the beam file is not int the
  load path)
 </p>
</div></div>
<div class="function">
<h3 id="get_abs_code/1">get_abs_code(Module::module()) -&gt; abstract_code()</h3>


<div class="description">

<p>Returns the abstract form of a loadable module</p>
 
  <p>This function throws <code>{no_abstract_code, Module}</code> when the module binary does
  not contain an <code>abstract_code</code> chunk. This is usually because the module was
  not compiled with <code>debug_info</code> or because it was stripped afterwards.</p>
 
  <p>It also throws <code>{cannot_get_object, Module}</code> if <code>Module</code> is not a loadable
  erlang module (e.g. the name is misspelled, or the code is not compiled).
 </p>
</div></div>
<div class="function">
<h3 id="load_abs_code/1">load_abs_code(Module::module(), AbsCode::abstract_code()) -&gt; ok</h3>


<div class="description">

<p>Substitutes current <code>Module</code> with the result of compiling <code>Forms</code></p>
 
  <p><code>Forms</code> will be slightly modified:
  </p><list>
  <item><p>The attribute <code>module</code> of <code>Forms</code> is set to <code>Module</code></p></item>
  <item><p>A wild attribute <code>-moka_orig_module(Module).</code> is added with the former
      module name</p></item>
  </list><p>
 </p>
</div></div>
<div class="function">
<h3 id="restore_module/1">restore_module(Module::module()) -&gt; ok</h3>


<div class="description">

<p>Restores the original module behaviour.</p>
 
  <p>This function unloads the module and loads it again from the code search path
 </p>
</div></div>
<div class="function">
<h3 id="to_str/1">to_str(AbsCode::abstract_code()) -&gt; iolist()</h3>


<div class="description">

<p>Returns a pretty printed version of <code>AbsCode</code></p>
</div></div>
<div class="function">
<h3 id="replace_remote_calls/1">replace_remote_calls(X1::mfa(), NewCall::remote_call(), AbsCode::abstract_code()) -&gt; abstract_code()</h3>


<div class="description">

<p>Replaces external function calls in <code>AbsCode</code></p>
 
  <p>An element <code>$args</code> in the <code>Args</code> list of the <code>remote_call()</code> is replaced  
by the arguments in the old call.</p>
 
  <p>For example, if <code>AbsCode</code> represents a module <code>my_mod</code> containing next code:
  </p><pre class="sh_erlang">  foo() -&gt;
     ...
     other_module:bar(X).</pre><p>
  Next call will change <code>other_module:bar()</code> by
  <code>io:format("Args: ~p~n", [X])</code>:
  </p><pre class="sh_erlang">  moka_mod_utils:replace_remote_calls(
     {other_module, bar, 0}, {io, format, ["Args: ~p~n", '$args']}, Forms)</pre><p>
 </p>
</div></div></div>
<div class="section"><h4>See also</h4><p><a href="code.html" class="seealso">code</a></p></div>
<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
