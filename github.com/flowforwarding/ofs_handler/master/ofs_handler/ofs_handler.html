<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ofs_handler (ofs_handler) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>ofs_handler</h1>
<h2 class="modsummary">
   ofs_handler provides a higher level, somewhat abstracted interface
   to an OpenFlow switch.</h2>
<div class="description">
<p>
   ofs_handler provides a higher level, somewhat abstracted interface
   to an OpenFlow switch.  It provides functions to send requests to
   the switch and subscribe to messages from the switch.  ofs_handler_driver
   should be used as the callback module with of_driver.  ofs_handler also
   has a callback interface.  The application environment variable
   <code>callback_module</code> is the default callback module.  <code>callback_opt</code> is   
a term() passed to the Module:init/7 and Module:connect/8 callback   
functions.  The Opt passed from of_driver overrides these values.</p>
  
   <p>ofs_handler always uses the main connection to send requests to the switch.   
It creates separate ofs_handler_message pids to handle messages   
received from the switch.  This allows for concurrent processing of   
asynchronous messages from the switch.</p>
  
   <em><marker id="of_driver_Callbacks">of_driver Callbacks</marker></em><p>
   <code>ofs_handler_driver</code> is the of_driver callback module for ofs_handler.</p>
  
   <p><code>ofs_handler_driver:init</code> - Accept the new main connection from the   
switch.  The Options passed from of_driver is a property list.  The   
keys 'callback_module' and 'callback_opt' override the values from   
ofs_handler's application environment.</p>
  
   <p><code>ofs_handler_driver:handle_connect</code> - Accept a new auxiliary connection   
from the switch.  The Options passed from of_driver is a property list.   
The keys 'callback_module' and 'callback_opt' override the values from   
ofs_handler's application environment.</p>
  
   <p><code>ofs_handler_driver:handle_message</code> - Accept message received from   
the switch.</p>
  
   <p><code>ofs_handler_driver:handle_error</code> - Accept error received from the   
switch.</p>
  
   <p><code>ofs_handler_driver:handle_disconnect</code> - Terminates handling of an   
auxiliary connection.</p>
  
   <p><code>ofs_handler_driver:terminate</code> - Terminates handling of the main   
connection.  ofs_handler can no longer talk to the switch.</p>
  
   <em><marker id="Callback_Functions">Callback Functions</marker></em><p>
   <code>Module:init(active, IpAddr, DatapathId, Features, Version,
   Connection, Opt) -&gt; {ok, State} | {error, Reason}.</code> - Accept a new
   main connection.  <code>active</code> identifies it is the active ofs_handler
   that has received the new main connection.  <code>IpAddr</code> is the Ip
   address of the switch (<code>{A, B, C, D}</code> format), <code>DatapathId</code> is the
   datapath id of the switch, <code>Features</code> is the decoded <code>features_reply</code>
   message for the switch, <code>Version</code> is the protocol version, <code>Connection</code>
   is the of_driver connection, and <code>Opt</code> is the <code>callback_opt</code>.  The function
   returns <code>{ok, State}</code> where <code>State</code> is any Erlang term that is then
   passed to other callback functions.  The <code>State</code> is associated with
   the <code>Connection</code>, so the callback functions may use <code>State</code> to identify   
the connection that triggered the callback.</p>
  
   <p><code>Module:connect(active, IpAddr, DatapathId, Features, Version,
   Connection, AuxId, Opt) -&gt; {ok, State} | {error, Reason}.</code> - Accept
   a new auxiliary connection.  The caller may assume that there is
   already a main connection from the same switch.  The parameters and
   return are the same as for <code>Module:init</code> with the addition of the
   <code>AuxId</code> parameter.  This is the auxiliary connection Id which was
   read from <code>Features</code>.</p>
  
   <p><code>Module:disconnect(State) -&gt; ok.</code> - Called when an auxiliary connection
   disconnects.  <code>State</code> is the Erlang term returned to ofs_handler
   from the <code>Module:connect</code> callback for the disconnecting auxiliary
   connection.  The callback module may want to store identifying information
   in <code>State</code>.</p>
  
   <p><code>SubscriptionModule:handle_message(Msg, State) -&gt; ok.</code> - Called when
   a message is received from the switch that matches a subscription.
   Note that the callback module for subscriptions may differ from
   module for the other callback functions.  Create subscriptions using
   <code>ofs_handler:subscribe/3</code>.</p>
  
   <p><code>Module:handle_error(Reason, State) -&gt; ok.</code> - Called when an error
   occurs on a connection.  'State' is the Erlang term returned to ofs_handler
   from <code>Module:init</code> or <code>Module:connect</code>.</p>
  
   <code>Module:terminate(State) -&gt; ok.</code> - Called when the main connection
   disconnects.  <code>State</code> is the Erlang term returned to ofs_handler
   from the <code>Module:init</code>.
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-datapath_id">datapath_id() = {<a href="#type-datapath_lsid" class="seealso">datapath_lsid()</a>, <a href="#type-datapath_mac" class="seealso">datapath_mac()</a>}</h3></div>
    <div class="type"><h3 id="type-datapath_lsid">datapath_lsid() = integer()</h3></div>
    <div class="type"><h3 id="type-datapath_mac">datapath_mac() = binary()</h3></div>
    <div class="type"><h3 id="type-error_reason">error_reason() = atom()</h3></div>
    <div class="type"><h3 id="type-ofp_message">ofp_message() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ofp_message{version = undefined | integer(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = undefined | atom(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xid = integer(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body = any()}</h3></div>
    <div class="type"><h3 id="type-subscription_filter">subscription_filter() = function()</h3></div>
    <div class="type"><h3 id="type-subscription_item">subscription_item() = <a href="#type-subscription_type" class="seealso">subscription_type()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {<a href="#type-subscription_type" class="seealso">subscription_type()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-subscription_filter" class="seealso">subscription_filter()</a>}</h3></div>
    <div class="type"><h3 id="type-subscription_type">subscription_type() = atom()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/1">start_link(DatapathId::datapath_id()) -&gt; {ok, pid()}</h3>


<div class="description">

<p>
 Start a ofs_handler process for the switch identified by DatapathId.</p>
</div></div>
<div class="function">
<h3 id="send/1">send(DatapathId::datapath_id(), Msg::ofp_message()) -&gt; ok | {error, error_reason()}</h3>


<div class="description">

<p>
 Send a request to the switch with the DatapathId.  The reply, if
 any, is returned via the Module:handle_message/2 callback.  An error
 occurs if there was a problem sending the request to the switch.  It
 does not indicate an error return from the switch.</p>
</div></div>
<div class="function">
<h3 id="sync_send/1">sync_send(DatapathId::datapath_id(), Msg::ofp_message()) -&gt; {ok, ofp_message() | noreply} | {error, error_reason()}</h3>


<div class="description">

<p>
 Send a request to the switch with the DatapathId.  Implicitly
 adds a barrier request and waits for any replies.  The reply is
 returned to the caller as an ofp_message() that may be
 decoded using of_msg_lib:decode/1.  Returns <code>no_reply</code> if there
 was no reply.  An error occurs if there was
 a problem sending the request to the switch.  An error does not indicate
 an error response from the switch.</p>
</div></div>
<div class="function">
<h3 id="send_list/1">send_list(DatapathId::datapath_id(), Msgs::[ofp_message()]) -&gt; ok | {error, [ok | error_reason()]}</h3>


<div class="description">

<p>
 Send a list of requests to the switch with the DatapathId.  Replies,
 if any, are returned via the Module:handler_message/2 callback.  Returns
 <code>ok</code> if there are no errors.  Returns <code>error</code> if one or more requests
 resulted in an error.  The accompanying list has one element for
 each request in the request list in the corresponding order.
 Errors occur when there is a problem sending the
 request to the switch.  An error does not indicate an error response
 from the switch.</p>
</div></div>
<div class="function">
<h3 id="sync_send_list/1">sync_send_list(DatapathId::datapath_id(), Msgs::[ofp_message()]) -&gt; {ok, [{ok, ofp_message() | no_reply}]} | {error, error_reason(), [{ok, ofp_message() | no_reply | {error, error_reason()}}]}</h3>


<div class="description">

<p>
 Send a list of requests to the switch with the DatapathId.  Implicitly
 adds a barrier request after sending the list of requests and
 waits for any replies.  Replies are returned to the caller as ofp_message()
 records that may be decoded using of_msg_lib:decode/1.  The replies are
 returned in a list with one element for each request in the corresponding
 order.  Returns <code>no_reply</code> if the request had no reply.  An error
 occurs when there is a problem sending the request to the switch.  The
 accompanying list has one element for each request in the request list
 in the corresponding order.  An error does not indicate an error
 response from the switch.</p>
</div></div>
<div class="function">
<h3 id="ping_switch/1">ping_switch(DatapathId::datapath_id()) -&gt; pong | pang</h3>


<div class="description">

<p>
 Send an echo request to the switch with the DatapathId
 and wait for a response. Returns <code>pong</code> if the switch is alive
 and <code>pang</code> if not.</p>
</div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(DatapathId::datapath_id(), Module::module(), Item::subscription_item()) -&gt; ok</h3>


<div class="description">

<p> 
Add a callback subscription for asynchronous messages from the switch at 
DatapathId matching Item.  The callback function is in Module.  The 
item is a of_msg_lib message type (e.g., echo_reply) or a tuple with the 
message type and a filter function.</p>

 <p>If the Item is a message type atom, when the switch sends a message of that 
type to ofs_handler, ofs_handler calls Module:handle_message/2 
with the message.</p>

<p>If the Item is a message type, filter function tuple, when the switch 
sends a message of that type to ofs_handler, ofs_handler calls the 
filter function with the message.  The message is a ofp_message record. 
If the filter function returns true, ofs_handler 
calls Module:handle_message/2 with the message and callback state 
returned by init or connect.  Otherwise, ofs_handler 
discards the message.</p>

 <p>Messages with no subscriptions are discarded.</p>

 There may be any number of subscriptions to the same message type.
 ofs_handler calls Module:handle_message/2 for every matching subscription.
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(DatapathId::datapath_id(), Module::module(), Item::subscription_item()) -&gt; ok</h3>


<div class="description">

<p>
 Remove a callback subscription for asynchronous messages from the switch
 at DatapathId for the matching Item.  After calling unsubscribe/3,
 Module will no longer recieve callbacks for Item.</p>
</div></div>
<div class="function">
<h3 id="get_subscriptions/1">get_subscriptions(DatapathId::datapath_id(), Module::module()) -&gt; [{MessageType::subscription_type(), Module::module(), FilterFunction::subscription_filter() | true}]</h3>


<div class="description">

<p>
 Get the current list of callback subscriptions for the switch at DatapathId
 for Module.  FilterFunction is <code>true</code> if the subscription did not have
 a filter function.</p>
</div></div>
<div class="function">
<h3 id="terminate/1">terminate(DatapathId::datapath_id()) -&gt; ok</h3>


<div class="description">

<p>
 Terminate the ofs_handler for the switch at DatapathId.</p>
</div></div></div>

<authors>

<aname>Erlang Solutions Ltd.</aname>
<email>openflow@erlang-solutions.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
