<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>node_hometree (ejabberd-app) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>node_hometree</h1>
<h2 class="modsummary">The module node_hometree is the default PubSub plugin.</h2>
<div class="description">
<p>The module <em>node_hometree</em> is the default PubSub plugin.
   </p><p>It is used as a default for all unknown PubSub node type.  It can serve
   as a developer basis and reference to build its own custom pubsub node
   types.</p>
   <p>PubSub plugin nodes are using the <a href="gen_node.html" class="seealso">gen_node</a> behaviour.</p>
   <p><em>The API isn't stabilized yet</em>. The pubsub plugin
   development is still a work in progress. However, the system is already
   useable and useful as is. Please, send us comments, feedback and
   improvements.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/3">init(Host, ServerHost, Options) -&gt; ok</h3>

<ul class="type">
<li><code>Host = string()</code></li><li><code>ServerHost = string()</code></li><li><code>Options = [{atom(), term()}]</code></li></ul>
<div class="description">

<p>Called during pubsub modules initialisation. Any pubsub plugin must
  implement this function. It can return anything.</p>
  <p>This function is mainly used to trigger the setup task necessary for the
  plugin. It can be used for example by the developer to create the specific
  module database schema if it does not exists yet.</p>
</div></div>
<div class="function">
<h3 id="terminate/2">terminate(Host, ServerHost) -&gt; ok</h3>

<ul class="type">
<li><code>Host = string()</code></li><li><code>ServerHost = string()</code></li></ul>
<div class="description">

<p>Called during pubsub modules termination. Any pubsub plugin must
  implement this function. It can return anything.</p>
</div></div>
<div class="function">
<h3 id="options/0">options() -&gt; Options</h3>

<ul class="type">
<li><code>Options = [nodeOption() (see module mod_pubsub)]</code></li></ul>
<div class="description">

<p>Returns the default pubsub node options.
  </p><p>Example of function return value:</p>
 	<pre class="sh_erlang"> 	 [{deliver_payloads, true},
 	  {notify_config, false},
 	  {notify_delete, false},
 	  {notify_retract, true},
 	  {persist_items, true},
 	  {max_items, 10},
 	  {subscribe, true},
 	  {access_model, open},
 	  {publish_model, publishers},
 	  {max_payload_size, 100000},
 	  {send_last_published_item, never},
 	  {presence_based_delivery, false}]</pre>
</div></div>
<div class="function">
<h3 id="features/0">features() -&gt; Features</h3>

<ul class="type">
<li><code>Features = [string()]</code></li></ul>
<div class="description">

<p>Returns the node features</p>
</div></div>
<div class="function">
<h3 id="create_node_permission/6">create_node_permission(Host, ServerHost, NodeId, ParentNodeId, Owner, Access) -&gt; {result, Allowed}</h3>

<ul class="type">
<li><code>Host = hostPubsub() (see module mod_pubsub)</code></li><li><code>ServerHost = string()</code></li><li><code>NodeId = nodeId() (see module mod_pubsub)</code></li><li><code>ParentNodeId = nodeId() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li><li><code>Access = all | atom()</code></li><li><code>Allowed = boolean()</code></li></ul>
<div class="description">

<p>Checks if the current user has the permission to create the requested node
  </p><p>In <a href="node_default.html" class="seealso">node_default</a>, the permission is decided by the place in the
  hierarchy where the user is creating the node. The access parameter is also
  checked in the default module. This parameter depends on the value of the
  <code>access_createnode</code> ACL value in ejabberd config file.</p>
  <p>This function also check that node can be created a a children of its
  parent node</p>
  <p>PubSub plugins can redefine the PubSub node creation rights as they
  which. They can simply delegate this check to the <a href="node_default.html" class="seealso">node_default</a>
  module by implementing this function like this:
  </p><pre class="sh_erlang">     check_create_user_permission(Host, ServerHost, NodeId, ParentNodeId, Owner, Access) -&gt;
 	   node_default:check_create_user_permission(Host, ServerHost, NodeId, ParentNodeId, Owner, Access).</pre>
</div></div>
<div class="function">
<h3 id="create_node/2">create_node(NodeIdx, Owner) -&gt; {result, {default, broadcast}}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p />
</div></div>
<div class="function">
<h3 id="delete_node/1">delete_node(Nodes) -&gt; {result, {default, broadcast, Reply}}</h3>

<ul class="type">
<li><code>Nodes = [pubsubNode() (see module mod_pubsub)]</code></li><li><code>Reply = [{pubsubNode() (see module mod_pubsub), [{ljid() (see module mod_pubsub), [{subscription() (see module mod_pubsub), subId() (see module mod_pubsub)}]}]}]</code></li></ul>
<div class="description">

<p>purge items of deleted nodes after effective deletion.</p>
</div></div>
<div class="function">
<h3 id="subscribe_node/8">subscribe_node(NodeIdx, Sender, Subscriber, AccessModel, SendLast, PresenceSubscription, RosterGroup, Options) -&gt; {error, Reason} | {result, Result}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Sender = jid() (see module mod_pubsub)</code></li><li><code>Subscriber = jid() (see module mod_pubsub)</code></li><li><code>AccessModel = accessModel() (see module mod_pubsub)</code></li><li><code>SendLast = atom()</code></li><li><code>PresenceSubscription = boolean()</code></li><li><code>RosterGroup = boolean()</code></li><li><code>Options = [nodeOption() (see module mod_pubsub)]</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li><li><code>Result = {result, {default, subscribed, subId() (see module mod_pubsub)}} | {result, {default, subscribed, subId() (see module mod_pubsub), send_last}} | {result, {default, pending, subId() (see module mod_pubsub)}}</code></li></ul>
<div class="description">

<p>Accepts or rejects subcription requests on a PubSub node.</p>
  <p>The mechanism works as follow:
  </p><list>
  <item><p>The main PubSub module prepares the subscription and passes the
  result of the preparation as a record.</p></item>
  <item><p>This function gets the prepared record and several other parameters and
  can decide to:</p><list>
   <item><p>reject the subscription;</p></item>
   <item><p>allow it as is, letting the main module perform the database
   persistance;</p></item>
   <item><p>allow it, modifying the record. The main module will store the
   modified record;</p></item>
   <item><p>allow it, but perform the needed persistance operations.</p></item></list><p>
  </p></item></list>
  <p>The selected behaviour depends on the return parameter:
   </p><list>
    <item><p><code>{error, Reason}</code>: an IQ error result will be returned. No
    subscription will actually be performed.</p></item>
    <item><p><code>true</code>: Subscribe operation is allowed, based on the
    unmodified record passed in parameter <code>SubscribeResult</code>. If this
    parameter contains an error, no subscription will be performed.</p></item>
    <item><p><code>{true, PubsubState}</code>: Subscribe operation is allowed, but
    the <url href="/home/pete/wefwefwef/docs/other/1022035301/repo/ejd_otp_clean/.xml/ejabberd-app/./mod_pubsub.xml#type-pubsubState">mod_pubsub:pubsubState()</url> record returned replaces the value
    passed in parameter <code>SubscribeResult</code>.</p></item>
    <item><p><code>{true, done}</code>: Subscribe operation is allowed, but the
    <url href="/home/pete/wefwefwef/docs/other/1022035301/repo/ejd_otp_clean/.xml/ejabberd-app/./mod_pubsub.xml#type-pubsubState">mod_pubsub:pubsubState()</url> will be considered as already stored and
    no further persistance operation will be performed. This case is used,
    when the plugin module is doing the persistance by itself or when it want
    to completly disable persistance.</p></item></list><p>
  </p>
  <p>In the default plugin module, the record is unchanged.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe_node/4">unsubscribe_node(NodeIdx, Sender, Subscriber, SubId) -&gt; {error, Reason} | {result, default}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Sender = jid() (see module mod_pubsub)</code></li><li><code>Subscriber = jid() (see module mod_pubsub)</code></li><li><code>SubId = subId() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Unsubscribe the <code>Subscriber</code> from the <code>Node</code>.</p>
</div></div>
<div class="function">
<h3 id="publish_item/6">publish_item(NodeIdx, Publisher, PublishModel, MaxItems, ItemId, Payload) -&gt; {result, {default, broadcast, ItemIds}} | {error, Reason}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Publisher = jid() (see module mod_pubsub)</code></li><li><code>PublishModel = atom()</code></li><li><code>MaxItems = integer()</code></li><li><code>ItemId = itemId() (see module mod_pubsub)</code></li><li><code>Payload = payload() (see module mod_pubsub)</code></li><li><code>ItemIds = [itemId() (see module mod_pubsub)] | []</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Publishes the item passed as parameter.</p>
  <p>The mechanism works as follow:
  </p><list>
  <item><p>The main PubSub module prepares the item to publish and passes the
  result of the preparation as a <url href="/home/pete/wefwefwef/docs/other/1022035301/repo/ejd_otp_clean/.xml/ejabberd-app/./mod_pubsub.xml#type-pubsubItem">mod_pubsub:pubsubItem()</url> record.</p></item>
  <item><p>This function gets the prepared record and several other parameters and can decide to:</p><list>
   <item><p>reject the publication;</p></item>
   <item><p>allow the publication as is, letting the main module perform the database persistance;</p></item>
   <item><p>allow the publication, modifying the record. The main module will store the modified record;</p></item>
   <item><p>allow it, but perform the needed persistance operations.</p></item></list><p>
  </p></item></list>
  <p>The selected behaviour depends on the return parameter:
   </p><list>
    <item><p><code>{error, Reason}</code>: an iq error result will be return. No
    publication is actually performed.</p></item>
    <item><p><code>true</code>: Publication operation is allowed, based on the
    unmodified record passed in parameter <code>Item</code>. If the <code>Item</code>
    parameter contains an error, no subscription will actually be
    performed.</p></item>
    <item><p><code>{true, Item}</code>: Publication operation is allowed, but the
    <url href="/home/pete/wefwefwef/docs/other/1022035301/repo/ejd_otp_clean/.xml/ejabberd-app/./mod_pubsub.xml#type-pubsubItem">mod_pubsub:pubsubItem()</url> record returned replaces the value passed
    in parameter <code>Item</code>. The persistance will be performed by the main
    module.</p></item>
    <item><p><code>{true, done}</code>: Publication operation is allowed, but the
    <url href="/home/pete/wefwefwef/docs/other/1022035301/repo/ejd_otp_clean/.xml/ejabberd-app/./mod_pubsub.xml#type-pubsubItem">mod_pubsub:pubsubItem()</url> will be considered as already stored and
    no further persistance operation will be performed. This case is used,
    when the plugin module is doing the persistance by itself or when it want
    to completly disable persistance.</p></item></list><p>
  </p>
  <p>In the default plugin module, the record is unchanged.</p>
</div></div>
<div class="function">
<h3 id="remove_extra_items/3">remove_extra_items(NodeIdx, MaxItems, ItemIds) -&gt; {result, {NewItemIds, OldItemIds}}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>MaxItems = integer() | unlimited</code></li><li><code>ItemIds = [itemId() (see module mod_pubsub)]</code></li><li><code>NewItemIds = [itemId() (see module mod_pubsub)]</code></li><li><code>OldItemIds = [itemId() (see module mod_pubsub)] | []</code></li></ul>
<div class="description">

<p>This function is used to remove extra items, most notably when the
  maximum number of items has been reached.</p>
  <p>This function is used internally by the core PubSub module, as no
  permission check is performed.</p>
  <p>In the default plugin module, the oldest items are removed, but other
  rules can be used.</p>
  <p>If another PubSub plugin wants to delegate the item removal (and if the
  plugin is using the default pubsub storage), it can implements this function like this:
  </p><pre class="sh_erlang">     remove_extra_items(NodeIdx, MaxItems, ItemIds) -&gt;
 	   node_default:remove_extra_items(NodeIdx, MaxItems, ItemIds).</pre>
</div></div>
<div class="function">
<h3 id="delete_item/4">delete_item(NodeIdx, Publisher, PublishModel, ItemId) -&gt; {result, {default, broadcast}} | {error, Reason}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Publisher = jid() (see module mod_pubsub)</code></li><li><code>PublishModel = atom()</code></li><li><code>ItemId = itemId() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Triggers item deletion.</p>
  <p>Default plugin: The user performing the deletion must be the node owner
  or a publisher, or PublishModel being open.</p>
</div></div>
<div class="function">
<h3 id="purge_node/2">purge_node(NodeIdx, Owner) -&gt; {error, Reason} | {result, {default, broadcast}}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">
 </div></div>
<div class="function">
<h3 id="get_entity_affiliations/2">get_entity_affiliations(Host, Owner) -&gt; {result, Reply}</h3>

<ul class="type">
<li><code>Host = hostPubsub() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li><li><code>Reply = [] | [{pubsubNode() (see module mod_pubsub), affiliation() (see module mod_pubsub)}]</code></li></ul>
<div class="description">

<p>Return the current affiliations for the given user</p>
  <p>The default module reads affiliations in the main Mnesia
  <code>pubsub_state</code> table. If a plugin stores its data in the same
  table, it should return an empty list, as the affiliation will be read by
  the default PubSub module. Otherwise, it should return its own affiliation,
  that will be added to the affiliation stored in the main
  <code>pubsub_state</code> table.</p>
</div></div>
<div class="function">
<h3 id="get_node_affiliations/1">get_node_affiliations(NodeId) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_affiliation/2">get_affiliation(NodeId, Owner) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_affiliation/3">set_affiliation(NodeId, Owner, Affiliation) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_entity_subscriptions/2">get_entity_subscriptions(Host, Owner) -&gt; {result, [] | [{Node, Subscription, SubId, Entity}] | [{Node, Subscription, Entity}]}</h3>

<ul class="type">
<li><code>Host = hostPubsub() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li><li><code>Node = pubsubNode() (see module mod_pubsub)</code></li><li><code>Subscription = subscription() (see module mod_pubsub)</code></li><li><code>SubId = subId() (see module mod_pubsub)</code></li><li><code>Entity = ljid() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Return the current subscriptions for the given user</p>
  <p>The default module reads subscriptions in the main Mnesia
  <code>pubsub_state</code> table. If a plugin stores its data in the same
  table, it should return an empty list, as the affiliation will be read by
  the default PubSub module. Otherwise, it should return its own affiliation,
  that will be added to the affiliation stored in the main
  <code>pubsub_state</code> table.</p>
</div></div>
<div class="function">
<h3 id="get_node_subscriptions/1">get_node_subscriptions(NodeId) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_subscriptions/2">get_subscriptions(NodeId, Owner) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_subscriptions/4">set_subscriptions(NodeId, Owner, Subscription, SubId) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_pending_nodes/2">get_pending_nodes(Host, Owner) -&gt; {result, Reply} | {error, Reason}</h3>

<ul class="type">
<li><code>Host = hostPubsub() (see module mod_pubsub)</code></li><li><code>Owner = jid() (see module mod_pubsub)</code></li><li><code>Reply = [] | [nodeId() (see module mod_pubsub)]</code></li></ul>
<div class="description">

<p>Returns a list of Owner's nodes on Host with pending
  subscriptions.</p>
</div></div>
<div class="function">
<h3 id="get_states/1">get_states(NodeIdx) -&gt; {result, States}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>States = [] | [pubsubState() (see module mod_pubsub)]</code></li></ul>
<div class="description">

<p>Returns the list of stored states for a given node.
  </p><p>For the default PubSub module, states are stored in Mnesia database.</p>
  <p>We can consider that the pubsub_state table have been created by the main
  mod_pubsub module.</p>
  <p>PubSub plugins can store the states where they wants (for example in a
  relational database).</p>
  <p>If a PubSub plugin wants to delegate the states storage to the default node,
  they can implement this function like this:
  </p><pre class="sh_erlang">     get_states(NodeIdx) -&gt;
 	   node_default:get_states(NodeIdx).</pre>
</div></div>
<div class="function">
<h3 id="get_state/2">get_state(NodeIdx, JID) -&gt; State</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>JID = jid() (see module mod_pubsub)</code></li><li><code>State = pubsubState() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Returns a state (one state list), given its reference.</p>
</div></div>
<div class="function">
<h3 id="set_state/1">set_state(State) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>State = pubsubState() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Write a state into database.</p>
</div></div>
<div class="function">
<h3 id="get_items/2">get_items(NodeIdx, From) -&gt; {result, Items}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>From = jid() (see module mod_pubsub)</code></li><li><code>Items = [] | [pubsubItem() (see module mod_pubsub)]</code></li></ul>
<div class="description">

<p>Returns the list of stored items for a given node.
  </p><p>For the default PubSub module, items are stored in Mnesia database.</p>
  <p>We can consider that the pubsub_item table have been created by the main
  mod_pubsub module.</p>
  <p>PubSub plugins can store the items where they wants (for example in a
  relational database), or they can even decide not to persist any items.</p>
  <p>If a PubSub plugin wants to delegate the item storage to the default node,
  they can implement this function like this:
  </p><pre class="sh_erlang">     get_items(NodeIdx, From) -&gt;
 	   node_default:get_items(NodeIdx, From).</pre>
</div></div>
<div class="function">
<h3 id="get_items/6">get_items(NodeIdx, JID, AccessModel, PresenceSubscription, RosterGroup, SubId) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_item/2">get_item(NodeIdx, ItemId) -&gt; {result, Item} | {error, 'item-not-found'}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>ItemId = itemId() (see module mod_pubsub)</code></li><li><code>Item = pubsubItem() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Returns an item (one item list), given its reference.</p>
</div></div>
<div class="function">
<h3 id="get_item/7">get_item(NodeIdx, ItemId, JID, AccessModel, PresenceSubscription, RosterGroup, SubId) -&gt; {result, Item} | {error, Reason}</h3>

<ul class="type">
<li><code>NodeIdx = nodeIdx() (see module mod_pubsub)</code></li><li><code>ItemId = itemId() (see module mod_pubsub)</code></li><li><code>JID = jid() (see module mod_pubsub)</code></li><li><code>AccessModel = accessModel() (see module mod_pubsub)</code></li><li><code>PresenceSubscription = boolean()</code></li><li><code>RosterGroup = boolean()</code></li><li><code>SubId = subId() (see module mod_pubsub)</code></li><li><code>Item = pubsubItem() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub) | 'item-not-found'</code></li></ul>
<div class="description">
 </div></div>
<div class="function">
<h3 id="set_item/1">set_item(Item) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Item = pubsubItem() (see module mod_pubsub)</code></li><li><code>Reason = stanzaError() (see module mod_pubsub)</code></li></ul>
<div class="description">

<p>Write an item into database.</p>
</div></div>
<div class="function">
<h3 id="get_item_name/3">get_item_name(Host, Node, Id) -&gt; term()
</h3>


<div class="description">

<p>Return the name of the node if known: Default is to return
  node id.</p>
</div></div>
<div class="function">
<h3 id="node_to_path/1">node_to_path(Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="path_to_node/1">path_to_node(Path) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Christophe Romain</aname>
<email>christophe.romain@process-one.net</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
