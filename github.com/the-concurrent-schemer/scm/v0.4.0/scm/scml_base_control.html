<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>scml_base_control (scm) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>scml_base_control</h1>
<h2 class="modsummary">Scheme base library for control features.</h2>
<div class="description">
<p>Scheme base library for control features</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-scm_any">scm_any() = <a href="smc_type.html#type-scm_any" class="seealso">smc_type:scm_any()</a></h3></div>
    <div class="type"><h3 id="type-scm_boolean">scm_boolean() = <a href="scmd_types.html#type-scm_boolean" class="seealso">scmd_types:scm_boolean()</a></h3></div>
    <div class="type"><h3 id="type-scm_false">scm_false() = <a href="scmd_types.html#type-scm_false" class="seealso">scmd_types:scm_false()</a></h3></div>
    <div class="type"><h3 id="type-scm_obj">scm_obj() = <a href="scmd_types.html#type-scm_obj" class="seealso">scmd_types:scm_obj()</a></h3></div>
    <div class="type"><h3 id="type-scm_proc">scm_proc() = <a href="scmd_types.html#type-scm_proc" class="seealso">scmd_types:scm_proc()</a></h3></div>
    <div class="type"><h3 id="type-scm_string">scm_string() = <a href="scmd_types.html#type-scm_string" class="seealso">scmd_types:scm_string()</a></h3></div>
    <div class="type"><h3 id="type-scm_symbol">scm_symbol() = <a href="scmd_types.html#type-scm_symbol" class="seealso">scmd_types:scm_symbol()</a></h3></div>
    <div class="type"><h3 id="type-scm_thunk">scm_thunk() = <a href="scmd_types.html#type-scm_thunk" class="seealso">scmd_types:scm_thunk()</a></h3></div>
    <div class="type"><h3 id="type-scm_vector">scm_vector() = <a href="scmd_types.html#type-scm_vector" class="seealso">scmd_types:scm_vector()</a></h3></div>
    <div class="type"><h3 id="type-scmi_ccng">scmi_ccng() = <a href="scmi_types.html#type-ccng" class="seealso">scmi_types:ccng()</a></h3></div>
    <div class="type"><h3 id="type-scmi_ccok">scmi_ccok() = <a href="scmi_types.html#type-ccok" class="seealso">scmi_types:ccok()</a></h3></div>
    <div class="type"><h3 id="type-scmi_env">scmi_env() = <a href="scmi_types.html#type-env" class="seealso">scmi_types:env()</a></h3></div>
    <div class="type"><h3 id="type-scmi_nip">scmi_nip() = <a href="scmi_types.html#type-nip" class="seealso">scmi_types:nip()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="$scml_exports/0">$scml_exports() -&gt; [{scm_symbol(), scmi_nip()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="procedure?/1">procedure?(Nip0::scm_obj()) -&gt; scm_boolean()</h3>


<div class="description">

<p>Returns #t if obj is a procedure, otherwise returns #f.</p>
</div></div>
<div class="function">
<h3 id="apply/1">apply(Arg::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_any()</h3>


<div class="description">

<p>Calls +Proc+ with the elements of the list +(append (list arg1
  ...) args)+ as the actual arguments.</p>
</div></div>
<div class="function">
<h3 id="map/1">map(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; [scm_any()]</h3>


<div class="description">

<p>Applies proc element-wise to the elements of the lists and
  returns a list of the results, in order.  If more than one list is
  given and not all lists have the same length, map terminates when
  the shortest list runs out.  The dynamic order in which proc is
  applied to the elements of the lists is unspecified.</p>
</div></div>
<div class="function">
<h3 id="string-map/1">string-map(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_string()</h3>


<div class="description">
<p>Equivalent to <a href="#map/1" class="seealso">map([Proc | Args])</a>.</p>
</div></div>
<div class="function">
<h3 id="vector-map/1">vector-map(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_vector()</h3>


<div class="description">
<p>Equivalent to <a href="#map/1" class="seealso">map([Proc | Args])</a>.</p>
</div></div>
<div class="function">
<h3 id="for-each/1">for-each(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_false()</h3>


<div class="description">

<p>Applies proc element-wise to the elements of the lists and
  returns #f.  Calls proc for its side effects rather than for its
  values.  Unlike map, for-each is guaranteed to call proc on the
  elements of the lists in order from the first element(s) to the
  last. If more than one list is given and not all lists have the
  same length, for-each terminates when the shortest list runs out.</p>
</div></div>
<div class="function">
<h3 id="string-for-each/1">string-for-each(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_false()</h3>


<div class="description">
<p>Equivalent to <a href="#for-each/1" class="seealso">'for-each'([Proc | Args])</a>.</p>
</div></div>
<div class="function">
<h3 id="vector-for-each/1">vector-for-each(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_false()</h3>


<div class="description">
<p>Equivalent to <a href="#for-each/1" class="seealso">'for-each'([Proc | Args])</a>.</p>
</div></div>
<div class="function">
<h3 id="call/cc/1">call/cc(Proc::scm_proc(), Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_any()</h3>


<div class="description">

<p>Packages the current continuation as an "escape procedure" and
  passes it as an argument to +Proc+. The escape procedure is a
  Scheme procedure that, if it is later called, will abandon whatever
  continuation is in effect at that later time and will instead use
  the continuation that was in effect when the escape procedure was
  created. Calling the escape procedure will cause the invocation of
  before and after thunks installed using +dynamic-wind+.</p>
</div></div>
<div class="function">
<h3 id="values/1">values(Args::[scm_any(), ...], Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_any()</h3>


<div class="description">

<p>Delivers all of its arguments to its continuation.</p>
</div></div>
<div class="function">
<h3 id="call-with-values/1">call-with-values(Producer::scm_thunk(), Consumer::scm_proc(), Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_any()</h3>


<div class="description">

<p>Calls its producer argument with no values and a continuation
  that, when passed some values, calls the consumer procedure with
  those values as arguments. The continuation for the call to
  consumer is the continuation of the call to +call-with-values+.</p>
</div></div>
<div class="function">
<h3 id="dynamic-wind/1">dynamic-wind(Before::scm_thunk(), Thunk::scm_thunk(), After::scm_thunk(), Env::scmi_env(), Ok::scmi_ccok(), Ng::scmi_ccng()) -&gt; scm_any()</h3>


<div class="description">

<p>Calls +Thunk+ without arguments, returning the result(s) of  
this call. +Before+ and +After+ are called, also without arguments,  
as required.  Note that, in the absence of calls to continuations  
captured using +call/cc+, the three arguments are called once each,  
in order.  +Before+ is called whenever execution enters the dynamic  
extent of the call to +Thunk+ and +After+ is called whenever it  
exits that dynamic extent.  The +Before+ and +After+ thunks are  
called in the same dynamic environment as the call to  
+dynamic-wind+.</p>
 
  <p>No special handling is given for escapes that might occur inside  
the +Before+ and +After+ thunks. It protects the +Thunk+ by its  
continuation that enforces the following three rules.</p>
 
  <p>1. Its normal continuation is for +Before+ to be called before
     +Thunk+, which is called before +After+, and finally to return
     the value of the evaluation of +Thunk+ as the value of the
     entire dynamic-wind expression.
  2. If an escape is made out of the +Thunk+, +dynamic-wind+
     guarantees that the +After+ will be called before the escape
     occurs.
  3. If an escape is made into the +Thunk+, it guarantees that the
     +Before+ will be called before control is returned to the place
     of initial escape in the +Thunk+, and finally the +After+ is
     called.</p>
</div></div></div>

<authors>

<aname>Joseph Wayne Norton</aname>
<email>norton@alum.mit.edu</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
