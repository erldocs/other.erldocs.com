<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>subset_sum (algorithms) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>subset_sum</h1>
<h2 class="modsummary">Search a list of integers for a subset summing zero.</h2>
<div class="description">
<p>Search a list of integers for a subset summing zero.</p>
 
  <p><em><marker id="Requirements">Requirements</marker></em></p>
 
  <list>
   <item><p>Should be fast, very fast.</p></item>
   <item><p>Should find ONE subset summing zero.</p></item>
   <item><p>Should work with BIG lists of integers (&gt; 1000000).</p></item>
   <item><p>Should be parallelizable.</p></item>
   <item><p>Should not take exponential amounts of time.</p></item>
   <item><p>Should not take exponential amounts of memory.</p></item>
  </list>
 
 
  <p><em><marker id="Assumptions">Assumptions</marker></em></p>
 
  <list>
   <item><p>The set of integer is a uniform distribution.</p></item>
   <item><p>The range of the integer is small and centered on zero,
       something like  [-65000..65000].</p></item>
   <item><p>False negative result are acceptable.</p></item>
  </list>
 
  <p><em><marker id="Algorithm">Algorithm</marker></em></p>
 
  <p>Because the problem is NP complete we cannot possibly resolve the problem  
by testing all combinations so we have to create a good enough  
approximation. So we reduce the solution space with some limitations:</p>
 
  <list>
   <item><p>Limit to subsets up to 32 integers.</p></item>
   <item><p>Limit to subsets coming from two partitions of 16 integers.</p></item>
  </list>
 
  <p>With these limitations, we know that for sets of up to 32 integers we have  
the guarantee to find a subset summing zero if it exists. For bigger sets  
of integers, only part of the combination space will be explored but  
because we are not interested in all the solutions, and the probabilities  
are very high for uniform distribution of integer it is good enough.</p>
 
  <p>The algorithm has two phases:</p>
 
  <p><em><marker id="Phase_1:_Expand">Phase 1: Expand</marker></em></p>
 
  <p>The set of value is successively combined and populated with intermediary  
results checking for subset summing zero on the way:</p>
 
  <p><code>[A, B, C, D, E, F, G, H |Etc]</code></p>
 
  <list>
   <item><code>[[A, B, A+B], [C, D, C+D], [E, F, E+F], [G, H, G+H] |Etc]</code></item>
   <item><code>[[A, B, A+B, C, D, C+D, A+C, A+D, A+C+D, B+C, B+D, B+C+D, A+B+C, A+B+D. A+B+C+D],
        [E, F, E+F, G, H, G+H, E+G, E+H, E+G+H, F+G, F+H, F+G+H, E+F+G, E+F+H, E+F+G+H] |Etc]</code></item>
   <item><code>...</code></item>
  </list>
 
  <p>Because we don't want the memory usage to grow exponentially this step is  
done only 4 times to stay in an acceptable range of memory consumption.  
After this step we have all sums up to 16 integers for every  
partitions of 16 integers.</p>
 
 
  <p><em><marker id="Phase_2:_Combinate">Phase 2: Combinate</marker></em></p>
 
  <p>Each pairs of intermediary results are tagged, merged and sorted using the  
tag and the absolute value as key. Then the result is browsed only one time  
for contiguous entries with different tags summing zero.</p>
 
  <p>With this second step we found all subsets up to 32 integers coming from  
up to 2 partitions of 16 integers.</p>
 
 
  <p><em><marker id="Parallelization">Parallelization</marker></em></p>
 
  <p>The algorithm could easily be parallelized an processed by different  
processes, by splitting the list in phase 1 and distributing block  
processing in phase 2.</p>
 
 
  <p><em><marker id="Usage">Usage</marker></em></p>
 
  <pre class="sh_erlang">
  $ make shell
  1&gt; L = subset_sum:random_data(1000).
  2&gt; subset_sum:find_subset(L).
  </pre>
 
 
  <p><em><marker id="Benchmark">Benchmark</marker></em></p>
 
  <pre class="sh_erlang">
  $ make shell
  1&gt; subset_sum:benchmark(1000, 20).
  </pre>
 
 </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="find_subset/1">find_subset(Set::value_set()) -&gt; not_found | value_set()</h3>

<ul class="type">
<li><code>[] | [integer()]</code></li></ul>
<div class="description">

<p>Returns a subset of the specified set of integer whose sum gives zero,
  or 'not_found' if no such a subset has been found. Up to sets of 32
  integers, if 'not_found' is returned it is guaranteed that the specified
  set do not contains any subset summing zero. For bigger sets, it only means
  that the approximation algorithm did not find any.</p>
</div></div>
<div class="function">
<h3 id="has_subset/1">has_subset(Set::value_set()) -&gt; boolean()</h3>

<ul class="type">
<li><code>[] | [integer()]</code></li></ul>
<div class="description">

<p>Returns 'true' if the specified set of integer contains a subset
  summing zero, of 'false' if not found. Up to sets of 32 integers,
  if 'false' is returned it is guaranteed that the specified set do not
  contains any subset summing zero. For bigger sets it only means that the
  approximation algorithm did not find any.</p>
</div></div>
<div class="function">
<h3 id="random_data/1">random_data(Size::pos_integer()) -&gt; Set::value_set()</h3>

<ul class="type">
<li><code>[] | [integer()]</code></li></ul>
<div class="description">

<p>Returns a list of non-zero integers in range [-65000..65000]
  of specified size using an uniform random distribution.</p>
</div></div>
<div class="function">
<h3 id="benchmark/1">benchmark(Size::pos_integer(), Iter::pos_integer()) -&gt; ok</h3>


<div class="description">

<p>Benchmarks find_subset/1 with a random list of integers of specified
  size multiple times and print the result to the console.</p>
</div></div></div>

<authors>

<aname>Sebastien Merle</aname>
<email>s.merle@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
