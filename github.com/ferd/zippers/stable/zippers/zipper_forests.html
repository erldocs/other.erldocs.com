<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>zipper_forests (zippers) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>zipper_forests</h1>
<h2 class="modsummary">Zipper forests are the zipper equivalent of a tree where each
  node is a list of subtrees.</h2>
<div class="description">
<p>Zipper forests are the zipper equivalent of a tree where each
  node is a list of subtrees. The term is chosen because a forest, in graph
  theory, means an undirected acyclic graphs, which is precisely the shape
  such a tree can represent. The advantage of the zipper forest is that it
  allows the graph/tree to be navigated in an iterative manner.
  Potential uses of such a forest can be to represent a minimum spanning tree,
  a DOM document, an undo tree, etc.
  Adding, replacing and deleting items is done in amortized constant time.
  Note that zippers are not search data structures.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-zipper_forest">zipper_forest() = {<a href="#type-thread" class="seealso">thread()</a>, <a href="#type-znode" class="seealso">znode()</a>}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="root/1">root(Val::term()) -&gt; zipper_forest()</h3>


<div class="description">

<p>creates an empty zipper forest with <var>Val</var> as the first
  element in it.</p>
</div></div>
<div class="function">
<h3 id="value/1">value(X1::zipper_forest()) -&gt; {ok, term()} | undefined</h3>


<div class="description">

<p>Extracts the node's value from the current tree position.
  If no item exists at the current position, the atom <code>undefined</code>
  is returned.</p>
</div></div>
<div class="function">
<h3 id="replace/1">replace(Val::term(), X2::zipper_forest()) -&gt; zipper_forest()</h3>


<div class="description">

<p>Replaces the value from at the current tree position, without touching
  the children nodes.</p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(Val::term(), X2::zipper_forest()) -&gt; zipper_forest()</h3>


<div class="description">

<p>Add a new node at the current position with the value Val.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(X1::zipper_forest()) -&gt; zipper_forest()</h3>


<div class="description">

<p>Deletes the node at the current position and its children.
  The next one becomes the current position.</p>
</div></div>
<div class="function">
<h3 id="prev/1">prev(X1::zipper_forest()) -&gt; zipper_forest() | undefined</h3>


<div class="description">

<p>Moves to the previous node of the current level. If no
  such node exists, the atom <code>undefined</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="next/1">next(X1::zipper_forest()) -&gt; zipper_forest() | undefined</h3>


<div class="description">

<p>Moves to the next node of the current level. If no
  such node exists, the atom <code>undefined</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="children/1">children(X1::zipper_forest()) -&gt; zipper_forest() | undefined</h3>


<div class="description">

<p>Goes down one level to the children of the current node.
  If the current node is undefined, the atom <code>undefined</code>
  is returned.</p>
</div></div>
<div class="function">
<h3 id="parent/1">parent(X1::zipper_forest()) -&gt; zipper_forest() | undefined</h3>


<div class="description">

<p>Moves up to the direct parent level. Doesn't rewind the current
  level's child list. This means that if you have a tree, go to the
  children, browse to the next element 2-3 times, then go back up and
  down to the children again, you'll be at the same position you were
  before. If no parent exists, the atom <code>undefined</code> is returned.
  If you prefer the children to be <em>rewinded</em>, use
  <a href="#rparent/1" class="seealso">rparent/1</a></p>
</div></div>
<div class="function">
<h3 id="rparent/1">rparent(X1::zipper_forest()) -&gt; zipper_forest() | undefined</h3>


<div class="description">

<p>Moves up to the direct parent level, much like
  <a href="#parent/1" class="seealso">parent/1</a>, However,
  it rewinds the current level's list before doing so. This allows
  the programmer to access children as if it were the first time,
  all the time.
  If no parent exists, the atom <code>undefined</code> is returned.</p>
</div></div></div>

<authors>

<aname>Fred Hebert</aname>
<email>mononcqc@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
