<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>recon_trace (recon) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>recon_trace</h1>
<h2 class="modsummary">
   recon_trace is a module that handles tracing in a safe manner for single   
Erlang nodes, currently for function calls only.</h2>
<div class="description">
<p>
   <code>recon_trace</code> is a module that handles tracing in a safe manner for single   
Erlang nodes, currently for function calls only. Functionality includes:</p>
  
   <list>
       <item><p>Nicer to use interface (arguably) than <code>dbg</code> or trace BIFs.</p></item>
       <item><p>Protection against dumb decisions (matching all calls on a node
           being traced, for example)</p></item>
       <item><p>Adding safe guards in terms of absolute trace count or
           rate-limitting</p></item>
       <item><p>Nicer formatting than default traces</p></item>
   </list>
  
   <em><marker id="Tracing_Erlang_Code">Tracing Erlang Code</marker></em>
  
   <p>The Erlang Trace BIFs allow to trace any Erlang code at all. They work in   
two parts: pid specifications, and trace patterns.</p>
  
   <p>Pid specifications let you decide which processes to target. They can be
   specific pids, <code>all</code> pids, <code>existing</code> pids, or <code>new</code> pids (those not   
spawned at the time of the function call).</p>
  
   <p>The trace patterns represent functions. Functions can be specified in two
   parts: specifying the modules, functions, and arguments, and then with
   Erlang match specifications to add constraints to arguments (see
   <a href="#calls/3" class="seealso">calls/3</a> for details).</p>
  
   <p>What defines whether you get traced or not is the intersection of both:</p>
  
   <pre class="sh_erlang">           _,--------,_      _,--------,_
        ,-'            `-,,-'            `-,
     ,-'              ,-'  '-,              `-,
    |   Matching    -'        '-   Matching    |
    |     Pids     |  Getting   |    Trace     |
    |              |   Traced   |  Patterns    |
    |               -,        ,-               |
     '-,              '-,  ,-'              ,-'
        '-,_          _,-''-,_          _,-'
            '--------'        '--------'</pre>
  
   <p>If either the pid specification excludes a process or a trace pattern   
excludes a given call, no trace will be received.</p>
  
   <em><marker id="Example_Session">Example Session</marker></em>
  
   <p>First let's trace the <code>queue:new</code> functions in any process:</p>
  
   <pre class="sh_erlang">   1&gt; recon_trace:calls({queue, new, '_'}, 1).
   1
   13:14:34.086078 &lt;0.44.0&gt; queue:new()
   Recon tracer rate limit tripped.</pre>
  
   <p>The limit was set to <code>1</code> trace message at most, and <code>recon</code> let us   
know when that limit was reached.</p>
  
   <p>Let's instead look for all the <code>queue:in/2</code> calls, to see what it is   
we're inserting in queues:</p>
  
   <pre class="sh_erlang">   2&gt; recon_trace:calls({queue, in, 2}, 1).
   1
   13:14:55.365157 &lt;0.44.0&gt; queue:in(a, {[],[]})
   Recon tracer rate limit tripped.</pre>
  
   <p>In order to see the content we want, we should change the trace patterns
   to use a <code>fun</code> that matches on all arguments in a list (<code>_</code>) and returns
   <code>return_trace()</code>. This last part will generate a second trace for each   
call that includes the return value:</p>
  
   <pre class="sh_erlang">   3&gt; recon_trace:calls({queue, in, fun(_) -&gt; return_trace() end}, 3).
   1
  
   13:15:27.655132 &lt;0.44.0&gt; queue:in(a, {[],[]})
  
   13:15:27.655467 &lt;0.44.0&gt; queue:in/2 --&gt; {[a],[]}
  
   13:15:27.757921 &lt;0.44.0&gt; queue:in(a, {[],[]})
   Recon tracer rate limit tripped.</pre>
  
   <p>Matching on argument lists can be done in a more complex manner:</p>
  
   <pre class="sh_erlang">   4&gt; recon_trace:calls(
   4&gt;   {queue, '_', fun([A,_]) when is_list(A); is_integer(A) andalso A &gt; 1 -&gt; return_trace() end},
   4&gt;   {10,100}
   4&gt; ).
   32
  
   13:24:21.324309 &lt;0.38.0&gt; queue:in(3, {[],[]})
  
   13:24:21.371473 &lt;0.38.0&gt; queue:in/2 --&gt; {[3],[]}
  
   13:25:14.694865 &lt;0.53.0&gt; queue:split(4, {[10,9,8,7],[1,2,3,4,5,6]})
  
   13:25:14.695194 &lt;0.53.0&gt; queue:split/2 --&gt; {{[4,3,2],[1]},{[10,9,8,7],[5,6]}}
  
   5&gt; recon_trace:clear().
   ok</pre>
  
   <p>Note that in the pattern above, no specific function (<code>'_'</code>) was
   matched against. Instead, the <code>fun</code> used restricted functions to those
   having two arguments, the first of which is either a list or an integer
   greater than <code>1</code>.</p>
  
   <p>The limit was also set using <code>{10,100}</code> instead of an integer, making the   
rate-limitting at 10 messages per 100 milliseconds, instead of an absolute   
value.</p>
  
   <p>Any tracing can be manually interrupted by calling <code>recon_trace:clear()</code>,   
or killing the shell process.</p>
  
   <p>Be aware that extremely broad patterns with lax rate-limitting (or very
   high absolute limits) may impact your node's stability in ways
   <code>recon_trace</code> cannot easily help you with.</p>
  
   <p>In doubt, start with the most restrictive tracing possible, with low   
limits, and progressively increase your scope.</p>
  
   <p>See <a href="#calls/3" class="seealso">calls/3</a> for more details and tracing possibilities.</p>
  
   <em><marker id="Structure">Structure</marker></em>
  
   <p>This library is production-safe due to taking the following structure for   
tracing:</p>
  
   <pre class="sh_erlang">   [IO/Group leader] &lt;---------------------,
     |                                     |
   [shell] ---&gt; [tracer process] ----&gt; [formatter]</pre>
  
   <p>The tracer process receives trace messages from the node, and enforces   
limits in absolute terms or trace rates, before forwarding the messages   
to the formatter. This is done so the tracer can do as little work as   
possible and never block while building up a large mailbox.</p>
  
   <p>The tracer process is linked to the shell, and the formatter to the   
tracer process. The formatter also traps exits to be able to handle   
all received trace messages until the tracer termination, but will then   
shut down as soon as possible.</p>
  
   <p>In case the operator is tracing from a remote shell which gets   
disconnected, the links between the shell and the tracer should make it   
so tracing is automatically turned off once you disconnect.</p>
  
   <p>If sending output to the Group Leader is not desired, you may specify
   a different pid() via the option <code>io_server</code> in the <a href="#calls/3" class="seealso">calls/3</a> function.   
For instance to write the traces to a file you can do something like</p>
  
   <p>1&gt; {ok, Dev} = file:open("/tmp/trace",[write]).   
2&gt; recon_trace:calls({queue, in, fun(_) -&gt; return_trace() end}, 3, [{io_server, Dev}]).   
1   
3&gt;   
Recon tracer rate limit tripped.   
4&gt; file:close(Dev).</p>
  
   The only output still sent to the Group Leader is the rate limit being
   tripped, and any errors. The rest will be sent to the other IO
   server (see <url href="http://erlang.org/doc/apps/stdlib/io_protocol.html">http://erlang.org/doc/apps/stdlib/io_protocol.html</url>).</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-args">args() = '_' | 0..255 | <a href="#type-matchspec" class="seealso">matchspec()</a> | <a href="#type-shellfun" class="seealso">shellfun()</a></h3></div>
    <div class="type"><h3 id="type-fn">fn() = '_' | atom()</h3></div>
    <div class="type"><h3 id="type-formatterfun">formatterfun() = fun((term()) -&gt; iodata())</h3></div>
    <div class="type"><h3 id="type-matchspec">matchspec() = [{[term()], [term()], [term()]}]</h3></div>
    <div class="type"><h3 id="type-max">max() = <a href="#type-max_traces" class="seealso">max_traces()</a> | <a href="#type-max_rate" class="seealso">max_rate()</a></h3></div>
    <div class="type"><h3 id="type-max_rate">max_rate() = {<a href="#type-max_traces" class="seealso">max_traces()</a>, <a href="#type-millisecs" class="seealso">millisecs()</a>}</h3></div>
    <div class="type"><h3 id="type-max_traces">max_traces() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-millisecs">millisecs() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-mod">mod() = '_' | module()</h3></div>
    <div class="type"><h3 id="type-num_matches">num_matches() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-options">options() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{pid, <a href="#type-pidspec" class="seealso">pidspec()</a> | [<a href="#type-pidspec" class="seealso">pidspec()</a>, ...]} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{timestamp, formatter | trace} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{args, args | arity} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{io_server, pid()} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{formatter, <a href="#type-formatterfun" class="seealso">formatterfun()</a>} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{scope, global | local}]</h3></div>
    <div class="type"><h3 id="type-pidspec">pidspec() = all | existing | new | <a href="recon.html#type-pid_term" class="seealso">recon:pid_term()</a></h3></div>
    <div class="type"><h3 id="type-shellfun">shellfun() = fun((term()) -&gt; term())</h3></div>
    <div class="type"><h3 id="type-tspec">tspec() = {<a href="#type-mod" class="seealso">mod()</a>, <a href="#type-fn" class="seealso">fn()</a>, <a href="#type-args" class="seealso">args()</a>}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="clear/0">clear() -&gt; ok</h3>


<div class="description">

<p>Stops all tracing at once.</p>
</div></div>
<div class="function">
<h3 id="calls/1">calls(TSpecs::tspec() | [tspec(), ...], Max::max()) -&gt; num_matches()</h3>


<div class="description">
<p>Equivalent to <a href="#calls/3" class="seealso">calls({Mod, Fun, Args}, Max, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="calls/1-1">calls(TSpecs::tspec() | [tspec(), ...], Max::max(), Opts::options()) -&gt; num_matches()</h3>


<div class="description">

<p>Allows to set trace patterns and pid specifications to trace  
function calls.</p>
 
  <p>The basic calls take the trace patterns as tuples of the form
  <code>{Module, Function, Args}</code> where:</p>
 
  <list>
   <item><p><code>Module</code> is any atom representing a module</p></item>
   <item><p><code>Function</code> is any atom representing a function, or the wildcard
       <code>'_'</code></p></item>
   <item><p><code>Args</code> is either the arity of a function (<code>0..255</code>), a wildcard
       pattern (<code>'_'</code>), a
       <url href="http://learnyousomeerlang.com/ets#you-have-been-selected">match specification</url>,
       or a function from a shell session that can be transformed into
       a match specification</p></item>
  </list>
 
  <p>There is also an argument specifying either a maximal count (a number)
  of trace messages to be received, or a maximal frequency (<code>{Num, Millisecs}</code>).</p>
 
  <p>Here are examples of things to trace:</p>
 
  <list>
   <item><p>All calls from the <code>queue</code> module, with 10 calls printed at most:
       <code>recon_trace:calls({queue, '_', '_'}, 10)</code></p></item>
   <item><p>All calls to <code>lists:seq(A,B)</code>, with 100 calls printed at most:
       <code>recon_trace:calls({lists, seq, 2}, 100)</code></p></item>
   <item><p>All calls to <code>lists:seq(A,B)</code>, with 100 calls per second at most:
       <code>recon_trace:calls({lists, seq, 2}, {100, 1000})</code></p></item>
   <item><p>All calls to <code>lists:seq(A,B,2)</code> (all sequences increasing by two)
       with 100 calls at most:
       <code>recon_trace:calls({lists, seq, fun([_,_,2]) -&gt; ok end}, 100)</code></p></item>
   <item><p>All calls to <code>iolist_to_binary/1</code> made with a binary as an argument
       already (kind of useless conversion!):
       <code>recon_trace:calls({erlang, iolist_to_binary, fun([X]) when is_binary(X) -&gt; ok end}, 10)</code></p></item>
   <item><p>Calls to the queue module only in a given process <code>Pid</code>, at a rate
       of 50 per second at most:
       <code>recon_trace:calls({queue, '_', '_'}, {50,1000}, [{pid, Pid}])</code></p></item>
   <item><p>Print the traces with the function arity instead of literal arguments:
       <code>recon_trace:calls(TSpec, Max, [{args, arity}])</code></p></item>
   <item><p>Matching the <code>filter/2</code> functions of both <code>dict</code> and <code>lists</code> modules,
       across new processes only:
       <code>recon_trace:calls([{dict,filter,2},{lists,filter,2}], 10, [{pid, new}])</code></p></item>
   <item><p>Tracing the <code>handle_call/3</code> functions of a given module for all new processes,
       and those of an existing one registered with <code>gproc</code>:
       <code>recon_trace:calls({Mod,handle_call,3}, {10,100}, [{pid, [{via, gproc, Name}, new]}</code></p></item>
   <item><p>Show the result of a given function call:
       <code>recon_trace:calls({Mod,Fun,fun(_) -&gt; return_trace() end}, Max, Opts)</code>
       or
       <code>recon_trace:calls({Mod,Fun,[{'_', [], [{return_trace}]}]}, Max, Opts)</code>,
       the important bit being the <code>return_trace()</code> call or the
       <code>{return_trace}</code> match spec value.</p></item>
  </list>
 
  <p>There's a few more combination possible, with multiple trace patterns per call, and more  
options:</p>
 
  <list>
   <item><p><code>{pid, PidSpec}</code>: which processes to trace. Valid options is any of
       <code>all</code>, <code>new</code>, <code>existing</code>, or a process descriptor (<code>{A,B,C}</code>,
       <code>"&lt;A.B.C&gt;"</code>, an atom representing a name, <code>{global, Name}</code>,
       <code>{via, Registrar, Name}</code>, or a pid). It's also possible to specify
       more than one by putting them in a list.</p></item>
   <item><p><code>{timestamp, formatter | trace}</code>: by default, the formatter process
       adds timestamps to messages received. If accurate timestamps are
       required, it's possible to force the usage of timestamps within
       trace messages by adding the option <code>{timestamp, trace}</code>.</p></item>
   <item><p><code>{args, arity | args}</code>: whether to print arity in function calls
       or their (by default) literal representation.</p></item>
   <item><p><code>{scope, global | local}</code>: by default, only 'global' (fully qualified
       function calls) are traced, not calls made internally. To force tracing
       of local calls, pass in <code>{scope, local}</code>. This is useful whenever
       you want to track the changes of code in a process that isn't called
       with <code>Module:Fun(Args)</code>, but just <code>Fun(Args)</code>.</p></item>
   <item><p><code>{formatter, fun(Term) -&gt; io_data() end}</code>: override the default
        formatting functionality provided by recon.</p></item>
   <item><p><code>{io_server, pid() | atom()}</code>: by default, recon logs to the current
       group leader, usually the shell. This option allows to redirect
       trace output to a different IO server (such as a file handle).</p></item>
  </list>
 
  <p>Also note that putting extremely large <code>Max</code> values (i.e. <code>99999999</code> or
  <code>{10000,1}</code>) will probably negate most of the safe-guarding this library
  does and be dangerous to your node. Similarly, tracing extremely large
  amounts of function calls (all of them, or all of <code>io</code> for example)
  can be risky if more trace messages are generated than any process on
  the node could ever handle, despite the precautions taken by this library.</p>
</div></div>
<div class="function">
<h3 id="format/1">format(TraceMsg) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Fred Hebert</aname>
<email>mononcqc@ferd.ca</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
