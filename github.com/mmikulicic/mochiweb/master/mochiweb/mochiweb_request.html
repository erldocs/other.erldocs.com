<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>mochiweb_request (mochiweb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>mochiweb_request</h1>
<h2 class="modsummary">MochiWeb HTTP Request abstraction.</h2>
<div class="description">
<p>MochiWeb HTTP Request abstraction.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-encoding">encoding() = string()</h3></div>
    <div class="type"><h3 id="type-field">field() = socket | method | raw_path | version | headers | peer | path | body_length | range</h3></div>
    <div class="type"><h3 id="type-headers">headers()</h3></div>
    <div class="type"><h3 id="type-iodata">iodata() = binary() | iolist()</h3></div>
    <div class="type"><h3 id="type-ioheaders">ioheaders() = headers() | [{key(), value()}]</h3></div>
    <div class="type"><h3 id="type-iolist">iolist() = [iolist() | binary() | char()]</h3></div>
    <div class="type"><h3 id="type-key">key() = atom() | string() | binary()</h3></div>
    <div class="type"><h3 id="type-response">response()</h3></div>
    <div class="type"><h3 id="type-value">value() = atom() | string() | binary() | integer()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="get_header_value/1">get_header_value(K) -&gt; undefined | Value</h3>


<div class="description">

<p>Get the value of a given request header.</p>
</div></div>
<div class="function">
<h3 id="get_primary_header_value/1">get_primary_header_value(K) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get/1">get(X1::field()) -&gt; term()</h3>


<div class="description">

<p>Return the internal representation of the given field.</p>
</div></div>
<div class="function">
<h3 id="dump/0">dump() -&gt; {mochiweb_request, [{atom(), term()}]}</h3>


<div class="description">

<p>Dump the internal representation to a "human readable" set of terms
       for debugging/inspection purposes.</p>
</div></div>
<div class="function">
<h3 id="send/1">send(Data::iodata()) -&gt; ok</h3>


<div class="description">

<p>Send data over the socket.</p>
</div></div>
<div class="function">
<h3 id="recv/1">recv(Length::integer()) -&gt; binary()</h3>


<div class="description">

<p>Receive Length bytes from the client as a binary, with the default
       idle timeout.</p>
</div></div>
<div class="function">
<h3 id="recv/1-1">recv(Length::integer(), Timeout::integer()) -&gt; binary()</h3>


<div class="description">

<p>Receive Length bytes from the client as a binary, with the given
       Timeout in msec.</p>
</div></div>
<div class="function">
<h3 id="recv_body/0">recv_body() -&gt; binary()</h3>


<div class="description">

<p>Receive the body of the HTTP request (defined by Content-Length).
       Will only receive up to the default max-body length of 1MB.</p>
</div></div>
<div class="function">
<h3 id="recv_body/1">recv_body(MaxBody::integer()) -&gt; binary()</h3>


<div class="description">

<p>Receive the body of the HTTP request (defined by Content-Length).
       Will receive up to MaxBody bytes.</p>
</div></div>
<div class="function">
<h3 id="stream_body/3">stream_body(MaxChunkSize, ChunkFun, FunState) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_response/1">start_response(X1::{integer(), ioheaders()}) -&gt; response()</h3>


<div class="description">

<p>Start the HTTP response by sending the Code HTTP response and
       ResponseHeaders. The server will set header defaults such as Server
       and Date if not present in ResponseHeaders.</p>
</div></div>
<div class="function">
<h3 id="start_raw_response/1">start_raw_response(X1::{integer(), headers()}) -&gt; response()</h3>


<div class="description">

<p>Start the HTTP response by sending the Code HTTP response and
       ResponseHeaders.</p>
</div></div>
<div class="function">
<h3 id="start_response_length/1">start_response_length(X1::{integer(), ioheaders(), integer()}) -&gt; response()</h3>


<div class="description">

<p>Start the HTTP response by sending the Code HTTP response and
       ResponseHeaders including a Content-Length of Length. The server
       will set header defaults such as Server
       and Date if not present in ResponseHeaders.</p>
</div></div>
<div class="function">
<h3 id="respond/1">respond(X1::{integer(), ioheaders(), iodata() | chunked | {file, IoDevice}}) -&gt; response()</h3>


<div class="description">

<p>Start the HTTP response with start_response, and send Body to the
       client (if the get(method) /= 'HEAD'). The Content-Length header
       will be set by the Body length, and the server will insert header
       defaults.</p>
</div></div>
<div class="function">
<h3 id="not_found/0">not_found() -&gt; response()</h3>


<div class="description">

<p>Alias for <code>not_found([])</code>.</p>
</div></div>
<div class="function">
<h3 id="not_found/1">not_found(ExtraHeaders) -&gt; response()</h3>


<div class="description">

<p>Alias for <code>respond({404, [{"Content-Type", "text/plain"}
  | ExtraHeaders], &lt;&lt;"Not found."&gt;&gt;})</code>.</p>
</div></div>
<div class="function">
<h3 id="ok/1">ok(X1::{value(), iodata()} | {value(), ioheaders(), iodata() | {file, IoDevice}}) -&gt; response()</h3>


<div class="description">

<p>respond({200, [{"Content-Type", ContentType} | Headers], Body}).</p>
</div></div>
<div class="function">
<h3 id="should_close/0">should_close() -&gt; bool()</h3>


<div class="description">

<p>Return true if the connection must be closed. If false, using
       Keep-Alive should be safe.</p>
</div></div>
<div class="function">
<h3 id="cleanup/0">cleanup() -&gt; ok</h3>


<div class="description">

<p>Clean up any junk in the process dictionary, required before continuing
       a Keep-Alive request.</p>
</div></div>
<div class="function">
<h3 id="parse_qs/0">parse_qs() -&gt; [{Key::string(), Value::string()}]</h3>


<div class="description">

<p>Parse the query string of the URL.</p>
</div></div>
<div class="function">
<h3 id="get_cookie_value/1">get_cookie_value(Key::string) -&gt; string() | undefined</h3>


<div class="description">

<p>Get the value of the given cookie.</p>
</div></div>
<div class="function">
<h3 id="parse_cookie/0">parse_cookie() -&gt; [{Key::string(), Value::string()}]</h3>


<div class="description">

<p>Parse the cookie header.</p>
</div></div>
<div class="function">
<h3 id="parse_post/0">parse_post() -&gt; [{Key::string(), Value::string()}]</h3>


<div class="description">

<p>Parse an application/x-www-form-urlencoded form POST. This
       has the side-effect of calling recv_body().</p>
</div></div>
<div class="function">
<h3 id="serve_file/2">serve_file(Path, DocRoot) -&gt; Response</h3>


<div class="description">

<p>Serve a file relative to DocRoot.</p>
</div></div>
<div class="function">
<h3 id="serve_file/3">serve_file(Path, DocRoot, ExtraHeaders) -&gt; Response</h3>


<div class="description">

<p>Serve a file relative to DocRoot.</p>
</div></div>
<div class="function">
<h3 id="accepted_encodings/1">accepted_encodings(SupportedEncodings::[encoding()]) -&gt; [encoding()] | bad_accept_encoding_value</h3>


<div class="description">

<p>Returns a list of encodings accepted by a request. Encodings that are       
not supported by the server will not be included in the return list.       
This list is computed from the "Accept-Encoding" header and       
its elements are ordered, descendingly, according to their Q values.</p>
 
       <p>Section 14.3 of the RFC 2616 (HTTP 1.1) describes the "Accept-Encoding"       
header and the process of determining which server supported encodings       
can be used for encoding the body for the request's response.</p>
 
       <p>Examples</p>
 
       <p>1) For a missing "Accept-Encoding" header:          
accepted_encodings(["gzip", "identity"]) -&gt; ["identity"]</p>
 
       <p>2) For an "Accept-Encoding" header with value "gzip, deflate":          
accepted_encodings(["gzip", "identity"]) -&gt; ["gzip", "identity"]</p>
 
       <p>3) For an "Accept-Encoding" header with value "gzip;q=0.5, deflate":
          accepted_encodings(["gzip", "deflate", "identity"]) -&gt;
             ["deflate", "gzip", "identity"]
 </p>
</div></div></div>

<authors>

<aname>Bob Ippolito</aname>
<email>bob@mochimedia.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
