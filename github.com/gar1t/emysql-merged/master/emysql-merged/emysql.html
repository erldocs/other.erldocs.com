<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>emysql (emysql-merged) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>emysql</h1>
<h2 class="modsummary">The main Emysql module.</h2>
<div class="description">
<p>The main Emysql module.</p>
 
  <p>Emysql is implemented as an Erlang
  <em>application</em>. The term has a special meaning in Erlang, see
  <url href="http://www.erlang.org/doc/design_principles/applications.html">http://www.erlang.org/doc/design_principles/applications.html</url></p>
 
  <p>This module exports functions to:
  <item><p><em>start</em> and <em>stop</em> the driver (the 'application'),</p></item>
  <item><p><em>execute</em> queries or prepared statements,</p></item>
  <item><p><em>prepare</em> such statements,</p></item>
  <item><p>change the <em>connection pool</em> size.</p></item></p>
 
  <p><em><marker id="Sample">Sample</marker></em>
  </p><pre class="sh_erlang">   -module(sample).
   -export([run/0]).
 
   run() -&gt;
 
       crypto:start(),
       emysql:start(),
 
       emysql:add_pool(hello_pool, 1,
           "hello_username", "hello_password", "localhost", 3306,
           "hello_database", utf8),
 
       emysql:execute(hello_pool,
           &lt;&lt;"INSERT INTO hello_table SET hello_text = 'Hello World!'"&gt;&gt;),
 
       emysql:prepare(my_stmt, &lt;&lt;"SELECT * from mytable WHERE id = ?"&gt;&gt;),
 
       Result = emysql:execute(mypoolname, my_stmt, [1]).</pre>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Under <em>Implementation</em>, you can find details about the  
inner workings of Emysql. If you are new to Emysql, you may safely ignore  
them.</p>
 
  <p>start(), stop(), modules() and default_timeout() are one-line 'fascades':
  </p><pre class="sh_erlang">   start() -&gt; application:start(emysql).
   stop() -&gt; application:stop(emysql).
   modules() -&gt; emysql_app:modules().
   default_timeout() -&gt; emysql_app:default_timeout().</pre>
 
  <p>execute() and prepare() are the bulk of the source
  of this module. A lot gets repeated for default values in lesser arities.
  The quintessential execute however is this, in execute/2:
  </p><pre class="sh_erlang">   execute(PoolId, Query, Args, Timeout)
       when (is_list(Query) orelse is_binary(Query)) andalso is_list(Args) andalso is_integer(Timeout) -&gt;
 
           Connection =
               emysql_conn_mgr:wait_for_connection(PoolId),
               monitor_work(Connection, Timeout, {emysql_conn, execute, [Connection, Query, Args]});</pre><p>  
As all executions, it uses the monitor_work/3 function to create a process to  
asynchronously handle the execution.</p>
 
  <p>The pool-related functions execute brief operations using the primitive
  functions exported by <code>emysql_conn_mgr</code> and <code>emysql_conn_mgr</code>.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/0">start() -&gt; ok</h3>


<div class="description">

<p>Start the Emysql application.</p>
 
  <p>Simply calls <code>application:start(emysql).</code></p>
 
  <p><em><marker id="From_the_Erlang_Manual">From the Erlang Manual</marker></em></p><p>  
If the application is not already loaded, the application controller will  
first load it using application:load/1. It will check the value of the  
applications key, to ensure that all applications that should be started  
before this application are running. The application controller then  
creates an application master for the application. The application master  
is the group leader of all the processes in the application. The  
application master starts the application by calling the application  
callback function start/2 in the module, and with the start argument,  
defined by the mod key in the .app file.</p>
 
  <p>application:start(Application) is the same as calling  
application:start(Application, temporary). If a temporary application  
terminates, this is reported but no other applications are terminated.</p>
 
  <p>See <url href="http://www.erlang.org/doc/design_principles/applications.html">http://www.erlang.org/doc/design_principles/applications.html</url></p>
</div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; ok</h3>


<div class="description">

<p>Stop the Emysql application.</p>
 
  <p>Simply calls <code>application:stop(emysql).</code></p>
 
  <p><em><marker id="From_the_Erlang_Manual">From the Erlang Manual</marker></em></p><p>  
It is always possible to stop an application explicitly by calling  
application:stop/1. Regardless of the mode, no other applications will be  
affected.</p>
 
  <p>See <url href="http://www.erlang.org/doc/design_principles/applications.html">http://www.erlang.org/doc/design_principles/applications.html</url></p>
</div></div>
<div class="function">
<h3 id="default_timeout/0">default_timeout() -&gt; Timeout</h3>

<ul class="type">
<li><code>Timeout = integer()</code></li></ul>
<div class="description">

<p>Returns the default timeout in milliseconds. As set in emysql.app.src,  
or if not set, the value ?TIMEOUT as defined in include/emysql.hrl (8000ms).</p>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>src/emysql.app.src is a template for the emysql app file from which
  ebin/emysql.app is created during building, by a sed command in 'Makefile'.</p>
</div></div>
<div class="function">
<h3 id="add_pool/2">add_pool(PoolId, Options) -&gt; Result</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Options = [option()]</code></li><li><code>{size, integer()} | {user, string()} | {password, string()} | {host, string()} | {port, integer()} | {database, string() | undefined} | {encoding, atom()} | {start_cmds, [binary()]} | {connect_timeout, integer()}</code></li><li><code>Result = {reply, {error, pool_already_exists}, state()} | {reply, ok, state()}</code></li></ul>
<div class="description">

<p>Synchronous call to the connection manager to add a pool.</p>
 
  <p>Options:</p>
 
  <p>size - pool size (defaults to 1)  
user - user to connect with (defaults to "")  
password - user password (defaults to "")  
host - host to connect to (defaults to "127.0.0.1")  
port - the port to connect to (defaults to 3306)  
database - the database to connect to (defaults to undefined)  
encoding - the connection encoding (defaults to utf8)  
start_cmds - a list of commands to execute on connect  
connect_timeout - millisecond timeout for connect or infinity (default)</p>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Refer to add_pool/8 for implementation details.</p>
</div></div>
<div class="function">
<h3 id="add_pool/8">add_pool(PoolId, Size, User, Password, Host, Port, Database, Encoding) -&gt; Result</h3>


<div class="description">

<p>Adds a pool using the default start commands (empty list).
 </p>
</div></div>
<div class="function">
<h3 id="add_pool/9">add_pool(PoolId, Size, User, Password, Host, Port, Database, Encoding, StartCmds) -&gt; Result</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Size = integer()</code></li><li><code>User = string()</code></li><li><code>Password = string()</code></li><li><code>Host = string()</code></li><li><code>Port = integer()</code></li><li><code>Database = string() | undefined</code></li><li><code>Encoding = utf8 | latin1</code></li><li><code>StartCmds = [binary()]</code></li><li><code>Result = {reply, {error, pool_already_exists}, state()} | {reply, ok, state()}</code></li></ul>
<div class="description">

<p>Synchronous call to the connection manager to add a pool.</p>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Creates a pool record, opens n=Size connections and calls
  emysql_conn_mgr:add_pool() to make the pool known to the pool management.
  emysql_conn_mgr:add_pool() is translated into a blocking gen-server call.</p>
</div></div>
<div class="function">
<h3 id="remove_pool/1">remove_pool(PoolId) -&gt; ok</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li></ul>
<div class="description">

<p>Synchronous call to the connection manager to remove a pool.</p>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Relies on emysql_conn:close_connection(Conn) for the proper closing of connections. Feeds
  any connection in the pool to it, also the locked ones.</p>
</div></div>
<div class="function">
<h3 id="increment_pool_size/1">increment_pool_size(PoolId::atom(), Num::non_neg_integer()) -&gt; ok | {error, list()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="decrement_pool_size/2">decrement_pool_size(PoolId, Num::By) -&gt; ok</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>By = integer()</code></li></ul>
<div class="description">

<p>Synchronous call to the connection manager to shrink a pool.</p>
 
  <p>This reduces the connections by up to n=By, but it only drops and closes available  
connections that are not in use at the moment that this function is called. Connections  
that are waiting for a server response are never dropped. In heavy duty, this function  
may thus do nothing.</p>
 
  <p>If 'By' is higher than the amount of connections or the amount of available connections,  
exactly all available connections are dropped and closed.</p>
 
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>First gets a list of target connections from emysql_conn_mgr:remove_connections(), then
  relies on emysql_conn:close_connection(Conn) for the proper closing of connections.</p>
</div></div>
<div class="function">
<h3 id="prepare/2">prepare(StmtName, Statement) -&gt; ok</h3>

<ul class="type">
<li><code>StmtName = atom()</code></li><li><code>Statement = binary() | string()</code></li></ul>
<div class="description">

<p>Prepare a statement.</p>
 
  <p>The atom given by parameter 'StmtName' is bound to the SQL string
  'Statement'. Calling <code>execute(&lt;Pool&gt;, StmtName, &lt;ParamList&gt;)</code> executes the
  statement with parameters from <code>&lt;ParamList&gt;</code>.</p>
 
  <p>This is not a mySQL prepared statement, but an implementation on the side of  
Emysql.</p>
 
  <p><em><marker id="Sample">Sample</marker></em>
  </p><pre class="sh_erlang">  -module(sample).
  -export([run/0]).
 
  run() -&gt;
 
   application:start(sasl),
   crypto:start(),
   application:start(emysql),
 
   emysql:add_pool(hello_pool, 1,
       "hello_username", "hello_password", "localhost", 3306,
       "hello_database", utf8),
 
   emysql:execute(hello_pool,
       &lt;&lt;"INSERT INTO hello_table SET hello_text = 'Hello World!'"&gt;&gt;),
 
   emysql:prepare(hello_stmt,
       &lt;&lt;"SELECT * from hello_table WHERE hello_text like ?"&gt;&gt;),
 
   Result = emysql:execute(hello_pool, hello_stmt, ["Hello%"]),
 
    io:format("~n~s~n", [string:chars($-,72)]),
    io:format("~p~n", [Result]),
 
      ok.</pre><p>
  Output:
  </p><pre class="sh_erlang">  {result_packet,32,
                [{field,2,&lt;&lt;"def"&gt;&gt;,&lt;&lt;"hello_database"&gt;&gt;,
                         &lt;&lt;"hello_table"&gt;&gt;,&lt;&lt;"hello_table"&gt;&gt;,
                         &lt;&lt;"hello_text"&gt;&gt;,&lt;&lt;"hello_text"&gt;&gt;,254,&lt;&lt;&gt;&gt;,33,
                         60,0,0}],
                 [[&lt;&lt;"Hello World!"&gt;&gt;]],
                 &lt;&lt;&gt;&gt;}</pre><p>
  <em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Hands parameters over to emysql_statements:add/2:
  <code>emysql_statements:add(StmtName, Statement).</code>, which calls
  <code>handle_call({add, StmtName, Statement}, _From, State)</code>.</p>
 
  <p>The statement is there added to the Emysql statement GB tree:
  ... </p><pre class="sh_erlang">               State#state{
                   statements = gb_trees:enter(StmtName, {1, Statement},
                       State#state.statements)</pre><p>
  Execution is called like this:
  </p><pre class="sh_erlang">  execute(Connection, StmtName, Args) when is_atom(StmtName), is_list(Args) -&gt;
   prepare_statement(Connection, StmtName),
   case set_params(Connection, 1, Args, undefined) of
       OK when is_record(OK, ok_packet) -&gt;
           ParamNamesBin = list_to_binary(string:join([[$@ | integer_to_list(I)] || I &lt;- lists:seq(1, length(Args))], ", ")),
           StmtNameBin = atom_to_binary(StmtName, utf8),
           Packet = &lt;&lt;?COM_QUERY, "EXECUTE ", StmtNameBin/binary, " USING ", ParamNamesBin/binary&gt;&gt;,
           emysql_tcp:send_and_recv_packet(Connection#emysql_connection.socket, Packet, 0);
       Error -&gt;
           Error
   end.</pre><p>
 </p>
<p><em>See also:</em> <a href="emysql_conn.html#execute/3" class="seealso">emysql_conn:execute/3</a>, <a href="emysql_statements.html#add/2" class="seealso">emysql_statements:add/2</a>, <a href="emysql_statements.html#handle/3" class="seealso">emysql_statements:handle/3</a>.</p>
</div></div>
<div class="function">
<h3 id="execute/2">execute(PoolId, Query::Query | StmtName) -&gt; Result | [Result]</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Query = binary() | string()</code></li><li><code>StmtName = atom()</code></li><li><code>Result = ok_packet() | result_packet() | error_packet()</code></li></ul>
<div class="description">

<p>Execute a query, prepared statement or a stored procedure.</p>
 
  <p>Same as <code>execute(PoolId, Query, [], default_timeout())</code>.</p>
 
  <p>The result is a list for stored procedure execution &gt;= MySQL 4.1
 </p>
<p><em>See also:</em> <a href="#execute/3" class="seealso">execute/3</a>, <a href="#execute/4" class="seealso">execute/4</a>, <a href="#execute/5" class="seealso">execute/5</a>, <a href="#prepare/2" class="seealso">prepare/2</a>.</p>
</div></div>
<div class="function">
<h3 id="execute/3">execute(PoolId, Query::Query | StmtName, Args::Args | Timeout) -&gt; Result | [Result]</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Query = binary() | string()</code></li><li><code>StmtName = atom()</code></li><li><code>Args = [any()]</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = ok_packet() | result_packet() | error_packet()</code></li></ul>
<div class="description">

<p>Execute a query, prepared statement or a stored procedure.</p>
 
  <p>Same as <code>execute(PoolId, Query, Args, default_timeout())</code>
  or <code>execute(PoolId, Query, [], Timeout)</code>.</p>
 
  <p>Timeout is the query timeout in milliseconds or the atom infinity.</p>
 
  <p>The result is a list for stored procedure execution &gt;= MySQL 4.1
 </p>
<p><em>See also:</em> <a href="#execute/2" class="seealso">execute/2</a>, <a href="#execute/4" class="seealso">execute/4</a>, <a href="#execute/5" class="seealso">execute/5</a>, <a href="#prepare/2" class="seealso">prepare/2</a>.</p>
</div></div>
<div class="function">
<h3 id="execute/4">execute(PoolId, Query::Query | StmtName, Args, Timeout) -&gt; Result | [Result]</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Query = binary() | string()</code></li><li><code>StmtName = atom()</code></li><li><code>Args = [any()]</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = ok_packet() | result_packet() | error_packet()</code></li></ul>
<div class="description">

<p>Execute a query, prepared statement or a stored procedure.</p>
 
  <p><ll>
  <item>Opens a connection,</item>
  <item>sends the query string, or statement atom, and</item>
  <item>returns the result packet.</item>
  </ll></p>
 
  <p>Basically:
  </p><pre class="sh_erlang">  Connection = emysql_conn_mgr:wait_for_connection(PoolId),
  monitor_work(Connection, Timeout, {emysql_conn, execute, [Connection, Query_or_StmtName, Args]}).</pre><p>  
Timeout is the query timeout in milliseconds or the atom infinity.</p>
 
  <p>All other execute function eventually call this function.
 </p>
<p><em>See also:</em> <a href="#execute/2" class="seealso">execute/2</a>, <a href="#execute/3" class="seealso">execute/3</a>, <a href="#execute/5" class="seealso">execute/5</a>, <a href="#prepare/2" class="seealso">prepare/2</a>.</p>
</div></div>
<div class="function">
<h3 id="execute/5">execute(PoolId, Query::Query | StmtName, Args, Timeout, X5::nonblocking) -&gt; Result | [Result]</h3>

<ul class="type">
<li><code>PoolId = atom()</code></li><li><code>Query = binary() | string()</code></li><li><code>StmtName = atom()</code></li><li><code>Args = [any()]</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = ok_packet() | result_packet() | error_packet()</code></li></ul>
<div class="description">

<p>Execute a query, prepared statement or a stored procedure - but return immediately, returning the atom 'unavailable', when no connection in the pool is readily available without wait.</p>
 
  <p><ll>
  <item>Checks if a connection is available,</item>
  <item>returns 'unavailable' if not,</item>
  <item>else as the other exception functions(): sends the query string, or statement atom, and</item>
  <item>returns the result packet.</item>
  </ll></p>
 
  <p>Timeout is the query timeout in milliseconds or the atom infinity.</p>
 
  <p><em><marker id="Implementation">Implementation</marker></em></p>
 
  <p>Basically:
  </p><pre class="sh_erlang">  {Connection, connection} = case emysql_conn_mgr:lock_connection(PoolId),
       monitor_work(Connection, Timeout, {emysql_conn, execute, [Connection, Query_or_StmtName, Args]}).</pre>
 
  <p>The result is a list for stored procedure execution &gt;= MySQL 4.1</p>
 
  <p>All other execute function eventually call this function.
 </p>
<p><em>See also:</em> <a href="#execute/2" class="seealso">execute/2</a>, <a href="#execute/3" class="seealso">execute/3</a>, <a href="#execute/4" class="seealso">execute/4</a>, <a href="#prepare/2" class="seealso">prepare/2</a>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
