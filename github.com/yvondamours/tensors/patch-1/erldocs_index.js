var index = [['app','tensors','tensors','[application]'],['mod','tensors','tensors_app',[]],['mod','tensors','tensors_block',[]],['mod','tensors','tensors_checksum',[]],['mod','tensors','tensors_file',[]],['mod','tensors','tensors_get_stream',[]],['mod','tensors','tensors_io',[]],['mod','tensors','tensors_put_stream',[]],['mod','tensors','tensors_tree',[]],['mod','tensors','tensors_tree_utils',[]],['mod','tensors','tensors_wm_file','Resource for serving large Riak objects over HTTP.'],['fun','tensors','tensors_app:start/2',[]],['fun','tensors','tensors_app:stop/1',[]],['fun','tensors','tensors_block:create/2',[]],['fun','tensors','tensors_block:data/1',[]],['fun','tensors','tensors_block:name/1',[]],['fun','tensors','tensors_checksum:sha1/2',[]],['fun','tensors','tensors_file:create/1','Create a tensors file handle with the given name a'],['fun','tensors','tensors_file:create/1','Create a tensors file handle with the given name a'],['fun','tensors','tensors_file:delete/1','deletes the named file from tensors.'],['fun','tensors','tensors_file:exists/1','Checks for the existence of the named file.'],['fun','tensors','tensors_file:get/1','returns a filehandle for the named file.'],['fun','tensors','tensors_file:get_attributes/1','Gets the attribute dictionary from the file handle'],['fun','tensors','tensors_file:get_default_block_size/0',[]],['fun','tensors','tensors_file:get_property/1','retrieves the named property from the filehandle.'],['fun','tensors','tensors_file:length/1','returns the length in bytes of the file.'],['fun','tensors','tensors_file:name/1','returns the name of the given file handle.'],['fun','tensors','tensors_file:set_attributes/1','Sets the new attributes, saves them, and returns a'],['fun','tensors','tensors_get_stream:close/1','Closes a get stream.'],['fun','tensors','tensors_get_stream:recv/1','Receive will block the calling process until eithe'],['fun','tensors','tensors_get_stream:start/1','Creates and returns a handle to a streaming get.'],['fun','tensors','tensors_io:get_range/1','Returns an iolist() for the starting offset and le'],['fun','tensors','tensors_io:put_range/1','Put range performs a synchronous write operation o'],['fun','tensors','tensors_io:truncate/1','Truncates a file to the specified offset.'],['fun','tensors','tensors_put_stream:close/1','Signals the stream to close.'],['fun','tensors','tensors_put_stream:flush/1','Causes the stream to immediately flush its buffers'],['fun','tensors','tensors_put_stream:ping/1','Pings the stream, resetting the TTL timer.'],['fun','tensors','tensors_put_stream:send/2','Sends the given binary to the stream for writing.'],['fun','tensors','tensors_put_stream:start/4',[]],['fun','tensors','tensors_put_stream:start_link/1','Starts a stream for writing at the specified offse'],['fun','tensors','tensors_put_stream:status/1','Gets the current filehandle on which the stream is'],['fun','tensors','tensors_tree:block_at/1',[]],['fun','tensors','tensors_tree:get/2',[]],['fun','tensors','tensors_tree:get_range/6',[]],['fun','tensors','tensors_tree:get_range/7',[]],['fun','tensors','tensors_tree:truncate/1',[]],['fun','tensors','tensors_tree:truncate/7',[]],['fun','tensors','tensors_tree:update/4',[]],['fun','tensors','tensors_tree:visualize_tree/2',[]],['fun','tensors','tensors_tree_utils:blocklist_length/1',[]],['fun','tensors','tensors_tree_utils:five_way_split/4',[]],['fun','tensors','tensors_tree_utils:foldrflatmap/3',[]],['fun','tensors','tensors_tree_utils:longest_divisable_subtree/2',[]],['fun','tensors','tensors_tree_utils:longest_divisable_subtree/4',[]],['fun','tensors','tensors_tree_utils:shortest_subtree_split/4',[]],['fun','tensors','tensors_tree_utils:split_at_length/2',[]],['fun','tensors','tensors_tree_utils:split_at_length_left_bias/2',[]],['fun','tensors','tensors_wm_file:accept_doc_body/1','Store the data the client is PUTing in the documen'],['fun','tensors','tensors_wm_file:allow_missing_post/1','Makes POST and PUT equivalent for creating new   '],['fun','tensors','tensors_wm_file:allowed_methods/1','Get the list of methods this resource supports.'],['fun','tensors','tensors_wm_file:charsets_provided/1','List the charsets available for representing this '],['fun','tensors','tensors_wm_file:content_types_accepted/1','Get the list of content types this resource will a'],['fun','tensors','tensors_wm_file:content_types_provided/1','List the content types available for representing '],['fun','tensors','tensors_wm_file:create_path/1','Choose the Key for the document created during a b'],['fun','tensors','tensors_wm_file:delete_resource/1','Delete the document specified.'],['fun','tensors','tensors_wm_file:encodings_provided/1','List the encodings available for representing this'],['fun','tensors','tensors_wm_file:generate_etag/1','Get the etag for this resource.'],['fun','tensors','tensors_wm_file:init/1','Initialize this resource.'],['fun','tensors','tensors_wm_file:last_modified/1','Get the last-modified time for this resource.'],['fun','tensors','tensors_wm_file:malformed_request/1','Determine whether query parameters, request header'],['fun','tensors','tensors_wm_file:ping/2',[]],['fun','tensors','tensors_wm_file:post_is_create/1','POST is considered a document-creation operation f'],['fun','tensors','tensors_wm_file:process_post/1','Pass-through for key-level requests to allow POST '],['fun','tensors','tensors_wm_file:produce_doc_body/1','Extract the value of the document, and place it in'],['fun','tensors','tensors_wm_file:produce_toplevel_body/1','Produce the JSON response to a bucket-level GET.'],['fun','tensors','tensors_wm_file:resource_exists/1','Determine whether or not the requested item exists'],['fun','tensors','tensors_wm_file:service_available/1','Determine whether or not a connection to Riak    ']];