<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>tensors_put_stream (tensors) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>tensors_put_stream</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/1">start_link(Riak::riak(), File::tensors_file(), Offset::int(), TTL::int()) -&gt; put_stream()</h3>


<div class="description">

<p>Starts a stream for writing at the specified offset.  The
       stream will remain open for TTL milliseconds.  Every time the
       stream is written to or pinged it will reset the TTL counter.
       Therefore slow writers should set an appropriate TTL or use
       ping/1 to keep a stream open.  This function links the stream
       process to the calling process.</p>
</div></div>
<div class="function">
<h3 id="start/4">start(Riak, File, Offset, TTL) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="send/2">send(X1, Data) -&gt; term()
</h3>


<div class="description">

<p>Sends the given binary to the stream for writing.  The put
       stream does its own internal buffering for performance
       reasons, so this is equivalent to writing to a regular file on
       a local filesystem.  If you want guarantees that your write is
       actually written then you need to call flush/1 on the put
       stream.</p>
</div></div>
<div class="function">
<h3 id="ping/1">ping(X1) -&gt; term()
</h3>


<div class="description">

<p>Pings the stream, resetting the TTL timer.  Use this if you
       have a slow writer but don't necessarily want to extend the
       TTL time.</p>
</div></div>
<div class="function">
<h3 id="close/1">close(X1) -&gt; term()
</h3>


<div class="description">

<p>Signals the stream to close.  The stream will immediately
       flush its buffers to the file and will stay open for TTL
       milliseconds waiting for one last status/2 call.</p>
</div></div>
<div class="function">
<h3 id="status/1">status(Stream::put_stream(), Timeout) -&gt; {ok, File} | {error, Reason}</h3>


<div class="description">

<p>Gets the current filehandle on which the stream is operating.
       Can be called at any time during the life of a stream,
       including after a call to close/1.  The returned file is not
       guaranteed to reflect the latest calls to send/2, since
       status/2 does not cause a flush to occur.</p>
</div></div>
<div class="function">
<h3 id="flush/1">flush(X1) -&gt; term()
</h3>


<div class="description">

<p>Causes the stream to immediately flush its buffers and commit
       any pending writes to the file.  Equivalent to an fsync call
       in most other filesystem API's.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
