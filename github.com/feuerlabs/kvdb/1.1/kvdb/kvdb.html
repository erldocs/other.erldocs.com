<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>kvdb (kvdb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>kvdb</h1>
<h2 class="modsummary">   
Key-value database frontend.</h2>
<div class="description">
<p>   
Key-value database frontend</p>
  
   <p>Kvdb is a key-value database library, supporting different backends   
(currently: sqlite3 and leveldb), and a number of different table types.</p>
  
   <p>Feature overview:</p>
  
   <p>- Multiple logical tables per database</p>
  
   <p>- Persistent ordered-set semantics</p>
  
   <p>- <code>{Key, Value}</code> or <code>{Key, Attributes, Value}</code> structure (per-table)</p>
  
   <p>- Table types: set (normal) or queue (FIFO, LIFO or keyed FIFO or LIFO)</p>
  
   <p>- Attributes can be indexed</p>
  
   <p>- Schema-based validation (per-database) with update triggers</p>
  
   <p>- Prefix matching</p>
  
   <p>- ETS-style select() operations</p>
  
   - Configurable encoding schemes (raw, sext or term_to_binary)
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-attr_name">attr_name() = atom()</h3></div>
    <div class="type"><h3 id="type-attr_value">attr_value() = any()</h3></div>
    <div class="type"><h3 id="type-attrs">attrs() = [{atom(), any()}]</h3></div>
    <div class="type"><h3 id="type-cont">cont() = fun(() -> {[<a href="#type-object" class="seealso">object()</a>], <a href="#type-cont" class="seealso">cont()</a>} | done)</h3></div>
    <div class="type"><h3 id="type-db">db() = #db{}</h3></div>
    <div class="type"><h3 id="type-db_name">db_name() = any()</h3></div>
    <div class="type"><h3 id="type-db_ref">db_ref() = #kvdb_ref{}</h3></div>
    <div class="type"><h3 id="type-int_table_name">int_table_name() = binary()</h3></div>
    <div class="type"><h3 id="type-key">key() = any()</h3></div>
    <div class="type"><h3 id="type-object">object() = {<a href="#type-key" class="seealso">key()</a>, <a href="#type-value" class="seealso">value()</a>} | {<a href="#type-key" class="seealso">key()</a>, <a href="#type-attrs" class="seealso">attrs()</a>, <a href="#type-value" class="seealso">value()</a>}</h3></div>
    <div class="type"><h3 id="type-options">options() = [{atom(), any()}]</h3></div>
    <div class="type"><h3 id="type-queue_name">queue_name() = any()</h3></div>
    <div class="type"><h3 id="type-status">status() = active | inactive | blocking</h3></div>
    <div class="type"><h3 id="type-table">table() = atom() | binary()</h3></div>
    <div class="type"><h3 id="type-value">value() = any()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="info/1">info(Name::db_name(), Item::attr_name()) -&gt; undefined | attr_value()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="dump_tables/1">dump_tables(Name::db_name()) -&gt; list()</h3>


<div class="description">

<p>Returns the contents of the database as a list of objects</p>
 
  <p>This function is mainly for debugging, and should not be called on a  
large database.</p>
 
  <p>The exact format of the list may vary from backend to backend.</p>
</div></div>
<div class="function">
<h3 id="open/1">open(Name::db_name(), Options::[{atom(), term()}]) -&gt; {ok, db_ref()} | {error, term()}</h3>


<div class="description">

<p>Opens a database</p>
 
  <p>Options:</p>
 
  <p>- <code>{backend, Backend}</code> - select a backend<br />
  Supported backends are Sqlite3 (<code>sqlite</code> or <code>sqlite3</code>), <code>ets</code> and <code>leveldb</code>,
  or any module that implements the <code>kvdb</code> behaviour.</p>
 
  <p>- <code>{schema, SchemaMod}</code> - Callback module used for validation and triggers.
  The module must implement the <code>kvdb_schema</code> behaviour.</p>
 
  <p>- <code>{file, File}</code> - File name or directory name of the database.</p>
 
  <p>- <code>{encoding, Encoding}</code> - Default encoding for tables.</p>
 
  <p>- <code>{db_opts, DbOpts}</code> - Backend-specific options.</p>
 
  <p>- <code>{set_timers, boolean()}</code> - If true, process kvdb_cron timers at startup.</p>
</div></div>
<div class="function">
<h3 id="close/1">close(Kvdb_ref) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="await/1">await(DbName::db_name()) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#await/2" class="seealso">await(DbName, 60000)</a>.</p>
</div></div>
<div class="function">
<h3 id="await/1-1">await(DbName::db_name(), Timeout::integer() | infinity) -&gt; ok</h3>


<div class="description">

<p>Waits for the kvdb database <code>DbName</code> to become available.</p>
</div></div>
<div class="function">
<h3 id="db/1">db(Kvdb_ref::db_name() | db_ref()) -&gt; db_ref()</h3>


<div class="description">

<p>Returns a low-level handle for accessing the data via kvdb_direct:* functions.</p>
 
  <p>Note that not all functions are safe to use concurrently from different
  processes. When accessing a database via Name, update functions are
  serialized so that database corruption won't occur.</p>
</div></div>
<div class="function">
<h3 id="db_name/1">db_name(Kvdb_ref) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="transaction/1">transaction(Db::db_name() | #kvdb_ref{}, F::(#kvdb_ref{}) -&gt; T) -&gt; T</h3>


<div class="description">

<p>Runs a transaction with commit/rollback semantics.</p>
 
  <p>This function creates a transaction instance (NewRef) and executes F(NewRef).
  The transaction commits if F returns a value, and this value becomes the
  return value of <code>transaction/2</code>, after committing any updates to the
  original kvdb instance.</p>
</div></div>
<div class="function">
<h3 id="in_transaction/1">in_transaction(Kvdb_ref::db_name() | #kvdb_ref{}, F::(#kvdb_ref{}) -&gt; T) -&gt; T</h3>


<div class="description">

<p>Runs inside an existing transaction if ongoing, or starts a new one.</p>
 
  <p>This function verifies that a transaction context exists, and runs <code>F</code>
  inside it. If no transaction context exists, a new transaction is started.</p>
</div></div>
<div class="function">
<h3 id="add_table/1">add_table(Name::db_name(), Table::table()) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#add_table/3" class="seealso">add_table(Name, Table, [{type, set}])</a>.</p>
</div></div>
<div class="function">
<h3 id="add_table/1-1">add_table(Name::db_name(), Table::table(), Opts::options()) -&gt; ok</h3>


<div class="description">

<p>Add a table to the database</p>
 
  <p>This function assumes that the table doesn't already exist in the database.  
Valid options are:</p>
 
  <p>- <code>{type, set | fifo | lifo | {keyed, fifo | lifo}</code><br />
  This defines the type of the table. <code>set</code> signifies an ordered-set table.
  <code>fifo</code> and <code>lifo</code> are queue table types, accessed using the functions
  <a href="#push/3" class="seealso">push/3</a>, <a href="#pop/2" class="seealso">pop/2</a>, <a href="#prel_pop/2" class="seealso">prel_pop/2</a>, <a href="#extract/3" class="seealso">extract/3</a>,
  <a href="#delete/3" class="seealso">delete/3</a>.</p>
 
  <p><code>{keyed, fifo | lifo}</code> are also a form of queued table type, where items  
are sorted by object key first, and then in FIFO or LIFO insertion order.  
This can be used for e.g. priority- or timer queues.</p>
 
  <p>- <code>{encoding, encoding()}</code><br />
    <code>encoding() :: enc() | {enc(), enc()} | {enc(), enc(), enc()}</code><br />
    <code>enc() :: raw | sext | term</code><br />  
Specifies how the object, or parts of the object, should be encoded.</p>
 
  <list>
  <item><p><code>raw</code> assumes that the data is of type binary; no extra encoding is
  performed.</p></item>
  <item><p><code>term</code> uses <code>term_to_binary/1</code> encoding. This is generally not useful
  for the key component, as sort order is not preserved, but is a good
  generic choice for the value component.</p></item>
  <item><p><code>sext</code> uses sext-encoding
  (<url href="http://github.com/uwiger/sext">github.com/uwiger/sext</url>), which
  preserves the inherent sort order of erlang terms. Note that <code>sext</code>-encoding
  is a bit more costly than term-encoding, both in time and space.</p></item>
  </list><p>
  When the short forms, <code>sext</code>, <code>raw</code> or <code>term</code> are used, they imply a
  <code>{Key, Value}</code> structure. For a <code>{Key, Attrs, Value}</code> structure, use the
  3-tuple form, e.g. <code>{sext, sext, term}</code>. (The leveldb backend ignores the
  encoding instruction for attrs, and encodes each attribute key with <code>sext</code>
  encoding and each attribute value with <code>term</code> encoding).</p>
 
  <p>- <code>{index, [index_expr()]}</code><br />
  <code>index_expr() :: atom() |
                   {index_ref(), value|each|words} |
                   {_Name::any(), value|each|words, _Attr::index_ref()}
   index_ref() :: atom() | {value} | {M:atom(), F::atom()}</code></p>
 
  <p>Attributes can be indexed, by naming the attribute names to include.
  If only the attribute name is given, the attribute value is used as the index
  value. If a tuple {IxName, Op, Attr} is given, the attribute value is
  processed to yield a list of index values. Supported operations are:<br />
  </p><list>
  <item><p><code>each</code> - the attribute value is a list; each list item becomes and index
  value.</p></item>
  <item><p><code>words</code> - the attribute value is a string (list) or binary; each word
  in the text becomes an index value.</p></item>
  <item><p><code>value</code> - the attribute value is taken as-is</p></item>
  </list>
 
  <p>An index reference can either be the attribute name (an atom), or
  the tuple <code>{value}</code>, meaning the actual value part of the object,
  or <code>{M, F}</code>, identifying a callback function, which will be called as
  <code>M:F({Key, Attrs, Value}) -&gt; IndexBase</code>. The type of <code>IndexBase</code> should
  suit the specified operation: it can be anything for <code>value</code>, should be
  a list for <code>each</code>, and a string or binary for <code>words</code>.</p>
</div></div>
<div class="function">
<h3 id="delete_table/2">delete_table(Name, Table) -&gt; term()
</h3>


<div class="description">

<p>Delete <code>Table</code> from the database</p>
</div></div>
<div class="function">
<h3 id="list_tables/1">list_tables(Name::db_name()) -&gt; [binary()]</h3>


<div class="description">

<p>Lists the tables defined in the database</p>
</div></div>
<div class="function">
<h3 id="meta_table/0">meta_table() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="put/1">put(Name::any(), Table::table(), Obj::object()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Inserts an object into Table</p>
 
  <p>The arity of the object tuple must match the encoding of the table
  (i.e. <code>{Key, Value}</code> or <code>{Key, Attrs, Value}</code>). If the key already exists  
in the table, the previous object will be replaced with the new.</p>
 
  <p>Attributes are stored as an 'orddict' - sorted and with unique keys. The
  given attribute list will be normalized as if it were a proplist. This means
  that if it contains duplicate keys, the first occurrence will be kept.</p>
</div></div>
<div class="function">
<h3 id="get/1">get(Name::db_name(), Table::table(), Key::any()) -&gt; {ok, object()} | {error, any()}</h3>


<div class="description">

<p>Perform a lookup on <code>Key</code> in <code>Table</code></p>
 
  <p>Returns <code>{ok, Object}</code> or <code>{error, Reason}</code>, e.g. <code>{error, not_found}</code>
  if the object could not be found.</p>
</div></div>
<div class="function">
<h3 id="index_get/1">index_get(Name::db_name(), Table::table(), _IxName::any(), _IxVal::any()) -&gt; [object()]</h3>


<div class="description">

<p>Perform an index lookup on the named index of Table</p>
 
  <p>This function returns a list of objects referenced by the index value, or
  raises an exception, if there is no such index for the Table.</p>
</div></div>
<div class="function">
<h3 id="index_keys/1">index_keys(Name::db_name(), Table::table(), _IxName::any(), _IxVal::any()) -&gt; [key()]</h3>


<div class="description">

<p>Perform an index lookup on the named index of Table, return matchin keys</p>
 
  <p>This function returns a list of keys referenced by the index value, or
  raises an exception, if there is no such index for the Table.</p>
</div></div>
<div class="function">
<h3 id="update_counter/4">update_counter(Name, Table, Key, Incr) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="push/1">push(Name::db_name(), Table::table(), Obj::object()) -&gt; {ok, _ActualKey::any()} | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#push/4" class="seealso">push(Name, Table, &lt;&lt;&gt;&gt;, Obj)</a>.</p>
</div></div>
<div class="function">
<h3 id="push/1-1">push(Name::any(), Table::table(), Q::queue_name(), Obj::object()) -&gt; {ok, _ActualKey::any()} | {error, any()}</h3>


<div class="description">

<p>Push an object onto a persistent queue</p>
 
  <p><code>Table</code> must be of one of the queue types (see <a href="#create_table/3" class="seealso">create_table/3</a>).
  The queue identifier <code>Q</code> specifies a given queue instance inside the table
  (there may be a large number of queue instances), and a special key is
  created to uniquely identify the inserted object. The actual key must be
  used to delete the object (unless it is automatically removed using the
  <a href="#pop/3" class="seealso">pop/3</a> function.</p>
</div></div>
<div class="function">
<h3 id="pop/1">pop(Name::db_name(), Table::table()) -&gt; {ok, object()} | done | blocked | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#pop/3" class="seealso">pop(Name, Table, &lt;&lt;&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="pop/1-1">pop(Name::db_name(), Table::table(), Q::queue_name()) -&gt; {ok, object()} | done | blocked | {error, any()}</h3>


<div class="description">

<p>Fetches and deletes the 'first' object in the given queue</p>
</div></div>
<div class="function">
<h3 id="peek/2">peek(Name, Table) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="peek/3">peek(Name, Table, Q) -&gt; term()
</h3>


<div class="description">

<p>Returns the first (active) object in the queue, without removing it</p>
 
  <p>If there is no active object, or it is preceded by a blocking object,
  <code>done</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="prel_pop/1">prel_pop(Name::db_name(), Table::table()) -&gt; {ok, object(), binary()} | done | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prel_pop/1-1">prel_pop(Name::db_name(), Table::table(), Q::queue_name()) -&gt; {ok, object(), binary()} | done | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="extract/1">extract(Name::db_name(), Table::table(), Key::binary()) -&gt; {ok, object()} | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mark_queue_object/1">mark_queue_object(Name::db_name(), Table::table(), Key::binary(), St::status()) -&gt; ok | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_queue/1">list_queue(Name::db_name(), Table::table(), Q::queue_name()) -&gt; [object()] | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_queue/1-1">list_queue(Name::db_name(), Table::table(), Q::queue_name(), _Fltr::(active | inactive | blocking, #q_key{}, tuple()) -&gt; keep | keep_raw | skip | stop | {keep, tuple()}, _HeedBlock::boolean(), _Limit::integer() | infinity) -&gt; [object()] | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_queue_empty/1">is_queue_empty(Name::db_name(), Table::table(), _Q::queue_name()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="first_queue/1">first_queue(Name::db_name(), Table::table()) -&gt; {ok, queue_name()} | done</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="next_queue/1">next_queue(Name::db_name(), Table::table(), _Q::queue_name()) -&gt; {ok, any()} | done</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_read/1">queue_read(Name::db_name(), Table::table(), Q_key::#q_key{}) -&gt; {ok, status(), object()} | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_insert/5">queue_insert(Name, Table, Q_key, St, Obj) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_delete/3">queue_delete(Name, Table, Q_key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_head_write/4">queue_head_write(Name, Table, Queue, Data) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_head_read/3">queue_head_read(Name, Table, Queue) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="queue_head_delete/3">queue_head_delete(Name, Table, Queue) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_attrs/1">get_attrs(Name::db_name(), Table::table(), _Key::any(), As::[attr_name()]) -&gt; {ok, attrs()} | {error, any()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/3">delete(Name, Table, Key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="first/2">first(Name, Table) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="last/2">last(Name, Table) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="next/3">next(Name, Table, Key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prev/3">prev(Name, Table, Key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prefix_match/3">prefix_match(Name, Table, Prefix) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prefix_match/4">prefix_match(Name, Table, Prefix, Limit) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prefix_match_rel/5">prefix_match_rel(Name, Table, Prefix, StartPoint, Limit) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="select/3">select(Name::Db, Table, MatchSpec) -&gt; {Objects, Cont} | done</h3>


<div class="description">

<p>Similar to ets:select/3.</p>
 
  <p>This function builds on prefix_match/3, and applies a match specification
  on the results. If keys are using <code>raw</code> encoding, a partial key can be
  given using string syntax, e.g. <code>"abc" ++ '_'</code>. Note that this
  will necessitate some data conversion back and forth on the found objects.
  If a prefix cannot be determined for the key, a full traversal of the table
  will be performed. <code>sext</code>-encoded keys can be prefixed in the same way as
  normal erlang terms in an ets:select().</p>
</div></div>
<div class="function">
<h3 id="select/4">select(Name, Table, MatchSpec, Limit) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_link/2">start_link(Name, Backend) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_session/2">start_session(Name, Id) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Ulf Wiger</aname>
<email>ulf@feuerlabs.com</email>
<aname>Tony Rogvall</aname>
<email>tony@rogvall.se</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
