<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>kvdb_conf (kvdb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>kvdb_conf</h1>
<h2 class="modsummary">   
API to store NETCONF-style config data in kvdb.</h2>
<div class="description">
<p>   
API to store NETCONF-style config data in kvdb</p>
  
   <p>The <code>kvdb_conf</code> API offers a number of functions geared towards
   management of a configuration database. Specifically, <code>kvdb_conf</code> is
   designed to work well with configuration management Ã&nbsp; la
   <url href="http://tools.ietf.org/html/rfc6241">NETCONF (RFC 6241)"</url> and
   the <url href="http://tools.ietf.org/html/rfc6020">YANG data modeling
   language (RFC 6020)</url>. When used in the Feuerlabs Exosense(tm) platform,
   <code>kvdb_conf</code> ties into the device lifecycle management concepts of the   
Feuerlabs ExoDM Device Management Platform.</p>
  
   <p>The database itself is a <code>kvdb</code> database, so the <code>kvdb</code> API also applies.</p>
  
   <p>Specifically, <code>kvdb_conf</code> provides the following functionality on top
   of <code>kvdb</code>:</p>
  
   <p>* The object structure is <code>{Key, Attribues, Value}</code>
   * Keys are always <code>raw</code>-encoded, and reflect a hierarchy
   * A hierarchical key can be constructed using '*' as a join symbol.
   * Keys can be constructed/deconstructed with
     <a href="#join_key/1" class="seealso">join_key/1</a>/<a href="#split_key/1" class="seealso">split_key/1</a>   
* Whole configuration subtrees can be read/written as one operation   
* Subtrees can be efficiently skipped during traversal due to key encoding.   
identifiers are stored as a structured key (binary)   
delimited by:</p>
  
   <p>Netconf identifiers can consist of alphanumerics, '-', '_' or '.'.   
The '*' as delimiter is chosen so that a "wildcard" character can be   
used that is greater than the delimiter, but smaller than any identifier   
character.</p>
  
   For further generality, <code>kvdb_conf</code> keys are escaped, using an algorithm
   that doesn't upset the sort order, or ability to skip past subtrees during
   traversal. Two functions exist for construction/deconstruction of
   composite keys: <a href="#join_key/1" class="seealso">join_key/1</a> and <a href="#split_key/1" class="seealso">split_key/1</a>. These functions
   also escape/unescape keys that are outside the Netconf alphabet. An escaped
   key starts with '='. The escaping character is '@', followed by the hex
   code of the escaped character. For efficiency, any key (or key part) that
   starts with '=' will be considered escaped. Thus, no unescaped key may
   begin with '=' (this is not enforced, but will lead to unpredictable
   behavior).</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-attrs">attrs() = [{atom(), any()}]</h3></div>
    <div class="type"><h3 id="type-conf_node">conf_node() = {<a href="#type-node_key" class="seealso">node_key()</a>, <a href="#type-attrs" class="seealso">attrs()</a>, <a href="#type-value" class="seealso">value()</a>, <a href="#type-conf_tree" class="seealso">conf_tree()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {<a href="#type-node_key" class="seealso">node_key()</a>, <a href="#type-conf_tree" class="seealso">conf_tree()</a>}</h3></div>
    <div class="type"><h3 id="type-conf_obj">conf_obj() = {<a href="#type-node_key" class="seealso">node_key()</a>, <a href="#type-attrs" class="seealso">attrs()</a>, <a href="#type-value" class="seealso">value()</a>}</h3></div>
    <div class="type"><h3 id="type-conf_tree">conf_tree() = [<a href="#type-conf_node" class="seealso">conf_node()</a> | <a href="#type-conf_obj" class="seealso">conf_obj()</a>]</h3></div>
    <div class="type"><h3 id="type-key">key() = binary()</h3></div>
    <div class="type"><h3 id="type-key_part">key_part() = binary() | {binary(), integer()}</h3></div>
    <div class="type"><h3 id="type-node_key">node_key() = <a href="#type-key" class="seealso">key()</a> | integer()</h3></div>
    <div class="type"><h3 id="type-shift_op">shift_op() = up | down | top | bottom</h3></div>
    <div class="type"><h3 id="type-value">value() = any()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="transaction/1">transaction(Fun::(db_ref() (see module kvdb)) -&gt; T) -&gt; T</h3>


<div class="description">
<p>Equivalent to <a href="kvdb.xml.html#transaction/2" class="seealso">kvdb:transaction(kvdb_conf_instance(), Fun)</a>.</p>
</div></div>
<div class="function">
<h3 id="in_transaction/1">in_transaction(Fun::(db_ref() (see module kvdb)) -&gt; T) -&gt; T</h3>


<div class="description">
<p>Equivalent to <a href="kvdb.xml.html#in_transaction/2" class="seealso">kvdb:in_transaction(kvdb_conf_instance(), Fun)</a>.</p>
</div></div>
<div class="function">
<h3 id="open/1">open(File) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#open/2" class="seealso">open(File, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="open/1-1">open(_Filename::undefined | string(), Options::options() (see module kvdb)) -&gt; {ok, pid()} | {error, any()}</h3>


<div class="description">

<p>Opens a kvdb_conf-compliant kvdb database.</p>
 
  <p>The kvdb_conf API offers a number of functions geared towards management of
  a configuration database. The database itself is a <code>kvdb</code> database, so the
  <code>kvdb</code> API also applies. Specifically, <code>kvdb_conf</code> provides the following
  functionality on top of <code>kvdb</code>:</p>
 
  <p>The default options provided by <code>kvdb_conf</code> may be overridden, except for
  the key encoding, which must always be <code>raw</code>, and the object structure,  
which must always include attributes.</p>
 
  <p>If <code>File == undefined</code>, either a filename will be picked by the chosen
  <code>kvdb</code> backend, or - e.g. in case of the <code>ets</code> backend - no file will be  
used at all. Please refer to the documentation of each backend for  
information about their respective strengths and weaknesses.</p>
 
  <p>By default, <code>kvdb_conf</code> specifies one table: <code>&lt;&lt;"data"&gt;&gt;</code>. This table is  
mandatory, and used unless another table is specified. Other tables can  
be created e.g. in order to use a different value encoding or indexes,  
or to separate different data sets.</p>
 
  <p>If a <code>name</code> option is given, the database instance can be called something
  other than <code>kvdb_conf</code>. This is primarily intended for e.g. device
  simulators. The database name is handled transparently in the <code>kvdb_conf</code>
  API, and no facility exists to explicitly choose between different
  <code>kvdb_conf</code> instances. The name of the current instance is stored in the
  process dictionary of the current process, and automatically fetched by
  the <code>kvdb_conf</code> functions.</p>
</div></div>
<div class="function">
<h3 id="add_table/1">add_table(T::table() (see module kvdb)) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#add_table/2" class="seealso">add_table(T, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="add_table/1-1">add_table(T::table() (see module kvdb), Opts::options() (see module kvdb)) -&gt; ok</h3>


<div class="description">

<p>Adds a table to the <code>kvdb_conf</code> database. By default, <code>kvdb_conf</code>
  uses a table called <code>data</code>, which is created when the database is first
  created. Additional tables can opt for different types of indexing, or
  encoding of the <code>Value</code> part. The <code>Key</code> part must always be <code>raw</code>, since
  the <code>kvdb_conf</code> API requires the keys to be of type <code>binary()</code>, and the
  object structure must be <code>{Key, Attributes, Value}</code>. The default encoding
  is <code>{raw, term, raw}</code>.</p>
 
  <p>(While it is of course possible to store binary keys with any type of
  encoding, enforcing <code>raw</code> encoding ensures that this restriction is not
  subverted through the normal <code>kvdb</code> API).</p>
 
  <p>All other table options supported by <a href="kvdb.html#add_table/3" class="seealso">kvdb:add_table/3</a> are also
  supported here.</p>
</div></div>
<div class="function">
<h3 id="delete_table/1">delete_table(T::table() (see module kvdb)) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="kvdb.xml.html#delete_table/1" class="seealso">kvdb:delete_table(T)</a>.</p>
</div></div>
<div class="function">
<h3 id="close/0">close() -&gt; ok</h3>


<div class="description">

<p>Closes the current <code>kvdb_conf</code> database.</p>
</div></div>
<div class="function">
<h3 id="read/1">read(Key::key()) -&gt; {ok, conf_obj()} | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#read/2" class="seealso">read(&lt;&lt;"data"&gt;&gt;, Key)</a>.</p>
</div></div>
<div class="function">
<h3 id="read/2">read(Tab, Key) -&gt; term()
</h3>


<div class="description">

<p>Reads a configuration object from the database</p>
 
  <p>The returned item is always the single node. See read_tree(Prefix) on how to read an
  entire tree structure.</p>
</div></div>
<div class="function">
<h3 id="write/1">write(Obj::conf_obj()) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#write/2" class="seealso">write(&lt;&lt;"data"&gt;&gt;, Obj)</a>.</p>
</div></div>
<div class="function">
<h3 id="write/1-1">write(Tab::table() (see module kvdb), Obj0::conf_obj()) -&gt; ok</h3>


<div class="description">

<p>Writes a configuration object into the database.</p>
 
  <p>Each node or leaf in the tree is stored as a separate object, so updating  
or inserting a node or leaf in the tree is a very cheap operation.</p>
 
  <p>Note that the <code>kvdb_conf</code> API only accepts keys of type <code>binary()</code>,
  even though it allows kvdb_conf tables to select a different key encoding.</p>
</div></div>
<div class="function">
<h3 id="update_counter/1">update_counter(K::key() (see module kvdb), Incr::integer()) -&gt; integer() | binary()</h3>


<div class="description">
<p>Equivalent to <a href="#update_counter/3" class="seealso">update_counter(&lt;&lt;"data"&gt;&gt;, Key, Incr)</a>.</p>
</div></div>
<div class="function">
<h3 id="update_counter/1-1">update_counter(Tab::table() (see module kvdb), K::key() (see module kvdb), Incr::integer()) -&gt; integer() | binary()</h3>


<div class="description">

<p>Updates a counter with the given increment.</p>
 
  <p>This function can be used to update a counter object (the value part is  
assumed to contain the counter value). The counter value can be either  
a byte- or bitstring representation of an integer, or a regular integer.  
The return value will be the new counter value, of the same type as the  
counter itself.</p>
 
  <p>In the case of a byte- or bitstring-encoded counter, the size of the
  value is preserved. No overflow check is currently performed.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(K::key() (see module kvdb)) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#delete/2" class="seealso">delete(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="delete/1-1">delete(Tab::table() (see module kvdb), K::key() (see module kvdb)) -&gt; ok</h3>


<div class="description">

<p>Deletes an object denoted by Key, returns <code>ok</code> even if object not found.</p>
</div></div>
<div class="function">
<h3 id="delete_all/1">delete_all(Prefix::prefix() (see module kvdb)) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#delete_all/2" class="seealso">delete_all(&lt;&lt;"data"&gt;&gt;, Prefix)</a>.</p>
</div></div>
<div class="function">
<h3 id="delete_all/1-1">delete_all(Tab::table() (see module kvdb), Prefix::prefix() (see module kvdb)) -&gt; ok</h3>


<div class="description">

<p>Deletes all objects with a key matching <code>Prefix</code>. Always returns <code>ok</code>.</p>
</div></div>
<div class="function">
<h3 id="prefix_match/1">prefix_match(Prefix::prefix() (see module kvdb)) -&gt; {[conf_obj()], cont() (see module kvdb)}</h3>


<div class="description">
<p>Equivalent to <a href="#prefix_matc/2" class="seealso">prefix_matc(&lt;&lt;"data"&gt;&gt;, Prefix)</a>.</p>
</div></div>
<div class="function">
<h3 id="prefix_match/1-1">prefix_match(Tab::table() (see module kvdb), Prefix::prefix() (see module kvdb)) -&gt; {[conf_obj()], cont() (see module kvdb)}</h3>


<div class="description">

<p>Performs a prefix match, returning all matching objects.</p>
 
  <p>The difference between this function and <a href="kvdb.html#prefix_match/3" class="seealso">kvdb:prefix_match/3</a> is that
  this function automatically ensures that the prefix is escaped using the
  <code>kvdb_conf</code> escaping rules.</p>
</div></div>
<div class="function">
<h3 id="prefix_match/3">prefix_match(Tab, Prefix, Limit) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="all/0">all() -&gt; [conf_obj()]</h3>


<div class="description">
<p>Equivalent to <a href="#all/1" class="seealso">all(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="all/1">all(Tab::table() (see module kvdb)) -&gt; [conf_obj()]</h3>


<div class="description">

<p>Returns a list of all configuration objects in the given table.</p>
 
  <p>Note: this function returns <em>all</em> objects in one sweep. It doesn't
  return a subset together with a continuation. Thus, this function is more
  suited to debugging (given that the data set is small!). For safer
  semantics, see <a href="#prefix_match/2" class="seealso">prefix_match/2</a> - An equivalent version to this
  function would be <code>prefix_match(Tab, &lt;&lt;&gt;&gt;)</code>.</p>
</div></div>
<div class="function">
<h3 id="first/0">first() -&gt; {ok, conf_obj()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#first/1" class="seealso">first(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="last/0">last() -&gt; {ok, conf_obj()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#last/1" class="seealso">last(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="next/1">next(K::key() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#next/2" class="seealso">next(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="prev/1">prev(K::key() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#prev/2" class="seealso">prev(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="first/1">first(Tab::table() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">

<p>Returns the first object in <code>Tab</code>, if there is one; otherwise <code>done</code>.</p>
</div></div>
<div class="function">
<h3 id="first_child/1">first_child(Parent::key()) -&gt; {ok, key()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#first_child/2" class="seealso">first_child(&lt;&lt;"data"&gt;&gt;, Parent)</a>.</p>
</div></div>
<div class="function">
<h3 id="first_child/1-1">first_child(Table::table() (see module kvdb), Parent::key()) -&gt; {ok, key()} | done</h3>


<div class="description">

<p>Returns the first child, if any, of the given <code>Parent</code>.</p>
</div></div>
<div class="function">
<h3 id="next_child/1">next_child(Prev::key()) -&gt; {ok, key()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#next_child/2" class="seealso">next_child(&lt;&lt;"data"&gt;&gt;, Prev)</a>.</p>
</div></div>
<div class="function">
<h3 id="next_child/1-1">next_child(Table::table() (see module kvdb), PrevChild::key()) -&gt; {ok, key()} | done</h3>


<div class="description">

<p>Returns the next child at the same level as <code>PrevChild</code>.
 </p>
</div></div>
<div class="function">
<h3 id="last_child/1">last_child(K::key()) -&gt; {ok, key()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#last_child/2" class="seealso">last_child(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="last_child/1-1">last_child(Tab::table() (see module kvdb), Parent0::key()) -&gt; {ok, key()} | done</h3>


<div class="description">

<p>Returns the last child, if any, of the given <code>Parent</code>; otherwise <code>done</code>.</p>
</div></div>
<div class="function">
<h3 id="fold_children/1">fold_children(Fun::(key(), Acc) -&gt; Acc, Acc, K::key()) -&gt; Acc</h3>


<div class="description">
<p>Equivalent to <a href="#fold_children/4" class="seealso">fold_children(&lt;&lt;"data"&gt;&gt;, Fun, Acc, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="fold_children/1-1">fold_children(Tab::table() (see module kvdb), Fun::(key(), Acc) -&gt; Acc, Acc, K::key()) -&gt; Acc</h3>


<div class="description">

<p>Folds over the immediate children of <code>K</code>, applying <code>Fun(K, Acc)</code>.</p>
</div></div>
<div class="function">
<h3 id="fold_list/1">fold_list(Fun::(integer(), key(), Acc) -&gt; Acc, Acc, BaseKey::key()) -&gt; Acc</h3>


<div class="description">
<p>Equivalent to <a href="#fold_list/4" class="seealso">fold_list(&lt;&lt;"data"&gt;&gt;, Fun, Acc, BaseKey)</a>.</p>
</div></div>
<div class="function">
<h3 id="fold_list/1-1">fold_list(Tab::table() (see module kvdb), Fun::(integer(), key(), Acc) -&gt; Acc, Acc, BaseKey::key()) -&gt; Acc</h3>


<div class="description">

<p>Fold through a configuration list set.</p>
 
  <p>This function assumes that <code>BaseKey</code> is a prefix to a set of list keys,
  e.g. <code>&lt;&lt;"a*b*c"&gt;&gt;</code> would be a base key for <code>&lt;&lt;"a*b*c[00000001]"&gt;&gt;</code>,
  <code>&lt;&lt;"a*b*c[00000002]"&gt;&gt;</code>, etc. This function folds through all matching
  keys, applying <code>Fun(PosIndex, Key, Acc)</code> and accumulating the result.
  <code>PosIndex</code> is the numerical index value of the list key. <code>Key</code> is the
  entire key.</p>
</div></div>
<div class="function">
<h3 id="last_list_pos/1">last_list_pos(Prefix) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="last_list_pos/2">last_list_pos(Table, Prefix0) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="last/1">last(Tab::table() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">

<p>Returns the last object in <code>Tab</code>, if there is one; otherwise
  <code>done</code>.</p>
</div></div>
<div class="function">
<h3 id="next/1-1">next(Tab::table() (see module kvdb), K::key() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">

<p>Returns the next object in <code>Tab</code> following the key <code>K</code>,
  if there is one; otherwise <code>done</code>.</p>
</div></div>
<div class="function">
<h3 id="prev/1-1">prev(Tab::table() (see module kvdb), K::key() (see module kvdb)) -&gt; {ok, conf_obj()} | done</h3>


<div class="description">

<p>Returns the previous object in <code>Tab</code> before the key <code>K</code>,
  if there is one; otherwise <code>done</code>.</p>
</div></div>
<div class="function">
<h3 id="first_tree/0">first_tree() -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">
<p>Equivalent to <a href="#first_tree/1" class="seealso">first_tree(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="first_tree/1">first_tree(Table::table() (see module kvdb)) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">

<p>Reads the first config tree from <code>Table</code>, returns <code>[]</code> if <code>Table</code> empty.</p>
 
  <p>This function returns a <code>#conf_tree{}</code> record which, among other things,
  can be passed to <a href="#write_tree/3" class="seealso">write_tree/3</a> or <a href="#flatten_tree/1" class="seealso">flatten_tree/1</a>.</p>
</div></div>
<div class="function">
<h3 id="last_tree/0">last_tree() -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">
<p>Equivalent to <a href="#last_tree/1" class="seealso">last_tree(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="last_tree/1">last_tree(Table::table() (see module kvdb)) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">

<p>Returns the last config tree from <code>Table</code>, or <code>[]</code> if <code>Table</code> empty.</p>
 
  <p>This function returns a <code>#conf_tree{}</code> record which, among other things,
  can be passed to <a href="#next_tree/2" class="seealso">next_tree/2</a>, <a href="#write_tree/3" class="seealso">write_tree/3</a> or
  <a href="#flatten_tree/1" class="seealso">flatten_tree/1</a>.</p>
</div></div>
<div class="function">
<h3 id="next_tree/1">next_tree(K::key() (see module kvdb)) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">
<p>Equivalent to <a href="#next_tree/2" class="seealso">next_tree(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="next_tree/1-1">next_tree(Tab::table() (see module kvdb), Conf_tree::key() (see module kvdb) | #conf_tree{root=key(), tree=conf_tree()}) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">

<p>Returns the next config tree in <code>Table</code> after <code>K</code>, or <code>[]</code> if not found.</p>
 
  <p>This function returns a <code>#conf_tree{}</code> record which, among other things,
  can be passed to <a href="#write_tree/3" class="seealso">write_tree/3</a> or <a href="#flatten_tree/1" class="seealso">flatten_tree/1</a>.
 </p>
</div></div>
<div class="function">
<h3 id="next_at_level/1">next_at_level(K::key() (see module kvdb)) -&gt; {ok, key() (see module kvdb)} | done</h3>


<div class="description">
<p>Equivalent to <a href="#next_at_level/2" class="seealso">next_at_level(&lt;&lt;"data"&gt;&gt;, K)</a>.</p>
</div></div>
<div class="function">
<h3 id="next_at_level/1-1">next_at_level(Tab::table() (see module kvdb), K0::key() (see module kvdb)) -&gt; {ok, key() (see module kvdb)} | done</h3>


<div class="description">

<p>Skips to the next sibling at the same level in the subtree.</p>
</div></div>
<div class="function">
<h3 id="first_top_key/0">first_top_key() -&gt; {ok, key()} | done</h3>


<div class="description">
<p>Equivalent to <a href="#first_top_key/1" class="seealso">first_top_key(&lt;&lt;"data"&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="first_top_key/1">first_top_key(Table::table() (see module kvdb)) -&gt; {ok, key()} | done</h3>


<div class="description">

<p>Returns the first top-level key in <code>Table</code>, or <code>done</code> if empty.</p>
</div></div>
<div class="function">
<h3 id="read_tree/1">read_tree(Prefix::binary()) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">
<p>Equivalent to <a href="#read_tree/2" class="seealso">read_tree(&lt;&lt;"data"&gt;&gt;, Prefix)</a>.</p>
</div></div>
<div class="function">
<h3 id="read_tree/1-1">read_tree(Tab::table() (see module kvdb), Prefix::binary()) -&gt; #conf_tree{root=key(), tree=conf_tree()} | []</h3>


<div class="description">

<p>Read a configuration (sub-)tree matching Prefix.</p>
 
  <p>This function does a prefix match on the configuration database, and builds
  a tree from the result. The empty binary will result in the whole table
  being built as a tree. The returned tree is <code>[]</code> if nothing was found, or
  a <code>#conf_tree{}</code> record, which can be passed to e.g. <a href="#write_tree/3" class="seealso">write_tree/3</a>,
  <a href="#flatten_tree/1" class="seealso">flatten_tree/1</a>, etc.</p>
</div></div>
<div class="function">
<h3 id="make_tree/1">make_tree(Objs::[conf_obj()]) -&gt; #conf_tree{root=key(), tree=conf_tree()}</h3>


<div class="description">

<p>Converts an ordered list of configuration objects into a configuration tree.</p>
</div></div>
<div class="function">
<h3 id="get_root/1">get_root(Conf_tree::#conf_tree{root=key(), tree=conf_tree()}) -&gt; key()</h3>


<div class="description">

<p>Returns the root key of the given config tree.</p>
</div></div>
<div class="function">
<h3 id="set_root/1">set_root(R::key(), Conf_tree::#conf_tree{root=key(), tree=conf_tree()}) -&gt; #conf_tree{root=key(), tree=conf_tree()}</h3>


<div class="description">

<p>Inserts a new root into a <code>#conf_tree{}</code> record.</p>
</div></div>
<div class="function">
<h3 id="shift_root/1">shift_root(Dirs::shift_op() | [shift_op()], Conf_tree::#conf_tree{root=key(), tree=conf_tree()}) -&gt; #conf_tree{root=key(), tree=conf_tree()} | error</h3>


<div class="description">

<p>Shifts the config tree root upwards or downwards if possible.</p>
 
  <p>This function allows the root of a config tree to be made longer or shorter,
  shifting key parts of the root in or out of the actual tree. For
  <code>shift_root(top, Tree)</code>, the root will be shifted into the tree until the
  remaining root is <code>&lt;&lt;&gt;&gt;</code>. For <code>shift_root(bottom, Tree)</code>, the root will be
  shifted out of the tree, until it is the longest common prefix for all
  child nodes in the tree. If the root cannot be shifted any more in a given
  direction, <code>error</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="split_key/1">split_key(K::key()) -&gt; [key_part()]</h3>


<div class="description">

<p>Splits a <code>kvdb_conf</code> key into a list of (unescaped) key parts.</p>
 
  <p>Examples:
  <code>split_key(&lt;&lt;"=a*=b*=c"&gt;&gt;) -&gt; [&lt;&lt;"a"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"c"&gt;&gt;].</code>
  <code>split_key(&lt;&lt;"=a*=b[00000001]*=c"&gt;&gt;) -&gt; [&lt;&lt;"a"&gt;&gt;,{&lt;&lt;"b"&gt;&gt;,1},&lt;&lt;"c"&gt;&gt;]</code></p>
</div></div>
<div class="function">
<h3 id="raw_split_key/1">raw_split_key(K) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="join_key/1">join_key(T::[key_part()]) -&gt; key()</h3>


<div class="description">

<p>Joins a list of key parts into one key, ensuring all parts are escaped.</p>
 
  <p>A key part can either be a <code>binary()</code> or a <code>{binary(), integer()}</code> tuple.
  The tuple construct corresponds to a "list key", where the first element
  is the base key, and the second, a list index.
  For example, <code>{&lt;&lt;"port"&gt;&gt;, 1}</code> is expanded to <code>&lt;&lt;"port[00000001]"&gt;&gt;</code> and  
then escaped.</p>
 
  <p>NOTE: This function does not automatically escape '*', '[' and ']', as
  they are key delimiters. If they are meant to be escaped, escape the parts
  explicitly with <a href="#escape_key_part/1" class="seealso">escape_key_part/1</a> and then use
  <a href="#raw_join_key/1" class="seealso">raw_join_key/1</a>.</p>
</div></div>
<div class="function">
<h3 id="join_key/1-1">join_key(K::key_part(), K2::key_part()) -&gt; key()</h3>


<div class="description">

<p>Joins two key parts into one key, ensuring both parts are escaped.
  See <a href="#join_key/1" class="seealso">join_key/1</a>.</p>
</div></div>
<div class="function">
<h3 id="raw_join_key/1">raw_join_key(T::[key_part()]) -&gt; key()</h3>


<div class="description">

<p>Joins key parts without escaping them.
  Use this function when you either don't care about escaping/unescaping,
  or know it has already been done (e.g. with <a href="#escape_key_part/1" class="seealso">escape_key_part/1</a>).</p>
</div></div>
<div class="function">
<h3 id="escape_key/1">escape_key(K::key()) -&gt; key()</h3>


<div class="description">

<p>Escapes a key; leaves it unchanged if already escaped.</p>
 
  <p>Any key starting with "=" is assumed to be escaped already.</p>
 
  <p>NOTE: This function does not escape '*', '[' and ']', as they are key
  delimiters. If they are intended to be escaped as well, use
  <a href="#escape_key_part/1" class="seealso">escape_key_part/1</a> instead.</p>
</div></div>
<div class="function">
<h3 id="escape_key_part/1">escape_key_part(Esc::key_part()) -&gt; key_part()</h3>


<div class="description">

<p>Escapes a key part according to <code>kvdb_conf</code> escaping rules.</p>
 
  <p>Encoding users @ as an escape character followed by the escaped char  
hex-coded (e.g. "@" -&gt; "@40", "/" -&gt; "@2F"). In order to know that the  
id has been encoded - so we don't encode it twice - we prepend a '='  
to the encoded key part. Since '=' lies between ASCII numbers and letters  
(just as '@' does), it won't upset the kvdb sort order.</p>
 
  <p>As a consequence, no unescaped key part string may begin with '='.</p>
 
  <p>NOTE: This function also escapes the key delimiters '*', '[' and ']'.</p>
</div></div>
<div class="function">
<h3 id="unescape_key/1">unescape_key(K::key()) -&gt; key()</h3>


<div class="description">

<p>Unescapes a key.
 </p>
</div></div>
<div class="function">
<h3 id="unescape_key_part/1">unescape_key_part(Bin::key_part()) -&gt; key_part()</h3>


<div class="description">

<p>Unescapes a key part; leaving it untouched if already escaped.</p>
 
  <p>See <a href="#escape_key_part/1" class="seealso">escape_key_part/1</a>.</p>
</div></div>
<div class="function">
<h3 id="list_key/1">list_key(Name::binary(), Pos::integer()) -&gt; binary()</h3>


<div class="description">

<p>Creates a "list key" part from a base (binary) and an index (integer).</p>
 
  <p>List keys are useful for representing list-like data sets. To preserve
  sort order, they are encoded as <code>&lt;&lt;"Base[nnnnnnnn]"&gt;&gt;</code>, where Base is the  
name of the list, and nnnnnnnn is a zero-padded 8-digit hex number.</p>
 
  <p>Example: <code>list_key(&lt;&lt;"port"&gt;&gt;, 28) -&gt; &lt;&lt;"=port[0000001C]"&gt;&gt;</code></p>
</div></div>
<div class="function">
<h3 id="write_tree/1">write_tree(_Parent::key(), Conf_tree::#conf_tree{root=key(), tree=conf_tree()}) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#write_tree/3" class="seealso">write_tree(&lt;&lt;"data"&gt;&gt;, Parent, T)</a>.</p>
</div></div>
<div class="function">
<h3 id="write_tree/1-1">write_tree(Table::table() (see module kvdb), Parent::key(), Conf_tree::#conf_tree{root=key(), tree=conf_tree()}) -&gt; ok</h3>


<div class="description">

<p>Writes a configuration tree under the given parent.</p>
 
  <p>This function inserts a config tree, such as is returned from e.g.
  <a href="#read_tree/3" class="seealso">read_tree/3</a>. The root to insert it under must be made explicit,
  but could of course be the same root as in the original tree
  (can be retrieved using <a href="#get_root/1" class="seealso">get_root/1</a>).</p>
</div></div>
<div class="function">
<h3 id="flatten_tree/1">flatten_tree(Conf_tree::#conf_tree{root=key(), tree=conf_tree()} | conf_tree()) -&gt; [conf_obj()]</h3>


<div class="description">

<p>Converts a configuration tree into an ordered list of configuration objects.</p>
</div></div></div>

<authors>

<aname>Ulf Wiger</aname>
<email>ulf@feuerlabs.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
