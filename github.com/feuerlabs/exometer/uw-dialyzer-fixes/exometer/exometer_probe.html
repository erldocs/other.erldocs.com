<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>exometer_probe (exometer) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>exometer_probe</h1>
<h2 class="modsummary">Interface library for managing probes.</h2>
<div class="description">
<p>Interface library for managing probes.<br /></p>
 
   <p>This library contains the main API for accessing all probes   
executing in exometer.</p>
 
   <p>All exported functions in the <code>exomter_probe</code> module are invoked
   by the <code>exometer</code> module; a developer will not have to call
   <code>exometer_probe</code> functions directly.</p>
 
   <p>A probe is an implementation of the <code>exometer_probe</code> behavior
   which runs in its own process in order to collect data to be
   handled and reported by exometer. The implementation will be
   invoked through the <code>exomoeter_probe</code> module, which, as stated
   above, in its turn is invoked by the <code>exometer</code> module.</p>
 
   <p>A custom exometer probe is invoked by mapping a type to the module
   name of the custom exometer probe module. All metrics created with the
   given type will trigger the invocation of the new probe module. See
   <a href="#Configuring_type_-_entry_maps" class="seealso">Configuring type - entry maps</a> for details on how to setup   
such maps.</p>
 
   <p>If the data can be collected at a high speed, and without
   blocking, an <code>exometer_entry</code> implementation can be used instead   
to do the gathering in-process.</p>
 
   <p>A probe is created throgh the <code>exomter_probe:new/3</code> call, which in
   its turn is called by <code>exometer:new/3</code>. During probe creation, a   
new process is spawned to handle the probe and call its   
implementation.  While the created process is not a gen_server, it   
behaves similarly and provides a state to all implementation   
calls.</p>
 
   <p>Once running, the probe collects data from a subsystem, such as
   <code>/proc</code>, <code>sysfs</code>, and <code>netlink</code>, through timer-based calls to
   <code>probe_sample/1</code> or explicit calls to <code>probe_update/2</code>.</p>
 
   <p>A probe implementation can support any number of data points,
   where each data point is a specifric sample from the probe. For
   example, a probe that measures network traffic would have
   <code>rx_packets</code>, <code>tx_packets</code>, <code>errors</code>, <code>dropped</code>, and other data
   points reported by <code>ifconfig(8)</code> and <code>ip(8)</code>.</p>
 
   <p>Values are retrieved from the probe through the <code>probe_get_value/2</code>   
call, which specifies the data points to be returned. The probe is   
expected to gather the given data points and return them to the   
caller.</p>
 
  <p><em><marker id="The_probe_callback_interface">The probe callback interface</marker></em></p>
 
  <p>The following functions are to be implemented and exported by a probe  
implementation.</p>
 
  <p><em><marker id="behaviour/0">behaviour/0</marker></em></p>
 
  <p>The <code>behaviour/0</code> function for an entry implementation should return
  the atom <code>probe</code>. This function will be involved by the  
exometer system in order to determine if a callback is  
an entry or a probe.</p>
 
  <p><em><marker id="probe_init/3">probe_init/3</marker></em></p><p>
  The <code>probe_init/3</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_init(Name, Type, Options)</pre>
 
  <p>The implementation shall initiate the probe, create the
  necessary state, and return it for furure access
  through <code>probe_update/2</code>, <code>probe_sample/1</code> and <code>get_value/2</code> calls.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>Name</code>      
Specifies the name of the metric to be created as a list of atoms.</p>
 
  <p>+ <code>Type</code>
      Specifies the type provided to the <code>exometer:new/3</code> call (before it      
was translated by the type - exometer probe map). It can be used if several      
different types are mapped to the same probe module.</p>
 
  <p>+ <code>Options</code>
      Specifies an option list that contains additional setup directives to
      the probe. The actual options to support are a combination of the
      standard options, described below, and probe specific options
      processed by <code>probe_init/3</code>.</p>
 
  <p>Standard options are processed directly by <code>new/3</code>, before
  <code>probe_init/3</code> is calledm and are as follows:</p>
 
  <p>+ <code>{priority, P}</code>
      Will be forwarded by the probe's process to <code>erlang:process_flag/2</code>.</p>
 
  <p>+ <code>{min_heap_size, S}</code>
      Will be forwarded by the probe's process to <code>erlang:process_flag/2</code>.</p>
 
  <p>+ <code>{min_bin_vheap_size, S}</code>
      Will be forwarded by the probe's process to <code>erlang:process_flag/2</code>.</p>
 
  <p>+ <code>{sensitive, true | false}</code>
      Will be forwarded by the probe's process to <code>erlang:process_flag/2</code>.</p>
 
  <p>+ <code>{sample_interval, t}</code>
      Specifies the interval, in milliseconds, that <code>exometer_probe:sample/1</code>.      
should be invoked at.</p>
 
  <p>The <code>probe_init/3</code> implementation is invoked by <code>exometer:new/3</code>,
  which calls <code>exometer_probe:new/3</code>, which invokes the probe  
implementation..</p>
 
  <p>The <code>probe_init/3</code> function shall return <code>{ok, State}</code> where State
  is a tuple that will be provided as a the <code>State</code> argument to all  
future probe implementation calls for the metric.</p>
 
  <p>If the <code>sample_interval</code> option has been specified in <code>Opts</code>,
  probe_sample/2' will be invoked immediately after <code>probe_init/2</code>
  returns to retrieve a first sample. After that, <code>probe_sample/2</code>  
will repeatedly will be called by the probe process at the  
millisecond-specified interval.</p>
 
  <p>Should <code>probe_init/3</code> return antyhing else but <code>{ok, State}</code>,
  invoking <code>new/3</code> call will fail.</p>
 
 
  <p><em><marker id="probe_terminate/1">probe_terminate/1</marker></em></p><p>
  The <code>probe_terminate/1</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_terminate(State)</pre>
 
  <p>The custom probe shall release any resources associated with the
  given state and return <code>ok</code>.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
 
  <p>The <code>probe_terminate/1</code> implementation is invoked by <code>exometer:delete/1</code>, which
  calls <code>exometer_probe:delete/3</code>, which invokes the probe  
implementation.</p>
 
 
  <p><em><marker id="probe_setopts/3">probe_setopts/3</marker></em></p><p>
  The <code>probe_setopts/2</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_setopts(Entry, Opts, State)</pre>
 
  <p>The <code>probe_setopts/4</code> implementation is invoked by
  <code>exometer:setopts/3</code>, which calls <code>exometer_probe:setopts/3</code>,  
which invokes the probe implementation.</p>
 
  <p>The implementation of this function shall modify the options of a
  probe. The <code>setopts/3</code> function, which will process standard
  options before invoking <code>probe_setopts/4</code> with the remaining
  options. See the documentation for <code>probe_init/3</code> for details.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>Entry</code>
      The (opaque) exometer entry record. See <a href="exometer_info.html" class="seealso">exometer_info</a> for      
information on how to inspect the data structure.</p>
 
  <p>+ <code>Opts</code>      
The probe-specific options to be processed.</p>
 
  <p>+ <code>Status</code>      
The new status of the entry.</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequently      
modified by other probe implementation calls.</p>
 
  <p>This function shall return <code>{ok, NewState}</code> where <code>NewState</code> is  
the modified probe state that incorporates the new options.</p>
 
 
  <p><em><marker id="probe_update/2">probe_update/2</marker></em></p><p>
  The <code>probe_update/2</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_update(Value, State)</pre>
 
  <p>Incorporate a new value into the metric maintained by the metric.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>Value</code>      
The value to integrate.</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>This function can be called outside the periodic <code>probe_sample/1/</code>
  call to have the probe process a value given in <code>Value</code>.</p>
 
  <p>The <code>probe_update/2</code> implementation is invoked by <code>exometer:update/2</code>, which
  calls <code>exometer_probe:update/4</code>, which invokes the probe  
implementation.</p>
 
  <p>Once processed, <code>probe_update/2</code> shall return <code>{ok, NewState}</code>,
  where <code>NewState</code> contains the new probe state with the processed  
value.</p>
 
 
  <p><em><marker id="probe_get_value/2">probe_get_value/2</marker></em></p><p>
  The <code>probe_get_value/2</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_get_value(DataPoints, State)</pre>
 
  <p>The <code>probe_get_value/2</code> implementation shall retrieve the value of  
one or more data points from the probe.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>DataPoints</code>      
List of data point atoms to retrieve values for.</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>The <code>probe_get_value/2</code> implementation is invoked by
  <code>exometer:get_value/2</code>, which calls <code>exometer_probe:get_value/4</code>,  
which invokes the probe implementation.</p>
 
  <p>If <code>exometer:get_value/2</code> is invoked with <code>default</code> as a single
  data point, the probe's <code>probe_get_datapoints/1</code> function will be
  called to retrieve all data points supported by the probe
  implementation. <code>probe_get_value/2</code> will then be called with the  
returned set of data points provided as an argument.</p>
 
  <p>This function shall return the value of all data points provided in
  <code>DataPoints</code>, given that they are supported.</p>
 
  <p>The list in the returned tuple shall have the format:</p>
 
  <pre lang="erlang">
       [{ DP, Val}, ...]</pre>
 
  <p>Where <code>DP</code> one of the data points in the <code>DataPoints</code> argument, and
  <code>Val</code> is the value of that data point.</p>
 
  <p>If one of the argument-provided data points are not supported by the probe,
  the tuple returned for that data point shall be <code>{ DP, {error, undefined}</code>.</p>
 
  <p>For example, if the provided <code>DataPoint</code> argument is set to <code>[ min,
  max, xyzzy ]</code>, and only <code>min</code> and <code>max</code> are supported  
by the probe, the returned list shall look like below:</p>
 
  <pre lang="erlang">
       [{ min, 0.1265 }, { max, 3338.21 }, { xyzzy, { error, unsupported } ]</pre>
 
  <p>The <code>probe_get_value/2</code> implementation shall return <code>{ok, List}</code>,
  where <code>List</code> is the list of data points and their values described  
above. No new state is returned by this function.</p>
 
 
  <p><em><marker id="probe_get_datapoints/1">probe_get_datapoints/1</marker></em></p><p>
  The <code>probe_get_datapoints/1</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_get_datapoints(State)</pre>
 
  <p>The <code>probe_get_datapoints/1</code> shall return a list with all data points  
supported by the probe</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>The <code>probe_get_datapoints/1</code> implementation is invoked by
  <code>exometer:info/2</code>, which calls <code>exometer_probe:get_datapoints/3</code>,  
which invokes the probe implementation.</p>
 
  <p>In cases where <code>exometer:get_value/2</code> is called with <code>default</code> as a
  single data point, <code>probe_get_datapoints/1</code> is also called to
  retrieve a list of all supported data points, which is then
  forwarded to <code>probe_get_value/2</code>.</p>
 
  <p>The implementation of <code>probe_get_datapoints/1</code> shall return <code>{ok, DpList}</code>,
  where <code>DpList</code> is a list of data point atoms supported by the probe.</p>
 
 
  <p><em><marker id="probe_reset/1">probe_reset/1</marker></em></p><p>
  The <code>probe_reset/1</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_reset(State)</pre>
 
  <p>The <code>probe_reset/1</code> shall reset the state of the probe to its initial state.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
 
  <p>The <code>probe_reset/1</code> implementation is invoked by
  <code>exometer:reset/1</code>, which calls <code>exometer_probe:reset/3</code>, which  
invokes the probe implementation.</p>
 
  <p>The implementation of <code>probe_reset/1</code> shall return <code>{ok,
  NewState}</code>, where <code>NewState</code> contains the reset state of the probe.</p>
 
 
  <p><em><marker id="probe_sample/1">probe_sample/1</marker></em></p><p>
  The <code>probe_sample/1</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_sample(State)</pre>
 
  <p>The <code>probe_sample/1</code> implementation shall sample data from the  
subsystem the probe is integrated with.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>When invoked, <code>probe_sample/1</code> is expected to interface the  
sub-system (/proc, /sysfs, etc) monitored by the probe, extract the  
relevant data from it, and return an updated probe state that  
incorporates the extracted data.</p>
 
  <p>The <code>probe_sample/1</code> function is invoked by the probe thread at
  intervals specified by the <code>{sample_interval, Intv}</code> option
  provided to <code>exometer_probe:new/3</code>. If this option is missing, or
  set to infinity, <code>probe_sample/1</code> will never be called.</p>
 
  <p>The implementation of <code>probe_sample/1</code> shall return <code>{ok,
  NewState}</code>, where <code>NewState</code> contains the new state of the probe  
with the sampled data integrated into it.</p>
 
 
  <p><em><marker id="probe_handle_msg/2">probe_handle_msg/2</marker></em></p><p>
  The <code>probe_handle_msg/2</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       probe_handle_msg(Msg, State)</pre>
 
  <p>The <code>probe_handle_msg/1</code> is invoked to process messages received  
by the probe process.</p>
 
  <p>The arguments are as follows:</p>
 
  <p>+ <code>State</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>+ <code>Msg</code>
      The probe state, originally returned by <code>probe_init/3</code> and subsequentially      
modified by other probe implementation calls.</p>
 
  <p>The implementation of this function will be called by the probe's  
process when it receives a message that is not recognized by the  
internal receive loop.</p>
 
  <p>The implementation of <code>probe_handle_msg/2</code> shall return <code>{ok,
  NewState}</code>, where <code>NewState</code> contains the new state of the probe
  that reflects the processed message.
 </p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/3">new(Name, Type, Opts) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="behaviour/0">behaviour() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/3">delete(Name, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_value/3">get_value(Name, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_value/4">get_value(Name, Type, Pid, DataPoints) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_datapoints/3">get_datapoints(Name, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="setopts/3">setopts(Exometer_entry, Opts, Status) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update/4">update(Name, Value, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="reset/3">reset(Name, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="sample/3">sample(Name, Type, Pid) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
