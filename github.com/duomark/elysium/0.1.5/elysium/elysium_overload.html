<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>elysium_overload (elysium) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>elysium_overload</h1>
<h2 class="modsummary">     
Elysium_overload offers optional buffering of connection requests.</h2>
<div class="description">
<p>     
Elysium_overload offers optional buffering of connection requests.     
This approach allows spikes in the traffic which exceed the number     
of available elysium sessions. The buffer is maintained as an in     
memory erlang Queue of requests by unloading them from the FSM     
message mailbox as the requests arrive and sending no reply to the     
requestor. Any subsequent checkins will match against the buffered     
queue prior to being checked in.</p>
  
     If the buffered queue grows too big, a one-time state change causes
     a fresh set of sessions to be spawned to empty the buffer. These
     new sessions are unsupervised and will stick around only until they
     decay. This provides a way to absorb a spike in traffic, however, it
     could lead to overload on the Cassandra cluster. Be careful when
     using this feature as it masks the backpressure signal when all
     sessions are occupied.
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-config_type">config_type() = {config_mod, module()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {vbisect, <a href="vbisect.html#type-bindict" class="seealso">vbisect:bindict()</a>}</h3></div>
    <div class="type"><h3 id="type-fsm_state_name">fsm_state_name() = empty | buffering | overloaded</h3></div>
    <div class="type"><h3 id="type-max_sessions">max_sessions() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-query_request">query_request() = {bare_fun,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-config_type" class="seealso">config_type()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun((pid(), [any()], <a href="seestar.html#type-consistency" class="seealso">seestar:consistency()</a>) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[any()]),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[any()],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="seestar.html#type-consistency" class="seealso">seestar:consistency()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {mod_fun,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-config_type" class="seealso">config_type()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atom(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[any()],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="seestar.html#type-consistency" class="seealso">seestar:consistency()</a>}</h3></div>
    <div class="type"><h3 id="type-requests_queue_name">requests_queue_name() = <a href="ets_buffer.html#type-buffer_name" class="seealso">ets_buffer:buffer_name()</a></h3></div>
    <div class="type"><h3 id="type-session_queue_name">session_queue_name() = <a href="ets_buffer.html#type-buffer_name" class="seealso">ets_buffer:buffer_name()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, pid()}</h3>


<div class="description">

<p>Create an FSM to track pending requests in a queue.</p>
</div></div>
<div class="function">
<h3 id="status/0">status() -&gt; {fsm_state_name(), non_neg_integer()}</h3>


<div class="description">

<p>Get the current status and queue size of the FSM.</p>
</div></div>
<div class="function">
<h3 id="idle_connections/1">idle_connections(Config::config_type()) -&gt; {session_queue_name(), Idle_Count, Max_Count} | {session_queue_name(), {missing_buffer, Idle_Count, Max_Count}}</h3>

<ul class="type">
<li><code>Idle_Count = max_sessions()</code></li><li><code>Max_Count = max_sessions()</code></li></ul>
<div class="description">

<p>Idle connections are those in the queue, not checked out.</p>
</div></div>
<div class="function">
<h3 id="pending_requests/1">pending_requests(Config::config_type()) -&gt; {requests_queue_name(), Pending_Count, Reply_Timeout} | {requests_queue_name(), {missing_buffer, 0, Reply_Timeout}}</h3>

<ul class="type">
<li><code>Pending_Count = non_neg_integer()</code></li><li><code>Reply_Timeout = non_neg_integer()</code></li></ul>
<div class="description">

<p>Pending requests are queries waiting for a free session.</p>
</div></div>
<div class="function">
<h3 id="checkout_connection/1">checkout_connection(Config::config_type()) -&gt; pid() | none_available</h3>


<div class="description">

<p>    
Allocate a seestar_session to the caller by popping an entry    
from the front of the connection queue. This function either    
returns a live pid(), or none_available to indicate that all    
connections to Cassandra are currently checked out.</p>
 
    <p>If there are internal delays on the ets_buffer FIFO queue,    
this function will retry. If the session handed back is no    
longer live, it is tossed and a new session is fetched. In    
both cases, up to Config_Module:checkout_max_retry attempts    
are tried before returning none_available.</p>
 
    <p>If the queue is actually empty, no retries are performed.    
It is left to the application in this case to decide when    
and how often to retry.</p>
 
    <p>The configuration parameter is not validated because this
    function should be a hotspot and we don't want it to slow
    down or become a concurrency bottleneck.</p>
</div></div>
<div class="function">
<h3 id="checkin_connection/1">checkin_connection(Config::config_type(), Session_Id::pid()) -&gt; {boolean(), {session_queue_name(), Idle_Count, Max_Count}}</h3>

<ul class="type">
<li><code>Idle_Count = max_sessions() | buffer_error() (see module ets_buffer)</code></li><li><code>Max_Count = max_sessions() | buffer_error() (see module ets_buffer)</code></li></ul>
<div class="description">

<p>    
Checkin a seestar_session, IF there are no pending requests.    
One pending request will use the session immediately before    
the session is checked in with the possibility of decay.</p>
 
    <p>Because this function is likely called from a try / after
    construct and the return value is ignored, it is safe to
    execute this asynchronously. The real reason to do it in
    an asynchronous call is that the original user of a session
    might be penalized with latency waiting on a second user
    when in an overload situation. To avoid this possibility,
    we run the checkin asynchronous, possbily spawning a new
    process to execute the query so as not to block the FSM
    from handling other checkin and buffer requests.</p>
</div></div>
<div class="function">
<h3 id="buffer_request/1">buffer_request(Config::config_type(), Query_Request::query_request()) -&gt; any() | buffer_error() (see module ets_buffer)</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Jay Nelson</aname>
<email>jay@duomark.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
