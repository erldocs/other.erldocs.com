<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gen_httpd (gen_httpd) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gen_httpd</h1>
<h2 class="modsummary">   
The gen_httpd behaivour implements a generic HTTP server interface.</h2>
<div class="description">
<p>   
The gen_httpd behaivour implements a generic HTTP server interface.</p>
  
   <p>There are currently two modes of operation sequential processing of   
requests and concurrent pipeliens. With the sequential processsing a   
each request have to be processed and a response must be returned before   
the next request can be processed, even if the client have pipelined   
several requests. In the concurrent pipeline mode the server will read   
as many requests as allowed and process them in paralell.</p>
  
   <pre class="sh_erlang">
   gen_httpd module            Callback module
   ----------------            ---------------
   gen_httpd:start_link -----&gt; Module:init/2
   -                    -----&gt; Module:handle_request/6
   -                    -----&gt; Module:handle_continue/5
   -                    -----&gt; Module:terminate/2
   </pre>
  
   <em><marker id="Concurrent_pipeline_mode">Concurrent pipeline mode</marker></em><p>   
If a client is pipelining requests the server can process them in   
paralell as long as the responses are serialised. There is a bit of   
overhead on the server if this mode is selected due to the serialisation   
of responses. Two processes will be created for each client connection,   
and each request will processed in an independent process.</p>
  
   <p>Since responses must be returned in the same order as the requests are   
received the responses are serialised and if an early request takes a long   
time to return, the responses will wait in a response queue and the   
pipeline is blocked.</p>
  
   <em><marker id="Callbacks">Callbacks</marker></em>
   <pre class="sh_erlang">
   Module:init(ConnInfo, Arg) -&gt; Result
       Types ConnInfo = #gen_httpd_conn{}
             Args = term()
             Result = {ok, State} | {stop, Reason}
   </pre><p>
   After <a href="#start_link/6" class="seealso">start_link/6</a> or <a href="#start_link/7" class="seealso">start_link/7</a> has been called this
   function is called by the new to initialise a state. If the the
   initialisation is successful the function should return
   <code>{ok, State}</code> where <code>State</code> is the state which
   will be passed to the client in in the next callback.
   <code>Arg</code> is the <code>CallbackArg</code> passed
   to <a href="#start_link/6" class="seealso">start_link/6</a> or <a href="#start_link/7" class="seealso">start_link/7</a>.</p>
  
   <em>Note!</em> This
   callback will <em>not</em> be called by the same process that
   will call the handle_request later if <code>{ok, State}</code>
   is returned.
   <pre class="sh_erlang">
   Module:handle_request(Method, URI, Vsn, Headers, RequestBody, State) -&gt; Result
       Types Method = 'OPTIONS' | 'GET' | 'HEAD' | 'POST' | 'PUT' |
                      'DELETE' | 'TRACE' | string()
             URI = '*' | {absoluteURI, http |
                   https, Host=string(), Port=int() |
                   undefined, Path=string()} |
                   {scheme, Scheme=string(), string()} | {abs_path, string} |
                   string()
             Vsn = {Major, Minor}
             Major = Minor = integer()
             Headers = [{Name, Value}]
             RequestBody = binary()
             Name = Value = string()
             State = term()
             Result = {reply, Status, Headers, Body, State}
             Status = StatusCode | {StatusCode, Description}
             StatusCode = integer()
             Description = string()
             Body = io_list()
   </pre><p>   
Handle a HTTP request.</p>
  
   <p>In case of POST or PUT requests, the body is received in
   <code>RequestBody</code>.
   For all requests that don't have a entity, the <code>RequestBody</code>
   should be ignored. If the <code>RequestBody</code> is <code>{chunked,
   Reader}</code> the client is using chunked Transfer-Encoding to transfer
   data with the request.
   In this case every call to the <code>Reader</code> fun will
   return a chunk in the form <code>{ok, Data}</code> where
   <code>data</code> is a binary(). When the last chunk has been read, the
   next call to <code>Reader</code> will return
   <code>{error, last_chunk}</code>.
   If the <code>Reader</code> fails due to a protocol error it will return
   <code>{error, bad_request}</code>. <code>Reason</code> can also be
   anything that <code>gen_tcp</code> returns as error codes when calling
   recv/2 in TCP mode and what <code>ssl</code> returns as error codes   
when calling recv/2 in ssl mode.</p>
  
   <pre class="sh_erlang">
   Module:handle_continue(Method, URI, Vsn, Headers, State) -&gt; Result
       Types Method = 'OPTIONS' | 'GET' | 'HEAD' | 'POST' | 'PUT' |
                      'DELETE' | 'TRACE' | string()
             URI = '*' | {absoluteURI, http | https, Host=string(), Port=int() |
                   undefined, Path=string()} |
                   {scheme, Scheme=string(), string()} | {abs_path, string} |
                   string()
             Vsn = {Major, Minor}
             Major = Minor = integer()
             Headers = [{Name, Value}]
             Name = Value = string()
             State = term()
             Result = {continue, State} | {reply, Status, Headers, Body, State}
             Status = StatusCode | {StatusCode, Description}
             StatusCode = integer()
             Description = string()
             Body = io_list()
   </pre><p>
   If the HTTP client sends the the <code>100-continue</code> token in the
   <code>Expect</code> header this function will be called to allow the
   callback module to decide if it wants to continue with the request or not.
   For more information on <code>Expect: 100-continue</code> see:
   <url href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1">HTTP/1.1
   Section 10.1.1</url> and <url href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3">Use
   of the 100 (Continue) Status</url>.</p>
  
   <p>If the server wishes to continue with the request, i.e. send a status
   100 Continue and read the request body, this function should return
   <code>{continue, State}</code>. If
   <code>{reply, Status, Headers, Body, State}</code> is returned the   
server will return an appropriate HTTP response and try to read the next   
request from the client.</p>
  
   <em>Note!</em> This
   callback will <em>not</em> be called by the same process that
   will call the handle_request later if <code>{continue, State}</code>
   is returned.</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/6">start_link(Callback, CallbackArg, Port, Timeout, SockOpts, Options) -&gt; {ok, Pid}</h3>

<ul class="type">
<li><code>Callback = atom()</code></li><li><code>CallbackArg = term()</code></li><li><code>Port = integer()</code></li><li><code>Timeout = integer()</code></li><li><code>SockOpts = [SockOpt]</code></li><li><code>Options = [Opt]</code></li><li><code>Opt = {concurrent_pipeline, Length::integer()}</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Starts a gen_httpd process and links to it.
  The process created will call <code>Callback:init/2</code> with
  <code>CallbackArg</code> to initialise an internal state.
  The HTTP server will listen on port <code>Port</code> and keep persistent
  connections open for <code>Timeout</code> milliseconds.</p>
 
  <p>For <code>SockOpts</code>, see backend module
  <url href="http://www.erlang.org/doc/man/gen_tcp.html">gen_tcp</url>.</p>
 
  <p>This function should normally be called from a supervisor.</p>
</div></div>
<div class="function">
<h3 id="start_link/7">start_link(Callback, CallbackArg, Port, Timeout, SockOpts, SSL, Options) -&gt; {ok, Pid}</h3>

<ul class="type">
<li><code>Callback = atom()</code></li><li><code>CallbackArg = term()</code></li><li><code>Port = integer()</code></li><li><code>Timeout = integer()</code></li><li><code>SockOpts = [SockOpt]</code></li><li><code>SSL = [SSLOpt]</code></li><li><code>Options = [Opt]</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Starts a gen_httpd process with an SSL backend and links to it.</p>
 
  <p>For <code>SockOpts</code> and <code>SSLOpts</code>, see backend module
  <url href="http://www.erlang.org/doc/man/ssl.html">ssl</url>.</p>
 
  <p>This function should normally be called from a supervisor.</p>
</div></div>
<div class="function">
<h3 id="port/1">port(Ref) -&gt; {ok, Port}</h3>

<ul class="type">
<li><code>Ref = pid()</code></li><li><code>Port = integer()</code></li></ul>
<div class="description">

<p>
  Returns the port a gen_tcpd process is listening on.</p>
</div></div></div>

<authors>

<aname>Martin Carlson</aname>
<email>martin@martinc.eu</email>
<aname>Oscar Hellstr√∂m</aname>
<email>oscar@hellstrom.st</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
