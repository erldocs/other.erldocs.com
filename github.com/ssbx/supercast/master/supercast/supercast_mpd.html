<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>supercast_mpd (supercast) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>supercast_mpd</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="delete_channel/1">delete_channel(Channel) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="main_chans/0">main_chans() -&gt; [atom()]</h3>


<div class="description">

<p>
 Called by supercast_server.
 Called at the initial connexion of a client. Give him the main (static)
 channels. If dynamic channels exist in the application, this is the role
 of one of these channels to inform the client. Note that depending on the
 supercast_channel module perm/0 function return, a client might not be able to
 subscribe to a channel apearing here. It is checked at the
 subscribe_stage1/1 call.</p>
</div></div>
<div class="function">
<h3 id="subscribe_stage1/1">subscribe_stage1(Channel::atom(), Client_state::#client_state{}) -&gt; ok | error</h3>


<div class="description">

<p>
 Called by a client via supercast_server.
 If return is ok, the supercast_server will then call subscribe_stage2.
 If return is error, do nothing more.
 In both case, supercast_server interpret the return and send subscribeErr or
 subscribeOk to the client.</p>
</div></div>
<div class="function">
<h3 id="subscribe_stage2/1">subscribe_stage2(Channel::atom(), Client_state::#client_state{}) -&gt; ok</h3>


<div class="description">

<p>
 Called by supercast_server after a supercast_mpd:subscribe_stage1/2 success. The call
 will trigger a subscribe_stage3/2 called by the channel. sync sync.</p>
</div></div>
<div class="function">
<h3 id="subscribe_stage3/1">subscribe_stage3(Channel::atom(), Client_state::#client_state{}) -&gt; ok</h3>


<div class="description">

<p>
 Called by a channel after a supercast_mpd:subscribe_stage2/2 success.
 In fact, the client will really be subscribed here by the channel.</p>
</div></div>
<div class="function">
<h3 id="multicast_msg/1">multicast_msg(Chan::atom(), X2::{#perm_conf{read=[term()], write=[term()]}, tuple()}) -&gt; ok</h3>


<div class="description">

<p>
 Called by a supercast_channel module with a message that can be of interest for
 clients that have subscribed to the channel.
 Will be send depending of the right of the user.</p>
</div></div>
<div class="function">
<h3 id="unicast_msg/2">unicast_msg(Client_state::#client_state{}, X2::tuple()) -&gt; ok</h3>


<div class="description">

<p>
 Called by a supercast_channel module with a message for a single client. Message
 will or will not be sent to the client depending on the permissions.
 Note that the channel is not checked. Thus a client wich is not subscriber
 of any channels can receive these messages.
 Typicaly used when the supercast_channel need to synchronize the client using his
 handle_cast({synchronize, CState}, State) function.</p>
</div></div>
<div class="function">
<h3 id="client_disconnect/1">client_disconnect(Client_state::#client_state{}) -&gt; ok</h3>


<div class="description">

<p>
 Called by supercast_server when the client disconnect.
 Result in removing the client state from all the initialized channels.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(Chan::atom(), Client_state::#client_state{}) -&gt; ok</h3>


<div class="description">

<p>
 Called by a client using the supercast asn API via supercast_server.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(X1) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_call/3">handle_call(Call, F, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_cast/2">handle_cast(Cast, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_info/2">handle_info(I, S) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="terminate/2">terminate(R, S) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="code_change/3">code_change(O, S, E) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
