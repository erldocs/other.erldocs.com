<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>file_monitor (eunit) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>file_monitor</h1>
<h2 class="modsummary">Erlang file monitoring service.</h2>
<div class="description">
<p>Erlang file monitoring service</p>
 
  <p>The behaviour of this service is inspired by the open source FAM
  daemon (<url href="http://oss.sgi.com/projects/fam/">http://oss.sgi.com/projects/fam/</url>). It allows file system  
paths to be monitored, so that a message will be sent to the client  
process whenever a status change is detected. Currently, the only  
supported method of detection is by regular polling by the server.  
While it is not optimal, polling has less overhead than might be  
expected, and is portable across platforms. The polling interval can  
be adjusted; by default the server polls all monitored paths every 5  
seconds. Recursive (automatic) monitoring is supported. The server  
keeps track of its client processes, and removes all their monitors  
if they should die.</p>
 
  <p><em><marker id="Event_messages">Event messages</marker></em></p>
 
  <p>When a new monitor is set up, or a change is detected, an event
  message is sent to the client. These have the following general form:
  </p><pre class="sh_erlang">{file_monitor, Ref::monitor(), Event}</pre><p>
  where <code>Ref</code> is the monitor reference returned when the monitor was
  set up, and <code>Event</code> is one of the following:
  </p><list>
   <item><p><code>{found, Path::binary(), Type, Info::#file_info{}, Entries::[{added | deleted, Name::binary()}]}</code></p></item>
   <item><p><code>{changed, Path::binary(), Type, Info::#file_info{}, Entries::[{added | deleted, Name::binary()}]}</code></p></item>
   <item><p><code>{error, Path::binary(), Type, PosixError::atom()}</code></p></item>
  </list><p>
  where <code>Path</code> is the watched path (as a binary), <code>Type</code> is the type of
  monitoring being performed (either <code>file</code> or <code>directory</code>), <code>Info</code> is
  a <code>file_info</code> record as defined in <code>kernel/include/file.hrl</code>, and
  <code>Entries</code> is a list of tuples <code>{added, binary()}</code> and <code>{deleted,
  binary()}</code> describing changes to the directory entries if <code>Type</code> is
  <code>directory</code>, otherwise this is always the empty list. For a <code>found</code>
  event, all entries are <code>{added, Name}</code>.</p>
 
  <p>A <code>found</code> event is sent when a monitor is initially set up, if the
  path can be read. After that, whenever a change in status is
  detected, a <code>changed</code> event is sent. If the file does not exist or
  could for some other reason not be accessed, an <code>error</code> event is sent
  (both initially and for subsequent changes). In other words, the
  first event for a path is always either <code>found</code> or <code>error</code>, and later
  events are either <code>changed</code> or <code>error</code>.</p>
 
  <p><em><marker id="Detection_of_file_type_changes">Detection of file type changes</marker></em></p>
 
  <p>If the object found at a path changes type in the interval between
  two polls, for example if a directory is replaced by a file with the
  same name, or vice versa, the file monitor server will detect this
  and dispatch an <code>enoent</code> error event before the new status event. A  
client can thus rely on always seeing the old file disappear before  
any change that reports a different file type.</p>
 
  <p><em><marker id="Monitoring_types">Monitoring types</marker></em></p>
 
  <p>There are two ways in which a path can be monitored: as a <code>file</code>,
  meaning that we are interested only in the object found at that path,
  or as a <code>directory</code>, meaning that we expect the path to point to a  
directory, and we are also interested in the list of entries of that  
directory.</p>
 
  <p>If a path is monitored as a directory, and the object at the path
  exists but is not a directory, an <code>enotdir</code> error event will be  
generated. An existing directory can however both be monitored as a  
directory and as a file - the difference is that in the latter case,  
the reported list of entries will always be empty.</p>
 
  <p><em><marker id="Automatic_(recursive)_monitoring">Automatic (recursive) monitoring</marker></em></p>
 
  <p>Automatic monitoring (automonitoring for short) can be used to watch
  a single file of any type, or a whole directory tree. The monitoring
  type (<code>file</code> or <code>directory</code>) used for any path is based on the actual
  type of object found at the path (<code>directory</code> if the object is a
  readable directory, and <code>file</code> otherwise). If the object is replaced  
by another of different type, the monitoring type will change  
automatically.</p>
 
  <p>When a directory becomes automonitored, all of its entries will also  
be automatically monitored, recursively. As entries are created or  
deleted in an automonitored directory, they will be dynamically added  
or removed, respectively, from being monitored. The root path used to  
create the automonitor will however always remain monitored (even if  
the object temporarily or permanently disappears) until the server is  
told to delete the monitor.</p>
 
  <p>The event messages sent to the client are the same as if manual
  monitoring was done. A newly discovered path will be reported by a
  <code>found</code> (or possibly, by an <code>error</code> event), and subsequent changes on
  that path are reported by <code>changed</code> and <code>error</code> events. If the
  monitoring type is changed, a new <code>found</code> event is sent, and so on.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-filename">filename() = binary() | atom() | [char() | filename()]</h3></div>
    <div class="type"><h3 id="type-monitor">monitor() = reference()</h3></div>
    <div class="type"><h3 id="type-options">options() = [term()]</h3></div>
    <div class="type"><h3 id="type-server_ref">server_ref() = pid() | atom() | {Node::atom(), atom()} | {global, atom()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="monitor_file/1">monitor_file(Path::filename()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">
<p>Equivalent to <a href="#monitor_file/2" class="seealso">monitor_file(Path, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="monitor_file/1-1">monitor_file(Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">
<p>Equivalent to <a href="#monitor_file/3" class="seealso">monitor_file(file_monitor, Path, Opts)</a>.</p>
</div></div>
<div class="function">
<h3 id="monitor_file/1-2">monitor_file(Server::server_ref(), Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">

<p>Monitors the specified file path. Returns the monitor reference  
as well as the monitored path as a binary.</p>
 
  <p>Options:
  </p><list>
    <item><p><code>{monitor, monitor()}</code>: specifies a reference for
    identifying the monitor to which the path should be added. The
    monitor need not already exist, but if it does, only the same
    process is allowed to add paths to it, and paths may not be added
    manually to an automonitor.</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="monitor_dir/1">monitor_dir(Path::filename()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">
<p>Equivalent to <a href="#monitor_dir/2" class="seealso">monitor_dir(Path, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="monitor_dir/1-1">monitor_dir(Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">
<p>Equivalent to <a href="#monitor_dir/3" class="seealso">monitor_dir(file_monitor, Path, Opts)</a>.</p>
</div></div>
<div class="function">
<h3 id="monitor_dir/1-2">monitor_dir(Server::server_ref(), Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()} | {error, not_owner | automonitor}</h3>


<div class="description">

<p>Monitors the specified directory path. Returns the monitor  
reference as well as the monitored path as a binary.</p>
 
  <p>Options: see <a href="#monitor_file/3" class="seealso">monitor_file/3</a>.</p>
</div></div>
<div class="function">
<h3 id="automonitor/1">automonitor(Path::filename()) -&gt; {ok, monitor(), binary()}</h3>


<div class="description">
<p>Equivalent to <a href="#automonitor/2" class="seealso">automonitor(Path, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="automonitor/1-1">automonitor(Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()}</h3>


<div class="description">
<p>Equivalent to <a href="#automonitor/3" class="seealso">automonitor(file_monitor, Path, Opts)</a>.</p>
</div></div>
<div class="function">
<h3 id="automonitor/1-2">automonitor(Server::server_ref(), Path::filename(), Opts::options()) -&gt; {ok, monitor(), binary()}</h3>


<div class="description">

<p>Automonitors the specified path. Returns the monitor reference as  
well as the monitored path as a binary.</p>
 
  <p>Options: none at present.</p>
</div></div>
<div class="function">
<h3 id="demonitor/1">demonitor(Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">
<p>Equivalent to <a href="#demonitor/2" class="seealso">demonitor(file_monitor, Ref)</a>.</p>
</div></div>
<div class="function">
<h3 id="demonitor/1-1">demonitor(Server::server_ref(), Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">

<p>Deletes the specified monitor. This can only be done by the
  process that created the monitor.</p>
</div></div>
<div class="function">
<h3 id="demonitor_file/1">demonitor_file(Path::filename(), Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">
<p>Equivalent to <a href="#demonitor_file/3" class="seealso">demonitor_file(file_monitor, Path, Ref)</a>.</p>
</div></div>
<div class="function">
<h3 id="demonitor_file/1-1">demonitor_file(Server::server_ref(), Path::filename(), Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">

<p>Removes the file path from the specified monitor. This can only
  be done by the process that created the monitor.</p>
</div></div>
<div class="function">
<h3 id="demonitor_dir/1">demonitor_dir(Path::filename(), Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">
<p>Equivalent to <a href="#demonitor_dir/3" class="seealso">demonitor_dir(file_monitor, Path, Ref)</a>.</p>
</div></div>
<div class="function">
<h3 id="demonitor_dir/1-1">demonitor_dir(Server::server_ref(), Path::filename(), Ref::monitor()) -&gt; ok | {error, not_owner}</h3>


<div class="description">

<p>Removes the directory path from the specified monitor. This can
  only be done by the process that created the monitor.</p>
</div></div>
<div class="function">
<h3 id="get_interval/0">get_interval() -&gt; integer()</h3>


<div class="description">
<p>Equivalent to <a href="#get_interval/1" class="seealso">get_interval(file_monitor)</a>.</p>
</div></div>
<div class="function">
<h3 id="get_interval/1">get_interval(Server::server_ref()) -&gt; integer()</h3>


<div class="description">

<p>Returns the current polling interval.</p>
</div></div>
<div class="function">
<h3 id="set_interval/1">set_interval(Time::integer()) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#set_interval/2" class="seealso">set_interval(file_monitor, Time)</a>.</p>
</div></div>
<div class="function">
<h3 id="set_interval/1-1">set_interval(Server::server_ref(), Time::integer()) -&gt; ok</h3>


<div class="description">

<p>Sets the polling interval. Units are in milliseconds.</p>
</div></div>
<div class="function">
<h3 id="start/0">start() -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#start/1" class="seealso">start([])</a>.</p>
</div></div>
<div class="function">
<h3 id="start/1">start(Options::options()) -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#start/2" class="seealso">start({local, file_monitor}, Options)</a>.</p>
</div></div>
<div class="function">
<h3 id="start/2">start(Name::{local, atom()} | {global, atom()} | undefined, Options::options()) -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">

<p>Starts the server and registers it using the specified name.
  If the name is <code>undefined</code>, the server will not be registered. See
  <url href="http://www.erlang.org/edoc/doc/stdlib/doc/gen_server.xml#start_link-4">//stdlib/gen_server:start_link/4</url> for details about the return  
value.</p>
 
  <p>Options:
  </p><list>
    <item><p><code>{interval, Milliseconds::integer()}</code></p></item>
  </list>
</div></div>
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#start_link/1" class="seealso">start_link([])</a>.</p>
</div></div>
<div class="function">
<h3 id="start_link/1">start_link(Options::options()) -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#start_link/2" class="seealso">start_link({local, file_monitor}, Options)</a>.</p>
</div></div>
<div class="function">
<h3 id="start_link/2">start_link(Name::{local, atom()} | {global, atom()} | undefined, Options::options()) -&gt; {ok, ServerPid::pid()} | ignore | {error, any()}</h3>


<div class="description">

<p>Starts the server, links it to the current process, and
  registers it using the specified name. If the name is <code>undefined</code>,
  the server will not be registered. See <url href="http://www.erlang.org/edoc/doc/stdlib/doc/gen_server.xml#start_link-4">//stdlib/gen_server:start_link/4</url> for details about the return value.</p>
 
  <p>Options: see <a href="#start/2" class="seealso">start/2</a>.</p>
</div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#stop/1" class="seealso">stop(file_monitor)</a>.</p>
</div></div>
<div class="function">
<h3 id="stop/1">stop(Server::server_ref()) -&gt; ok</h3>


<div class="description">

<p>Stops the specified server.</p>
</div></div>
<div class="function">
<h3 id="normalize_path/1">normalize_path(Path::filename()) -&gt; binary()</h3>


<div class="description">

<p>Flattens the given path to a single binary.</p>
</div></div></div>

<authors>

<aname>Richard Carlsson</aname>
<email>carlsson.richard@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
