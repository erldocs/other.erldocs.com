<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>luwak_wm_file (luwak) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>luwak_wm_file</h1>
<h2 class="modsummary">Resource for serving large Riak objects over HTTP.</h2>
<div class="description">
<p>Resource for serving large Riak objects over HTTP.</p>
 
  <p>Available operations:</p>
 
  <p>GET /Prefix/    
Get information about the luwak interface, in JSON form:      
{"props":{Prop1:Val1,Prop2:Val2,...},       
"keys":[Key1,Key2,...]}.    
Each property will be included in the "props" object.    
Including the query param "props=false" will cause the "props"    
field to be omitted from the response.    
Including the query param "keys=false" will cause the "keys"    
field to be omitted from the response.</p>
 
  <p>POST /Prefix/    
Equivalent to "PUT /Prefix/Key" where Key is chosen    
by the server.</p>
 
  <p>GET /Prefix/Key    
Get the data stored under the named Key.    
Content-type of the response will be whatever incoming    
Content-type was used in the request that stored the data.    
Additional headers will include:      
Etag: The Riak "vtag" metadata of the object      
Last-Modified: The last-modified time of the object      
Encoding: The value of the incoming Encoding header from        
the request that stored the data.      
X-Riak-Meta-: Any headers prefixed by X-Riak-Meta- supplied        
on PUT are returned verbatim</p>
 
  <p>PUT /Prefix/Key    
Store new data under the named Key.    
A Content-type header *must* be included in the request.  The    
value of this header will be used in the response to subsequent    
GET requests.    
The body of the request will be stored literally as the value    
of the riak_object, and will be served literally as the body of    
the response to subsequent GET requests.    
Include an Encoding header if you would like an Encoding header    
to be included in the response to subsequent GET requests.    
Include custom metadata using headers prefixed with X-Riak-Meta-.    
They will be returned verbatim on subsequent GET requests.</p>
 
  <p>POST /Prefix/Key    
Equivalent to "PUT /Prefix/Key" (useful for clients that    
do not support the PUT method).</p>
 
  <p>DELETE /Prefix/Key    
Delete the data stored under the named Key.</p>
 
  <p>Webmachine dispatch lines for this resource should look like:</p>
 
   <p>{["luwak"],    
luwak_wm_file,    
[{prefix, "luwak"}    
]}.   
{["luwak", key],    
luwak_wm_file,    
[{prefix, "luwak"}    
]}.</p>
 
  <p>These example dispatch lines will expose this resource at
  /luwak/ and /luwak/Key.  The resource will attempt to
  connect to Riak on the same Erlang node one which the resource
  is executing.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-context">context() = term()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ping/2">ping(ReqData, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(Props::proplist()) -&gt; {ok, context()}</h3>


<div class="description">

<p>Initialize this resource.  This function extracts the
       'prefix' property from the dispatch args.</p>
</div></div>
<div class="function">
<h3 id="service_available/1">service_available(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether or not a connection to Riak
       can be established.  This function also takes this
       opportunity to extract the 'bucket' and 'key' path
       bindings from the dispatch, as well as any vtag
       query parameter.</p>
</div></div>
<div class="function">
<h3 id="allowed_methods/1">allowed_methods(RD::reqdata(), Ctx::context()) -&gt; {[method()], reqdata(), context()}</h3>


<div class="description">

<p>Get the list of methods this resource supports.
       HEAD, GET, POST, and PUT are supported at both
       the bucket and key levels.  DELETE is supported
       at the key level only.</p>
</div></div>
<div class="function">
<h3 id="allow_missing_post/1">allow_missing_post(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Makes POST and PUT equivalent for creating new
       bucket entries.</p>
</div></div>
<div class="function">
<h3 id="malformed_request/1">malformed_request(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether query parameters, request headers,
       and request body are badly-formed.
       Body format
       is not tested for a key-level request (since the
       body may be any content the client desires).</p>
</div></div>
<div class="function">
<h3 id="content_types_provided/1">content_types_provided(RD::reqdata(), Ctx::context()) -&gt; {[{ContentType::string(), Producer::atom()}], reqdata(), context()}</h3>


<div class="description">

<p>List the content types available for representing this resource.
       "application/json" is the content-type for bucket-level GET requests
       The content-type for a key-level request is the content-type that
       was used in the PUT request that stored the document in Riak.</p>
</div></div>
<div class="function">
<h3 id="charsets_provided/1">charsets_provided(RD::reqdata(), Ctx::context()) -&gt; {no_charset | [{Charset::string(), Producer::function()}], reqdata(), context()}</h3>


<div class="description">

<p>List the charsets available for representing this resource.
       No charset will be specified for a bucket-level request.
       The charset for a key-level request is the charset that was used
       in the PUT request that stored the document in Riak (none if
       no charset was specified at PUT-time).</p>
</div></div>
<div class="function">
<h3 id="encodings_provided/1">encodings_provided(RD::reqdata(), Ctx::context()) -&gt; {[{Encoding::string(), Producer::function()}], reqdata(), context()}</h3>


<div class="description">

<p>List the encodings available for representing this resource.
       "identity" and "gzip" are available for bucket-level requests.
       The encoding for a key-level request is the encoding that was
       used in the PUT request that stored the document in Riak, or
       "identity" and "gzip" if no encoding was specified at PUT-time.</p>
</div></div>
<div class="function">
<h3 id="content_types_accepted/1">content_types_accepted(RD::reqdata(), Ctx::context()) -&gt; {[{ContentType::string(), Acceptor::atom()}], reqdata(), context()}</h3>


<div class="description">

<p>Get the list of content types this resource will accept.
       "application/json" is the only type accepted for bucket-PUT.
       Whatever content type is specified by the Content-Type header
       of a key-level PUT request will be accepted by this resource.
       (A key-level put *must* include a Content-Type header.)</p>
</div></div>
<div class="function">
<h3 id="resource_exists/1">resource_exists(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether or not the requested item exists.
       Documents exists if a read request to Riak returns {ok, riak_object()}.</p>
</div></div>
<div class="function">
<h3 id="produce_toplevel_body/1">produce_toplevel_body(RD::reqdata(), Ctx::context()) -&gt; {binary(), reqdata(), context()}</h3>


<div class="description">

<p>Produce the JSON response to a bucket-level GET.
       Includes the bucket props unless the "props=false" query param
       is specified.
       Includes the keys of the documents in the bucket unless the
       "keys=false" query param is specified. If "keys=stream" query param
       is specified, keys will be streamed back to the client in JSON chunks
       like so: {"keys":[Key1, Key2,...]}.</p>
</div></div>
<div class="function">
<h3 id="post_is_create/1">post_is_create(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>POST is considered a document-creation operation for bucket-level
       requests (this makes webmachine call create_path/2, where the key
       for the created document will be chosen).</p>
</div></div>
<div class="function">
<h3 id="create_path/1">create_path(RD::reqdata(), Ctx::context()) -&gt; {string(), reqdata(), context()}</h3>


<div class="description">

<p>Choose the Key for the document created during a bucket-level POST.
       This function also sets the Location header to generate a
       201 Created response.</p>
</div></div>
<div class="function">
<h3 id="process_post/1">process_post(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Pass-through for key-level requests to allow POST to function
       as PUT for clients that do not support PUT.</p>
</div></div>
<div class="function">
<h3 id="accept_doc_body/1">accept_doc_body(RD::reqdata(), Ctx::context()) -&gt; {true, reqdat(), context()}</h3>


<div class="description">

<p>Store the data the client is PUTing in the document.
       This function translates the headers and body of the HTTP request
       into their final riak_object() form, and executes the Riak put.</p>
</div></div>
<div class="function">
<h3 id="produce_doc_body/1">produce_doc_body(RD::reqdata(), Ctx::context()) -&gt; {binary(), reqdata(), context()}</h3>


<div class="description">

<p>Extract the value of the document, and place it in the response
       body of the request.</p>
</div></div>
<div class="function">
<h3 id="delete_resource/1">delete_resource(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Delete the document specified.</p>
</div></div>
<div class="function">
<h3 id="generate_etag/1">generate_etag(RD::reqdata(), Ctx::context()) -&gt; {undefined | string(), reqdata(), context()}</h3>


<div class="description">

<p>Get the etag for this resource.
       Bucket requests will have no etag.
       Documents will have an etag equal to their vtag.  No etag will be
       given for documents with siblings, if no sibling was chosen with the
       vtag query param.</p>
</div></div>
<div class="function">
<h3 id="last_modified/1">last_modified(RD::reqdata(), Ctx::context()) -&gt; {undefined | datetime(), reqdata(), context()}</h3>


<div class="description">

<p>Get the last-modified time for this resource.
       Bucket requests will have no last-modified time.
       Documents will have the last-modified time specified by the riak_object.
       No last-modified time will be given for documents with siblings, if no
       sibling was chosen with the vtag query param.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
