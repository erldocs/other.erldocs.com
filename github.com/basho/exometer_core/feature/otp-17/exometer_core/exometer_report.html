<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>exometer_report (exometer_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>exometer_report</h1>
<h2 class="modsummary">.</h2>
<div class="description">
<p>A custom reporter plugin, executing in its own process, can receive
  updated metric values by having its module referenced in an
  <code>exometer_report:subscribe()</code> call.</p>
 
  <p>The reporter, once it is setup as a subscription destination, will  
receive periodic calls with updated metrics and data points to be  
reported.</p>
 
  <p>Each custom plugin implements the exometer_report behavior.</p>
 
  <p>The life cycle of a a custom reporter consists of the following steps.</p>
 
  <p>+ Reporter creation <br /><code>exometer_init/1</code> is invoked by exometer when
      the reporter is configured in the reporter application
      environment. See <a href="#Configuring_reporter_plugins" class="seealso">Configuring reporter plugins</a> for      
details.</p>
 
  <p>+ Setup subscription<br />When <code>exometer_report:subscribe()</code> is called, targeting the
      custom report plugin, the gen_server's <code>exometer_subscribe()</code> function      
will be invoked to notify the plugin of the new metrics subscription.</p>
 
  <p>+ Report Metrics<br />Updated metrics are sent by exometer to the
      <code>exometer_report/4</code>. All reported metrics will have been notified
      to the recipient through a previous <code>exometer_report()</code> function.</p>
 
  <p>+ Tear down subscription<br />When <code>exometer_report:unsubscribe()</code> is called, addressing the
      custom report plugin, the recipient's <code>exometer_unsubscribe()</code> function      
will be invoked to notify the plugin of the deleted subscription.</p>
 
 
  <p>The following chapters details each of the callbacks to be implemented  
in the exometer_report behavior.</p>
 
  <p><em><marker id="exometer_init/1">exometer_init/1</marker></em></p>
 
  <p>The <code>exometer_init()</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       exometer_init(Options)</pre>
 
  <p>The custom reporter plugin should create the necessary state for the  
new plugin and return a state to be used in future plugin calls.</p>
 
  <p>+ <code>Options</code><br />Provides the prop list with attributes from the application environment
      for the cusom recipient. See <a href="#Configuring_reporter_plugins" class="seealso">Configuring reporter plugins</a> for</p>
 
  <p>The <code>exomoeter_init()</code> function should return <code>{ok, State}</code> where  
State is a tuple that will be provided as a reference argument to  
future calls made into the plugin. Any other return formats will  
cancel the creation of the custom reporting plugin.</p>
 
 
  <p><em><marker id="exometer_subscribe/4">exometer_subscribe/4</marker></em></p>
 
  <p>The <code>exometer_subscribe()</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       exometer_subscribe(Metric, DataPoint, Interval State)</pre>
 
  <p>The custom plugin can use this notification to modify and return its
  state in order to prepare for future calls to <code>exometer_report()</code> with  
the given meteric and data point.</p>
 
  <p>+ <code>Metric</code><br />Specifies the metric that is now subscribed to by the plugin      
as a list of atoms.</p>
 
  <p>+ <code>DataPoint</code><br />Specifies the data point within the subscribed-to metric  
as an atom, or a list of atoms.</p>
 
  <p>+ <code>Interval</code><br />Specifies the interval, in milliseconds, that the  
subscribed-to value will be reported at, or an atom, referring to a named  
interval configured in the reporter.</p>
 
  <p>+ <code>State</code><br />Contains the state returned by the last called plugin function.</p>
 
  <p>The <code>exomoeter_subscribe()</code> function should return <code>{ok, State}</code> where  
State is a tuple that will be provided as a reference argument to  
future calls made into the plugin. Any other return formats will  
generate an error log message by exometer.</p>
 
 
  <p><em><marker id="exometer_report/4">exometer_report/4</marker></em></p>
 
  <p>The <code>exometer_report()</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       exometer_report(Metric, DataPoint, State)</pre>
 
  <p>The custom plugin will receive this call when a periodic subscription  
triggers and wants to report its current value through the plugin.  
The plugin should export the value to the external system it interfaces and  
return its possibly modified state.</p>
 
  <p>+ <code>Metric</code><br />Specifies the metric that is to be reported.</p>
 
  <p>+ <code>DataPoint</code><br />Specifies the data point or data points within the metric   
to be reported.</p>
 
  <p>+ <code>State</code><br />Contains the state returned by the last called plugin function.</p>
 
  <p>The <code>exomoeter_report()</code> function should return <code>{ok, State}</code> where  
State is a tuple that will be provided as a reference argument to  
future calls made into the plugin. Any other return formats will  
generate an error log message by exometer.</p>
 
 
  <p><em><marker id="exometer_unsubscribe/3">exometer_unsubscribe/3</marker></em></p>
 
  <p>The <code>exometer_unsubscribe()</code> function is invoked as follows:</p>
 
  <pre lang="erlang">
       exometer_unsubscribe(Metric, DataPoint, State)</pre>
 
  <p>The custom plugin can use this notification to modify and return its
  state in order to free resources used to maintain the now de-activated
  subscription. When this call returns, the given metric / data point
  will not be present in future calls to <code>exometer_report()</code>.</p>
 
  <p>+ <code>Metric</code><br />Specifies the metric that is now subscribed to by the plugin      
as a list of atoms.</p>
 
  <p>+ <code>DataPoint</code><br />Specifies the data point or data points within the   
subscribed-to metric as an atom or a list of atoms.</p>
 
  <p>+ <code>State</code><br />Contains the state returned by the last called plugin function.</p>
 
  <p>The <code>exometer_unsubscribe()</code> function should return <code>{ok, State}</code> where
  State is a tuple that will be provided as a reference argument to
  future calls made into the plugin. Any other return formats will
  generate an error log message by exometer.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-datapoint">datapoint() = <a href="exometer.html#type-datapoint" class="seealso">exometer:datapoint()</a></h3></div>
    <div class="type"><h3 id="type-datapoints">datapoints() = <a href="#type-datapoint" class="seealso">datapoint()</a> | [<a href="#type-datapoint" class="seealso">datapoint()</a>]</h3></div>
    <div class="type"><h3 id="type-delay">delay() = <a href="#type-time_ms" class="seealso">time_ms()</a></h3></div>
    <div class="type"><h3 id="type-error">error() = {error, any()}</h3></div>
    <div class="type"><h3 id="type-extra">extra() = any()</h3></div>
    <div class="type"><h3 id="type-interval">interval() = integer() &gt;= 1 | atom()</h3></div>
    <div class="type"><h3 id="type-metric">metric() = <a href="exometer.html#type-name" class="seealso">exometer:name()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {find, <a href="exometer.html#type-name" class="seealso">exometer:name()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {select, <a href="ets.html#type-match_spec" class="seealso">ets:match_spec()</a>}</h3></div>
    <div class="type"><h3 id="type-options">options() = [{atom(), any()}]</h3></div>
    <div class="type"><h3 id="type-reporter_name">reporter_name() = atom()</h3></div>
    <div class="type"><h3 id="type-retry">retry() = boolean()</h3></div>
    <div class="type"><h3 id="type-time_ms">time_ms() = integer() &gt;= 1</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, pid()} | ignore | {error, any()}</h3>


<div class="description">

<p>Starts the server
 --------------------------------------------------------------------</p>
</div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(Reporter::reporter_name(), Metric::metric(), DataPoint::datapoints(), Interval::interval()) -&gt; ok | not_found | unknown_reporter | error</h3>


<div class="description">
<p>Equivalent to <a href="#subscribe/6" class="seealso">subscribe(Reporter, Metric, DataPoint, Interval, [],
	  false)</a>.</p>
</div></div>
<div class="function">
<h3 id="subscribe/1-1">subscribe(Reporter::reporter_name(), Metric::metric(), DataPoint::datapoints(), Interval::interval(), Extra::extra()) -&gt; ok | not_found | unknown_reporter | error</h3>


<div class="description">
<p>Equivalent to <a href="#subscribe/6" class="seealso">subscribe(Reporter, Metric, DataPoint, Interval, Extra,
	  false)</a>.</p>
</div></div>
<div class="function">
<h3 id="subscribe/1-2">subscribe(Reporter::reporter_name(), Metric::metric(), DataPoint::datapoints(), Interval::interval(), Extra::extra(), Retry::retry()) -&gt; ok | not_found | unknown_reporter | error</h3>


<div class="description">

<p>Add a subscription to an existing reporter.</p>
 
  <p>The reporter must first be started using <a href="#add_reporter/2" class="seealso">add_reporter/2</a>, or through
  a static configuration. <code>Metric</code> is the name of an exometer entry. <code>DataPoint</code>  
is either a single data point (an atom) or a list of data points (a list).</p>
 
  <p><code>Interval</code> is the sampling/reporting interval in milliseconds, or an atom,
  referring to a named interval configured in the reporter. The named
  interval need not be defined yet in the reporter (the subscription will
  not trigger until it <em>is</em> defined.)</p>
 
  <p><code>Extra</code> can be anything that the chosen reporter understands (default: <code>[]</code>).
  If the reporter uses <a href="exometer_util.html#report_type/3" class="seealso">exometer_util:report_type/3</a>, <code>Extra</code> should be
  a proplist, and the option <code>{report_type, T}</code> can control which type (e.g.  
for collectd or statsd) that the value corresponds to.</p>
 
  <p><code>Retry</code>: boolean(). If true, retry the subscription at the next interval,
  even if the metric cannot be read.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(Reporter::module(), Metric::metric(), DataPoint::datapoint()) -&gt; ok | not_found</h3>


<div class="description">
<p>Equivalent to <a href="#unsubscribe/4" class="seealso">unsubscribe(Reporter, Metric, DataPoint, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1-1">unsubscribe(Reporter::module(), Metric::metric(), DataPoint::datapoint() | [datapoint()], Extra::extra()) -&gt; ok | not_found</h3>


<div class="description">

<p>Removes a subscription.</p>
 
  <p>Note that the subscription is identified by the combination
  <code>{Reporter, Metric, DataPoint, Extra}</code>. The exact information can be
  extracted using <a href="#list_subscriptions/1" class="seealso">list_subscriptions/1</a>.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe_all/1">unsubscribe_all(Reporter::module(), Metric::metric()) -&gt; ok</h3>


<div class="description">

<p>Removes all subscriptions related to Metric in Reporter.</p>
</div></div>
<div class="function">
<h3 id="list_metrics/0">list_metrics() -&gt; {ok, [{name() (see module exometer), [datapoint()], [{reporter_name(), datapoint()}], status() (see module exometer)}]} | {error, any()}</h3>


<div class="description">
<p>Equivalent to <a href="#list_metrics/1" class="seealso">list_metrics([])</a>.</p>
</div></div>
<div class="function">
<h3 id="list_metrics/1">list_metrics(Path::metric()) -&gt; {ok, [{name() (see module exometer), [datapoint()], [{reporter_name(), datapoint()}], status() (see module exometer)}]} | {error, any()}</h3>


<div class="description">

<p>List all metrics matching <code>Path</code>, together with subscription status.</p>
 
  <p>This function performs a metrics search using <code>exometer:find_entries/1</code>,
  then matches the result against known subscriptions. It reports, for each
  metric, the available data points, as well as which reporters subscribe to
  which data points.</p>
</div></div>
<div class="function">
<h3 id="list_reporters/0">list_reporters() -&gt; [{reporter_name(), pid()}]</h3>


<div class="description">

<p>List the name and pid of each known reporter.</p>
</div></div>
<div class="function">
<h3 id="list_subscriptions/1">list_subscriptions(Reporter::reporter_name()) -&gt; [{metric(), datapoint(), interval(), extra()}]</h3>


<div class="description">

<p>List all subscriptions for <code>Reporter</code>.</p>
</div></div>
<div class="function">
<h3 id="add_reporter/1">add_reporter(Reporter::reporter_name(), Options::options()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Add a reporter.</p>
 
  <p>The reporter can be configured using the following options. Note that all  
options are also passed to the reporter callback module, which may support  
additional options.</p>
 
  <p><code>{module, atom()}</code> - The name of the reporter callback module. If no module  
is given, the module name defaults to the given reporter name.</p>
 
  <p><code>{status, enabled | disabled}</code> - The operational status of the reporter  
if enabled, the reporter will report values to its target. If disabled, the  
reporter process will be terminated and subscription timers canceled, but  
the subscriptions will remain, and it will also be possible to add new  
subscriptions to the reporter.</p>
 
  <p><code>{intervals, [named_interval()]}</code>
  named_interval() :: {Name::atom(), Interval::pos_integer()}
                    | {Name::atom(), Interval::time_ms(), delay()::time_ms()}
  Define named intervals. The name can be used by subscribers, so that all
  subsriptions for a given named interval will be reported when the interval
  triggers. An optional delay (in ms) can be given: this will cause the first
  interval to start in <code>Delay</code> milliseconds. When all intervals are named
  at the same time, the delay parameter can be used to achieve staggered
  reporting.</p>
</div></div>
<div class="function">
<h3 id="remove_reporter/1">remove_reporter(Reporter::reporter_name()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Remove reporter and all its subscriptions.</p>
</div></div>
<div class="function">
<h3 id="set_interval/1">set_interval(Reporter::reporter_name(), Name::atom(), Time::time_ms() | {time_ms(), delay()}) -&gt; ok | error()</h3>


<div class="description">

<p>Specify a named interval.</p>
 
  <p>See <a href="#add_reporter/2" class="seealso">add_reporter/2</a> for a description of named intervals.
  The named interval is here specified as either <code>Time</code> (milliseconds) or
  <code>{Time, Delay}</code>, where a delay in milliseconds is provided.</p>
 
  <p>If the named interval exists, it will be replaced with the new definition.
  Otherwise, it will be added. Use <a href="#restart_intervals/1" class="seealso">restart_intervals/1</a> if you want
  all intervals to be restarted/resynched with corresponding relative delays.</p>
</div></div>
<div class="function">
<h3 id="delete_interval/1">delete_interval(Reporter::reporter_name(), Name::atom()) -&gt; ok | error()</h3>


<div class="description">

<p>Delete a named interval.
 </p>
</div></div>
<div class="function">
<h3 id="restart_intervals/1">restart_intervals(Reporter::reporter_name()) -&gt; ok</h3>


<div class="description">

<p>Restart all named intervals, respecting specified delays.</p>
 
  <p>This function can be used if named intervals are added incrementally, and
  it is important that all intervals trigger separated by the given delays.</p>
</div></div>
<div class="function">
<h3 id="get_intervals/1">get_intervals(Reporter::reporter_name()) -&gt; [{atom(), [{time, pos_integer()} | {delay, pos_integer()} | {timer_ref, reference()}]}]</h3>


<div class="description">

<p>List the named intervals for <code>Reporter</code>.</p>
</div></div>
<div class="function">
<h3 id="enable_reporter/1">enable_reporter(Reporter::reporter_name()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Enable <code>Reporter</code>.</p>
 
  <p>The reporter will be 'restarted' in the same way as if it had crashed  
and was restarted by the supervision logic, but without counting it as  
a restart.</p>
 
  <p>If the reporter was already enabled, nothing is changed.</p>
</div></div>
<div class="function">
<h3 id="disable_reporter/1">disable_reporter(Reporter::reporter_name()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Disable <code>Reporter</code>.</p>
 
  <p>The reporter will be terminated, and all subscription timers will be
  canceled, but the subscriptions themselves and reporter metadata are kept.</p>
</div></div>
<div class="function">
<h3 id="disable_me/1">disable_me(Mod::module(), St::any()) -&gt; no_return()</h3>


<div class="description">

<p>Used by a reporter to disable itself.</p>
 
  <p>This function can be called from a reporter instance if it wants to be
  disabled, e.g. after exhausting a configured number of connection attempts.
  The arguments passed are the name of the reporter callback module and the
  module state, and are used to call the <code>Mod:terminate/2</code> function.</p>
</div></div>
<div class="function">
<h3 id="call_reporter/1">call_reporter(Reporter::reporter_name(), Msg::any()) -&gt; any() | {error, any()}</h3>


<div class="description">

<p>Send a custom (synchronous) call to <code>Reporter</code>.</p>
 
  <p>This function is used to make a client-server call to a given reporter
  instance. Note that the reporter type must recognize the request.</p>
</div></div>
<div class="function">
<h3 id="cast_reporter/1">cast_reporter(Reporter::reporter_name(), Msg::any()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Send a custom (asynchronous) cast to <code>Reporter</code>.</p>
 
  <p>This function is used to make an asynchronous cast to a given reporter
  instance. Note that the reporter type must recognize the message.</p>
</div></div>
<div class="function">
<h3 id="remove_reporter/1-1">remove_reporter(Reporter::reporter_name(), _Reason::any()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>Remove <code>Reporter</code> (non-blocking call).</p>
 
  <p>This function can be used to order removal of a reporter with a custom
  reason. Note that the function is asynchronous, making it suitable e.g.
  for calling from within the reporter itself.</p>
</div></div>
<div class="function">
<h3 id="setopts/1">setopts(Metric::entry() (see module exometer), Options::options(), Status::status() (see module exometer)) -&gt; ok</h3>


<div class="description">

<p>Called by exometer when options of a metric entry are changed.</p>
 
  <p>Reporters subscribing to the metric get a chance to process the options
  change in the function <code>Mod:exometer_setopts(Metric,Options,Status,St)</code>.</p>
</div></div>
<div class="function">
<h3 id="new_entry/1">new_entry(Entry::entry() (see module exometer)) -&gt; ok</h3>


<div class="description">

<p>Called by exometer whenever a new entry is created.</p>
 
  <p>This function is called whenever a new metric is created, giving each
  reporter the chance to enable a subscription for it. Note that each
  reporter is free to call the subscription management functions, as there
  is no risk of deadlock. The callback function triggered by this call is
  <code>Mod:exometer_newentry(Entry, St)</code>.</p>
</div></div>
<div class="function">
<h3 id="start_reporters/0">start_reporters() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="terminate_reporter/1">terminate_reporter(Reporter) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
