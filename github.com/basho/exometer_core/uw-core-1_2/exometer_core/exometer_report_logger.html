<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>exometer_report_logger (exometer_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>exometer_report_logger</h1>
<h2 class="modsummary">Exometer report collector and logger.</h2>
<div class="description">
<p>Exometer report collector and logger.</p>
 
  <p>This module implements a behavior for collecting reporting data and  
handling it (logging to disk or ets, printing to tty, etc.)</p>
 
  <p>The logger has built-in support for receiving input via UDP, TCP or  
internal Erlang messaging, as well as a plugin API for custom input  
handling. Correspondingly, it has support for output to TTY or ets, as  
well as a plugin API for custom output.</p>
 
  <p>An example of how the logger can be used can be found in
  <code>test/exometer_test_udp_reporter.erl</code>, which implements a UDP-based
  reporter as well as an input plugin and an output plugin. This reporter
  is used by <code>test/exometer_report_SUITE.erl</code>.</p>
 
  <p>Loggers can be combined, e.g. by creating one logger that receives Erlang  
messages, and other loggers that receive from different sources, prefix  
their reports and pass them on to the first logger.</p>
 
  <p><em>Input plugins</em></p>
 
  <p>An input plugin is initiated by <code>Module:logger_init_input(State)</code>, where
  <code>State</code> is whatever was given as a <code>state</code> option (default: <code>undefined</code>).
  The function must create a process and return <code>{ok, Pid}</code>. <code>Pid</code> is
  responsible for setting up whatever input channel is desired, and passes
  on incoming data to the logger via Erlang messages <code>{plugin, Pid, Data}</code>.</p>
 
  <p><em>Output Chaining</em></p>
 
  <p>Each incoming data item is passed through the list of output operators.
  Each output operator is able to modify the data (the <code>tty</code> and <code>ets</code>
  operators leave the data unchanged). Output plugins receive the data
  in <code>Module:logger_handle_data(Data, State)</code>, which must return
  <code>{NewData, NewState}</code>. The state is private to the plugin, while <code>NewData</code>  
will be passed along to the next output operator.</p>
 
  <p><em>Flow control</em></p>
 
  <p>The logger will handle flow control automatically for <code>udp</code> and <code>tcp</code>
  inputs. If <code>{active,once}</code> or <code>{active, false}</code>, the logger will trigger
  <code>{active, once}</code> each time it has handled an incoming message.
  If <code>{active, N}</code>, it will "refill" the port each time it receives an  
indication that it has become passive.</p>
 
  <p>Input plugins create a process in <code>Module:logger_init_input/1</code>. This process
  can mimick the behavior of Erlang ports by sending a <code>{plugin_passive, Pid}</code>
  message to the logger. The logger will reply with a message,
  <code>{plugin_active, N}</code>, where <code>N</code> is the value given by the <code>active</code> option.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-logger_info">logger_info() = {id, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {input, <a href="#type-proplist" class="seealso">proplist()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {output, <a href="#type-proplist" class="seealso">proplist()</a>}</h3></div>
    <div class="type"><h3 id="type-proplist">proplist() = [{atom(), any()}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/2">new(Options::[{id, any()} | {input, list()} | {output, list()}]) -&gt; {ok, pid()}</h3>


<div class="description">

<p>Create a new logger instance.</p>
 
  <p>This function creates a logger process with the given input and output  
parameters.</p>
 
  <p>* <code>{id, ID}</code> is mainly for documentation and simplifying identification
    of instances returned by <a href="#info/0" class="seealso">info/0</a>.
  * <code>{input, PropList}</code> specifies what the logger listens to. Only the first
    <code>input</code> entry is regarded, but the option is mandatory.
  * <code>{output, PropList}</code> specifies what the logger should to with received
     data. Multiple <code>output</code> entries are allowed, and they will be processed     
in the order given.</p>
 
  <p>Valid input options:</p>
 
  <p>* <code>{mode, udp | tcp | internal | plugin}</code> defines the protocol
  * <code>{active, false | true | once | N}</code> provides flow control. Default: <code>true</code>.  
* (mode-specific options)</p>
 
  <p>Valid output options:</p>
 
  <p>* <code>{mode, tty | ets | plugin | internal}</code> defines output types  
* (output-specific options)</p>
 
  <p>Mode-specific options, <code>udp</code>:</p>
 
  <p>* <code>{port, integer()}</code> - UDP port number
  * <code>{options, list()}</code> - Options to pass to <a href="gen_udp.html#open/2" class="seealso">gen_udp:open/2</a></p>
 
  <p>Mode-specific options, <code>tcp</code>:</p>
 
  <p>* <code>{port, integer()}</code> - TCP port number
  * <code>{options, list()}</code> - Options to pass to <a href="gen_tcp.html#listen/2" class="seealso">gen_tcp:listen/2</a></p>
 
  <p>Mode-specific options, <code>tty</code>:</p>
 
  <p>* <code>{prefix, iolist()}</code> - Prefix string inserted before the data, which is    
printed as-is (note that any delimiter would need to be part of the prefix)</p>
 
  <p>Mode-specific options, <code>ets</code>:
  * <code>{table, ets:table()}</code> - Ets table identifier. If not specified, an
     ordered-set table will be created by the logger process. The incoming
     data will be inserted as <code>{erlang:now(), Data}</code>.</p>
 
  <p>Mode-specific options, <code>internal</code>:
  * <code>{process, PidOrRegname}</code> specifies another logger instance, which is to
    receive data from this logger (if used in output), or which is allowed
    to send to this logger (if used in input). If no process is given for
    input, any process can send data (on the form
    <code>{exometer_report_logger, Pid, Data}</code>) to this logger.</p>
 
  <p>Mode-specific options, <code>plugin</code>:</p>
 
  <p>* <code>{module, Module}</code> - name of callback module
     (behaviour: <code>exometer_report_logger</code>)
  * <code>{state, State}</code> - Passed as initial argument to
    <code>Module:logger_init_input/1</code> or <code>Module:logger_init_output/1</code>, depending
    on whether the plugin is specified as input or output.</p>
</div></div>
<div class="function">
<h3 id="start_link/1">start_link(Options::proplist()) -&gt; {ok, pid()}</h3>


<div class="description">

<p>Start function for logger instance.</p>
 
  <p>This function is the start function eventually called as a result from
  <a href="#new/1" class="seealso">new/1</a>, but whereas <code>new/1</code> creates a supervised instance, this
  function simply creates the process. It would normally not be used directly.</p>
</div></div>
<div class="function">
<h3 id="info/0">info() -&gt; [{pid(), [logger_info()]}]</h3>


<div class="description">

<p>List active logger instances.</p>
 
  <p>This function lists the instances started via <a href="#new/1" class="seealso">new/1</a>, along with their
  respective settings as nested property lists.</p>
</div></div>
<div class="function">
<h3 id="info/1">info(P::pid()) -&gt; [logger_info()]</h3>


<div class="description">

<p>Lists the settings of a given logger instance.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
