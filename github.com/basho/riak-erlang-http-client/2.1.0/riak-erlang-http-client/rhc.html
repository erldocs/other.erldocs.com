<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>rhc (riak-erlang-http-client) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>rhc</h1>
<h2 class="modsummary">Riak Erlang HTTP Client.</h2>
<div class="description">
<p>Riak Erlang HTTP Client.  This module provides access to Riak's
       HTTP interface.  For basic usage, please read
       <url href="overview.html">the riakhttpc application overview</url>.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-rhc">rhc()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="create/0">create() -&gt; term()
</h3>


<div class="description">

<p>Create a client for connecting to the default port on localhost.</p>
</div></div>
<div class="function">
<h3 id="create/1">create(IP::string(), Port::integer(), Prefix::string(), Options::list()) -&gt; rhc()</h3>


<div class="description">

<p>Create a client for connecting to a Riak node.</p>
 
       <p>Connections are made to:
       </p><pre class="sh_erlang">          http://IP:Port/Prefix/(&lt;bucket&gt;/&lt;key&gt;)</pre>
 
       <p>Defaults for r, w, dw, rw, and return_body may be passed in
       the Options list.  The client id can also be specified by
       adding <code>{client_id, ID}</code> to the Options list.</p>
</div></div>
<div class="function">
<h3 id="ip/1">ip(Rhc::rhc()) -&gt; string()</h3>


<div class="description">

<p>Get the IP this client will connect to.</p>
</div></div>
<div class="function">
<h3 id="port/1">port(Rhc::rhc()) -&gt; integer()</h3>


<div class="description">

<p>Get the Port this client will connect to.</p>
</div></div>
<div class="function">
<h3 id="prefix/1">prefix(Rhc::rhc()) -&gt; string()</h3>


<div class="description">

<p>Get the prefix this client will use for object URLs</p>
</div></div>
<div class="function">
<h3 id="ping/1">ping(Rhc::rhc()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Ping the server by requesting the "/ping" resource.</p>
</div></div>
<div class="function">
<h3 id="get_client_id/1">get_client_id(Rhc::rhc()) -&gt; {ok, string()}</h3>


<div class="description">

<p>Get the client ID that this client will use when storing objects.</p>
</div></div>
<div class="function">
<h3 id="get_server_info/1">get_server_info(Rhc::rhc()) -&gt; {ok, proplist()} | {error, term()}</h3>


<div class="description">

<p>Get some basic information about the server.  The proplist returned
       should include <code>node</code> and <code>server_version</code> entries.</p>
</div></div>
<div class="function">
<h3 id="get_server_stats/1">get_server_stats(Rhc::rhc()) -&gt; {ok, proplist()} | {error, term()}</h3>


<div class="description">

<p>Get the list of full stats from a /stats call to the server.</p>
</div></div>
<div class="function">
<h3 id="get/3">get(Rhc, Bucket, Key) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#get/4" class="seealso">get(Rhc, Bucket, Key, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="get/1">get(Rhc::rhc(), Bucket::bucket(), Key::key(), Options::proplist()) -&gt; {ok, riakc_obj()} | {error, term()}</h3>


<div class="description">

<p>Get the objects stored under the given bucket and key.</p>
 
       <p>Allowed options are:
       </p><taglist>
         <dt><code>r</code></dt>
           <item><p>The 'R' value to use for the read</p></item>
         <dt><code>timeout</code></dt>
           <item><p>The server-side timeout for the write in ms</p></item>
       </taglist>
 
       <p>The term in the second position of the error tuple will be
       <code>notfound</code> if the key was not found.</p>
</div></div>
<div class="function">
<h3 id="put/2">put(Rhc, Object) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#put/3" class="seealso">put(Rhc, Object, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="put/1">put(Rhc::rhc(), Object::riakc_obj(), Options::proplist()) -&gt; ok | {ok, riakc_obj()} | {error, term()}</h3>


<div class="description">

<p>Store the given object in Riak.</p>
 
       <p>Allowed options are:
       </p><taglist>
         <dt><code>w</code></dt>
           <item><p>The 'W' value to use for the write</p></item>
         <dt><code>dw</code></dt>
           <item><p>The 'DW' value to use for the write</p></item>
         <dt><code>timeout</code></dt>
           <item><p>The server-side timeout for the write in ms</p></item>
         <dt>return_body</dt>
           <item><p>Whether or not to return the updated object in the
           response.  <code>ok</code> is returned if return_body is false.
           <code>{ok, Object}</code> is returned if return_body is true.</p></item>
       </taglist>
</div></div>
<div class="function">
<h3 id="counter_incr/1">counter_incr(Rhc::rhc(), Bucket::binary(), Key::binary(), Amt::integer()) -&gt; ok | {ok, integer()} | {error, term()}</h3>


<div class="description">

<p>Increment the counter stored under <code>bucket</code>, <code>key</code>
       by the given <code>amount</code>.</p>
</div></div>
<div class="function">
<h3 id="counter_incr/1-1">counter_incr(Rhc::rhc(), Bucket::binary(), Key::binary(), Amt::integer(), Options::list()) -&gt; ok | {ok, integer()} | {error, term()}</h3>


<div class="description">

<p>Increment the counter stored at <code>bucket</code>, <code>key</code> by
       <code>Amt</code>. Note: <code>Amt</code> can be a negative or positive integer.</p>
 
       <p>Allowed options are:
       </p><taglist>
         <dt><code>w</code></dt>
           <item><p>The 'W' value to use for the write</p></item>
         <dt><code>dw</code></dt>
           <item><p>The 'DW' value to use for the write</p></item>
         <dt><code>pw</code></dt>
           <item><p>The 'PW' value to use for the write</p></item>
         <dt><code>timeout</code></dt>
           <item><p>The server-side timeout for the write in ms</p></item>
         <dt><code>returnvalue</code></dt>
           <item><p>Whether or not to return the updated value in the
           response. <code>ok</code> is returned if returnvalue is absent | <code>false</code>.
           <code>{ok, integer()}</code> is returned if returnvalue is <code>true</code>.</p></item>
       </taglist><p>
  See the riak docs at http://docs.basho.com/riak/latest/references/apis/http/ for details</p>
</div></div>
<div class="function">
<h3 id="counter_val/1">counter_val(Rhc::rhc(), Bucket::term(), Key::term()) -&gt; {ok, integer()} | {error, term()}</h3>


<div class="description">

<p>Get the counter stored at <code>bucket</code>, <code>key</code>.</p>
</div></div>
<div class="function">
<h3 id="counter_val/1-1">counter_val(Rhc::rhc(), Bucket::term(), Key::term(), Options::list()) -&gt; {ok, integer()} | {error, term()}</h3>


<div class="description">

<p>Get the counter stored at <code>bucket</code>, <code>key</code>.</p>
 
       <p>Allowed options are:
       </p><taglist>
         <dt><code>r</code></dt>
           <item><p>The 'R' value to use for the read</p></item>
         <dt><code>pr</code></dt>
           <item><p>The 'PR' value to use for the read</p></item>
         <dt><code>pw</code></dt>
           <item><p>The 'PW' value to use for the write</p></item>
         <dt><code>timeout</code></dt>
           <item><p>The server-side timeout for the write in ms</p></item>
         <dt><code>notfound_ok</code></dt>
           <item><p>if <code>true</code> not_found replies from vnodes count toward read quorum.</p></item>
         <dt><code>basic_quorum</code></dt>
           <item><p>When set to <code>true</code> riak will return a value as soon as it gets a quorum of responses.</p></item>
       </taglist><p>
  See the riak docs at http://docs.basho.com/riak/latest/references/apis/http/ fro details</p>
</div></div>
<div class="function">
<h3 id="delete/3">delete(Rhc, Bucket, Key) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#delete/4" class="seealso">delete(Rhc, Bucket, Key, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(Rhc::rhc(), Bucket::bucket(), Key::key(), Options::proplist()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Delete the given key from the given bucket.</p>
 
       <p>Allowed options are:
       </p><taglist>
         <dt><code>rw</code></dt>
           <item><p>The 'RW' value to use for the delete</p></item>
         <dt><code>timeout</code></dt>
           <item><p>The server-side timeout for the write in ms</p></item>
       </taglist>
</div></div>
<div class="function">
<h3 id="delete_obj/2">delete_obj(Rhc, Obj) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#delete_obj/3" class="seealso">delete_obj(Rhc, Obj, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="delete_obj/3">delete_obj(Rhc, Obj, Options) -&gt; term()
</h3>


<div class="description">

<p>Delete the key of the given object, using the contained vector
  clock if present.</p>
</div></div>
<div class="function">
<h3 id="list_buckets/1">list_buckets(Rhc) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_buckets/2">list_buckets(Rhc, BucketType) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stream_list_buckets/1">stream_list_buckets(Rhc) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stream_list_buckets/2">stream_list_buckets(Rhc, BucketType) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_keys/2">list_keys(Rhc, Bucket) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_keys/1">list_keys(Rhc::rhc(), Bucket::bucket(), Timeout::integer()) -&gt; {ok, [key()]} | {error, term()}</h3>


<div class="description">

<p>List the keys in the given bucket.</p>
</div></div>
<div class="function">
<h3 id="stream_list_keys/2">stream_list_keys(Rhc, Bucket) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stream_list_keys/1">stream_list_keys(Rhc::rhc(), Bucket::bucket(), Timeout::integer()) -&gt; {ok, reference()} | {error, term()}</h3>


<div class="description">

<p>Stream key lists to a Pid.  Messages sent to the Pid will
       be of the form <code>{reference(), message()}</code>
       where <code>message()</code> is one of:
       </p><taglist>
          <dt><code>done</code></dt>
             <item><p>end of key list, no more messages will be sent</p></item>
          <dt><code>{keys, [key()]}</code></dt>
             <item><p>a portion of the key list</p></item>
          <dt><code>{error, term()}</code></dt>
             <item><p>an error occurred</p></item>
       </taglist>
</div></div>
<div class="function">
<h3 id="get_index/1">get_index(Rhc::rhc(), Bucket::bucket(), Index::index(), Query::index_query()) -&gt; {ok, index_results()} | {error, term()}</h3>


<div class="description">

<p>Query a secondary index.</p>
</div></div>
<div class="function">
<h3 id="get_index/1-1">get_index(Rhc::rhc(), Bucket::bucket(), Index::index(), Query::index_query(), Options::index_options()) -&gt; {ok, index_results()} | {error, term()}</h3>


<div class="description">

<p>Query a secondary index.</p>
</div></div>
<div class="function">
<h3 id="stream_index/1">stream_index(Rhc::rhc(), Bucket::bucket(), Index::index(), Query::index_query()) -&gt; {ok, reference()} | {error, term()}</h3>


<div class="description">

<p>Query a secondary index, streaming the results back.</p>
</div></div>
<div class="function">
<h3 id="stream_index/1-1">stream_index(Rhc::rhc(), Bucket::bucket(), Index::index(), Query::index_query(), Options::index_options()) -&gt; {ok, reference()} | {error, term()}</h3>


<div class="description">

<p>Query a secondary index, streaming the results back.</p>
</div></div>
<div class="function">
<h3 id="get_bucket/1">get_bucket(Rhc::rhc(), Bucket::bucket()) -&gt; {ok, proplist()} | {error, term()}</h3>


<div class="description">

<p>Get the properties of the given bucket.</p>
</div></div>
<div class="function">
<h3 id="set_bucket/1">set_bucket(Rhc::rhc(), Bucket::bucket(), Props0::proplist()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Set the properties of the given bucket.</p>
 
       <p>Allowed properties are:
       </p><taglist>
         <dt><code>n_val</code></dt>
           <item><p>The 'N' value to use for storing data in this bucket</p></item>
         <dt><code>allow_mult</code></dt>
           <item><p>Whether or not this bucket should allow siblings to
           be created for its keys</p></item>
       </taglist>
</div></div>
<div class="function">
<h3 id="reset_bucket/2">reset_bucket(Rhc, Bucket) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_bucket_type/1">get_bucket_type(Rhc::rhc(), Type::bucket()) -&gt; {ok, proplist()} | {error, term()}</h3>


<div class="description">

<p>Get the properties of the given bucket.</p>
</div></div>
<div class="function">
<h3 id="set_bucket_type/1">set_bucket_type(Rhc::rhc(), Type::bucket(), Props0::proplist()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Set the properties of the given bucket type.
 </p>
</div></div>
<div class="function">
<h3 id="mapred/3">mapred(Rhc, Inputs, Query) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#mapred/4" class="seealso">mapred(Rhc, Inputs, Query, DEFAULT_TIMEOUT)</a>.</p>
</div></div>
<div class="function">
<h3 id="mapred/1">mapred(Rhc::rhc(), Inputs::map_input() (see module rhc_mapred), Query::[query_part() (see module rhc_mapred)], Timeout::integer()) -&gt; {ok, [phase_result() (see module rhc_mapred)]} | {error, term()}</h3>


<div class="description">

<p>Execute a map/reduce query. See <a href="rhc_mapred.html#encode_mapred/2" class="seealso">rhc_mapred:encode_mapred/2</a> for details of the allowed formats
       for <code>Inputs</code> and <code>Query</code>.</p>
</div></div>
<div class="function">
<h3 id="mapred_stream/4">mapred_stream(Rhc, Inputs, Query, ClientPid) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#mapred_stream/5" class="seealso">mapred_stream(Rhc, Inputs, Query, ClientPid,
	      DEFAULT_TIMEOUT)</a>.</p>
</div></div>
<div class="function">
<h3 id="mapred_stream/1">mapred_stream(Rhc::rhc(), Inputs::mapred_input() (see module rhc_mapred), Query::[query_phase() (see module rhc_mapred)], ClientPid::pid(), Timeout::integer()) -&gt; {ok, reference()} | {error, term()}</h3>


<div class="description">

<p>Stream map/reduce results to a Pid.  Messages sent to the Pid
       will be of the form <code>{reference(), message()}</code>,
       where <code>message()</code> is one of:
       </p><taglist>
          <dt><code>done</code></dt>
             <item><p>query has completed, no more messages will be sent</p></item>
          <dt><code>{mapred, integer(), mochijson()}</code></dt>
             <item><p>partial results of a query the second item in the tuple
              is the (zero-indexed) phase number, and the third is the
              JSON-decoded results</p></item>
          <dt><code>{error, term()}</code></dt>
              <item><p>an error occurred</p></item>
       </taglist>
</div></div>
<div class="function">
<h3 id="search/1">search(Rhc::rhc(), Bucket::bucket(), SearchQuery::string()) -&gt; {ok, [phase_result() (see module rhc_mapred)]} | {error, term()}</h3>


<div class="description">

<p>Execute a search query. This command will return an error
       unless executed against a Riak Search cluster.</p>
</div></div>
<div class="function">
<h3 id="search/1-1">search(Rhc::rhc(), Bucket::bucket(), SearchQuery::string(), MRQuery::[query_part() (see module rhc_mapred)], Timeout::integer()) -&gt; {ok, [phase_result() (see module rhc_mapred)]} | {error, term()}</h3>


<div class="description">

<p>Execute a search query and feed the results into a map/reduce
       query. See <a href="rhc_mapred.html#encode_mapred/2" class="seealso">rhc_mapred:encode_mapred/2</a> for details of
       the allowed formats for <code>MRQuery</code>. This command will return an error
       unless executed against a Riak Search cluster.</p>
</div></div>
<div class="function">
<h3 id="mapred_bucket/3">mapred_bucket(Rhc, Bucket, Query) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#mapred_bucket/4" class="seealso">mapred_bucket(Rhc, Bucket, Query, DEFAULT_TIMEOUT)</a>.</p>
</div></div>
<div class="function">
<h3 id="mapred_bucket/1">mapred_bucket(Rhc::rhc(), Bucket::bucket(), Query::[query_phase() (see module rhc_mapred)], Timeout::integer()) -&gt; {ok, [phase_result() (see module rhc_mapred)]} | {error, term()}</h3>


<div class="description">

<p>Execute a map/reduce query over all keys in the given bucket.</p>
</div></div>
<div class="function">
<h3 id="mapred_bucket_stream/1">mapred_bucket_stream(Rhc::rhc(), Bucket::bucket(), Query::[query_phase() (see module rhc_mapred)], ClientPid::pid(), Timeout::integer()) -&gt; {ok, reference()} | {error, term()}</h3>


<div class="description">

<p>Stream map/reduce results over all keys in a bucket to a Pid.
       Similar to <a href="#mapred_stream/5" class="seealso">mapred_stream/5</a></p>
</div></div>
<div class="function">
<h3 id="fetch_type/1">fetch_type(Rhc::rhc(), BucketAndType::{BucketType::binary(), Bucket::binary()}, Key::binary()) -&gt; {ok, datatype() (see module riakc_datatype)} | {error, term()}</h3>


<div class="description">

<p>Fetches the representation of a convergent datatype from Riak.</p>
</div></div>
<div class="function">
<h3 id="fetch_type/1-1">fetch_type(Rhc::rhc(), BucketAndType::{BucketType::binary(), Bucket::binary()}, Key::binary(), Options::[property() (see module proplists)]) -&gt; {ok, datatype() (see module riakc_datatype)} | {error, term()}</h3>


<div class="description">

<p>Fetches the representation of a convergent datatype from Riak,
  using the given request options.</p>
</div></div>
<div class="function">
<h3 id="update_type/1">update_type(Rhc::rhc(), BucketAndType::{BucketType::binary(), Bucket::binary()}, Key::binary(), Update::update(term()) (see module riakc_datatype)) -&gt; ok | {ok, Key::binary()} | {ok, datatype() (see module riakc_datatype)} | {ok, Key::binary(), datatype() (see module riakc_datatype)} | {error, term()}</h3>


<div class="description">

<p>Updates the convergent datatype in Riak with local
  modifications stored in the container type.</p>
</div></div>
<div class="function">
<h3 id="update_type/1-1">update_type(Rhc::rhc(), BucketAndType::{BucketType::binary(), Bucket::binary()}, Key::binary(), Update::update(term()) (see module riakc_datatype), Options::[property() (see module proplists)]) -&gt; ok | {ok, Key::binary()} | {ok, datatype() (see module riakc_datatype)} | {ok, Key::binary(), datatype() (see module riakc_datatype)} | {error, term()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="modify_type/1">modify_type(Rhc::rhc(), Fun::(datatype() (see module riakc_datatype)) -&gt; datatype() (see module riakc_datatype), BucketAndType::{BucketType::binary(), Bucket::binary()}, Key::binary(), Options::[property() (see module proplists)]) -&gt; ok | {ok, datatype() (see module riakc_datatype)} | {error, term()}</h3>


<div class="description">

<p>Fetches, applies the given function to the value, and then
  updates the datatype in Riak. If an existing value is not found,
  but you want the updates to apply anyway, use the 'create' option.</p>
</div></div>
<div class="function">
<h3 id="get_preflist/1">get_preflist(Rhc::rhc(), Bucket::binary(), Key::binary()) -&gt; {ok, [tuple()]} | {error, term()}</h3>


<div class="description">

<p>Get the active preflist based on a particular bucket/key
       combination.</p>
</div></div>
<div class="function">
<h3 id="options/1">options(Rhc::rhc()) -&gt; proplist()</h3>


<div class="description">

<p>Get the default options for the given client</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
