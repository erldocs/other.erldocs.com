<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_pipe_w_reduce (riak_pipe) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_pipe_w_reduce</h1>
<h2 class="modsummary">A "reduce"-like fitting (in the MapReduce sense).</h2>
<div class="description">
<p>A "reduce"-like fitting (in the MapReduce sense).  Really more
       like a keyed list-fold.  This fitting expects inputs of the
       form <code>{Key, Value}</code>.  For each input, the fitting evaluates a
       function (its argument) on the <code>Value</code> and any previous result
       for that <code>Key</code>, or <code>[]</code> (the empty list) if that <code>Key</code> has
       never been seen by this worker.  When <code>done</code> is finally       
received, the fitting sends each key-value pair it has       
evaluated as an input to the next fittin.</p>
 
       <p>The intent is that a fitting might receive a stream of inputs
       like <code>{a, 1}, {b, 2}, {a 3}, {b, 4}</code> and send on results like
       <code>{a, 4}, {b, 6}</code> by using a simple "sum" function.</p>
 
       <p>This function expects a function as its argument.  The function
       should be arity-4 and expect the arguments:
 </p><taglist><dt>
       <code>Key</code> :: term()
 </dt><item><p>
       Whatever aggregation key is necessary for the algorithm.
 </p></item><dt>
       <code>InAccumulator</code> :: [term()]
 </dt><item><p>
       A list composed of the new input, cons'd on the front of the
       result of the last evaluation for this <code>Key</code> (or the empty list
       if this is the first evaluation for the key).
 </p></item><dt>
       <code>Partition</code> :: riak_pipe_vnode:partition()
 </dt><item><p>
       The partition of the vnode on which this worker is running.
       (Useful for logging, or sending other output.)
 </p></item><dt>
       <code>FittingDetails</code> :: #fitting_details{}
 </dt><item><p>
       The details of this fitting.
       (Useful for logging, or sending other output.)
 </p></item></taglist>
 
       <p>The function should return a tuple of the form <code>{ok,
       NewAccumulator}</code>, where <code>NewAccumulator</code> is a list, onto which
       the next input will be cons'd.  For example, the function to
       sum values for a key, as described above might look like:
  </p><pre class="sh_erlang">  fun(_Key, Inputs, _Partition, _FittingDetails) -&gt;
     {ok, [lists:sum(Inputs)]}
  end</pre>
 
       <p>The preferred consistent-hash function for this fitting is
       <a href="#chashfun/1" class="seealso">chashfun/1</a>.  It hashes the input <code>Key</code>.  Any other
       partition function should work, but beware that a function
       that sends values for the same <code>Key</code> to different partitions
       will result in fittings down the pipe receiving multiple
       results for the <code>Key</code>.</p>
 
       <p>This fitting produces as its archive, the store of evaluation
       results for the keys it has seen.  To merge handoff values,
       the lists stored with each key are concatenated, and the
       reduce function is re-evaluated.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-state">state()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/1">init(Partition::partition() (see module riak_pipe_vnode), FittingDetails::details() (see module riak_pipe_fitting)) -&gt; {ok, state()}</h3>


<div class="description">

<p>Setup creates the store for evaluation results (a dict()) and
       stashes away the <code>Partition</code> and <code>FittingDetails</code> for later.</p>
</div></div>
<div class="function">
<h3 id="process/1">process(X1::{term(), term()}, Last::boolean(), State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Process looks up the previous result for the <code>Key</code>, and then
       evaluates the funtion on that with the new <code>Input</code>.</p>
</div></div>
<div class="function">
<h3 id="done/1">done(State::state()) -&gt; ok</h3>


<div class="description">

<p>Unless the aggregation function sends its own outputs, done/1
       is where all outputs are sent.</p>
</div></div>
<div class="function">
<h3 id="archive/1">archive(State::state()) -&gt; {ok, dict()}</h3>


<div class="description">

<p>The archive is just the store (dict()) of evaluation results.</p>
</div></div>
<div class="function">
<h3 id="handoff/1">handoff(HandoffAccs::dict(), State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>The handoff merge is simple a dict:merge, where entries for
       the same key are concatenated.  The reduce function is also
       re-evaluated for the key, such that <a href="#done/1" class="seealso">done/1</a> still has
       the correct value to send, even if no more inputs arrive.</p>
</div></div>
<div class="function">
<h3 id="validate_arg/1">validate_arg(Fun::term()) -&gt; ok | {error, iolist()}</h3>


<div class="description">

<p>Check that the arg is a valid arity-4 function.  See <url href="/home/pete/wefwefwef/docs/other/1546958157/repo/1.3/.xml/riak_pipe/./riak_pipe_v.xml#validate_function-3">riak_pipe_v:validate_function/3</url>.</p>
</div></div>
<div class="function">
<h3 id="chashfun/1">chashfun(X1::{term(), term()}) -&gt; chash() (see module riak_pipe_vnode)</h3>


<div class="description">

<p>The preferred hashing function.  Chooses a partition based
       on the hash of the <code>Key</code>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
