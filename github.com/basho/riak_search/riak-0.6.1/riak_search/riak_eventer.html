<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_eventer (riak_search) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_eventer</h1>
<h2 class="modsummary">  
Riak events provide information about what is happening behind-the-scenes  
in a Riak cluster.</h2>
<div class="description">
<p>  
Riak events provide information about what is happening behind-the-scenes  
in a Riak cluster.</p>
 
  <p>Events are generated using <a href="#notify/1" class="seealso">notify/1</a> or <a href="#notify/3" class="seealso">notify/3</a>.  
Each event consists of a Module, an EventName, the Node on which  
the event is generated, and additional detail about the event.</p>
 
  <p>A process can register to receive evets using
  <a href="#add_handler/4" class="seealso">add_handler/4</a>. Full ETS MatchSpec style matching is supported, allowing  
the process to receive a subset of events, if desired. Filtering occurs at the  
server level.</p>
 
  <p>An application can register multiple event handlers, and can register multiple  
filters for a single pid.</p>
 
  <p>Riak monitors running handlers, and automatically removes
  handlers of dead processors. Alternatively, an event handler
  can be removed using <a href="#remove_handler/3" class="seealso">remove_handler/3</a>.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-event">event() = {EventModule::atom(), EventName::atom(), Node::atom(), EventData::term()}</h3></div>
    <div class="type"><h3 id="type-eventmessage">eventmessage() = {event, Event::event()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="notify/1">notify(Event::event()) -&gt; ok</h3>


<div class="description">

<p>Generate an event that will be sent to all
  handlers whose MatchSpecs match the event.</p>
</div></div>
<div class="function">
<h3 id="notify/1-1">notify(EventModule::atom(), EventName::atom(), EventDetail::term()) -&gt; ok</h3>


<div class="description">
<p>Equivalent to <a href="#notify/1" class="seealso">notify({EventModule, EventName, node(), EventDetail})</a>.</p>
</div></div>
<div class="function">
<h3 id="add_handler/1">add_handler(Pid::pid(), Desc::string(), MatchHead::tuple(), MatchGuard::tuple()) -&gt; ok</h3>

<ul class="type">
<li><code>EventMessage = eventmessage()</code></li></ul>
<div class="description">

<p>
  Register a process that will receive Riak events
  generated by the cluster. Events are Erlang messages in the form
  <code>{event, {EventModule, EventName, Node, EventData}}</code>.</p>
 
  <p>During operation, Riak generates events for reporting
  and monitoring purposes. By registering an event handler
  an application can choose to receive all or a subset of these events.
  Riak allows for an unlimited number of event handlers (bounded only by memory).
  When an event handler process dies, Riak automatically removes
  that event handler from the list of event handlers. Alternatively,
  an event handler can be programatically removed via the
  <a href="#remove_handler/3" class="seealso">remove_handler/3</a> function.</p>
 
  <p>Event handlers are judged to be unique based on the Pid, MatchHead, and MatchGuard.  
In other words, multiple event handlers can be wired to the same pid so long as  
either their MatchHead or MatchGuard is different. If add_handler/4 is called twice  
with the same exact same Pid, MatchHead, and MatchGuard, then the old handler  
is replaced by the new handler.</p>
 
  <p>In addition, while registering an event handler, a  
developer can choose to filter the events that the  
event handler will receive. This filtering happens on  
the node generating the event. Riak generates a large number  
of events, so tight filtering is a good idea in order to minimize  
network traffic.</p>
 
  <p>An event filter is specified using the MatchSpec syntax
  established by the ETS module. See
  <url href="http://erlang.org/doc/apps/erts/match_spec.html">ETS MatchSpec</url>  
for more information.</p>
 
  <p>Register for all events generated by the node 'riak@127.0.0.1':
  </p><pre class="sh_erlang">
  RiakClient:add_event_handler(self(), "Description", {'_', '_', 'riak@127.0.0.1', '_'}, [])).
  </pre>
 
  <p>Register for all events generated by the riak_vnode module:
  </p><pre class="sh_erlang">
  RiakClient:add_event_handler(self(), "Description", {riak_vnode, '_', '_', '_'}, []))
  </pre>
 
  <p>Register for all 'put', 'get', and 'delete' events generated by the riak_vnode module:
  </p><pre class="sh_erlang">
  MatchHead = {'$1', '$2', '_', '_'},
  MatchGuard = [
    {'andalso', {'==', '$1', riak_vnode}, {'orelse', {'==', '$2', get}, {'==', '$2', put}, {'==', '$2', delete}}}
  ],
  RiakClient:add_event_handler(self(), "Description", MatchHead, MatchGuard).
  </pre>
 
  <p>Events are sent once per matching filter. If a single process registers under more than  
one MatchSpecs, and an event matches both MatchSpecs, then the process will  
receive the event multiple times.</p>
 
  <p>The Description parameter is used to supply a human readable  
string used by monitoring software to displaying connected event handlers.</p>
 
  <p>Because of the way Riak shares information between clusters, it may be
  a few seconds before events start being sent to the handler from all nodes.</p>
</div></div>
<div class="function">
<h3 id="remove_handler/1">remove_handler(Pid::pid(), MatchHead::tuple(), MatchGuard::list()) -&gt; ok</h3>


<div class="description">

<p>  
Remove the previously registered event handler. The arguments  
supplied to remove_handler/3 must be the same arguments supplied to  
add_handler/4. remove_handler/3 returns 'ok' regardless of whether  
any event handlers are removed.</p>
 
  <p>Because of the way Riak shares information between clusters, it may be
  a few seconds before events stop being sent to the handler.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
