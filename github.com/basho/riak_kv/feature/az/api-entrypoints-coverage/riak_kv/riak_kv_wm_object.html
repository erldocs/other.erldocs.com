<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_wm_object (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_wm_object</h1>
<h2 class="modsummary">Resource for serving Riak objects over HTTP.</h2>
<div class="description">
<p>Resource for serving Riak objects over HTTP.</p>
 
  <p>URLs that begin with <code>/types</code> are necessary for the new bucket
  types implementation in Riak 2.0, those that begin with <code>/buckets</code>
  are for the default bucket type, and <code>/riak</code> is an old URL style,  
also only works for the default bucket type.</p>
 
  <p>It is possible to reconfigure the <code>/riak</code> prefix but that seems to  
be rarely if ever used.</p>
 
  <pre class="sh_erlang">  POST /types/Type/buckets/Bucket/keys
  POST /buckets/Bucket/keys
  POST /riak/Bucket</pre>
 
    <p>Allow the server to choose a key for the data.</p>
 
  <pre class="sh_erlang">  GET /types/Type/buckets/Bucket/keys/Key
  GET /buckets/Bucket/keys/Key
  GET /riak/Bucket/Key</pre>
 
    <p>Get the data stored in the named Bucket under the named Key.</p>
 
    <p>Content-type of the response will be taken from the    
Content-type was used in the request that stored the data.</p>
 
    <p>Additional headers will include:
  </p><list>
      <item><p><code>X-Riak-Vclock</code>: The vclock of the object</p></item>
      <item><p><code>Link</code>: The links the object has</p></item>
      <item><p><code>Etag</code>: The Riak "vtag" metadata of the object</p></item>
      <item><p><code>Last-Modified</code>: The last-modified time of the object</p></item>
      <item><p><code>Encoding</code>: The value of the incoming Encoding header from
        the request that stored the data.</p></item>
      <item><p><code>X-Riak-Meta-</code>: Any headers prefixed by X-Riak-Meta- supplied
        on PUT are returned verbatim</p></item>
  </list>
 
    <p>Specifying the query param <code>r=R</code>, where <code>R</code> is an integer will
    cause Riak to use <code>R</code> as the r-value for the read request. A    
default r-value of 2 will be used if none is specified.</p>
 
    <p>If the object is found to have siblings (only possible if the
    bucket property <code>allow_mult</code> is true), then
    Content-type will be <code>text/plain</code>; <code>Link</code>, <code>Etag</code>, and <code>Last-Modified</code>
    headers will be omitted; and the body of the response will
    be a list of the vtags of each sibling.  To request a specific
    sibling, include the query param <code>vtag=V</code>, where <code>V</code> is the vtag    
of the sibling you want.</p>
 
  <pre class="sh_erlang">  PUT /types/Type/buckets/Bucket/keys/Key
  PUT /buckets/Bucket/keys/Key
  PUT /riak/Bucket/Key</pre>
 
    <p>Store new data in the named Bucket under the named Key.</p>
 
    <p>A Content-type header *must* be included in the request.  The    
value of this header will be used in the response to subsequent    
GET requests.</p>
 
    <p>The body of the request will be stored literally as the value    
of the riak_object, and will be served literally as the body of    
the response to subsequent GET requests.</p>
 
    <p>Include an X-Riak-Vclock header to modify data without creating    
siblings.</p>
 
    <p>Include a Link header to set the links of the object.</p>
 
    <p>Include an Encoding header if you would like an Encoding header    
to be included in the response to subsequent GET requests.</p>
 
    <p>Include custom metadata using headers prefixed with X-Riak-Meta-.    
They will be returned verbatim on subsequent GET requests.</p>
 
    <p>Specifying the query param <code>w=W</code>, where W is an integer will    
cause Riak to use W as the w-value for the write request. A    
default w-value of 2 will be used if none is specified.</p>
 
    <p>Specifying the query param <code>dw=DW</code>, where DW is an integer will    
cause Riak to use DW as the dw-value for the write request. A    
default dw-value of 2 will be used if none is specified.</p>
 
    <p>Specifying the query param <code>r=R</code>, where R is an integer will    
cause Riak to use R as the r-value for the read request (used    
to determine whether or not the resource exists). A default    
r-value of 2 will be used if none is specified.</p>
 
  <pre class="sh_erlang">  POST /types/Type/buckets/Bucket/keys/Key
  POST /buckets/Bucket/keys/Key
  POST /riak/Bucket/Key</pre>
 
    <p>Equivalent to <code>PUT /riak/Bucket/Key</code> (useful for clients that    
do not support the PUT method).</p>
 
  <pre class="sh_erlang">  DELETE /types/Type/buckets/Bucket/keys/Key (with bucket-type)
  DELETE /buckets/Bucket/keys/Key (NEW)
  DELETE /riak/Bucket/Key (OLD)</pre>
 
    <p>Delete the data stored in the named Bucket under the named Key.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-context">context() = #ctx{}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ping/2">ping(ReqData, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(Props::proplist() (see module proplists)) -&gt; {ok, context()}</h3>


<div class="description">

<p>Initialize this resource.  This function extracts the
       'prefix' and 'riak' properties from the dispatch args.</p>
</div></div>
<div class="function">
<h3 id="service_available/2">service_available(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether or not a connection to Riak
       can be established.  This function also takes this
       opportunity to extract the 'bucket' and 'key' path
       bindings from the dispatch, as well as any vtag
       query parameter.</p>
</div></div>
<div class="function">
<h3 id="is_authorized/2">is_authorized(ReqData, Ctx) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="forbidden/2">forbidden(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; term()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="allowed_methods/2">allowed_methods(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[atom()], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the list of methods this resource supports.</p>
</div></div>
<div class="function">
<h3 id="allow_missing_post/2">allow_missing_post(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Makes POST and PUT equivalent for creating new
       bucket entries.</p>
</div></div>
<div class="function">
<h3 id="malformed_request/2">malformed_request(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether query parameters, request headers,
       and request body are badly-formed.
       Body format is checked to be valid JSON, including
       a "props" object for a bucket-PUT.  Body format
       is not tested for a key-level request (since the
       body may be any content the client desires).
       Query parameters r, w, dw, and rw are checked to
       be valid integers.  Their values are stored in
       the context() at this time.
       Link headers are checked for the form:
         &lt;/Prefix/Bucket/Key&gt;; riaktag="Tag",...
       The parsed links are stored in the context()
       at this time.</p>
</div></div>
<div class="function">
<h3 id="content_types_provided/2">content_types_provided(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[{ContentType::string(), Producer::atom()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the content types available for representing this resource.
       The content-type for a key-level request is the content-type that
       was used in the PUT request that stored the document in Riak.</p>
</div></div>
<div class="function">
<h3 id="charsets_provided/2">charsets_provided(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {no_charset | [{Charset::string(), Producer::function()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the charsets available for representing this resource.
       The charset for a key-level request is the charset that was used
       in the PUT request that stored the document in Riak (none if
       no charset was specified at PUT-time).</p>
</div></div>
<div class="function">
<h3 id="encodings_provided/2">encodings_provided(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {[{Encoding::string(), Producer::function()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the encodings available for representing this resource.
       The encoding for a key-level request is the encoding that was
       used in the PUT request that stored the document in Riak, or
       "identity" and "gzip" if no encoding was specified at PUT-time.</p>
</div></div>
<div class="function">
<h3 id="content_types_accepted/2">content_types_accepted(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[{ContentType::string(), Acceptor::atom()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the list of content types this resource will accept.
       Whatever content type is specified by the Content-Type header
       of a key-level PUT request will be accepted by this resource.
       (A key-level put *must* include a Content-Type header.)</p>
</div></div>
<div class="function">
<h3 id="resource_exists/2">resource_exists(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether or not the requested item exists.
       Documents exists if a read request to Riak returns {ok, riak_object()},
       and either no vtag query parameter was specified, or the value of the
       vtag param matches the vtag of some value of the Riak object.</p>
</div></div>
<div class="function">
<h3 id="post_is_create/2">post_is_create(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>POST is considered a document-creation operation for bucket-level
       requests (this makes webmachine call create_path/2, where the key
       for the created document will be chosen).</p>
</div></div>
<div class="function">
<h3 id="create_path/2">create_path(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {string(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Choose the Key for the document created during a bucket-level POST.
       This function also sets the Location header to generate a
       201 Created response.</p>
</div></div>
<div class="function">
<h3 id="process_post/2">process_post(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Pass-through for key-level requests to allow POST to function
       as PUT for clients that do not support PUT.</p>
</div></div>
<div class="function">
<h3 id="accept_doc_body/2">accept_doc_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Store the data the client is PUTing in the document.
       This function translates the headers and body of the HTTP request
       into their final riak_object() form, and executes the Riak put.</p>
</div></div>
<div class="function">
<h3 id="multiple_choices/2">multiple_choices(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether a document has siblings.  If the user has
       specified a specific vtag, the document is considered not to
       have sibling versions.  This is a safe assumption, because
       resource_exists will have filtered out requests earlier for
       vtags that are invalid for this version of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_doc_body/2">produce_doc_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {binary(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Extract the value of the document, and place it in the
       response body of the request.  This function also adds the
       Link, X-Riak-Meta- headers, and X-Riak-Index- headers to the
       response.  One link will point to the bucket, with the
       property "rel=container".  The rest of the links will be
       constructed from the links of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_sibling_message_body/2">produce_sibling_message_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {iolist(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Produce the text message informing the user that there are multiple
       values for this document, and giving that user the vtags of those
       values so they can get to them with the vtag query param.</p>
</div></div>
<div class="function">
<h3 id="produce_multipart_body/2">produce_multipart_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {iolist(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Produce a multipart body representation of an object with multiple
       values (siblings), each sibling being one part of the larger
       document.</p>
</div></div>
<div class="function">
<h3 id="delete_resource/2">delete_resource(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Delete the document specified.</p>
</div></div>
<div class="function">
<h3 id="generate_etag/2">generate_etag(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {undefined | string(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the etag for this resource.
       Documents will have an etag equal to their vtag. For documents with
       siblings when no vtag is specified, this will be an etag derived from
       the vector clock.</p>
</div></div>
<div class="function">
<h3 id="last_modified/2">last_modified(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {undefined | datetime() (see module calendar), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the last-modified time for this resource.
       Documents will have the last-modified time specified by the riak_object.
       For documents with siblings, this is the last-modified time of the latest
       sibling.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
