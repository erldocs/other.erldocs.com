<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_crdt (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_crdt</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-crdt">crdt() = #crdt{}</h3></div>
    <div class="type"><h3 id="type-crdts">crdts() = [{DT_MOD :: module(), <a href="#type-crdt" class="seealso">crdt()</a>}]</h3></div>
    <div class="type"><h3 id="type-precondition_error">precondition_error() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{error, {precondition, {not_present, term()}}}</h3></div>
    <div class="type"><h3 id="type-ro_content">ro_content() = {Meta :: dict(), Value :: binary()}</h3></div>
    <div class="type"><h3 id="type-ro_contents">ro_contents() = [<a href="#type-ro_content" class="seealso">ro_content()</a>]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="update/1">update(RObj::riak_object() (see module riak_object), Actor::actor() (see module riak_dt), Operation::operation() (see module riak_dt)) -&gt; riak_object() (see module riak_object) | precondition_error()</h3>


<div class="description">

<p>applies the given <code>Operation</code> to the merged value.  first
  performs a merge (@see merge/1), and then applies the update.
  NOTE: operation needs to be a ?CRDT_OP in case of siblings of different
  types</p>
</div></div>
<div class="function">
<h3 id="merge/1">merge(RObj::riak_object() (see module riak_object)) -&gt; riak_object() (see module riak_object)</h3>


<div class="description">

<p>Merge all sibling values that are CRDTs into a single value
  for that CRDT type.  NOTE: handles sibling types. For example if
  there are 5 siblings, 2 or which are riak_dt_pncounter, and 2 are
  riak_dt_vvorset, and 1 user supplied opaque value, then the results
  is a converge counter, a converged set, and the opaque sibling, a
  total of 3 sibings. Hopefully with bucket types, sibling types will
  NEVER occur.</p>
</div></div>
<div class="function">
<h3 id="value/1">value(RObj::riak_object() (see module riak_object), Type::module()) -&gt; {{binary(), value() (see module riak_dt)}, [{atom(), atom(), number()}]}</h3>


<div class="description">

<p>for the given riak_object <code>RObj</code> and the provided <code>Type</code>,
  which must be a support riak_dt crdt module, returns an update
  context, and user value. Performs a merge, then gets the CRDT end
  user value.  @see merge/1</p>
</div></div>
<div class="function">
<h3 id="value/1-1">value(RObj::riak_object() (see module riak_object)) -&gt; {atom(), term()} | undefined</h3>


<div class="description">

<p>convenience function for (e.g.) MapReduce. Attempt to get a
  CRDT value for a given object. Checks the bucket props for the
  object, if it has a datatype entry, uses that to get value. Returns
  either a tuple of <code>{Type, Value}</code> or <code>undefined</code> if not a 2.0 CRDT.</p>
</div></div>
<div class="function">
<h3 id="counter_value/1">counter_value(RObj::riak_object() (see module riak_object)) -&gt; integer()</h3>


<div class="description">

<p>convenience for (e.g.) MapReduce functions. Pass an object,
  get a 2.0+ counter type value, or zero if no counter is present.</p>
</div></div>
<div class="function">
<h3 id="set_value/1">set_value(RObj::riak_object() (see module riak_object)) -&gt; list()</h3>


<div class="description">

<p>convenience for (e.g.) MapReduce functions. Pass an object,
  get a 2.0+ Set type value, or <code>[]</code> if no Set is present.</p>
</div></div>
<div class="function">
<h3 id="map_value/1">map_value(RObj::riak_object() (see module riak_object)) -&gt; proplist() (see module proplist)</h3>


<div class="description">

<p>convenience for (e.g.) MapReduce functions. Pass an object,
  get a 2.0+ Map type value, or <code>[]</code> if no Map is present.</p>
</div></div>
<div class="function">
<h3 id="log_merge_errors/1">log_merge_errors(Bucket::bucket() (see module riak_object), Key::key() (see module riak_object), CRDTs::crdts(), Errors::list()) -&gt; ok</h3>


<div class="description">

<p>log any accumulated merge errors</p>
</div></div>
<div class="function">
<h3 id="merge_value/1">merge_value(NonCRDT::ro_content(), X2::{crdts(), ro_contents(), Errors::list()}) -&gt; {crdts(), ro_contents(), Errors::list()}</h3>


<div class="description">

<p>if the content is a CRDT, de-binary it, merge it and store the
  most merged value in the accumulator dictionary.</p>
</div></div>
<div class="function">
<h3 id="meta/2">meta(Meta, Crdt) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="new/3">new(B, K, Mod) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="to_binary/1">to_binary(CRDT::crdt()) -&gt; binary()</h3>


<div class="description">

<p>turn a <code>crdt()</code> record into a binary for storage on disk /
  passing on the network</p>
</div></div>
<div class="function">
<h3 id="to_binary/1-1">to_binary(CRDT::crdt(), Version::pos_integer()) -&gt; binary()</h3>


<div class="description">

<p>turn a <code>crdt()</code> record into a <code>Version</code> binary for storage on
  disk / passing on the network</p>
</div></div>
<div class="function">
<h3 id="from_binary/1">from_binary(Bin::binary()) -&gt; {ok, crdt()} | {error, term()}</h3>


<div class="description">

<p>deserialize a crdt from it's binary format.  The binary must
  start with the riak_kv_crdt tag and a version If the binary can be
  deserailised into a <code>crdt()</code> returns <code>{ok, crdt()}</code>, otherwise
  <code>{error, term()}</code></p>
</div></div>
<div class="function">
<h3 id="supported/1">supported(Mod) -&gt; term()
</h3>


<div class="description">

<p>Check cluster capability for crdt support</p>
</div></div>
<div class="function">
<h3 id="to_mod/1">to_mod(Crdt) -&gt; term()
</h3>


<div class="description">

<p>turn a string token / atom into a
  CRDT type</p>
</div></div>
<div class="function">
<h3 id="from_mod/1">from_mod(Mod) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="from_mod/2">from_mod(Mod, ModMap) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mod_map/1">mod_map(X1::atom()) -&gt; [{atom(), atom()}]</h3>


<div class="description">

<p>mapping of atom/shortname types (map, set, counter etc) to
  actual modules that implement them. Notice the mod map for maps is
  different since embedded types are different.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
