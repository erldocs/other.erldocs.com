<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_mrc_pipe (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_mrc_pipe</h1>
<h2 class="modsummary">Riak KV MapReduce / Riak Pipe Compatibility.</h2>
<div class="description">
<p>Riak KV MapReduce / Riak Pipe Compatibility</p>
 
  <p><em><marker id="About_using_`{modfun,_Mod,_Fun,_Arg}'_generator_to_a_MapReduce_job">About using `{modfun, Mod, Fun, Arg}' generator to a MapReduce job</marker></em></p>
 
  <p>The six methods of specifying input for a MapReduce job are:</p>
 
  <list>
  <item> Specify a bucket name (to emit all bucket/key pairs for that
       bucket) </item>
  <item> Specify a bucket name and keyfilter spec, <code>{Bucket,
       KeyFilter}</code> </item>
  <item> Specify an explicit list of bucket/key pairs </item>
  <item> Specify <code>{index, Bucket, Index, Key}</code> or <code>{index, Bucket,
       Index, StartKey, EndKey}</code> to query secondary indexes and send
       matching keys into the MR as inputs. </item>
  <item> Specify <code>{search, Bucket, Query}</code> or <code>{search, Bucket, Query,
       Filter}</code> to query Riak Search and send matching keys into the
       MR as inputs. </item>
  <item> Specify <code>{modfun, Mod, Fun, Arg}</code> to generate the raw input
       data for the rest of the workflow </item>
  </list>
 
  <p>For the final method, "raw input data" means that the output of the  
function will be used as-is by the next item MapReduce workflow.  
If that next item is a map phase, then that item's input is  
expected to be a bucket/key pair.  If the next item is a reduce  
phase, then the input can be an arbitrary term.</p>
 
  <p>The type specification for a <code>{modfun, Mod, Fun, Arg}</code> generator
  function is:
  </p><pre class="sh_erlang">  -spec generator_func(Pipe::riak_pipe:pipe(),
                       Arg::term(),
                       Timeout::integer() | 'infinity').</pre>
 
  <p>This generator function is responsible for using <a href="riak_pipe.html#queue_work/2" class="seealso">riak_pipe:queue_work/2</a> to send any data to the pipe, and it is
  responsible for calling <a href="riak_pipe.html#eoi/2" class="seealso">riak_pipe:eoi/2</a> to signal the end  
of input.</p>
 
  <p><em><marker id="About_reduce_phase_compatibility">About reduce phase compatibility</marker></em></p>
 
  <p>An Erlang reduce phase is defined by the tuple:
  <code>{reduce, Fun::function(2), Arg::term(), Keep::boolean()}</code>.</p>
 
  <list>
  <item><p> <code>Fun</code> takes the form of <code>Fun(InputList, Arg)</code> where <code>Arg</code> is        
the argument specified in the definition 4-tuple above.</p>
 
        <p>NOTE: Unlike a fold function (e.g., <code>lists:foldl/3</code>), the
        <code>Arg</code> argument is constant for each iteration of the reduce
        function. </p></item>
  <item><p> The <code>Arg</code> may be any term, as the caller sees fit.  However, if
       the caller wishes to have more control over the reduce phase,
       then <code>Arg</code> must be a property list.  The control knobs that may
       be specified are:
       </p><list>
       <item><p> <code>reduce_phase_only_1</code> will buffer all inputs to the reduce            
phase fitting and only call the reduce function once.</p>
 
            <p>NOTE: Use with caution to avoid excessive memory use. </p></item>
       <item><p> <code>{reduce_phase_batch_size, Max::integer()}</code> will buffer all
            inputs to the reduce phase fitting and call the reduce function
            after <code>Max</code> items have been buffered. </p></item>
       </list><p>
       If neither <code>reduce_phase_only_1</code> nor
       <code>{reduce_phase_batch_size, Max}</code> are present, then the
       batching size will default to the value of the application
       environment variable <code>mapred_reduce_phase_batch_size</code> in the
       <code>riak_kv</code> application.</p>
 
       <p>NOTE: This mixing of user argument data and MapReduce
       implementation metadata is suboptimal, but to separate the two
       types of data would require a change that is incompatible with
       the current Erlang MapReduce input specification, e.g., a
       5-tuple such as <code>{reduce, Fun, Arg, Keep, MetaData}</code> or else a
       custom wrapper around the 3rd arg, e.g. <code>{reduce, Fun,
       {magic_tag, Arg, Metadata}, Keep}</code>.
  </p></item>
  <item><p> If <code>Keep</code> is <code>true</code>, then the output of this phase will be returned
       to the caller (i.e. the output will be "kept"). </p></item>
  </list></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-bucket_input">bucket_input() = binary()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {Bucket :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyFilter :: [<a href="#type-keyfilter" class="seealso">keyfilter()</a>]}</h3></div>
    <div class="type"><h3 id="type-grouped_results">grouped_results() = [Results :: list()] | list()</h3></div>
    <div class="type"><h3 id="type-index_input">index_input() = {index,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key :: term()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {index,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End :: term()}</h3></div>
    <div class="type"><h3 id="type-input">input() = [<a href="#type-key_input" class="seealso">key_input()</a>]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-bucket_input" class="seealso">bucket_input()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-index_input" class="seealso">index_input()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-search_input" class="seealso">search_input()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-modfun_input" class="seealso">modfun_input()</a></h3></div>
    <div class="type"><h3 id="type-key_input">key_input() = <a href="riak_kv_pipe_get.html#type-input" class="seealso">riak_kv_pipe_get:input()</a></h3></div>
    <div class="type"><h3 id="type-keyfilter">keyfilter() = [string()]</h3></div>
    <div class="type"><h3 id="type-link_match">link_match() = binary() | '_'</h3></div>
    <div class="type"><h3 id="type-map_query_fun">map_query_fun() = {qfun,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun((Input :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeyData :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhaseArg :: term()) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[term()])}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-query_fun" class="seealso">query_fun()</a></h3></div>
    <div class="type"><h3 id="type-modfun_input">modfun_input() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{modfun, Module :: atom(), Function :: atom(), Arg :: term()}</h3></div>
    <div class="type"><h3 id="type-query_fun">query_fun() = {modfun, Module :: atom(), Function :: atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {strfun, {Bucket :: binary(), Key :: binary()}}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {strfun, Source :: string()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {jsanon, {Bucket :: binary(), Key :: binary()}}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {jsfun, Name :: binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {jsanon, Source :: binary()}</h3></div>
    <div class="type"><h3 id="type-query_part">query_part() = {map,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-map_query_fun" class="seealso">map_query_fun()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arg :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep :: boolean()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {reduce,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-reduce_query_fun" class="seealso">reduce_query_fun()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arg :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep :: boolean()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {link,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BucketMatch :: <a href="#type-link_match" class="seealso">link_match()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TagMatch :: <a href="#type-link_match" class="seealso">link_match()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep :: boolean()}</h3></div>
    <div class="type"><h3 id="type-reduce_query_fun">reduce_query_fun() = {qfun,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun((Input :: [term()],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhaseArg :: term()) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[term()])}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-query_fun" class="seealso">query_fun()</a></h3></div>
    <div class="type"><h3 id="type-search_input">search_input() = {search,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query :: binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {search,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bucket :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query :: binary(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filter :: [<a href="#type-keyfilter" class="seealso">keyfilter()</a>]}</h3></div>
    <div class="type"><h3 id="type-ungrouped_results">ungrouped_results() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{From :: integer() >= 0, Result :: term()}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="mapred/2">mapred(Inputs, Query) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#mapred/3" class="seealso">mapred(Inputs, Query, 60000)</a>.</p>
</div></div>
<div class="function">
<h3 id="mapred/1">mapred(Inputs::input(), Query::[query_part()], Timeout::timeout()) -&gt; {ok, grouped_results()} | {error, Reason::term()} | {error, Reason::term(), {ok, grouped_results()} | {error, Reason::term()}}</h3>


<div class="description">

<p>Perform a MapReduce <code>Query</code> over <code>Inputs</code> and return the
  result.  <code>Timeout</code> here is the maximum time to wait between the
  delivery of each output, not an overall timeout.</p>
</div></div>
<div class="function">
<h3 id="mapred_stream/1">mapred_stream(Query::[query_part()]) -&gt; {{ok, pipe() (see module riak_pipe)}, NumKeeps::integer()}</h3>


<div class="description">

<p>Setup the MapReduce plumbing, preparted to receive inputs.
  The caller should then use <a href="#send_inputs/2" class="seealso">send_inputs/2</a> or <a href="#send_inputs/3" class="seealso">send_inputs/3</a> to give the query inputs to process.</p>
 
  <p>The second element of the return tuple is the number of phases that
  requested to keep their inputs, and will need to be passed to
  <a href="#collect_outputs/3" class="seealso">collect_outputs/3</a> or <a href="#group_outputs/2" class="seealso">group_outputs/2</a> to get labels
  compatible with HTTP and PB interface results.</p>
</div></div>
<div class="function">
<h3 id="mapred_plan/1">mapred_plan(Query::[query_part()]) -&gt; [fitting_spec() (see module riak_pipe)]</h3>


<div class="description">

<p>Produce the pipe spec that will implement the given MapReduce
  query.  <em>Intended for debugging only.</em></p>
</div></div>
<div class="function">
<h3 id="mapred_plan/1-1">mapred_plan(BucketOrList::[key_input()] | binary(), Query::[query_part()]) -&gt; [{bkeys, [key_input()]} | fitting_spec() (see module riak_pipe)]</h3>


<div class="description">

<p>Produce the pipe spec that will implement the given MapReduce
  query, and prepend a tuple of the form <code>{bkeys, [key_input()]}</code>.
  If <code>BucketOrList</code> is a binary bucket name, this function will list
  the keys in the bucket to return in this tuple.  <em>Intended
  for debugging only.</em></p>
</div></div>
<div class="function">
<h3 id="send_inputs_async/2">send_inputs_async(Pipe, Inputs) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#send_inputs_async/3" class="seealso">send_inputs_async(Pipe, Inputs, 60000)</a>.</p>
</div></div>
<div class="function">
<h3 id="send_inputs_async/1">send_inputs_async(Pipe::pipe() (see module riak_pipe), Inputs::input(), Timeout::timeout()) -&gt; {Sender::pid(), MonitorRef::reference()}</h3>


<div class="description">

<p>Spawn a process to send inputs to the MapReduce pipe.  If  
sending completes without error, the process will exit normally.  
If errors occur, the process exits with the error as its reason.</p>
 
  <p>The process links itself to the pipeline (via the builder), so if  
the pipeline shutsdown before sending inputs finishes, the process  
will be torn down automatically.  This also means that an error  
sending inputs will automatically tear down the pipe (because the  
process will exit abnormally).</p>
 
  <p>It's a good idea to prefer sending inputs and receiving outputs in
  different processes, especially if you're both sending a large
  number of inputs (a large bucket list, for instance) and expecting
  to receive a large number of outputs.  The mailbox for a process
  doing both is likely to be a point of contention, otherwise.</p>
</div></div>
<div class="function">
<h3 id="send_inputs/2">send_inputs(Pipe, Inputs) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#send_inputs/3" class="seealso">send_inputs(Pipe, Inputs, 60000)</a>.</p>
</div></div>
<div class="function">
<h3 id="send_inputs/1">send_inputs(Pipe::pipe() (see module riak_pipe), BucketKeyList::input(), Timeout::timeout()) -&gt; ok | term()</h3>


<div class="description">

<p>Send inputs into the MapReduce pipe.  This function handles
  setting up the bucket-listing, index-querying, searching, or
  modfun-evaluating needed to produce keys, if the input is not just
  a list of keys.</p>
</div></div>
<div class="function">
<h3 id="collect_outputs/2">collect_outputs(Pipe, NumKeeps) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#collect_outputs/3" class="seealso">collect_outputs(Pipe, NumKeeps, 60000)</a>.</p>
</div></div>
<div class="function">
<h3 id="collect_outputs/1">collect_outputs(Pipe::pipe() (see module riak_pipe), NumKeeps::non_neg_integer(), Timeout::timeout()) -&gt; {ok, grouped_results()} | {error, {Reason::term(), Outputs::ungrouped_results()}}</h3>


<div class="description">

<p>Receive the results produced by the MapReduce pipe, grouped by
  the phase they came from.  See <a href="#group_outputs/2" class="seealso">group_outputs/2</a> for details
  on that grouping.</p>
</div></div>
<div class="function">
<h3 id="group_outputs/1">group_outputs(Outputs::ungrouped_results(), NumKeeps::non_neg_integer()) -&gt; grouped_results()</h3>


<div class="description">

<p>Group the outputs of the MapReduce pipe by the phase that
  produced them.  If <code>NumKeeps</code> is 2 or more, the return value is a
  list of result lists, <code>[Results :: list()]</code>, in the same order as
  the phases that produced them.  If <code>NumKeeps</code> is less than 2, the
  return value is just a list (possibly empty) of results, <code>Results
  :: list()</code>.</p>
</div></div>
<div class="function">
<h3 id="compile_string/1">compile_string(Binary::string()) -&gt; {ok, term()} | {ErrorType::term, Reason::term}</h3>


<div class="description">

<p>Produce an Erlang term from a string containing Erlang code.
  This is used by <url href="/home/pete/wefwefwef/docs/other/c94408376b755f24b026086c91fef124/repo/adt-key-compare/.xml/riak_kv/./riak_kv_mrc_map.xml">riak_kv_mrc_map</url> and <url href="/home/pete/wefwefwef/docs/other/c94408376b755f24b026086c91fef124/repo/adt-key-compare/.xml/riak_kv/./riak_kv_w_reduce.xml">riak_kv_w_reduce</url> to compile functions specified as <code>{strfun,
  Source}</code>.</p>
</div></div>
<div class="function">
<h3 id="example/0">example() -&gt; {ok, [binary()]} | {error, term()} | {error, term(), term()}</h3>


<div class="description">

<p>Use a MapReduce query to get the value of the <code>foo/bar</code>
  object.  See <a href="#example_setup/1" class="seealso">example_setup/1</a> for details of what should be
  in <code>foo/bar</code>.</p>
</div></div>
<div class="function">
<h3 id="example_bucket/0">example_bucket() -&gt; {ok, [binary()]} | {error, term()} | {error, term(), term()}</h3>


<div class="description">

<p>Use a MapReduce query to get the values of the objects in the
  <code>foo</code> bucket.  See <a href="#example_setup/1" class="seealso">example_setup/1</a> for details of what
  should be in <code>foo/*</code>.</p>
</div></div>
<div class="function">
<h3 id="example_reduce/0">example_reduce() -&gt; {ok, [[integer()]]} | {error, term()} | {error, term(), term()}</h3>


<div class="description">

<p>Use a MapReduce query to sum the values of the objects in the
  <code>foonum</code> bucket.  See <a href="#example_setup/1" class="seealso">example_setup/1</a> for details of what
  should be in <code>foonum/*</code>.</p>
 
  <p>This function asks to keep the results of both the map phase and
  the reduce phase, so the output should be a list containing two
  lists.  The first sublist should contain all of the values of the
  objects in the bucket.  The second sublist should contain only one
  element, equal to the sum of the elements in the first sublist.
  For example, <code>[[1,2,3,4,5],[15]]</code>.</p>
</div></div>
<div class="function">
<h3 id="example_setup/0">example_setup() -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#example_setup/1" class="seealso">example_setup(5)</a>.</p>
</div></div>
<div class="function">
<h3 id="example_setup/1">example_setup(Num::pos_integer()) -&gt; ok</h3>


<div class="description">

<p>Store some example data for the other example functions.</p>
 
  <p>Objects stored:
  </p><taglist>
    <dt><code>foo/bar</code></dt>
    <item><p>Stores the string "what did you expect?"</p></item>
 
    <dt><code>foo/bar1</code> .. <code>foo/barNum</code></dt>
    <item><p>Each stores the string "bar val INDEX"</p></item>
 
    <dt><code>foonum/bar1</code> .. <code>foo/barNum</code></dt>
    <item><p>Each stores its index as an integer</p></item>
 </taglist>
</div></div>
<div class="function">
<h3 id="compat_fun/1">compat_fun(Fun) -&gt; term()
</h3>


<div class="description">

<p>For Riak 1.0 compatibility, provide a translation from old  
anonymous functions to new ones.  This function should have a  
limited-use lifetime: it will only be evaluated while a cluster is  
in the middle of a rolling-upgrade from 1.0.x to 1.1.</p>
 
  <p>Yes, the return value is a new anonymous function.  This shouldn't
  be a problem with a future upgrade, though, as no one should be
  running a cluster that includes three Riak versions.  Therefore, the
  node that spread this old Fun around the cluster should have been
  stopped, along with the pipe defined by the old fun before this new
  fun would itself be considered old.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
