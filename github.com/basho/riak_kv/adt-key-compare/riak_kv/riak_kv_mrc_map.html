<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_mrc_map (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_mrc_map</h1>
<h2 class="modsummary">A pipe fitting that applies a function to a Riak object, and  
sends its results downstream.</h2>
<div class="description">
<p>A pipe fitting that applies a function to a Riak object, and  
sends its results downstream.</p>
 
  <p>This module is intended as the second half of the emulation layer
  for running Riak KV MapReduce on top of Riak Pipe.  An upstream
  fitting should read the object out of Riak KV, and then send it to
  this fitting as a 3-tuple of the form <code>{ok, RiakObject, KeyData}</code>.
  If there was an error reading the object, that can be sent to this
  fitting as a 3-tuple of the form <code>{{error, Reason}, {Bucket, Key},
  KeyData}</code>.  (The <url href="/home/pete/wefwefwef/docs/other/1599039297/repo/adt-key-compare/.xml/riak_kv/./riak_kv_pipe_get.xml">riak_kv_pipe_get</url> fitting conforms to this  
interface.)</p>
 
  <p>This module expects a 2-tuple, <code>{PhaseSpec, PhaseArg}</code> as argument.
  Both elements come directly from the phase definition in the
  MapReduce query: <code>{map, PhaseSpec, PhaseArg, Keep}</code>.</p>
 
  <p>When an <code>ok</code> input arrives, the function defined by <code>PhaseSpec</code> is
  evalutated as, in pseudocode: <code>PhaseSpec(RiakObject, KeyData,
  PhaseArg)</code>.  The result of the function is expected to be a list.  
Each element of the result list is sent downstream as an output.</p>
 
  <p>When an <code>error</code> input arrives, the behavior of this fitting depends
  on whether <code>PhaseSpec</code> specifies an Erlang function or a Javascript
  function.  In the case of an Erlang function, <code>PhaseSpec</code> will be
  evaluated as <code>PhaseSpec({error, Reason}, KeyData, PhaseArg)</code>.  In
  the case of a Javascript function, if the <code>Reason</code> is <code>not_found</code>,
  then the output <code>{not_found, {Bucket, Key}, KeyData}</code> is sent
  downstream as output.  Other error reasons cause Javascript
  evaluation to fail.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-state">state()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/1">init(Partition::partition() (see module riak_pipe_vnode), Fitting_details::details() (see module riak_pipe_fitting)) -&gt; {ok, state()} | {error, Reason::term()}</h3>


<div class="description">

<p>Init verifies the phase spec, and then stashes it away with
  <code>Partition</code> and the rest of <code>FittingDetails</code> for use during
  processing.</p>
</div></div>
<div class="function">
<h3 id="process/1">process(Input::term(), Last::boolean(), State::state()) -&gt; {ok | forward_preflist, state()}</h3>


<div class="description">

<p>Process evaluates the fitting's argument function, and sends
       output downstream.</p>
</div></div>
<div class="function">
<h3 id="link_phase/1">link_phase(Object::term(), KeyData::term(), X3::{Bucket::link_match() (see module riak_kv_mrc_pipe), Tag::link_match() (see module riak_kv_mrc_pipe)}) -&gt; [key_input() (see module riak_kv_mrc_pipe)]</h3>


<div class="description">

<p>Function to do link extraction via this module.  The function  
will extract all links matching Bucket and Tag from an input  
object, and send them as fitting output.</p>
 
  <p>Note: This function was added in Riak 1.0.2, but is not used there.
  It is intended to smooth the transition from 1.0.2 to 1.1.0.</p>
</div></div>
<div class="function">
<h3 id="done/1">done(State::state()) -&gt; ok</h3>


<div class="description">

<p>Unused.</p>
</div></div>
<div class="function">
<h3 id="validate_arg/1">validate_arg(Other::term()) -&gt; ok | {error, iolist()}</h3>


<div class="description">

<p>Check that the argument is a 2-tuple, with the first element
       being a valid map phase specification.  For <code>modfun</code> and
       <code>qfun</code> phases, also check that the specified function exists,
       and is arity-3 (see <a href="#riak_pipe_v_validate_function/3" class="seealso">riak_pipe_v_validate_function/3</a>).</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
