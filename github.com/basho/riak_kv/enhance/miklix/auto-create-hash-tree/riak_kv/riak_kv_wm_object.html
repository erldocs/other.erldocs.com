<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_wm_object (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_wm_object</h1>
<h2 class="modsummary">Resource for serving Riak objects over HTTP.</h2>
<div class="description">
<p>Resource for serving Riak objects over HTTP.</p>
 
  <p>Available operations:</p>
 
  <p>POST /types/Type/buckets/Bucket/keys (with bucket-type)  
POST /buckets/Bucket/keys (NEW)  
POST /Prefix/Bucket (OLD)    
Equivalent to "PUT /Prefix/Bucket/Key" where Key is chosen    
by the server.</p>
 
  <p>GET /types/Type/buckets/Bucket/keys/Key (with bucket-type)  
GET /buckets/Bucket/keys/Key (NEW)  
GET /Prefix/Bucket/Key (OLD)    
Get the data stored in the named Bucket under the named Key.    
Content-type of the response will be whatever incoming    
Content-type was used in the request that stored the data.    
Additional headers will include:      
X-Riak-Vclock: The vclock of the object.      
Link: The links the object has      
Etag: The Riak "vtag" metadata of the object      
Last-Modified: The last-modified time of the object      
Encoding: The value of the incoming Encoding header from        
the request that stored the data.      
X-Riak-Meta-: Any headers prefixed by X-Riak-Meta- supplied        
on PUT are returned verbatim    
Specifying the query param "r=R", where R is an integer will    
cause Riak to use R as the r-value for the read request. A    
default r-value of 2 will be used if none is specified.    
If the object is found to have siblings (only possible if the    
bucket property "allow_mult" has been set to true), then    
Content-type will be text/plain; Link, Etag, and Last-Modified    
headers will be omitted; and the body of the response will    
be a list of the vtags of each sibling.  To request a specific    
sibling, include the query param "vtag=V", where V is the vtag    
of the sibling you want.</p>
 
  <p>PUT /types/Type/buckets/Bucket/keys/Key (with bucket-type)  
PUT /buckets/Bucket/keys/Key (NEW)  
PUT /Prefix/Bucket/Key (OLD)    
Store new data in the named Bucket under the named Key.    
A Content-type header *must* be included in the request.  The    
value of this header will be used in the response to subsequent    
GET requests.    
The body of the request will be stored literally as the value    
of the riak_object, and will be served literally as the body of    
the response to subsequent GET requests.    
Include an X-Riak-Vclock header to modify data without creating    
siblings.    
Include a Link header to set the links of the object.    
Include an Encoding header if you would like an Encoding header    
to be included in the response to subsequent GET requests.    
Include custom metadata using headers prefixed with X-Riak-Meta-.    
They will be returned verbatim on subsequent GET requests.    
Specifying the query param "w=W", where W is an integer will    
cause Riak to use W as the w-value for the write request. A    
default w-value of 2 will be used if none is specified.    
Specifying the query param "dw=DW", where DW is an integer will    
cause Riak to use DW as the dw-value for the write request. A    
default dw-value of 0 will be used if none is specified.    
Specifying the query param "r=R", where R is an integer will    
cause Riak to use R as the r-value for the read request (used    
to determine whether or not the resource exists). A default    
r-value of 2 will be used if none is specified.</p>
 
  <p>POST /types/Type/buckets/Bucket/keys/Key (with bucket-type)  
POST /buckets/Bucket/keys/Key (NEW)  
POST /Prefix/Bucket/Key (OLD)    
Equivalent to "PUT /Prefix/Bucket/Key" (useful for clients that    
do not support the PUT method).</p>
 
  <p>DELETE /types/Type/buckets/Bucket/keys/Key (with bucket-type)
  DELETE /buckets/Bucket/keys/Key (NEW)
  DELETE /Prefix/Bucket/Key (OLD)
    Delete the data stored in the named Bucket under the named Key.
    Specifying the query param "rw=RW", where RW is an integer will
    cause Riak to use RW as the rw-value for the delete request. A
    default rw-value of 2 will be used if none is specified.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-context">context() = #ctx{}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ping/2">ping(ReqData, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(Props::proplist() (see module proplists)) -&gt; {ok, context()}</h3>


<div class="description">

<p>Initialize this resource.  This function extracts the
       'prefix' and 'riak' properties from the dispatch args.</p>
</div></div>
<div class="function">
<h3 id="service_available/2">service_available(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether or not a connection to Riak
       can be established.  This function also takes this
       opportunity to extract the 'bucket' and 'key' path
       bindings from the dispatch, as well as any vtag
       query parameter.</p>
</div></div>
<div class="function">
<h3 id="is_authorized/2">is_authorized(ReqData, Ctx) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="forbidden/2">forbidden(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; term()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="allowed_methods/2">allowed_methods(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[atom()], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the list of methods this resource supports.</p>
</div></div>
<div class="function">
<h3 id="allow_missing_post/2">allow_missing_post(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Makes POST and PUT equivalent for creating new
       bucket entries.</p>
</div></div>
<div class="function">
<h3 id="malformed_request/2">malformed_request(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether query parameters, request headers,
       and request body are badly-formed.
       Body format is checked to be valid JSON, including
       a "props" object for a bucket-PUT.  Body format
       is not tested for a key-level request (since the
       body may be any content the client desires).
       Query parameters r, w, dw, and rw are checked to
       be valid integers.  Their values are stored in
       the context() at this time.
       Link headers are checked for the form:
         &lt;/Prefix/Bucket/Key&gt;; riaktag="Tag",...
       The parsed links are stored in the context()
       at this time.</p>
</div></div>
<div class="function">
<h3 id="content_types_provided/2">content_types_provided(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[{ContentType::string(), Producer::atom()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the content types available for representing this resource.
       The content-type for a key-level request is the content-type that
       was used in the PUT request that stored the document in Riak.</p>
</div></div>
<div class="function">
<h3 id="charsets_provided/2">charsets_provided(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {no_charset | [{Charset::string(), Producer::function()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the charsets available for representing this resource.
       The charset for a key-level request is the charset that was used
       in the PUT request that stored the document in Riak (none if
       no charset was specified at PUT-time).</p>
</div></div>
<div class="function">
<h3 id="encodings_provided/2">encodings_provided(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {[{Encoding::string(), Producer::function()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>List the encodings available for representing this resource.
       The encoding for a key-level request is the encoding that was
       used in the PUT request that stored the document in Riak, or
       "identity" and "gzip" if no encoding was specified at PUT-time.</p>
</div></div>
<div class="function">
<h3 id="content_types_accepted/2">content_types_accepted(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {[{ContentType::string(), Acceptor::atom()}], #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the list of content types this resource will accept.
       Whatever content type is specified by the Content-Type header
       of a key-level PUT request will be accepted by this resource.
       (A key-level put *must* include a Content-Type header.)</p>
</div></div>
<div class="function">
<h3 id="resource_exists/2">resource_exists(Wm_reqdata::#wm_reqdata{}, Ctx0::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether or not the requested item exists.
       Documents exists if a read request to Riak returns {ok, riak_object()},
       and either no vtag query parameter was specified, or the value of the
       vtag param matches the vtag of some value of the Riak object.</p>
</div></div>
<div class="function">
<h3 id="post_is_create/2">post_is_create(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>POST is considered a document-creation operation for bucket-level
       requests (this makes webmachine call create_path/2, where the key
       for the created document will be chosen).</p>
</div></div>
<div class="function">
<h3 id="create_path/2">create_path(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {string(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Choose the Key for the document created during a bucket-level POST.
       This function also sets the Location header to generate a
       201 Created response.</p>
</div></div>
<div class="function">
<h3 id="process_post/2">process_post(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Pass-through for key-level requests to allow POST to function
       as PUT for clients that do not support PUT.</p>
</div></div>
<div class="function">
<h3 id="accept_doc_body/2">accept_doc_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Store the data the client is PUTing in the document.
       This function translates the headers and body of the HTTP request
       into their final riak_object() form, and executes the Riak put.</p>
</div></div>
<div class="function">
<h3 id="multiple_choices/2">multiple_choices(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {boolean(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Determine whether a document has siblings.  If the user has
       specified a specific vtag, the document is considered not to
       have sibling versions.  This is a safe assumption, because
       resource_exists will have filtered out requests earlier for
       vtags that are invalid for this version of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_doc_body/2">produce_doc_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {binary(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Extract the value of the document, and place it in the
       response body of the request.  This function also adds the
       Link, X-Riak-Meta- headers, and X-Riak-Index- headers to the
       response.  One link will point to the bucket, with the
       property "rel=container".  The rest of the links will be
       constructed from the links of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_sibling_message_body/2">produce_sibling_message_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {iolist(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Produce the text message informing the user that there are multiple
       values for this document, and giving that user the vtags of those
       values so they can get to them with the vtag query param.</p>
</div></div>
<div class="function">
<h3 id="produce_multipart_body/2">produce_multipart_body(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {iolist(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Produce a multipart body representation of an object with multiple
       values (siblings), each sibling being one part of the larger
       document.</p>
</div></div>
<div class="function">
<h3 id="delete_resource/2">delete_resource(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {true, #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Delete the document specified.</p>
</div></div>
<div class="function">
<h3 id="generate_etag/2">generate_etag(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {undefined | string(), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the etag for this resource.
       Documents will have an etag equal to their vtag. For documents with
       siblings when no vtag is specified, this will be an etag derived from
       the vector clock.</p>
</div></div>
<div class="function">
<h3 id="last_modified/2">last_modified(Wm_reqdata::#wm_reqdata{}, Ctx::context()) -&gt; {undefined | datetime() (see module calendar), #wm_reqdata{}, context()}</h3>


<div class="description">

<p>Get the last-modified time for this resource.
       Documents will have the last-modified time specified by the riak_object.
       For documents with siblings, this is the last-modified time of the latest
       sibling.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
