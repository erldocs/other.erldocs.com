<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_mutator (riak_kv) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_mutator</h1>
<h2 class="modsummary">There are circumstances where the object stored on disk is not  
the object to return; and there are times the object written to the  
data storage backend is not meant to be the object given.</h2>
<div class="description">
<p>There are circumstances where the object stored on disk is not  
the object to return; and there are times the object written to the  
data storage backend is not meant to be the object given. An  
example would be storing only meta data for an object on a remote  
cluster. This module is an interface to register mutators that will  
be run.</p>
 
  <p>This doubles as a behavior defining module for the mutators.</p>
 
  <p><em><marker id="Words_of_Warning">Words of Warning</marker></em></p>
 
  <p>Once an object has been stored with a given mutator list, attempting to  
retreive that object will require those mutators. If the mutators done't  
exists or have changed in a non-backwards compatible way, you can expect  
to have at worst a crash, or at best a corrupted object.</p>
 
  <p><em><marker id="Callbacks">Callbacks</marker></em></p>
 
  <p>A mutator callback must implement 2 function: mutate_put/5 and mutate_get/1.</p>
 
  <p><code>mutate_put(MetaData, Value, ExposedMeta,
  FullObject, BucketProperties) -&gt; Result</code></p>
 
  <p>Types:
  </p><pre class="sh_erlang">      MetaData = dict()
      Value = term()
      ExposedMeta = dict()
      FullObject = riak_object:riak_object()
      BucketProperties = orddict:orddict()
      Result = {NewMeta, NewValue, NewExposedMeta}
          NewMeta = dict()
          NewValue = term()
          NewExposedMeta = dict()</pre>
 
  <p>The mutate_put callback is called for each metadata/value pair a riak_object  
has. The return value of NewMeta and NewValue are used by the storage backend  
while the NewExposedMeta is used for the client return where NewMeta would  
normally. The NewExposedMeta is merged with the NewMeta to generate the  
exposed metadata; if the same key is found, the NewExposedMeta value is used.</p>
 
  <p>The mutations are run in the same process as the vnode.</p>
 
  <p><code>mutate_get(Object) -&gt; Result</code></p>
 
  <p>Types:
  </p><pre class="sh_erlang">      Object = riak_object:riak_object()
      Result = riak_object:riak_object() | 'notfound'</pre><p>
  Take the object from storage and reverse whatever mutation was applied. Note
  the bucket properties are not part of this callback, so if some data is
  important to reverse a mutation, it must be put in the metadata by the
  <code>mutate_put</code> function. Also note how the entire object is given as opposed to  
simply a metadata/value pair. Care must be taken not to corrupt the object.</p>
 
  <p>A return of <code>'notfound</code>' stops the mutator chain and returns immediately. This
  provides an escape hatch of sorts; if the mutator cannot reverse the mutation
  effectively, return <code>'notfound</code>'.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="register/1">register(Module::atom()) -&gt; ok</h3>


<div class="description">

<p>Register the given module as a mutator with the default priority of 0.</p>
<p><em>See also:</em> <a href="#register/2" class="seealso">register/2</a>.</p>
</div></div>
<div class="function">
<h3 id="register/1-1">register(Module::atom(), Priority::term()) -&gt; ok</h3>


<div class="description">

<p>Register a module as a mutator with the given priority. Modules with
  equal priority are done in default (alphabetical) order. A module
  can only be registered once. When there is a conflict (two different
  lists), those lists are merged. Note that if an object is stored with
  a mutator, that mutator is used on retrieval. If that mutator code is
  removed or changed in a backwards incompatible manner, at best the
  object will be corrupted; at worst it will cause a crash.</p>
</div></div>
<div class="function">
<h3 id="unregister/1">unregister(Module::atom()) -&gt; ok</h3>


<div class="description">

<p>Remove a module from the mutator list. Removing a mutator from the
  list does not remove the mutator from use for retreiving objects. Any
  object that was stored while the mutator was registered will use that
  mutator on get. Thus, if the code for a mutator is not available or
  was changed in a non-backwards compatible way, at best one can expect
  corrupt objects, at worst a crash.</p>
</div></div>
<div class="function">
<h3 id="get/0">get() -&gt; {ok, [atom()]}</h3>


<div class="description">

<p>Retrieve the list of mutators in the order to apply them when doing a
  a put mutation. To get the order when doing a get mutation, reverse the list.</p>
</div></div>
<div class="function">
<h3 id="mutate_get/1">mutate_get(Object::riak_object() (see module riak_object)) -&gt; riak_object() (see module riak_object)</h3>


<div class="description">

<p>Unmutate an object after retrieval from storage. When an object is
  mutated, the mutators applied are put into the object's metadata.
  If the mutator does not exist anymore or has changed in a backwards
  incompatible manner, at best there will be corrupt objects, at worst
  a crash.</p>
</div></div>
<div class="function">
<h3 id="mutate_put/1">mutate_put(Object::riak_object() (see module riak_object), BucketProps::orddict() (see module orddict)) -&gt; {riak_object() (see module riak_object), riak_object() (see module riak_object)}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="mutate_put/1-1">mutate_put(Object::riak_object() (see module riak_object), BucketProps::orddict() (see module orddict), Modules::[atom()]) -&gt; {riak_object() (see module riak_object), riak_object() (see module riak_object)}</h3>


<div class="description">

<p>Mutate an object in preparation to storage, returning a tuple of the
  object to store and the object to return to the client. For each sibling
  the object has {Meta, Value} pair, each mutator is called with a copy
  that iteration's Meta used as the exposed meta." Later mutators are
  given the results of previous mutators. Once all mutations are complete,
  two <url href="/home/pete/wefwefwef/docs/other/c94408376b755f24b026086c91fef124/repo/jra_bucket_types_riakobj/.xml/riak_kv/./riak_object.xml#type-riak_object">riak_object:riak_object()</url>s are returned. The first is what
  is to be stored, while the second has the exposed meta set with the
  orginal value(s).</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
