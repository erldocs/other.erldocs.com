<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>raw_http_resource (riak) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>raw_http_resource</h1>
<h2 class="modsummary">Resource for serving Riak objects over HTTP in a more "raw"       
form (when compared to jiak_resource).</h2>
<div class="description">
<p>Resource for serving Riak objects over HTTP in a more "raw"       
form (when compared to jiak_resource).</p>
 
  <p>Available operations:</p>
 
  <p>GET /Prefix/Bucket    
Get information about the named Bucket, in JSON form:      
{"props":{Prop1:Val1,Prop2:Val2,...},       
"keys":[Key1,Key2,...]}.    
Each bucket property will be included in the "props" object.    
"linkfun" and "chash_keyfun" properties will be encoded as    
JSON objects of the form:      
{"mod":ModuleName,       
"fun":FunctionName}    
Where ModuleName and FunctionName are each strings representing    
a module and function.    
Including the query param "props=false" will cause the "props"    
field to be omitted from the response.    
Including the query param "keys=false" will cause the "keys"    
field to be omitted from the response.</p>
 
  <p>PUT /Prefix/Bucket    
Modify bucket properties.    
Content-type must be application/json, and the body must have    
the form:      
{"props":{Prop:Val}}    
Where the "props" object takes the same form as returned from    
a GET of the same resource.</p>
 
  <p>POST /Prefix/Bucket    
Equivalent to "PUT /Prefix/Bucket/Key" where Key is chosen    
by the server.</p>
 
  <p>GET /Prefix/Bucket/Key    
Get the data stored in the named Bucket under the named Key.    
Content-type of the response will be whatever incoming    
Content-type was used in the request that stored the data.    
Additional headers will include:      
X-Riak-Vclock: The vclock of the object.      
Link: The links the object has      
Etag: The Riak "vtag" metadata of the object      
Last-Modified: The last-modified time of the object      
Encoding: The value of the incoming Encoding header from        
the request that stored the data.      
X-Riak-Meta-: Any headers prefixed by X-Riak-Meta- supplied        
on PUT are returned verbatim    
Specifying the query param "r=R", where R is an integer will    
cause Riak to use R as the r-value for the read request. A    
default r-value of 2 will be used if none is specified.    
If the object is found to have siblings (only possible if the    
bucket property "allow_mult" has been set to true), then    
Content-type will be text/plain; Link, Etag, and Last-Modified    
headers will be omitted; and the body of the response will    
be a list of the vtags of each sibling.  To request a specific    
sibling, include the query param "vtag=V", where V is the vtag    
of the sibling you want.</p>
 
  <p>PUT /Prefix/Bucket/Key    
Store new data in the named Bucket under the named Key.    
A Content-type header *must* be included in the request.  The    
value of this header will be used in the response to subsequent    
GET requests.    
The body of the request will be stored literally as the value    
of the riak_object, and will be served literally as the body of    
the response to subsequent GET requests.    
Include an X-Riak-Vclock header to modify data without creating    
siblings.    
Include a Link header to set the links of the object.    
Include an Encoding header if you would like an Encoding header    
to be included in the response to subsequent GET requests.    
Include custom metadata using headers prefixed with X-Riak-Meta-.    
They will be returned verbatim on subsequent GET requests.    
Specifying the query param "w=W", where W is an integer will    
cause Riak to use W as the w-value for the write request. A    
default w-value of 2 will be used if none is specified.    
Specifying the query param "dw=DW", where DW is an integer will    
cause Riak to use DW as the dw-value for the write request. A    
default dw-value of 0 will be used if none is specified.    
Specifying the query param "r=R", where R is an integer will    
cause Riak to use R as the r-value for the read request (used    
to determine whether or not the resource exists). A default    
r-value of 2 will be used if none is specified.</p>
 
  <p>POST /Prefix/Bucket/Key    
Equivalent to "PUT /Prefix/Bucket/Key" (useful for clients that    
do not support the PUT method).</p>
 
  <p>DELETE /Prefix/Bucket/Key    
Delete the data stored in the named Bucket under the named Key.    
Specifying the query param "rw=RW", where RW is an integer will    
cause Riak to use RW as the rw-value for the delete request. A    
default rw-value of 2 will be used if none is specified.</p>
 
  <p>Webmachine dispatch lines for this resource should look like:</p>
 
   <p>{["raw", bucket],    
raw_http_resource,    
[{prefix, "raw"},     
{riak, local} %% or {riak, {'riak@127.0.0.1', riak_cookie}}    
]}.   
{["raw", bucket, key],    
raw_http_resource,    
[{prefix, "raw"},     
{riak, local} %% or {riak, {'riak@127.0.0.1', riak_cookie}}    
]}.</p>
 
  <p>These example dispatch lines will expose this resource at
  /raw/Bucket and /raw/Bucket/Key.  The resource will attempt to
  connect to Riak on the same Erlang node one which the resource
  is executing.  Using the alternate {riak, {Node, Cookie}} form
  will cause the resource to connect to riak on the specified
  Node with the specified Cookie.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-context">context() = term()</h3></div>
    <div class="type"><h3 id="type-erlpropvalue">erlpropvalue() = integer() | string() | boolean() | {modfun, atom(), atom()} | {atom(), atom()}</h3></div>
    <div class="type"><h3 id="type-jsonmodfun">jsonmodfun() = {mod_binary(), binary()} | {fun_binary(), binary()}</h3></div>
    <div class="type"><h3 id="type-jsonpropvalue">jsonpropvalue() = integer() | string() | boolean() | {struct, [jsonmodfun()]}</h3></div>
    <div class="type"><h3 id="type-link">link() = {{Bucket::binary(), Key::binary()}, Tag::binary()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ping/2">ping(ReqData, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(Props::proplist()) -&gt; {ok, context()}</h3>


<div class="description">

<p>Initialize this resource.  This function extracts the
       'prefix' and 'riak' properties from the dispatch args.</p>
</div></div>
<div class="function">
<h3 id="service_available/1">service_available(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether or not a connection to Riak
       can be established.  This function also takes this
       opportunity to extract the 'bucket' and 'key' path
       bindings from the dispatch, as well as any vtag
       query parameter.</p>
</div></div>
<div class="function">
<h3 id="allowed_methods/1">allowed_methods(RD::reqdata(), Ctx::context()) -&gt; {[method()], reqdata(), context()}</h3>


<div class="description">

<p>Get the list of methods this resource supports.
       HEAD, GET, POST, and PUT are supported at both
       the bucket and key levels.  DELETE is supported
       at the key level only.</p>
</div></div>
<div class="function">
<h3 id="malformed_request/1">malformed_request(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether query parameters, request headers,
       and request body are badly-formed.
       Body format is checked to be valid JSON, including
       a "props" object for a bucket-PUT.  Body format
       is not tested for a key-level request (since the
       body may be any content the client desires).
       Query parameters r, w, dw, and rw are checked to
       be valid integers.  Their values are stored in
       the context() at this time.
       Link headers are checked for the form:
         &lt;/Prefix/Bucket/Key&gt;; riaktag="Tag",...
       The parsed links are stored in the context()
       at this time.</p>
</div></div>
<div class="function">
<h3 id="content_types_provided/1">content_types_provided(RD::reqdata(), Ctx::context()) -&gt; {[{ContentType::string(), Producer::atom()}], reqdata(), context()}</h3>


<div class="description">

<p>List the content types available for representing this resource.
       "application/json" is the content-type for bucket-level GET requests
       The content-type for a key-level request is the content-type that
       was used in the PUT request that stored the document in Riak.</p>
</div></div>
<div class="function">
<h3 id="charsets_provided/1">charsets_provided(RD::reqdata(), Ctx::context()) -&gt; {no_charset | [{Charset::string(), Producer::function()}], reqdata(), context()}</h3>


<div class="description">

<p>List the charsets available for representing this resource.
       No charset will be specified for a bucket-level request.
       The charset for a key-level request is the charset that was used
       in the PUT request that stored the document in Riak (none if
       no charset was specified at PUT-time).</p>
</div></div>
<div class="function">
<h3 id="encodings_provided/1">encodings_provided(RD::reqdata(), Ctx::context()) -&gt; {[{Encoding::string(), Producer::function()}], reqdata(), context()}</h3>


<div class="description">

<p>List the encodings available for representing this resource.
       "identity" and "gzip" are available for bucket-level requests.
       The encoding for a key-level request is the encoding that was
       used in the PUT request that stored the document in Riak, or
       "identity" and "gzip" if no encoding was specified at PUT-time.</p>
</div></div>
<div class="function">
<h3 id="content_types_accepted/1">content_types_accepted(RD::reqdata(), Ctx::context()) -&gt; {[{ContentType::string(), Acceptor::atom()}], reqdata(), context()}</h3>


<div class="description">

<p>Get the list of content types this resource will accept.
       "application/json" is the only type accepted for bucket-PUT.
       Whatever content type is specified by the Content-Type header
       of a key-level PUT request will be accepted by this resource.
       (A key-level put *must* include a Content-Type header.)</p>
</div></div>
<div class="function">
<h3 id="resource_exists/1">resource_exists(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether or not the requested item exists.
       All buckets exists, whether they have data in them or not.
       Documents exists if a read request to Riak returns {ok, riak_object()},
       and either no vtag query parameter was specified, or the value of the
       vtag param matches the vtag of some value of the Riak object.</p>
</div></div>
<div class="function">
<h3 id="produce_bucket_body/1">produce_bucket_body(RD::reqdata(), Ctx::context()) -&gt; {binary(), reqdata(), context()}</h3>


<div class="description">

<p>Produce the JSON response to a bucket-level GET.
       Includes the bucket props unless the "props=false" query param
       is specified.
       Includes the keys of the documents in the bucket unless the
       "keys=false" query param is specified.
       A Link header will also be added to the response by this function
       if the keys are included in the JSON object.  The Link header
       will include links to all keys in the bucket, with the property
       "rel=contained".</p>
</div></div>
<div class="function">
<h3 id="accept_bucket_body/1">accept_bucket_body(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Modify the bucket properties according to the body of the
       bucket-level PUT request.</p>
</div></div>
<div class="function">
<h3 id="post_is_create/1">post_is_create(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>POST is considered a document-creation operation for bucket-level
       requests (this makes webmachine call create_path/2, where the key
       for the created document will be chosen).</p>
</div></div>
<div class="function">
<h3 id="create_path/1">create_path(RD::reqdata(), Ctx::context()) -&gt; {string(), reqdata(), context()}</h3>


<div class="description">

<p>Choose the Key for the document created during a bucket-level POST.
       This function also sets the Location header to generate a
       201 Created response.</p>
</div></div>
<div class="function">
<h3 id="process_post/1">process_post(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Pass-through for key-level requests to allow POST to function
       as PUT for clients that do not support PUT.</p>
</div></div>
<div class="function">
<h3 id="accept_doc_body/1">accept_doc_body(RD::reqdata(), Ctx::context()) -&gt; {true, reqdat(), context()}</h3>


<div class="description">

<p>Store the data the client is PUTing in the document.
       This function translates the headers and body of the HTTP request
       into their final riak_object() form, and executes the Riak put.</p>
</div></div>
<div class="function">
<h3 id="multiple_choices/1">multiple_choices(RD::reqdata(), Ctx::context()) -&gt; {boolean(), reqdata(), context()}</h3>


<div class="description">

<p>Determine whether a document has siblings.  If the user has
       specified a specific vtag, the document is considered not to
       have sibling versions.  This is a safe assumption, because
       resource_exists will have filtered out requests earlier for
       vtags that are invalid for this version of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_doc_body/1">produce_doc_body(RD::reqdata(), Ctx::context()) -&gt; {binary(), reqdata(), context()}</h3>


<div class="description">

<p>Extract the value of the document, and place it in the response
       body of the request.  This function also adds the Link and X-Riak-Meta-
       headers to the response.  One link will point to the bucket, with the
       property "rel=container".  The rest of the links will be constructed
       from the links of the document.</p>
</div></div>
<div class="function">
<h3 id="produce_sibling_message_body/1">produce_sibling_message_body(RD::reqdata(), Ctx::context()) -&gt; {iolist(), reqdata(), context()}</h3>


<div class="description">

<p>Produce the text message informing the user that there are multiple
       values for this document, and giving that user the vtags of those
       values so they can get to them with the vtag query param.</p>
</div></div>
<div class="function">
<h3 id="produce_multipart_body/1">produce_multipart_body(RD::reqdata(), Ctx::context()) -&gt; {iolist(), reqdata(), context()}</h3>


<div class="description">

<p>Produce a multipart body representation of an object with multiple
       values (siblings), each sibling being one part of the larger
       document.</p>
</div></div>
<div class="function">
<h3 id="multipart_encode_body/1">multipart_encode_body(Prefix::string(), Bucket::binary(), X3::{dict(), binary()}) -&gt; iolist()</h3>


<div class="description">

<p>Produce one part of a multipart body, representing one sibling
       of a multi-valued document.</p>
</div></div>
<div class="function">
<h3 id="vclock_header/1">vclock_header(Doc::riak_object()) -&gt; {Name::string(), Value::string()}</h3>


<div class="description">

<p>Transform the Erlang representation of the document's vclock
       into something suitable for an HTTP header</p>
</div></div>
<div class="function">
<h3 id="delete_resource/1">delete_resource(RD::reqdata(), Ctx::context()) -&gt; {true, reqdata(), context()}</h3>


<div class="description">

<p>Delete the document specified.</p>
</div></div>
<div class="function">
<h3 id="generate_etag/1">generate_etag(RD::reqdata(), Ctx::context()) -&gt; {undefined | string(), reqdata(), context()}</h3>


<div class="description">

<p>Get the etag for this resource.
       Bucket requests will have no etag.
       Documents will have an etag equal to their vtag.  No etag will be
       given for documents with siblings, if no sibling was chosen with the
       vtag query param.</p>
</div></div>
<div class="function">
<h3 id="last_modified/1">last_modified(RD::reqdata(), Ctx::context()) -&gt; {undefined | datetime(), reqdata(), context()}</h3>


<div class="description">

<p>Get the last-modified time for this resource.
       Bucket requests will have no last-modified time.
       Documents will have the last-modified time specified by the riak_object.
       No last-modified time will be given for documents with siblings, if no
       sibling was chosen with the vtag query param.</p>
</div></div>
<div class="function">
<h3 id="format_link/1">format_link(Prefix::string(), Bucket::binary()) -&gt; string()</h3>


<div class="description">

<p>Format a Link header to a bucket.</p>
</div></div>
<div class="function">
<h3 id="format_link/1-1">format_link(Prefix::string(), Bucket::binary(), Key::binary(), Tag::binary()) -&gt; string()</h3>


<div class="description">

<p>Format a Link header to another document.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
