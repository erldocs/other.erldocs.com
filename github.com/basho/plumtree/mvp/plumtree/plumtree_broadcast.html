<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>plumtree_broadcast (plumtree) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>plumtree_broadcast</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-exchange">exchange() = {module(), node(), reference(), pid()}</h3></div>
    <div class="type"><h3 id="type-exchanges">exchanges() = [<a href="#type-exchange" class="seealso">exchange()</a>]</h3></div>
    <div class="type"><h3 id="type-nodename">nodename() = any()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, pid()} | ignore | {error, term()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_link/1">start_link(PeerService::module()) -&gt; {ok, pid()} | ignore | {error, term()}</h3>


<div class="description">

<p>Starts the broadcast server on this node. The initial membership list is
  fetched from the ring. If the node is a singleton then the initial eager and lazy
  sets are empty. If there are two nodes, each will be in the others eager set and the
  lazy sets will be empty. When number of members is less than 5, each node will initially
  have one other node in its eager set and lazy set. If there are more than five nodes
  each node will have at most two other nodes in its eager set and one in its lazy set, initally.
  In addition, after the broadcast server is started, a callback is registered with ring_events
  to generate membership updates as the ring changes.</p>
</div></div>
<div class="function">
<h3 id="start_link/1-1">start_link(InitMembers::[nodename()], InitEagers::[nodename()], InitLazys::[nodename()], Mods::[module()], PeerService::module()) -&gt; {ok, pid()} | ignore | {error, term}</h3>


<div class="description">

<p>Starts the broadcast server on this node. <code>InitMembers</code> must be a list
  of all members known to this node when starting the broadcast server.
  <code>InitEagers</code> are the initial peers of this node for all broadcast trees.
  <code>InitLazys</code> is a list of random peers not in <code>InitEagers</code> that will be used
  as the initial lazy peer shared by all trees for this node. If the number
  of nodes in the cluster is less than 3, <code>InitLazys</code> should be an empty list.
  <code>InitEagers</code> and <code>InitLazys</code> must also be subsets of <code>InitMembers</code>. <code>Mods</code> is
  a list of modules that may be handlers for broadcasted messages. All modules in
  <code>Mods</code> should implement the <code>plumtree_broadcast_handler</code> behaviour.</p>
 
  <p>NOTE: When starting the server using start_link/4 no automatic membership update from
  ring_events is registered. Use start_link/0.</p>
</div></div>
<div class="function">
<h3 id="broadcast/1">broadcast(Broadcast::any(), Mod::module()) -&gt; ok</h3>


<div class="description">

<p>Broadcasts a message originating from this node. The message will be delivered to
  each node at least once. The <code>Mod</code> passed is responsible for handling the message on remote
  nodes as well as providing some other information both locally and and on other nodes.
  <code>Mod</code> must be loaded on all members of the clusters and implement the
  <code>riak_core_broadcast_handler</code> behaviour.</p>
</div></div>
<div class="function">
<h3 id="update/1">update(LocalState) -&gt; term()
</h3>


<div class="description">

<p>Notifies broadcast server of membership update</p>
</div></div>
<div class="function">
<h3 id="broadcast_members/0">broadcast_members() -&gt; ordset(nodename()) (see module ordsets)</h3>


<div class="description">

<p>Returns the broadcast servers view of full cluster membership.
  Wait indefinitely for a response is returned from the process</p>
</div></div>
<div class="function">
<h3 id="broadcast_members/1">broadcast_members(Timeout::infinity | pos_integer()) -&gt; ordset(nodename()) (see module ordsets)</h3>


<div class="description">

<p>Returns the broadcast servers view of full cluster membership.
  Waits <code>Timeout</code> ms for a response from the server</p>
</div></div>
<div class="function">
<h3 id="exchanges/0">exchanges() -&gt; exchanges()</h3>


<div class="description">

<p>return a list of exchanges, started by broadcast on thisnode, that are running</p>
</div></div>
<div class="function">
<h3 id="exchanges/1">exchanges(Node::node()) -&gt; exchanges()</h3>


<div class="description">

<p>returns a list of exchanges, started by broadcast on <code>Node</code>, that are running</p>
</div></div>
<div class="function">
<h3 id="cancel_exchanges/2">cancel_exchanges(WhichExchanges::all | {peer, node()} | {mod, module()} | reference() | pid()) -&gt; exchanges()</h3>


<div class="description">

<p>cancel exchanges started by this node.</p>
</div></div>
<div class="function">
<h3 id="debug_get_peers/1">debug_get_peers(Node::node(), Root::node()) -&gt; {ordset(node()) (see module ordsets), ordset(node()) (see module ordsets)}</h3>


<div class="description">

<p>return the peers for <code>Node</code> for the tree rooted at <code>Root</code>.
  Wait indefinitely for a response is returned from the process</p>
</div></div>
<div class="function">
<h3 id="debug_get_peers/1-1">debug_get_peers(Node::node(), Root::node(), Timeout::infinity | pos_integer()) -&gt; {ordset(node()) (see module ordsets), ordset(node()) (see module ordsets)}</h3>


<div class="description">

<p>return the peers for <code>Node</code> for the tree rooted at <code>Root</code>.
  Waits <code>Timeout</code> ms for a response from the server</p>
</div></div>
<div class="function">
<h3 id="debug_get_tree/1">debug_get_tree(Root::node(), Nodes::[node()]) -&gt; [{node(), {ordset(node()) (see module ordsets), ordset(node()) (see module ordsets)}}]</h3>


<div class="description">

<p>return peers for all <code>Nodes</code> for tree rooted at <code>Root</code>
  Wait indefinitely for a response is returned from the process</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
