<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>hashtree_tree (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>hashtree_tree</h1>
<h2 class="modsummary">This module implements a specialized hash tree that is used  
primarily by cluster metadata's anti-entropy exchanges and by  
metadata clients for determining when groups of metadata keys have  
changed locally.</h2>
<div class="description">
<p>This module implements a specialized hash tree that is used  
primarily by cluster metadata's anti-entropy exchanges and by  
metadata clients for determining when groups of metadata keys have  
changed locally. The tree can be used, generally, for determining  
the differences in groups of keys, or to find missing groups, between  
two stores.</p>
 
  <p>Each node of the tree is itself a hash tree, specifically a <a href="hashtree.html" class="seealso">hashtree</a>.  The tree has a fixed height but each node has a
  variable amount of children. The height of the tree directly
  corresponds to the number of prefixes supported by the tree. A list
  of prefixes, or a "prefix list", represent a group of keys. Each
  unique prefix list is a node in the tree. The leaves store hashes
  for the individual keys in the segments of the node's <a href="hashtree.html" class="seealso">hashtree</a>. The buckets of the leaves' hashtree provide an efficient
  way of determining when keys in the segments differ between two
  trees.  The tails of the prefix list are used to roll up groups
  into parent groups. For example, the prefixes <code>[a, b]</code>, <code>[a, c]</code>,
  <code>[d, e]</code> will be rolled up into parent groups <code>a</code>, containing <code>c</code>
  and <code>b</code>, and <code>d</code>, containing only 'e'. The parent group's node has  
children corresponding to each child group. The top-hashes of the  
child nodes are stored in the parent nodes' segments. The parent  
nodes' buckets are used as an efficient method for determining when  
child groups differ between two trees. The root node corresponds to  
the empty list and it acts like any other node, storing hashes for  
the first level of child groups. The top hash of the root node is  
the top hash of the tree.</p>
 
  <p>The tree in the example above might store something like:</p>
 
  <p>node    parent   top-hash  segments  
---------------------------------------------------  
root     none       1      [{a, 2}, {d, 3}]  
[a]      root       2      [{b, 4}, {c, 5}]  
[d]      root       3      [{e, 6}]  
[a,b]    [a]        4      [{k1, 0}, {k2, 6}, ...]  
[a,c]    [a]        5      [{k1, 1}, {k2, 4}, ...]  
[d,e]    [d]        6      [{k1, 2}, {k2, 3}, ...]</p>
 
 
  <p>When a key is inserted into the tree it is inserted into the leaf  
corresponding to the given prefix list. The leaf and its parents  
are not updated at this time. Instead the leaf is added to a dirty  
set. The nodes are later updated in bulk.</p>
 
  <p>Updating the hashtree is a two step process. First, a snapshot of
  the tree must be obtained. This prevents new writes from affecting
  the update. Snapshotting the tree will snapshot each dirty
  leaf. Since writes to nodes other than leaves only occur during
  updates no snapshot is taken for them. Second, the tree is updated
  using the snapshot. The update is performed by updating the <a href="hashtree.html" class="seealso">hashtree</a> nodes at each level starting with the leaves. The top  
hash of each node in a level is inserted into its parent node after  
being updated. The list of dirty parents is then updated, moving up  
the tree. Once the root is reached and has been updated the process  
is complete. This process is designed to minimize the traversal of  
the tree and ensure that each node is only updated once.</p>
 
  <p>The typical use for updating a tree is to compare it with another
  recently updated tree. Comparison is done with the <code>compare/4</code>  
function.  Compare provides a sort of fold over the differences of  
the tree allowing for callers to determine what to do with those  
differences. In addition, the caller can accumulate a value, such  
as the difference list or stats about differencces.</p>
 
  <p>The tree implemented in this module assumes that it will be managed  
by a single process and that all calls will be made to it synchronously, with  
a couple exceptions:</p>
 
  <p>1. Updating a tree with a snapshot can be done in another process. The snapshot  
must be taken by the owning process, synchronously.  
2. Comparing two trees may be done by a seperate process. Compares should should use  
a snapshot and only be performed after an update.</p>
 
  <p>The nodes in this tree are backend by LevelDB, however, this is
  most likely temporary and Cluster Metadata's use of the tree is
  ephemeral. Trees are only meant to live for the lifetime of a
  running node and are rebuilt on start.  To ensure the tree is fresh
  each time, when nodes are created the backing LevelDB store is
  opened, closed, and then re-opened to ensure any lingering files
  are removed.  Additionally, the nodes themselves (references to
  <a href="hashtree.html" class="seealso">hashtree</a>, are stored in <a href="ets.html" class="seealso">ets</a>.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-diff">diff() = <a href="#type-prefix_diff" class="seealso">prefix_diff()</a> | <a href="#type-key_diffs" class="seealso">key_diffs()</a></h3></div>
    <div class="type"><h3 id="type-handler_fun">handler_fun/0</h3></div>
    <div class="type"><h3 id="type-insert_opt">insert_opt() = <a href="#type-insert_opt_if_missing" class="seealso">insert_opt_if_missing()</a></h3></div>
    <div class="type"><h3 id="type-insert_opt_if_missing">insert_opt_if_missing() = {if_missing, boolean()}</h3></div>
    <div class="type"><h3 id="type-insert_opts">insert_opts() = [<a href="#type-insert_opt" class="seealso">insert_opt()</a>]</h3></div>
    <div class="type"><h3 id="type-key_diffs">key_diffs() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{key_diffs,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-prefixes" class="seealso">prefixes()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{missing | remote_missing | different, binary()}]}</h3></div>
    <div class="type"><h3 id="type-new_opt">new_opt() = <a href="#type-new_opt_num_levels" class="seealso">new_opt_num_levels()</a> | <a href="#type-new_opt_data_dir" class="seealso">new_opt_data_dir()</a></h3></div>
    <div class="type"><h3 id="type-new_opt_data_dir">new_opt_data_dir() = {data_dir, <a href="file.html#type-name_all" class="seealso">file:name_all()</a>}</h3></div>
    <div class="type"><h3 id="type-new_opt_num_levels">new_opt_num_levels() = {num_levels, integer() &gt;= 0}</h3></div>
    <div class="type"><h3 id="type-new_opts">new_opts() = [<a href="#type-new_opt" class="seealso">new_opt()</a>]</h3></div>
    <div class="type"><h3 id="type-prefix">prefix() = atom() | binary()</h3></div>
    <div class="type"><h3 id="type-prefix_diff">prefix_diff() = {missing_prefix, local | remote, <a href="#type-prefixes" class="seealso">prefixes()</a>}</h3></div>
    <div class="type"><h3 id="type-prefixes">prefixes() = [<a href="#type-prefix" class="seealso">prefix()</a>]</h3></div>
    <div class="type"><h3 id="type-remote_fun">remote_fun()</h3></div>
    <div class="type"><h3 id="type-tree">tree()</h3></div>
    <div class="type"><h3 id="type-tree_node">tree_node()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/1">new(TreeId::term(), Opts::new_opts()) -&gt; tree()</h3>


<div class="description">

<p>Creates a new hashtree.</p>
 
  <p>Takes the following options:
    * num_levels - the height of the tree excluding leaves. corresponds to the
                   length of the prefix list passed to <a href="#insert/5" class="seealso">insert/5</a>.
    * data_dir   - the directory where the LevelDB instances for the nodes will
                   be stored.</p>
</div></div>
<div class="function">
<h3 id="destroy/1">destroy(Tree::tree()) -&gt; ok</h3>


<div class="description">

<p>Destroys the tree cleaning up any used resources.
  This deletes the LevelDB files for the nodes.</p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(Prefixes::prefixes(), Key::binary(), Hash::binary(), Tree::tree()) -&gt; tree() | {error, term()}</h3>


<div class="description">

<p>an alias for insert(Prefixes, Key, Hash, [], Tree)</p>
</div></div>
<div class="function">
<h3 id="insert/1-1">insert(Prefixes::prefixes(), Key::binary(), Hash::binary(), Opts::insert_opts(), Tree::tree()) -&gt; tree() | {error, term()}</h3>


<div class="description">

<p>Insert a hash into the tree. The length of <code>Prefixes</code> must
  correspond to the height of the tree -- the value used for
  <code>num_levels</code> when creating the tree. The hash is inserted into  
a leaf of the tree and that leaf is marked as dirty. The tree is not  
updated at this time. Future operations on the tree should used the  
tree returend by this fucntion.</p>
 
  <p>Insert takes the following options:
    * if_missing - if <code>true</code> then the hash is only inserted into the tree
                   if the key is not already present. This is useful for
                   ensuring writes concurrent with building the tree
                   take precedence over older values. <code>false</code> is the default
                   value.</p>
</div></div>
<div class="function">
<h3 id="update_snapshot/1">update_snapshot(Tree::tree()) -&gt; tree()</h3>


<div class="description">

<p>Snapshot the tree for updating. The return tree should be
  updated using <a href="#update_perform/1" class="seealso">update_perform/1</a> and to perform future operations
  on the tree</p>
</div></div>
<div class="function">
<h3 id="update_perform/1">update_perform(Tree::tree()) -&gt; ok</h3>


<div class="description">

<p>Update the tree with a snapshot obtained by <a href="#update_snapshot/1" class="seealso">update_snapshot/1</a>. This function may be called by a process other
  than the one managing the tree.</p>
</div></div>
<div class="function">
<h3 id="local_compare/1">local_compare(T1::tree(), T2::tree()) -&gt; [diff()]</h3>


<div class="description">

<p>Compare two local trees. This function is primarily for
  local debugging and testing.</p>
</div></div>
<div class="function">
<h3 id="compare/1">compare(LocalTree::tree(), RemoteFun::remote_fun(), HandlerFun::handler_fun(X), X) -&gt; X</h3>


<div class="description">

<p>Compare a local and remote tree.  <code>RemoteFun</code> is used to
  access the buckets and segments of nodes in the remote
  tree. <code>HandlerFun</code> will be called for each difference found in the
  tree. A difference is either a missing local or remote prefix, or a
  list of key differences, which themselves signify different or
  missing keys. <code>HandlerAcc</code> is passed to the first call of
  <code>HandlerFun</code> and each subsequent call is passed the value returned
  by the previous call. The return value of this function is the
  return value from the last call to <code>HandlerFun</code>.</p>
</div></div>
<div class="function">
<h3 id="top_hash/1">top_hash(Tree::tree()) -&gt; undefined | binary()</h3>


<div class="description">

<p>Returns the top-hash of the tree. This is the top-hash of the
  root node.</p>
</div></div>
<div class="function">
<h3 id="prefix_hash/1">prefix_hash(Prefixes::prefixes(), Tree::tree()) -&gt; undefined | binary()</h3>


<div class="description">

<p>Returns the top-hash of the node corresponding to the given
  prefix list. The length of the prefix list can be less than or
  equal to the height of the tree. If the tree has not been updated
  or if the prefix list is not found or invalid, then <code>undefined</code> is
  returned.  Otherwise the hash value from the most recent update is
  returned.</p>
</div></div>
<div class="function">
<h3 id="get_bucket/1">get_bucket(Prefixes::tree_node(), Level::integer(), Bucket::integer(), Tree::tree()) -&gt; orddict() (see module orddict)</h3>


<div class="description">

<p>Returns the <a href="hashtree.html" class="seealso">hashtree</a> buckets for a given node in the
  tree. This is used primarily for accessing buckets of a remote tree
  during compare.</p>
</div></div>
<div class="function">
<h3 id="key_hashes/1">key_hashes(Prefixes::tree_node(), Segment::integer(), Tree::tree()) -&gt; [{integer(), orddict() (see module orddict)}]</h3>


<div class="description">

<p>Returns the <a href="hashtree.html" class="seealso">hashtree</a> segment hashes for a given node
  in the tree.  This is used primarily for accessing key hashes of a
  remote tree during compare.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
