<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_kv_w_reduce (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_kv_w_reduce</h1>
<h2 class="modsummary">A pipe fitting that applies a function to a list of inputs,  
and sends the accumulated results downstream.</h2>
<div class="description">
<p>A pipe fitting that applies a function to a list of inputs,  
and sends the accumulated results downstream.  This module is  
intended to be used as the emulation of 'reduce' phases in Riak KV  
MapReduce.</p>
 
  <p>Upstream fittings should send each of their outputs separately.  
This worker will assemble them into a list and apply the function  
to that list.</p>
 
  <p>This fitting expects a 3-tuple of <code>{rct, Fun, Arg}</code>.  The <code>Fun</code>
  should be a function expecting two arguments: <code>Inputs :: list()</code>
  and <code>Arg</code>.  The fun should return a list as its result.  The
  function <a href="#reduce_compat/1" class="seealso">reduce_compat/1</a> should be used to transform the
  usual MapReduce phase spec (<code>{modfun, ...}</code>, '{jsanon, ...}', etc.)  
into the variety of function expected here.</p>
 
  <p>The default behavior is to apply the reduce function to the first
  20 inputs, and then apply the Fun to that result with the next 20
  inputs received cons'd on the front, and repeat this re-running
  untill finished.  Two knobs exist to change this behavior.  The
  first is <code>reduce_phase_batch_size</code>.  The property may be set by
  specifying <code>Arg</code> as a proplist, and providing a positive integer.
  For example, setting <code>Arg=[{reduce_phase_batch_size, 1}]</code>, if the
  inputs A, B, and C were received, evaluation would look something
  like:
  </p><pre class="sh_erlang">  X = Fun([A], Arg),
  Y = Fun([B,X], Arg),
  Z = Fun([C,Y], Arg)</pre>
 
  <p>Setting <code>Arg=[{reduce_phase_batch_size, 2}]</code>instead, with the same
  inputs would cause evaulation to look more like:
  </p><pre class="sh_erlang">  X = Fun([B,A], Arg),
  Y = Fun([C,X], Arg)</pre><p>
  The default batch size allowed is controlled by the riak_kv
  application environment variable <code>mapred_reduce_phase_batch_size</code></p>
 
  <p>The other knob to control batching behavior is known as
  <code>reduce_phase_only_1</code>.  If this option is set in the <code>Arg</code>
  proplist, the reduce function will be evaluated at most once.  That
  is, the example set of inputs from above would evaulate as:
  </p><pre class="sh_erlang">  X = Fun([C,B,A], Arg)</pre>
 
  <p>To use <code>reduce_phase_only_1</code> and <code>reduce_phase_batch_size</code> over the
  HTTP interface, specify a JSON structure as the function's
  argument, as in:
  </p><pre class="sh_erlang">  {...,"query":[...,{"reduce":{...,"arg":{"reduce_phase_batch_size":100}}}]}</pre><p>
  Or:
  </p><pre class="sh_erlang">  {...,"query":[...,{"reduce":{...,"arg":{"reduce_phase_only1":true}}}]}</pre><p>
  The HTTP interface will translate that argument into a mochijson2
  structure (e.g. <code>{struct, [{&lt;&lt;"reduce_phase_only_1"&gt;&gt;, true}]}</code>),  
which this fitting will understand.  This also provides a safe way  
to pass these arguments when using a reduce phase implemented in  
Javascript over the Protocol Buffer or native interfaces.  
Mochijson2 conversion will fail on the bare proplist, but will  
succeed at encoding this form.</p>
 
  <p>If no inputs are received before eoi, this fitting evaluated the
  function once, with an empty list as <code>Inputs</code>.</p>
 
  <p>For Riak KV MapReduce reduce phase compatibility, a chashfun that
  directs all inputs to the same partition should be used.  Multiple
  workers will reduce only parts of the input set, and produce
  multiple independent outputs, otherwise (note that this may be
  desirable in a "pre-reduce" phase).</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-state">state()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/1">init(Partition::partition() (see module riak_pipe_vnode), Fitting_details::details() (see module riak_pipe_fitting)) -&gt; {ok, state()}</h3>


<div class="description">

<p>Setup creates an empty list accumulator and
       stashes away the <code>Partition</code> and <code>FittingDetails</code> for later.</p>
</div></div>
<div class="function">
<h3 id="process/1">process(Input::term(), Last::boolean(), State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Evaluate the function if the batch is ready.</p>
</div></div>
<div class="function">
<h3 id="done/1">done(State::state()) -&gt; ok</h3>


<div class="description">

<p>Reduce any unreduced inputs, and then send on the outputs.</p>
</div></div>
<div class="function">
<h3 id="archive/1">archive(State::state()) -&gt; {ok, list()}</h3>


<div class="description">

<p>The archive is the accumulator.</p>
</div></div>
<div class="function">
<h3 id="handoff/1">handoff(HandoffAcc::list(), State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Handoff simply concatenates the accumulators from the remote
  worker with the accumulator from this worker, and then reduces if
  the resulting accumulator crosses the batch size threshold.</p>
</div></div>
<div class="function">
<h3 id="validate_arg/2">validate_arg(X1::{rct, function(), term()}) -&gt; ok | {error, iolist()}</h3>


<div class="description">

<p>Check that the arg is a valid arity-2 function.  See <a href="riak_pipe_v.html#validate_function/3" class="seealso">riak_pipe_v:validate_function/3</a>.</p>
</div></div>
<div class="function">
<h3 id="reduce_compat/1">reduce_compat(X1::reduce_query_fun() (see module riak_kv_mrc_pipe)) -&gt; function()</h3>


<div class="description">

<p>Compatibility wrapper for an old-school Riak MR reduce function,
       which is an arity-2 function <code>fun(InputList, SpecificationArg)</code>.</p>
</div></div>
<div class="function">
<h3 id="no_input_run_reduce_once/0">no_input_run_reduce_once() -&gt; term()
</h3>


<div class="description">

<p>True; this fitting should be started and stopped, even if
  no inputs were received (no normal workers were started).</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
