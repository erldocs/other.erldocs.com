<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_core_bucket_type (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_core_bucket_type</h1>
<h2 class="modsummary">Bucket Types allow groups of buckets to share configuration
  details.</h2>
<div class="description">
<p>Bucket Types allow groups of buckets to share configuration
  details.  Each bucket belongs to a type and inherits its
  properties. Buckets can override the properties they inherit using
  <a href="riak_core_bucket.html" class="seealso">riak_core_bucket</a>.  The "Default Bucket Type" always
  exists. The Default Type's properties come from the riak_core
  <code>default_bucket_props</code> application config, so the Default Type and  
its buckets continue to act as they had prior to the existence of  
Bucket Types.</p>
 
  <p>Unlike Buckets, Bucket Types must be explicitly created. In
  addition, types support setting some properties only on creation
  (via <a href="riak_core_bucket_props.html#validate/4" class="seealso">riak_core_bucket_props:validate/4</a>). Since, types are
  stored using <a href="riak_core_metadata.html" class="seealso">riak_core_metadata</a>, in order to provide safe  
creation semantics the following invariant must be satisfied: all  
nodes in the cluster either see no type or a single version of the  
type for the lifetime of the cluster (nodes need not see the single  
version at the same time). As part of ensuring this invariant, creation  
is a two-step process:</p>
 
    <p>1. The type is created and is inactive. To the node an inactive type       
does not exist    
2. When the creation has propogated to all nodes, the type may be activated.       
As the activation propogates, nodes will be able to use the type</p>
 
  <p>The first step is performed using <a href="#create/2" class="seealso">create/2</a>. The second by
  <a href="#activate/1" class="seealso">activate/1</a>.  After the type has been activated, some
  properties may be updated using <a href="#update/2" class="seealso">update/2</a>. All operations are
  serialized through <a href="riak_core_claimant.html" class="seealso">riak_core_claimant</a> except reading bucket
  type properties with <a href="#get/1" class="seealso">get/1</a>.</p>
 
  <p>Bucket types can be in one of four states. The
  state of a type can be queried using <a href="#status/1" class="seealso">status/1</a>.</p>
 
    <p>1. undefined - the type has not been created    
2. created - the type has been created but has not propogated to all nodes    
3. ready - the type has been created and has propogated to all nodes but               
has not been activated    
4. active - the Bucket Type has been activated, but the activation may                
not have propogated to all nodes yet</p>
 
  <p>In order for the invariant to hold, additional restrictions are
  placed on the operations, generally and based on the state of the
  Bucket Type. These restrictions are in-place to ensure safety
  during cases where membership changes or node failures change the
  <a href="riak_core_claimant.html" class="seealso">riak_core_claimant</a> to a new node -- ensuring concurrent  
updates do not break the invariant.</p>
 
    <p>* calling <a href="#create/1" class="seealso">create/1</a> multiple times before a Bucket Type
      is active is allowed. The newer creation will supersede any
      previous ones. In addition, the type will be "claimed" by the
      <a href="riak_core_claimant.html" class="seealso">riak_core_claimant</a> node writing the property. Future
      calls to <a href="#create/1" class="seealso">create/1</a> must be serialized through the same
      claimant node or the call will not succeed. In the case where
      the claimed type fails to propogate to a new claimant during a
      a failure the potential concurrent update is resolved with
      last-write-wins. Since nodes can not use inactive types, this is
      safe.
    * A type may only be activated if it is in the <code>ready</code> state. This means
      all nodes must be reachable from the claimant
    * <a href="#create/1" class="seealso">create/1</a> will fail if the type is active. Activation concurrent
      with creation is not possible due to the previous restriction
    * <a href="#update/1" class="seealso">update/1</a> will fail unless the type is updated. <a href="#update/1" class="seealso">update/1</a> does      
not allow modifications to properties for which the invariant must hold      
(NOTE: this is up to the implementor of the riak_core bucket_validator).</p>
 
  <p>There is one known case where this invariant does not hold:
     * in the case where a singleton cluster activates a type before being joined
       to a cluster that has activated the same type. This is a case poorly handled
       by most riak_core applications and is considered acceptable (so dont do it!).</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-bucket_type">bucket_type() = binary()</h3></div>
    <div class="type"><h3 id="type-bucket_type_props">bucket_type_props() = [{term(), term()}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="defaults/0">defaults() -&gt; bucket_type_props()</h3>


<div class="description">

<p>The hardcoded defaults for all bucket types.</p>
</div></div>
<div class="function">
<h3 id="defaults/1">defaults(X1::default_type) -&gt; bucket_type_props()</h3>


<div class="description">

<p>The hardcoded defaults for the legacy, default bucket
  type. These find their way into the <code>default_bucket_props</code>
  environment variable</p>
</div></div>
<div class="function">
<h3 id="create/1">create(BucketType::bucket_type(), Props::bucket_type_props()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Create the type. The type is not activated (available to nodes) at this time. This
  function may be called arbitratily many times if the claimant does not change between
  calls and the type is not active. An error will also be returned if the properties
  are not valid. Properties not provided will be taken from those returned by</p>
<p><em>See also:</em> <a href="#defaults/0" class="seealso">defaults/0</a>.</p>
</div></div>
<div class="function">
<h3 id="status/1">status(BucketType::bucket_type()) -&gt; undefined | created | ready | active</h3>


<div class="description">

<p>Returns the state the type is in.</p>
</div></div>
<div class="function">
<h3 id="activate/1">activate(BucketType::bucket_type()) -&gt; ok | {error, undefined | not_ready}</h3>


<div class="description">

<p>Activate the type. This will succeed only if the type is in the <code>ready</code> state. Otherwise,
  an error is returned.</p>
</div></div>
<div class="function">
<h3 id="update/1">update(BucketType::bucket_type(), Props::bucket_type_props()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Update an existing bucket type. Updates may only be performed
  on active types. Properties not provided will keep their existing
  values.</p>
</div></div>
<div class="function">
<h3 id="get/1">get(BucketType::bucket_type()) -&gt; undefined | bucket_type_props()</h3>


<div class="description">

<p>Return the properties associated with the given bucket type.</p>
</div></div>
<div class="function">
<h3 id="reset/1">reset(BucketType::bucket_type()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Reset the properties of the bucket. This only affects properties that
  can be set using <a href="#update/2" class="seealso">update/2</a> and can only be performed on an active  
type.</p>
 
  <p>This is not currently hooked into <code>riak-admin</code> but can be invoked
  from the console.</p>
</div></div>
<div class="function">
<h3 id="iterator/0">iterator() -&gt; iterator() (see module riak_core_metadata)</h3>


<div class="description">

<p>Return an iterator that can be used to walk through all existing bucket types
  and their properties</p>
</div></div>
<div class="function">
<h3 id="itr_next/1">itr_next(It::iterator() (see module riak_core_metadata)) -&gt; iterator() (see module riak_core_metadata)</h3>


<div class="description">

<p>Advance the iterator to the next bucket type. itr_done/1 should always be called
  before this function</p>
</div></div>
<div class="function">
<h3 id="itr_done/1">itr_done(It::iterator() (see module riak_core_metadata)) -&gt; boolean()</h3>


<div class="description">

<p>Returns true if there are no more bucket types to iterate over</p>
</div></div>
<div class="function">
<h3 id="itr_value/1">itr_value(It::iterator() (see module riak_core_metadata)) -&gt; {bucket_type(), bucket_type_props()}</h3>


<div class="description">

<p>Returns the type and properties that the iterator points too. Any siblings,
  are resolved at this time. itr_done/1 should be checked before calling this function.</p>
</div></div>
<div class="function">
<h3 id="itr_close/1">itr_close(It::iterator() (see module riak_core_metadata)) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="property_hash/1">property_hash(Type::bucket_type(), PropKeys::[term()]) -&gt; undefined | integer()</h3>


<div class="description">

<p>Returns a hash of a specified set of bucket type properties
  whose values may have implications on the treatment or handling of
  buckets created using the bucket type.</p>
</div></div>
<div class="function">
<h3 id="property_hash/1-1">property_hash(Type::bucket_type(), PropKeys::[term()], Props::undefined | bucket_type_props()) -&gt; undefined | integer()</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
