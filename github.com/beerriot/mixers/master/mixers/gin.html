<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gin (mixers) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gin</h1>
<h2 class="modsummary">Function-based generators.</h2>
<div class="description">
<p>Function-based generators.</p>
 
       <p>Sometimes building a list simply to have something to iterate
       along is annoying, wasteful, or impossible.  For those
       situations, consider <code>gin</code>.</p>
 
       <p>A gin is a function of zero arity.  When evaluated, it
       produces the "next" item, and a new gin (as a 2-tuple <code>{Item,
       Gin}</code>).  When the gin has nothing more to produce, the result
       of its evaluation should be the atom <code>stop</code>.</p>
 
       <p>The <a href="#seq/2" class="seealso">seq/2</a> function provides a nice example.  Calling
       it with the arguments 1 and 3 produces a gin that will
       evaluate to 1, 2, and 3, before stopping:
  </p><pre class="sh_erlang">  First       = gin:seq(1, 3).    % create a new gin
  {1, Second} = gin:next(First).  % get the first value
  {2, Third}  = gin:next(Second). % get the second value
  {3, Fourth} = gin:next(Third).  % get the third value
  stop        = gin:next(Fourth).</pre>
 
       <p>Remember that gins are functions, so they can do anything:       
compute pure values, receive messages, print output, receive       
input, etc.  The functions in this module have no side effects       
themselves, so it's up to the caller to determine whether they       
stay that way.</p>
 
       <p>SICP readers will recognize this construction as "streams"
       (a.k.a "delayed lists" or "lazy lists") from section 3.5.
  <url href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5</url></p>
 
       <p>Source code may be viewed at
       <url href="http://github.com/beerriot/mixers/blob/master/src/gin.erl">http://github.com/beerriot/mixers/blob/master/src/gin.erl</url></p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-gin">gin() = <a href="#type-gin_t" class="seealso">gin_t</a>(term())</h3></div>
    <div class="type"><h3 id="type-gin_t">gin_t/0</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="make/1">make(Fun::() -&gt; term()) -&gt; gin()</h3>


<div class="description">

<p>Turn a zero-arity function into an infinite gin.  Each time       
the gin is evaluated, the function is called.</p>
 
       <p>That is, calling <code>make(Fun)</code> creates a gin that produces the
       values <code>Fun()</code>, <code>Fun()</code>, <code>Fun()</code>, ...</p>
 
       <p>This could be useful for setting up a dumb message
       intermediary:
  </p><pre class="sh_erlang">  Dest = find_destination_pid(),
  LogFwd = fun(Msg) -&gt;
              error_logger:info_msg("Message: ~p", [Msg]),
              Dest ! Msg
           end,
  Rcv = fun() -&gt; receive Any -&gt; Any end end,
  I = spawn(gin, foreach, [LogFwd, gin:make(Rcv)]).</pre><p>
       Sending any message to <code>I</code> should print the message to SASL,
       and then forward it to <code>Dest</code>.</p>
</div></div>
<div class="function">
<h3 id="make_n/1">make_n(Fun::(number()) -&gt; term(), Start::number(), Step::number()) -&gt; gin()</h3>


<div class="description">

<p>Turn an arity-1 function into an infinite gin.  Each time the
       gin is evaluated, the function is evaluated on the value of
       <code>Start + Step * (number of previous evaluations)</code>.</p>
 
       <p>For example, calling this function as <code>make_n(Fun, 0, 1)</code>
       would create a gin that produced the values <code>Fun(0)</code>,
       <code>Fun(1)</code>, <code>Fun(2)</code>, ...</p>
 
       <p>This could be used to add ordinals to the messages in the
       intermediary example of <a href="#make/1" class="seealso">make/1</a>, by substituting:
  </p><pre class="sh_erlang">  ... LogFwd from make/1 example ...
  Rcv = fun(N) -&gt; receive Any -&gt; {N, Any} end end,
  I = spawn(gin, foreach, [LogFwd, gin:make_n(Rcv, 1, 1)]).</pre>
</div></div>
<div class="function">
<h3 id="make_acc/1">make_acc(Fun::(term()) -&gt; term(), Base::term()) -&gt; gin()</h3>


<div class="description">

<p>Turn an arity-1 function into an infinite gin.  Each time the
       gin is evaluated, the function is evaluation on its previous
       evaluation's output, or on the <code>Base</code> argument during the       
first evaluation.</p>
 
       <p>Put another way, calling this function as <code>make_acc(Fun,
       Base)</code> creates a gin that returns the values <code>Fun(Base)</code>,
       <code>Fun(Fun(Base))</code>, <code>Fun(Fun(Fun(Base)))</code>, ... .  Though, the
       re-evaluation implied by that description does not happen
       (<code>Fun(Base)</code> is only evaluated once).</p>
 
       <p>This could be used, for example, as the framework for a
       psuedorandom number gin-erator (George Marsaglia's Xorshift,
       in this case):
  </p><pre class="sh_erlang">  Xor128 = fun({X,Y,Z,W0}) -&gt;
              T = X bxor (X bsl 15),
              W1 = 16#FFFFFFFFFFFFFFFF band
                      ((W0 bxor (W0 bsr 21)) bxor (T bxor (T bsr 4))),
              {Y, Z, W0, W1}
           end,
  Seed = {7950130472521745565,10955255568897125814,
          4054168878756629592,3856359273729777771},
  GR0 = gin:make_acc(Xor128, Seed),
  {{_,_,_,13671966243293953624},GR1} = gin:next(GR0),
  {{_,_,_,1896413306210138800}, GR2} = gin:next(GR1),
  {{_,_,_,11344635856470842258},GR3} = gin:next(GR2).</pre>
</div></div>
<div class="function">
<h3 id="fold/1">fold(Fun::(Val::term(), Acc::term()) -&gt; NewAcc::term(), Init::term(), Gin::gin()) -&gt; term()</h3>


<div class="description">

<p>Fold over a gin, accumulating a result.  <code>Fun</code> is called once
       for each item the gin produces, as <code>Fun(Item, Accumulator)</code>.
       <code>Init</code> is passed as the accumulator for the first call.</p>
 
       <p>For example, "sum" might be defined as:
  </p><pre class="sh_erlang">  sum(Gin) -&gt;
      fold(fun erlang:'+'/2, 0, Gin).</pre>
</div></div>
<div class="function">
<h3 id="map/1">map(Fun::(term()) -&gt; term(), Gin::gin()) -&gt; gin()</h3>


<div class="description">

<p>Map over a gin, producing a new gin with each item being the
       result of the application <code>Fun(Item)</code>.  The input gin is not       
evaluated until something evaluates the output gin.</p>
 
       <p>For example, "double" might be implemented as:
  </p><pre class="sh_erlang">  double(Gin) -&gt;
     map(fun(I) -&gt; io:format("x"), I*2 end, Gin).</pre><p>
       But its side-effect behavior would be:
  </p><pre class="sh_erlang">  1&gt; Single = gin:seq(1,3).
  #Fun&lt;gin.5.58311043&gt;
  2&gt; Double = double(Single).
  #Fun&lt;gin.0.51198227&gt;
  3&gt; gin:to_list(Double).
  xxx[2,4,6]</pre><p>
       (Note that the "x" characters printed by the map function did
       not appear until the output gin was evaluated by
       <a href="#to_list/1" class="seealso">to_list/1</a>.)</p>
</div></div>
<div class="function">
<h3 id="filter/1">filter(Fun::(term()) -&gt; boolean(), Gin::gin()) -&gt; gin()</h3>


<div class="description">

<p>Filter a gin, producing a new gin that only produces those
       items for with <code>Fun(Item)</code> returns <code>true</code>.  The input gin is       
not evaluated until something evaluates the output gin.</p>
 
       <p>For example, "evens" might be implemented as:
  </p><pre class="sh_erlang">  evens(Gin) -&gt;
      filter(fun(X) -&gt; (X rem 2) =:= 0 end, Gin).</pre><p>
       See <a href="#map/2" class="seealso">map/2</a> for an example of the delayed-evaluation
       behavior.</p>
</div></div>
<div class="function">
<h3 id="foreach/1">foreach(Fun::(term()) -&gt; term(), Gin::gin()) -&gt; ok</h3>


<div class="description">

<p>Evaluate <code>Fun</code> for each item produced by <code>Gin</code>.</p>
 
       <p>For example, sending each item in a gin as a message to
       another process might be implemented as:
  </p><pre class="sh_erlang">  carrier(Pid, Gin) -&gt;
     foreach(fun(Item) -&gt; Pid ! Item end, Gin).</pre>
</div></div>
<div class="function">
<h3 id="sum/1">sum(Gin::gin_t(number())) -&gt; number()</h3>


<div class="description">

<p>Sum the items produced by a gin. This function assumes that
       the gin produces only numbers.
  </p><pre class="sh_erlang">  500000500000 = gin:sum(gin:seq(1, 1000000)).</pre>
</div></div>
<div class="function">
<h3 id="from_list/1">from_list(Rest::list()) -&gt; gin()</h3>


<div class="description">

<p>Create a gin that produces the items from a list, in order.</p>
 
       <p>The similarities can be seen in this snippet:
  </p><pre class="sh_erlang">  [Head|RestList] = List.
  {Head,RestGin}  = next(from_list(List)).
  stop            = next(from_list([])).</pre>
</div></div>
<div class="function">
<h3 id="to_list/1">to_list(Gin::gin()) -&gt; list()</h3>


<div class="description">

<p>Create a list containing the items produced by a gin, in order.
       </p><pre class="sh_erlang">          List = to_list(from_list(List))</pre>
</div></div>
<div class="function">
<h3 id="seq/1">seq(Start::number(), Finish::number()) -&gt; gin_t(number())</h3>


<div class="description">

<p>Create a gin that produces the numbers from <code>Start</code> to
       <code>Finish</code>, incrementing by 1 each time if <code>Start</code> is less than
       or equal to <code>Finish</code>, or decrementing by 1 each time if
       <code>Start</code> is less that <code>Finish</code>.
  </p><pre class="sh_erlang">  [1,2,3,4,5] = gin:to_list(gin:seq(1, 5)).
  [5,4,3,2,1] = gin:to_list(gin:seq(5, 1)).</pre>
</div></div>
<div class="function">
<h3 id="seq/1-1">seq(Start::number(), Finish::number(), Incr::number()) -&gt; gin_t(number())</h3>


<div class="description">

<p>Create a gin that produces a sequence of numbers, starting
       with <code>Start</code>, and incrementing by <code>Incr</code>, and finishing before
       producing any number past <code>Finish</code> (where "past" means "less
       than" if <code>Incr</code> is negative, or "greater than" if <code>Incr</code> is
       positive).
  </p><pre class="sh_erlang">  [1,11,21,31,41] = gin:to_list(gin:seq(1, 42, 10)).
  [1,-9,-19,-29,-39] = gin:to_list(gin:seq(1, -42, -10)).</pre>
</div></div>
<div class="function">
<h3 id="next/1">next(Gin::gin()) -&gt; stop | {term(), gin()}</h3>


<div class="description">

<p>Get the next value to be produced by a gin, and a handle to
       the next invocation of that gin.  The atom <code>stop</code> is returned
       instead, if the gin had nothing more to produce.  See the example
       use with <a href="#from_list/1" class="seealso">from_list/1</a>.</p>
</div></div>
<div class="function">
<h3 id="zip/1">zip(Gin1::gin(), Gin2::gin()) -&gt; gin_t({term(), term()})</h3>


<div class="description">
<p>Equivalent to <a href="#zip/1" class="seealso">zip([Gin1, Gin2])</a>.</p>
</div></div>
<div class="function">
<h3 id="zip/1-1">zip(Gins::[gin()]) -&gt; gin_t(tuple())</h3>


<div class="description">
<p>Equivalent to <a href="#zipwithl/2" class="seealso">zipwithl(fun erlang:list_to_tuple/1, Gins)</a>.</p>
</div></div>
<div class="function">
<h3 id="zipwithl/1">zipwithl(Fun::([term()]) -&gt; term(), Gins::[gin()]) -&gt; gin_t(tuple())</h3>


<div class="description">

<p>Zip N gins together into a new gin. Evaluating the new gin
       will evaluate the <code>Combine</code> function on a list containing one
       evaluation of each component gin, and produce that result.
  </p><pre class="sh_erlang">  Gin1 = gin:from_list([a,b,c]).
  Gin2 = gin:from_list([1,2,3]).
  Gin3 = gin:from_list(["x","y","z"]).
  GinC = gin:zipwithl(fun erlang:list_to_tuple/1, [Gin1, Gin2, Gin3]).
  { {a,1,"x"}, GinCC } = GinC().
  { {b,2,"y"}, GinCCC} = GinCC().
  { {c,3,"z"}, GinCCCC} = GinCCC().
  stop = GinCCCC().</pre>
</div></div>
<div class="function">
<h3 id="zipwitha/1">zipwitha(Fun::function(), Gins::[gin()]) -&gt; gin_t(tuple())</h3>


<div class="description">

<p>Zip N gins together into a new gin. Evaluating the new gin
       will apply the <code>Combine</code> function to the first evaluation of
       each component gin, and produce that result.
  </p><pre class="sh_erlang">  Gin1 = gin:from_list([a,b,c]).
  Gin2 = gin:from_list([1,2,3]).
  Gin3 = gin:from_list(["x","y","z"]).
  GinC = gin:zipwitha(fun(P,Q,R) -&gt; {P, Q, R} end, [Gin1, Gin2, Gin3]).
  { {a,1,"x"}, GinCC } = GinC().
  { {b,2,"y"}, GinCCC} = GinCC().
  { {c,3,"z"}, GinCCCC} = GinCCC().
  stop = GinCCCC().</pre>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
