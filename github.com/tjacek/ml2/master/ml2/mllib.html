<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>mllib (ml2) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>mllib</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-attribute">attribute() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#attribute{name = <a href="#type-name" class="seealso">name()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = <a href="#type-attribute_type" class="seealso">attribute_type()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values = [<a href="#type-value" class="seealso">value()</a>]}</h3></div>
    <div class="type"><h3 id="type-attribute_type">attribute_type() = nominal | ordered | continuous</h3></div>
    <div class="type"><h3 id="type-category">category() = <a href="#type-name" class="seealso">name()</a></h3></div>
    <div class="type"><h3 id="type-class">class() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#class{name = <a href="#type-name" class="seealso">name()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description = string(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;categories = [<a href="#type-category" class="seealso">category()</a>]}</h3></div>
    <div class="type"><h3 id="type-classifier">classifier() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#classifier{algorithm = atom(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class = <a href="#type-class" class="seealso">class()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specific_classifier = any()}</h3></div>
    <div class="type"><h3 id="type-example">example() = tuple()</h3></div>
    <div class="type"><h3 id="type-name">name() = atom() | integer()</h3></div>
    <div class="type"><h3 id="type-training_example">training_example() = {<a href="#type-example" class="seealso">example()</a>, <a href="#type-category" class="seealso">category()</a>}</h3></div>
    <div class="type"><h3 id="type-value">value() = atom() | integer() | float()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="learn_naive/6">learn_naive(Attributes, Class, TrainingExamples, Algorithm, Options, Nodes) -&gt; {ok, Classifier} | {error, Reason}</h3>

<ul class="type">
<li><code>Attributes = [attribute()]</code></li><li><code>Class = class() | name()</code></li><li><code>TrainingExamples = [training_example()]</code></li><li><code>Algorithm = atom()</code></li><li><code>Options = [Option]</code></li><li><code>Option = any()</code></li><li><code>Nodes = [node()]</code></li><li><code>Classifier = classifier()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>See learn for details. This won't start ets tables on nodes.</p>
</div></div>
<div class="function">
<h3 id="learn/5">learn(Attributes, Class, TrainingExamples, Algorithm, Options) -&gt; {ok, Classifier} | {error, Reason}</h3>

<ul class="type">
<li><code>Attributes = [attribute()]</code></li><li><code>Class = class() | name()</code></li><li><code>TrainingExamples = [training_example()]</code></li><li><code>Algorithm = atom()</code></li><li><code>Options = [Option]</code></li><li><code>Option = any()</code></li><li><code>Classifier = classifier()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Creates a classifier for a Class using Algorithm. TrainingExamples should as desribed in Attributes and be classified to class from Class. Algorithm should be an atom() specifying the proper module. Options are passed to an Algorithm and are specified by the Algorithm documentation. Returned Classifier is closely related to the Algorithm. <br />Algorithm module should export <code>learn(Attributes, Class, TrainingExamples, Options)</code>. <br /> You can pass the additional options for both arguments correctness checking and for the learning algorithm itself. Note that unrecognized options will be ignored. <br /> The arguments correctness checking Options are: </p><list><item><p><code>no_check</code> - there will be no arguments correctness checkings</p></item><item><p><code>attributes_ok</code> - there will be no Attributes correctness checking</p></item><item><p><code>class_ok</code> - there will be no Class correctness checking</p></item><item><p><code>trainingexamples_ok</code> - there will be no TrainingExamples correctness checking</p></item></list><p><br /> <i>author:</i> beben, kumateusz</p>
</div></div>
<div class="function">
<h3 id="learn/6">learn(Attributes, Class, TrainingExamples, Algorithm, Options, Nodes) -&gt; {ok, Classifier} | {error, Reason}</h3>

<ul class="type">
<li><code>Attributes = [attribute()]</code></li><li><code>Class = class() | name()</code></li><li><code>TrainingExamples = [training_example()]</code></li><li><code>Algorithm = atom()</code></li><li><code>Options = [Option]</code></li><li><code>Option = any()</code></li><li><code>Nodes = [node()]</code></li><li><code>Classifier = classifier()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Creates a classifier for a Class using Algorithm. TrainingExamples should as desribed in Attributes and be classified to class from Class. Algorithm should be an atom() specifying the proper module. Options are passed to an Algorithm and are specified by the Algorithm documentation. Nodes array consists of nodes that are to be used in computation. Returned Classifier is closely related to the Algorithm. <br />Algorithm module should export <code>learn(Attributes, Class, TrainingExamples, Options)</code>. <br /> You can pass the additional options for both arguments correctness checking and for the learning algorithm itself. Note that unrecognized options will be ignored. <br /> The arguments correctness checking Options are: </p><list><item><p><code>no_check</code> - there will be no arguments correctness checkings</p></item><item><p><code>attributes_ok</code> - there will be no Attributes correctness checking</p></item><item><p><code>class_ok</code> - there will be no Class correctness checking</p></item><item><p><code>trainingexamples_ok</code> - there will be no TrainingExamples correctness checking</p></item></list><p><br /> <i>author:</i> beben, kumateusz</p>
</div></div>
<div class="function">
<h3 id="mine/4">mine(Data, Algorithm::Module, Options, Nodes) -&gt; {ok, Result} | {error, Reason}</h3>

<ul class="type">
<li><code>Data = [[any()]]</code></li><li><code>Module = atom()</code></li><li><code>Options = [any()]</code></li><li><code>Nodes = [node()]</code></li><li><code>Result = any()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Data Mining in the given data. Implemented modules are : apriori <br /> <i>author:</i> beben, kumateusz</p>
</div></div>
<div class="function">
<h3 id="mine/3">mine(Data, Algorithm::Module, Options) -&gt; {ok, Result} | {error, Reason}</h3>

<ul class="type">
<li><code>Data = [[any()]]</code></li><li><code>Module = atom()</code></li><li><code>Options = [any()]</code></li><li><code>Result = any()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Data Mining in the given data. Implemented modules are : apriori <br /> <i>author:</i> beben, kumateusz</p>
</div></div>
<div class="function">
<h3 id="classify/3">classify(Classifier, Example, Options) -&gt; {ok, Category} | {error, Reason}</h3>

<ul class="type">
<li><code>Classifier = classifier()</code></li><li><code>Algorithm = atom()</code></li><li><code>Example = example()</code></li><li><code>Category = category()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Clasifies given Example of Attributes using Algorithm related with Classifier. Algorithm ahould be an atom() specifying the proper module. Classifier has to match the Algorithm. Example should contain values described in Attributes. <br />Algorithm module should export <code>classify(Attributes, Classifier, Example, Options)</code>. <br /> <i>author:</i> beben</p>
</div></div>
<div class="function">
<h3 id="transform_attributes/5">transform_attributes(Type, Attributes, Class, TrainingExamples, Options) -&gt; {NewAttributes, Transformer} | {error, Reason}</h3>

<ul class="type">
<li><code>Type = atom()</code></li><li><code>Attributes = [attribute()]</code></li><li><code>Class = class()</code></li><li><code>TrainingExamples = [training_example()]</code></li><li><code>Options = [any()]</code></li><li><code>NewAttributes = [attribute()]</code></li><li><code>Transformer = transformer</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Returns new definition of attributes NewAttributes and Transformer- the structure that is used to transform (training) examples. The possible Type values are : * discrete.</p>
</div></div>
<div class="function">
<h3 id="transform_example/2">transform_example(Transformer, Example) -&gt; TransformedExample | {error, Reason}</h3>

<ul class="type">
<li><code>Transformer = transformer()</code></li><li><code>Example = training_example() | example()</code></li><li><code>TransformedExample = training_example() | example()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Returns the example(or Training Example) transformed into new definition.</p>
</div></div>
<div class="function">
<h3 id="read_attributes/3">read_attributes(Filename, X2::Format, X3::Options) -&gt; {ok, Attributes} | {error, Reason}</h3>

<ul class="type">
<li><code>Filename = [any()]</code></li><li><code>Attributes = [attribute()]</code></li><li><code>Format = xml | arff</code></li><li><code>Options = [any()]</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Parses XML file containing attributes definition and returns ready to use Attributes. <br /> <i>author:</i> matis</p>
</div></div>
<div class="function">
<h3 id="read_classes/3">read_classes(Filename, X2::Format, Options) -&gt; {ok, Classes} | {error, Reason}</h3>

<ul class="type">
<li><code>Filename = [any()]</code></li><li><code>Classes = [class()]</code></li><li><code>Attributes = [attribute()]</code></li><li><code>Format = xml | arff</code></li><li><code>Options = [any()]</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">
<p><em>This function is deprecated: </em>Use <a href="#read/3" class="seealso">read/3</a> instead.</p>

<p>Parses XML file containing classes definition and returns a list of classes. <br /> <i>author:</i> matis</p>
</div></div>
<div class="function">
<h3 id="read/2">read(X1::Format, Options) -&gt; {Attributes, TrainingExamples} | {error, Reason::atom()}</h3>

<ul class="type">
<li><code>Format = xml | arff</code></li><li><code>Options = [any()]</code></li><li><code>Attributes = [attribute()]</code></li><li><code>TrainingExamples = [example()]</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Read attributes and training examples without specifying class. If chosen format is xml or c45, then two  options are required: <br /> - <code>{attributes, Filename}</code> - File containing attributes <br /> - <code>{tes, Filename}</code> - File containing training examples <br /> ARFF requires one option: <br /> - <code>{file, Filename}</code> - File containing both attributes and data</p>
</div></div>
<div class="function">
<h3 id="read/3">read(X1::Format, Classname, Options) -&gt; {Attributes, Class, TrainingExamples} | {error, Reason::atom()}</h3>

<ul class="type">
<li><code>Format = xml | arff</code></li><li><code>Classname = atom()</code></li><li><code>Options = [any()]</code></li><li><code>Attributes = [attribute()]</code></li><li><code>Class = class()</code></li><li><code>TrainingExamples = [example()]</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Read attributes and training examples with specified class. If chosen format is xml or c45, then two  options are required: <br /> - <code>{attributes, Filename}</code> - File containing attributes <br /> - <code>{tes, Filename}</code> - File containing training examples <br /> ARFF requires one option: <br /> - <code>{file, Filename}</code> - File containing both attributes and data <br /> If chosen format is c45, then Classname is ignored, as class is specified within attributes file.</p>
</div></div>
<div class="function">
<h3 id="read_mine_data/1">read_mine_data(Filename) -&gt; term()
</h3>


<div class="description">

<p>Loads data for Data Mining from CSV file.</p>
</div></div>
<div class="function">
<h3 id="read_examples/1">read_examples(Filename) -&gt; {ok, Examples} | {error, Reason}</h3>

<ul class="type">
<li><code>Filename = string()</code></li><li><code>Examples = [example()]</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Reads Examples from CSV Filename. The function is unaware of Attributes definitions. <br /> <i>author:</i> beben</p>
</div></div>
<div class="function">
<h3 id="read_trainingexamples/1">read_trainingexamples(Filename) -&gt; {ok, TrainingExamples} | {error, Reason}</h3>

<ul class="type">
<li><code>Filename = string()</code></li><li><code>TrainingExamples = [training_example()]</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Reads TrainingExamples from CSV Filename. The function is unaware of Attributes or Class definitions. <br /> <i>author:</i> beben</p>
</div></div>
<div class="function">
<h3 id="write_classifier/2">write_classifier(Filename, Classifier) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Filename = string()</code></li><li><code>Classifier = classifier()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Writes classifier to Filename. Classifier is human readable. <br /> <i>author:</i> beben</p>
</div></div>
<div class="function">
<h3 id="read_classifier/1">read_classifier(Filename::string()) -&gt; {ok, Classifier} | {error, Reason}</h3>

<ul class="type">
<li><code>Classifier = classifier()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Reads classifier from Filename. Classifier is human readable. <br /> <i>author:</i> beben</p>
</div></div>
<div class="function">
<h3 id="choose_class/3">choose_class(Attributes, TrainingExamples, ClassName) -&gt; {NewAttributes, Class, NewTrainingExamples} | {error, Reason}</h3>

<ul class="type">
<li><code>Attributes = [attribute()]</code></li><li><code>TrainingExamples = [example()]</code></li><li><code>ClassName = name()</code></li><li><code>NewAttributes = [attribute()]</code></li><li><code>Class = class()</code></li><li><code>NewTrainingExamples = [training_example()]</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Removes the Attribute with name ClassName from the Attributes, reinterprets this Attribute as Class and changes TrainingExamples allowing them to be used in the Class learning. Returns the NewAttributes and NewTrainingExamples that can be used during learning process. Attribute chosen as a Class has to be of nominal or ordered type.</p>
</div></div>
<div class="function">
<h3 id="supervisor_spawner/6">supervisor_spawner(Pid, Algorithm, Fun, Args, Nodes, X6) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="supervisor_spawner/5">supervisor_spawner(Pid, Algorithm, Fun, Args, Nodes) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
