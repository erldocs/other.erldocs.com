<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>empdb (empdb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>empdb</h1>
<h2 class="modsummary">
   This is the primary entry point for the EMP Database server.</h2>
<div class="description">
<p>
   This is the primary entry point for the EMP Database server. All callbacks
   are handled here and in subsequent backends.
   <br /><br />
   EMPDB is merely a wrapper module that calls through to the actual
   implementation of the database. This makes it fairly simple to swap out
   your own solution for EMP's database. The way this works is through macros
   that the preprocessor with swap out with the currently used database
   modules.
   <br /><br />
   If you want to implement your own backend, just swap out the macros at the
   of empdb.erl with your own packages and recompile empdb. Hotswaping the
   databases is as easy as reloading the new version of empdb, it will
   automatically redirect call throughs.
   <br /><br />
   You do not have to hotswap all of empdb if you need to fix a particular
   function in your backend, just hotswap the individual module. Call
   throughs will happen like normal.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-BINARYSTRING">BINARYSTRING() = binary()</h3></div>
    <div class="type"><h3 id="type-EMPCOMMAND">EMPCOMMAND() = #command{pid=undefined | UUID(), cid=undefined | UUID(), name=undefined | BINARYSTRING(), func=undefined | function(), dparams=[EMPPARAM()], rettype=undefined | EMPTYPEDEF()}</h3></div>
    <div class="type"><h3 id="type-EMPEVENT">EMPEVENT() = #command{pid=undefined | UUID(), cid=undefined | UUID(), name=undefined | BINARYSTRING(), func=undefined | function(), dparams=[EMPPARAM()], rettype=undefined | EMPTYPEDEF()}</h3></div>
    <div class="type"><h3 id="type-EMPPARAM">EMPPARAM() = #param{name=undefined | BINARYSTRING(), default=undefined | json_valid_value(), type=undefined | EMPTYPEDEF()}</h3></div>
    <div class="type"><h3 id="type-EMPPLUGINDEF">EMPPLUGINDEF() = #plugindef{id=undefined | UUID(), module=undefined | atom(), state=undefined | [{BINARYSTRING(), any()}], commands=undefined | EMPCOMMAND()}</h3></div>
    <div class="type"><h3 id="type-EMPSUBSCRIPTION">EMPSUBSCRIPTION() = #subscription{event=undefined | EMPEVENT(), command=undefined | EMPCOMMAND(), temp=boolean(), mapping=[tuple()]}</h3></div>
    <div class="type"><h3 id="type-EMPTYPEDEF">EMPTYPEDEF() = [0..3] | [4..5 | EMPTYPEDEF()] | [6 | atom()] | [7 | binary()] | [8] | [9 | atom() | EMPTYPEDEF()]</h3></div>
    <div class="type"><h3 id="type-EMPUSER">EMPUSER() = #user{uid=undefined | UUID(), name=BINARYSTRING()}</h3></div>
    <div class="type"><h3 id="type-UUID">UUID() = binary()</h3></div>
    <div class="type"><h3 id="type-json_valid_value">json_valid_value() = null<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| boolean()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| integer()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| float()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {[{binary(), <a href="#type-json_valid_value" class="seealso">json_valid_value()</a>}]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<a href="#type-json_valid_value" class="seealso">json_valid_value()</a>]</h3></div>
    <div class="type"><h3 id="type-nonempty_nodelist">nonempty_nodelist() = [atom(), ...]</h3></div>
    <div class="type"><h3 id="type-possible_failure">possible_failure(Success) = Success | {error, Reason::any()}</h3></div>
    <div class="type"><h3 id="type-user_option">user_option() = {password, RawPass :: binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {passhash, HashedPass :: binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {override_uuid, UUID :: binary()}</h3></div>
    <div class="type"><h3 id="type-useroptions">useroptions() = [<a href="#type-user_option" class="seealso">user_option()</a>, ...]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/0">start() -&gt; ok</h3>


<div class="description">

<p>Utility function for calling application:start/1 on empdb.</p>
</div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; ok</h3>


<div class="description">

<p>Utility function for calling application:stop/1 on empdb.</p>
</div></div>
<div class="function">
<h3 id="gen_uuid/0">gen_uuid() -&gt; binary()</h3>


<div class="description">

<p>Follows RFC4122 for generating UUIDs version 4 via Random Numbers.
  This function will perform fairly poorly on a 32 bit vm as the random
  number generation range is larger than the 28 bit word space on 32 bit
  machines. www.erlang.org/doc/efficiency_guide/advanced.html</p>
</div></div>
<div class="function">
<h3 id="gen_uuid2/0">gen_uuid2() -&gt; binary()</h3>


<div class="description">

<p>Just like gen_uuid/0 it generates UUIDs using version 4. However,
  the difference here is that it uses erlang's crypto module instead of
  the random module. It is a 'bit more random', but it takes twice as
  long on average.</p>
</div></div>
<div class="function">
<h3 id="start_link/1">start_link(Nodes::nonempty_nodelist(), Args::[tuple()]) -&gt; possible_failure({ok, pid()})</h3>


<div class="description">

<p>
   Starts the EMP DB system by calling the start_link/2 function on the
   specified backend module. This should return a PID of the running
   db server so that the application knows what to monitor.</p>
</div></div>
<div class="function">
<h3 id="verify/1">verify(Nodes::nonempty_nodelist(), Options::[tuple()]) -&gt; ok | {install, nonempty_nodelist()} | {error, continue | shutdown, Reason::any()}</h3>


<div class="description">

<p>
   Verify that your database is installed on at least one of the nodes
   and can be communicated to by all of them. This verification can take
   some time, as this is only called once on EMPDB startup.</p>
</div></div>
<div class="function">
<h3 id="install/1">install(Nodes::nonempty_nodelist(), Options::[tuple()]) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Install the database on a set of nodes with the set of options.
   This runs the install/2 call-through on the backend module. We
   separate this from verify/2 in case this needs to be run by hand.</p>
</div></div>
<div class="function">
<h3 id="get_root_user/0">get_root_user() -&gt; possible_failure(EMPUSER())</h3>


<div class="description">

<p>
   Return the Root user for the emp system.</p>
</div></div>
<div class="function">
<h3 id="add_user/1">add_user(Name::binary(), InfoOptions::useroptions()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Add a user to the database, this user will have access to
   all plugins and will have their own uman tree.</p>
</div></div>
<div class="function">
<h3 id="rm_user/1">rm_user(Name::binary()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Remove a user and all state for them (this includes plugin
   and system state). This function can not be reversed.</p>
</div></div>
<div class="function">
<h3 id="get_users/0">get_users() -&gt; possible_failure([EMPUSER()])</h3>


<div class="description">

<p>
   Gets the list of user objects stored in the database. This does
   NOT include the root user. So it is possible for an empty list
   to be returned if there are no other users in the system.</p>
</div></div>
<div class="function">
<h3 id="user_login/1">user_login(PUBKEY::binary()) -&gt; possible_failure({ok, EMPUSER(), UUID()})</h3>


<div class="description">

<p>
   Attempt to log a user in, using their public key. This should return
   a user whos public key has been registered with EMP.</p>
</div></div>
<div class="function">
<h3 id="user_login/1-1">user_login(UName::binary(), PHash::binary()) -&gt; possible_failure({ok, EMPUSER(), UUID()})</h3>


<div class="description">

<p>Standard login function using a username and a password hash.</p>
</div></div>
<div class="function">
<h3 id="user_logout/1">user_logout(SessionID::UUID()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>Log a user out using their session ID.</p>
</div></div>
<div class="function">
<h3 id="verify_session/1">verify_session(SessionId::UUID()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>Verify that a session is actually active and not fake.</p>
</div></div>
<div class="function">
<h3 id="add_subscription/1">add_subscription(User::EMPUSER(), TriggerPlug::EMPPLUGINDEF(), HandlePlug::EMPPLUGINDEF(), Subscription::EMPSUBSCRIPTION()) -&gt; possible_failure({ok, UUID()})</h3>


<div class="description">

<p>
   Add a subscription to be stored in the database for persistence.
   This function does not need to communicate with EMP.</p>
</div></div>
<div class="function">
<h3 id="rm_subscription/1">rm_subscription(SubscriptionId::UUID()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>Remove a particular subscription by its ID.</p>
</div></div>
<div class="function">
<h3 id="get_subscriptions/1">get_subscriptions(User::EMPUSER(), HandlePlug::EMPPLUGINDEF()) -&gt; possible_failure([EMPSUBSCRIPTION()])</h3>


<div class="description">

<p>
   Get all the subscriptions that a particular plugin needs to handle
   for a given user.</p>
</div></div>
<div class="function">
<h3 id="register_plugin/1">register_plugin(ModuleName::atom(), Info::[tuple()], Cmds::[EMPCOMMAND()], Events::[EMPEVENT()]) -&gt; possible_failure({ok, UUID()})</h3>


<div class="description">

<p>
   Register a plugin so that it gets an ID in the EMP system.</p>
</div></div>
<div class="function">
<h3 id="get_plugin_defs/1">get_plugin_defs(User::EMPUSER()) -&gt; possible_failure([EMPPLUGINDEF()])</h3>


<div class="description">

<p>
   Get all plugins for a particular user. Used at startup to initialize the
   system, so it can take longer.</p>
</div></div>
<div class="function">
<h3 id="get_target/1">get_target(User::EMPUSER(), Plugin::EMPPLUGINDEF()) -&gt; possible_failure(binary())</h3>


<div class="description">

<p>
   All users can specify unique targets for their plugins. This is the name
   by which they can communicate with the plugin.</p>
</div></div>
<div class="function">
<h3 id="get_commands/1">get_commands(PlugID::UUID()) -&gt; possible_failure([EMPCOMMAND()])</h3>


<div class="description">

<p>
   Get all of the commands for a particular plugin using its ID.</p>
</div></div>
<div class="function">
<h3 id="get_events/1">get_events(PlugID::UUID()) -&gt; possible_failure([EMPEVENT()])</h3>


<div class="description">

<p>
   Get all of the events for a particular plugin using its ID.</p>
</div></div>
<div class="function">
<h3 id="install_plugin/1">install_plugin(ModuleName::atom(), Files::[binary()]) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Installs a plugin by copying all files into the database to be replicated
   on all nodes attached to the EMP node. This is so that any drivers or
   runtime binaries can be transfered along with the Erlang modules when
   distributing EMP's Plugin computation.
   <br /><br />
   <em>WARNING:</em> Please note that this functionality is alpha and
   still definitely in testing, do not rely on this.</p>
</div></div>
<div class="function">
<h3 id="uninstall_plugin/1">uninstall_plugin(ModuleName::atom()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Removes the files from the database for an installed plugin. This does
   not unregister the plugin.</p>
</div></div>
<div class="function">
<h3 id="emp_get_var/1">emp_get_var(VarName::atom()) -&gt; possible_failure(term())</h3>


<div class="description">

<p>
   Grab a system configuration from storage. This is called fairly frequently
   and not just at start up.</p>
</div></div>
<div class="function">
<h3 id="emp_get_vars/0">emp_get_vars() -&gt; possible_failure([{atom(), term()}])</h3>


<div class="description">

<p>
   Get all system settings from the database. Only called when the system is
   queried to do so by an admin.</p>
</div></div>
<div class="function">
<h3 id="emp_set_var/1">emp_set_var(VarName::atom(), NewVal::term()) -&gt; possible_failure(term())</h3>


<div class="description">

<p>
   Set a system setting in the database, will add it if its not there.
   Infrequently called, normally only if a change is made by the admin.</p>
</div></div>
<div class="function">
<h3 id="plugin_get_var/1">plugin_get_var(Plugin::EMPPLUGINDEF(), User::EMPUSER(), VarName::binary()) -&gt; possible_failure(term())</h3>


<div class="description">

<p>
   Very frequently called, it returns a saved value for a plugin.</p>
</div></div>
<div class="function">
<h3 id="plugin_set_var/1">plugin_set_var(Plugin::EMPPLUGINDEF(), User::EMPUSER(), VarName::binary(), NewVal::term()) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Very frequently called, it saved the state of a single value into the
   database.</p>
</div></div>
<div class="function">
<h3 id="plugin_get_config/1">plugin_get_config(Plugin::EMPPLUGINDEF(), User::EMPUSER(), VarName::binary()) -&gt; possible_failure(term())</h3>


<div class="description">

<p>
   Plugin Configuration access, these are variables that have been set on
   build and on start-up and can-not be changed during runtime.</p>
</div></div>
<div class="function">
<h3 id="plugin_state_saver/1">plugin_state_saver(Plugin::EMPPLUGINDEF(), User::EMPUSER(), State::[{binary(), term()}]) -&gt; possible_failure(ok)</h3>


<div class="description">

<p>
   Upon crash or on an interval, EMP will automatically save the running
   state of the plugin in case of crash. The state is always saved when the
   plugin is shutdown as well. This is essentially like calling
   plugin_set_var/4 repeatedly.</p>
</div></div>
<div class="function">
<h3 id="plugin_load_prev_state/1">plugin_load_prev_state(Plugin::EMPPLUGINDEF(), User::EMPUSER()) -&gt; possible_failure([{binary(), term()}])</h3>


<div class="description">

<p>
   Upon plugin startup EMP will resume the old state of the plugin.</p>
</div></div></div>
<div class="section"><h4>See also</h4><p><a href="empdb_mnesia.html" class="seealso"><em>EMP's Mnesia Backend</em>
 </a></p></div>
<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
