<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>nksip_sipapp (nksip) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>nksip_sipapp</h1>
<h2 class="modsummary">SipApp callback behaviour and callbacks default implementation.</h2>
<div class="description">
<p>SipApp callback behaviour and callbacks default implementation.</p>
 
  <p>All of the available functions you can implement in your callback module are described  
here, along with the default implementation of each one.</p>
 
  <p>Every <em>SipApp</em> must define a <i>callback module</i>, using this module's behaviour.
  This behaviour works in a very similar way to any standard Erlang <code>gen_server</code>
  callback module, but only <a href="#init/1" class="seealso">init/1</a> is mandatory.</p>
 
  <p>Depending on the phase of the request processing, different functions will be called.
  Some of these calls expect an answer from the SipApp to continue the processing,
  and some others are called to inform the SipApp about a specific event and don't
  expect any answer. As in <code>gen_server</code>, the current SipApp state (created in the call
  to <code>init/1</code>) will be sent in every call, and can be updated by the SipApp  
implementation in every function return.</p>
 
  <p>Except for <code>init/1</code>, all defined functions belong
  to one of two groups: <i>expected answer</i> functions and
  <i>no expected answer</i> functions.</p>
 
  <p>The supported return values for <i>expected answer functions</i> are:
  </p><pre class="sh_erlang">    call_reply() ::
        {noreply, State} | {noreply, State, Timeout} |
        {reply, Reply, State} | {reply, Reply, State, Timeout} |
        {stop, Reason, State} | {stop, Reason, Reply, State}
        when State :: term(), Timeout :: infinity | non_neg_integer(), Reason :: term()</pre>
 
  <p>The function is expected to return <code>State</code> as new SipApp user's state and a <code>Reply</code>,
  whose meaning is specific to each function and it is described bellow.
  If a <code>Timeout</code> is defined the SipApp process will receive a <code>timeout</code> message
  after the indicated milliseconds period (you must implement <a href="#handle_info/2" class="seealso">handle_info/2</a>
  to receive it).
  If the function returns <code>stop</code> the SipApp will be stopped.
  If the function does not want to return a reply just know, it must return
  <code>{noreply, State}</code> and call <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#reply-2">nksip:reply/2</url> later on,  
possibly from a different spawned process.</p>
 
  <p>The supported return values for <i>no expected answer functions</i> are:
  </p><pre class="sh_erlang">    call_noreply() ::
        {noreply, State} | {noreply, State, Timeout} |
        {stop, Reason, State}
        when State :: term(), Timeout :: infinity | non_neg_integer(), Reason :: term()</pre>
 
  <p>Some of the callback functions allow the SipApp to send a response back
  to the calling party. See the available responses in <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_reply.xml">nksip_reply</url>.</p>
 
  <p>A typical call order would be the following:
  </p><list>
   <item>When starting the SipApp, <a href="#init/1" class="seealso"><code>init/1</code></a> is called to initialize the
       application state.</item>
   <item>When a request is received having an <i>Authorization</i> or
       <i>Proxy-Authorization</i> header, <a href="#get_user_pass/3" class="seealso"><code>get_user_pass/3</code></a> is called to check
       the user's password.</item>
   <item>NkSIP calls <a href="#authorize/4" class="seealso"><code>authorize/4</code></a> to check is the request should be
       authorized.</item>
   <item>If authorized, it calls <a href="#route/6" class="seealso"><code>route/6</code></a> to decide what to do with the
       request: reply, route or process locally.</item>
   <item>If the request is going to be processed locally, <a href="#invite/3" class="seealso"><code>invite/3</code></a>,
       <a href="#options/3" class="seealso"><code>options/3</code></a>, <a href="#register/3" class="seealso"><code>register/3</code></a> or <a href="#bye/3" class="seealso"><code>bye/3</code></a> are called,
       and the user must send a reply.
       If the request is a valid <i>CANCEL</i>, belonging to an active <i>INVITE</i>
       transaction, the INVITE is cancelled and <a href="#cancel/2" class="seealso"><code>cancel/2</code></a> is called.</item>
   <item>After sending a successful response to an <i>INVITE</i> request,
       the other party will send an <i>ACK</i> and <a href="#ack/3" class="seealso"><code>ack/3</code></a> will be called.</item>
   <item>If the request creates or modifies a dialog and/or a SDP session,
       <a href="#dialog_update/3" class="seealso"><code>dialog_update/3</code></a> and/or <a href="#session_update/3" class="seealso"><code>session_update/3</code></a> are called.</item>
   <item>If the remote party sends an in-dialog invite (a <i>reINVITE</i>),
       NkSIP will call <a href="#reinvite/3" class="seealso"><code>reinvite/3</code></a>.</item>
   <item>If the user has set up an automatic ping or registration,
       <a href="#ping_update/3" class="seealso"><code>ping_update/3</code></a> or <a href="#register_update/3" class="seealso"><code>register_update/3</code></a> are called on each
       status change.</item>
   <item>When the SipApp is stopped, <a href="#terminate/2" class="seealso"><code>terminate/2</code></a> is called.</item>
  </list>
 
 
  <p>It is <em>very important</em> to notice that, as in using normal <code>gen_server</code>,  
there is a single SipApp core process, so you must not spend a long time in any of  
the callback functions. If you do so, new requests arriving at your SipApp will be  
blocked and the other party will start to send retransmissions. As no transaction  
has been created yet, NkSIP will see them as new requests that will be also blocked,  
and so on.</p>
 
  <p>If the expected processing time of any of your callback functions is high
  (more than a few milliseconds), you must spawn a new process, return <code>{noreply, ...}</code>
  and do any time-consuming work there. If the called function spawning the process is
  in the expected answer group, it must call <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#reply-2">nksip:reply/2</url> from the spawned  
process when a reply is available.  
Launching new processes in Erlang is a very cheap operation,  
so in case of doubt follow this recommendation.</p>
 
  <p>Many of the callback functions receive a <code>RequesId</code> (<url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml#type-id">nksip_request:id()</url>)
  and a <code>Meta</code> (a list of properties) parameters.
  Depending on the function, <code>Meta</code> will contain the most useful parameters you
  will need to process the request (like de content-type and body).
  You can use <code>ReqId</code> to obtain any oher parameter from the request or dialog,
  using the helper funcions in <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> and <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_dialog.xml">nksip_dialog</url>.</p>
 
  <p><em>Inline functions</em></p>
 
  <p>NkSIP offers another option for defining callback functions. Many of them have
  an <i>inline</i> form, which, if defined, it will be called instead of
  the <i>normal</i> form.</p>
 
  <p>Inline functions have the same name of normal functions, but they don't have the
  last <code>State</code> parameter.  
They are called in-process, inside the call processing process and  
not from the SipApp's process like the normal functions.</p>
 
  <p>Inline functions are much quicker, but they can't modify the SipApp state.
  They received a full <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#type-request">nksip:request()</url> object in <code>Meta</code>, so it can use
  the functions in <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sipmsg.xml">nksip_sipmsg</url> to process it.
  See <code>inline_test</code> for an example of use</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-call_noreply">call_noreply() = {noreply, State :: term()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {noreply,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State :: term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Timeout :: timeout()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {stop, Reason :: term(), State :: term()}</h3></div>
    <div class="type"><h3 id="type-call_reply">call_reply(RetType) = {reply, Reply::RetType, State::term()} | {reply, Reply::RetType, State::term(), Timeout::timeout()} | {noreply, State::term()} | {noreply, State::term(), Timeout::timeout()} | {stop, Reason::term(), Reply::RetType, State::term()} | {stop, Reason::term(), State::term()}</h3></div>
    <div class="type"><h3 id="type-from">from() = term()</h3></div>
    <div class="type"><h3 id="type-init_return">init_return() = {ok, State :: term()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {ok, State :: term(), Timeout :: timeout()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {stop, Reason :: term()}</h3></div>
    <div class="type"><h3 id="type-meta">meta() = <a href="nksip_lib.html#type-proplist" class="seealso">nksip_lib:proplist()</a></h3></div>
    <div class="type"><h3 id="type-registrar_store_op">registrar_store_op() = {get, <a href="nksip.html#type-aor" class="seealso">nksip:aor()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {put,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="nksip.html#type-aor" class="seealso">nksip:aor()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<a href="nksip_registrar.html#type-reg_contact" class="seealso">nksip_registrar:reg_contact()</a>],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {del, <a href="nksip.html#type-aor" class="seealso">nksip:aor()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| del_all</h3></div>
    <div class="type"><h3 id="type-route_reply">route_reply() = proxy<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {proxy, ruri | <a href="nksip.html#type-uri_set" class="seealso">nksip:uri_set()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {proxy,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ruri | <a href="nksip.html#type-uri_set" class="seealso">nksip:uri_set()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="nksip_lib.html#type-proplist" class="seealso">nksip_lib:proplist()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| process<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {process, <a href="nksip_lib.html#type-proplist" class="seealso">nksip_lib:proplist()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {response, <a href="nksip.html#type-sipreply" class="seealso">nksip:sipreply()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {response,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="nksip.html#type-sipreply" class="seealso">nksip:sipreply()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="nksip_lib.html#type-proplist" class="seealso">nksip_lib:proplist()</a>}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/1">init(Args::term()) -&gt; init_return()</h3>


<div class="description">

<p>SipApp initialization.</p>
 
  <p>This callback function is called when the SipApp is launched using
  <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#start-4">nksip:start/4</url>.</p>
 
  <p>If <code>{ok, State}</code> or <code>{ok, State, Timeout}</code> is returned the SipApp is started with
  this initial state. If a <code>Timeout</code> is provided (in milliseconds) a
  <code>timeout</code> message will be sent to the process
  (you will need to implement <a href="#handle_info/2" class="seealso">handle_info/2</a> to receive it).
  If <code>{stop, Reason}</code> is returned the SipApp will not start.
 </p>
</div></div>
<div class="function">
<h3 id="terminate/1">terminate(Reason::term(), State::term()) -&gt; ok</h3>


<div class="description">

<p>Called when the SipApp is stopped.</p>
</div></div>
<div class="function">
<h3 id="get_user_pass/1">get_user_pass(User::binary(), Realm::binary(), State::term()) -&gt; {reply, Reply, NewState}</h3>

<ul class="type">
<li><code>Reply = true | false | binary()</code></li><li><code>NewState = term()</code></li></ul>
<div class="description">

<p>Called to check a user password for a realm.</p>
 
  <p>When a request is received containing a <code>Authorization</code> or <code>Proxy-Authorization</code>
  header, this function is called by NkSIP including the header's <code>User</code> and <code>Realm</code>,  
to check if the authorization data in the header corresponds to the user's password.</p>
 
  <p>You should normally reply with the user's password (if you have it for this user
  and realm). NkSIP will use the password and the digest information in the header
  to check if it is valid, offering this information in the call to
  <a href="#authorize/4" class="seealso">authorize/4</a>.</p>
 
  <p>You can also reply <code>true</code> if you want to accept any request from this user
  without checking any password, or <code>false</code> if you don't have a password for this user  
or want her blocked.</p>
 
  <p>If you don't want to store <i>clear-text</i> passwords of your users,
  you can use <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_auth.xml#make_ha1-3">nksip_auth:make_ha1/3</url> to generate a <i>hash</i> of the password  
for an user and a realm, and store only this hash instead of the real password.  
Later on you can reply here with the hash instead of the real password.</p>
 
  <p>If you don't define this function, NkSIP will reply with password <code>&lt;&lt;&gt;&gt;</code>
  if user is <code>anonymous</code>, and <code>false</code> for any other user.
 </p>
</div></div>
<div class="function">
<h3 id="authorize/1">authorize(ReqId::id() (see module nksip_request), AuthList, From::from(), State::term()) -&gt; call_reply(ok | authenticate | proxy_authenticate | forbidden)</h3>

<ul class="type">
<li><code>AuthList = [dialog | register | {{digest, Realm::binary}, boolean()}]</code></li></ul>
<div class="description">

<p>Called for every incoming request to be authorized or not.</p>
 
  <p>If <code>ok</code> is replied the request is authorized and the
  request processing continues. If <code>authenticate</code> is replied, the request will be
  rejected (statelessly) with a 401 <i>Unauthorized</i>.
  The other party will usually send the request again, this time with an
  <code>Authorization</code> header. If you reply <code>proxy_authenticate</code>, it is rejected
  with a 407 <i>Proxy Authentication Rejected</i> response and the other party
  will include a <code>Proxy-Authorization</code> header.</p>
 
  <p>You can use the tags included in <code>AuthList</code> in order to decide to authenticate
  or not the request.  AuthList includes the following tags:
  </p><list>
     <item><p><code>dialog</code>: the request is in-dialog and coming from the same ip and port
         than the last request for an existing dialog.</p></item>
     <item><p><code>register</code>: the request comes from the same ip, port and transport of a
         currently valid registration (and the method is not <i>REGISTER</i>).</p></item>
     <item><p><code>{{digest, Realm}, true}</code>: there is at least one valid user authenticated
         (has a correct password) with this Realm.</p></item>
     <item><p><code>{{digest, Realm}, false}</code>: there is at least one user offering an
         authentication header for this Realm, but all of them
         have failed the authentication (no password was valid). </p></item>
  </list>
 
  <p>You will usually want to combine these strategies. Typically you will first
  check using SIP digest authentication, and, in case of faillure, you can use
  previous registration and/or dialog authentication.
  If you don't define this function all requests will be authenticated.
 </p>
</div></div>
<div class="function">
<h3 id="route/1">route(ReqId::id() (see module nksip_request), Scheme::scheme() (see module nksip), User::binary(), Domain::binary(), From::from(), State::term()) -&gt; call_reply(route_reply())</h3>


<div class="description">

<p>This function is called by NkSIP for every new request, to check if it must be
  proxied, processed locally or replied immediately. For convenience, the scheme, user
  and domain parts of the <i>Request-Uri</i> are included.</p>
 
  <p>If we want to <em>act as a proxy</em> and route the request, and we are not responsible
  for <code>Domain</code> we must return <code>proxy</code> or <code>{proxy, ruri, ProxyOpts}</code>.
  We must not return an <code>UriSet</code> in this case.
  NkSIP will then make additional checks to the request (like inspecting the
  <code>Proxy-Require</code> header) and will route it statefully to the same <code>Request-URI</code>  
contained in the request.</p>
 
  <p>If we are the resposible proxy for <code>Domain</code> we can provide a new list
  of URIs to route the request to. NkSIP will use <em>serial and/or
  parallel forking</em> depending on the format of <code>UriSet</code>.
  If <code>UriSet</code> is a simple Erlang array of binaries representing uris, NkSIP will try
  each one serially. If any of the elements of the arrary is in turn a new array
  of binaries, it will fork them in parallel.
  For example, for  </p><pre class="sh_erlang">  [ &lt;&lt;"sip:aaa"&gt;&gt;, [&lt;&lt;"sip:bbb"&gt;&gt;, &lt;&lt;"sip:ccc"&gt;&gt;], &lt;&lt;"sip:ddd"&gt;&gt;]</pre><p>
  NkSIP will first forward the request to <code>aaa</code>. If it does not receive a successful
  (2xx) response, it will try <code>bbb</code> and <code>cccc</code> in parallel.
  If no 2xx is received again, <code>ddd</code> will be tried. See <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_registrar.xml">nksip_registrar</url>
  to find out how to get the registered contacts for this <code>Request-Uri</code>.</p>
 
  <p>Available options for <code>ProxyOpts</code> are:
  </p><list>
   <item><p><code>stateless</code>: Use it if you want to proxy the request <i>statelessly</i>.
        Only one URL is allowed in <code>UriSet</code> in this case.</p></item>
   <item><p><code>record_route</code>: NkSIP will insert a <i>Record-Route</i> header before sending
       the request, so that following request inside the dialog will be routed
       to this proxy.</p></item>
   <item><p><code>follow_redirects</code>: If any 3xx response is received, the received contacts
       will be inserted in the list of uris to try.</p></item>
   <item><p><code>{route, nksip:user_uri()}</code>:
       NkSIP will insert theses routes as <i>Route</i> headers
       in the request, before any other existing <code>Route</code> header.
       The request would then be sent to the first <i>Route</i>.</p></item>
   <item><p><code>{headers, [nksip:header()]}</code>:
       Inserts these headers before any existing header.</p></item>
   <item><p><code>remove_routes</code>: Removes any previous <i>Route</i> header in the request.
       A proxy should not usually do this. Use it with care.</p></item>
   <item><p><code>remove_headers</code>: Remove previous non-vital headers in the request.
       You can use modify the headers and include them with using <code>{headers, Headers}</code>.
       A proxy should not usually do this. Use it with care.</p></item>
  </list>
 
  <p>If we want to <em>act as an endpoint or B2BUA</em> and answer to the request
  from this SipApp, we must return <code>process</code> or <code>{process, ProcessOpts}</code>.
  NkSIP will then make additional checks to the request (like inspecting
  <code>Require</code> header), start a new transaction and call the function corresponding
  to the method in the request (like <code>invite/3</code>, <code>options/3</code>, etc.)</p>
 
  <p>Available options for <code>ProcessOpts</code> are:
  </p><list>
   <item><p><code>stateless</code>: Use it if you want to process this request <i>statelessly</i>.
        No transaction will be started.</p></item>
  <item><p><code>{headers, [nksip:header()]}</code>:
      Insert these headers before any existing header, before calling the next
      callback function.</p></item>
  </list>
 
  <p>We can also <em>send a reply immediately</em>, replying <code>{response, Response}</code>,
  <code>{response, Response, ResponseOpts}</code> or simply <code>Response</code>. See <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_reply.xml">nksip_reply</url>
  to find the recognized response values. The typical reason to reply a response here
  is to send <em>redirect</em> or an error like <code>not_found</code>, <code>ambiguous</code>,
  <code>method_not_allowed</code> or any other. If the form <code>{response, Response}</code> or
  <code>{response, Response, ResponseOpts}</code> is used the response is sent statefully,
  and a new transaction will be started, unless <code>stateless</code> is present in <code>ResponseOpts</code>.
  If simply <code>Response</code> is used no transaction will be started.
  The only recognized option in <code>ResponseOpts</code> is <code>stateless</code>.</p>
 
  <p>If route/3 is not defined the default reply would be <code>process</code>.
 </p>
</div></div>
<div class="function">
<h3 id="invite/1">invite(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new INVITE request as an endpoint.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, dialog_id, content_type
  and body (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details). If content-type is
  <code>application/sdp</code> the body will be decoded as a <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sdp.xml#type-sdp">nksip_sdp:sdp()</url> object
  you can manage with the functions in <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sdp.xml">nksip_sdp</url>.</p>
 
  <p>Before replying a final response, you will usually call
  <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml#reply-3">nksip_request:reply/3</url> to send a provisional response like
  <code>ringing</code> (which would send a 180 <i>Ringing</i> reply) or <code>ringing_rel</code> to send
  a <i>reliable provisional response</i>.%%</p>
 
  <p>If a quick response (like <code>busy</code>) is not going to be sent immediately
  (which is typical for INVITE requests, as the user would normally need to accept
  the call) you must return <code>{noreply, NewState}</code> and spawn a new process,
  calling <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#reply-2">nksip:reply/2</url> from the new process, in order to avoid  
blocking the SipApp process.</p>
 
  <p>You must then answer the request. The possible responses are defined in
  <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_reply.xml">nksip_reply</url>.
  If a successful (2xx) response is sent, you should include a new generated SDP body
  in the response. A new dialog will then start.
  The remote party should then send an ACK request immediately.
  If none is received, NkSIP will automatically stop the dialog.
 </p>
</div></div>
<div class="function">
<h3 id="reinvite/1">reinvite(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called when a new in-dialog INVITE request is received.</p>
 
  <p>The guidelines and <code>Meta</code> in <a href="#invite/4" class="seealso">invite/4</a> are still valid,  
but you shouldn't send provisional responses, sending a final response inmediatly.</p>
 
  <p>If the dialog's target or the SDP session parameters are updated by the request or
  its response, <a href="#dialog_update/3" class="seealso">dialog_update/3</a> and/or <a href="#session_update/3" class="seealso">session_update/3</a> would be
  called.
 </p>
</div></div>
<div class="function">
<h3 id="cancel/1">cancel(ReqId::id() (see module nksip_request), Meta::meta(), State::term()) -&gt; call_noreply()</h3>


<div class="description">

<p>Called when a pending INVITE request is cancelled.</p>
 
  <p>When a CANCEL request is received by NkSIP, it will check if it belongs to an
  existing INVITE transaction. If not, a 481 <i>Call/Transaction does not exist</i>  
will be automatically replied.</p>
 
  <p>If it belongs to an existing INVITE transaction, NkSIP replies 200 <i>OK</i> to the  
CANCEL request. If the matching INVITE transaction has not yet replied a  
final response, NkSIP replies it with a 487 (Request Terminated) and this function  
is called. If a final response has already beeing replied, it has no effect.</p>
 
  <p><code>Meta</code> will include a parameter <code>{req_id, InviteId}</code> showing the request id of the
  INVITE being cancelled.
 </p>
</div></div>
<div class="function">
<h3 id="ack/1">ack(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(ok)</h3>


<div class="description">

<p>Called when a valid ACK request is received.</p>
 
  <p>This function is called by NkSIP when a new valid in-dialog ACK request has to  
be processed locally.</p>
 
  <p><code>Meta</code> will include at least the following parameters: dialog_id, content_type
  and body (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).</p>
 
  <p>You don't usually need to implement this callback. One possible reason to do it is
  to receive the SDP body from the other party in case it was not present in the INVITE
  (you can also get it from the <a href="#session_update/3" class="seealso">session_update/3</a> callback).
 </p>
</div></div>
<div class="function">
<h3 id="bye/1">bye(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>Called when a valid BYE request is received.</p>
 
  <p>When a BYE request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.
  If it does, NkSIP stops the dialog and this callback functions is called.
  You won't usually need to implement this function, but in case you do, you
  should reply <code>ok</code> to send a 200 response back.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, dialog_id
  (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="info/1">info(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>Called when a valid INFO request is received.</p>
 
  <p>When an INFO request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.
  If it does, NkSIP this callback functions is called.
  If implementing this function, you should reply <code>ok</code> to send a 200 response back.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, content-type, body
  (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="options/1">options(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>Called when a OPTIONS request is received.</p>
 
  <p>This function is called by NkSIP to process a new incoming OPTIONS request as
  an endpoint. If not defined, NkSIP will reply with a 200 <i>OK</i> response,
  including automatically generated <code>Allow</code>, <code>Accept</code> and <code>Supported</code> headers.</p>
 
  <p>NkSIP will not send any body in its automatic response. This is ok for proxies.
  If you are implementing an endpoint or B2BUA, you should implement this function
  and include in your response a SDP body representing your supported list of codecs,
  and also <code>Allow</code>, <code>Accept</code> and <code>Supported</code> headers.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor
  (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="register/1">register(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new incoming REGISTER request.</p>
 
  <p>If it is not defined, but <code>registrar</code> option was present in the SipApp's
  startup config, NkSIP will process the request.
  It will NOT check if <i>From</i> and <i>To</i> headers contains the same URI,
  or if the registered domain is valid or not. If you need to check this,
  implement this function returning <code>register</code> if everything is ok.
  See <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_registrar.xml">nksip_registrar</url> for other possible response codes defined in the SIP  
standard registration process.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor
  (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).</p>
 
  <p>If this function is not defined, and no <code>registrar</code> option is found,
  a 405 <i>Method not allowed</i> would be replied.</p>
 
  <p>You should define this function in case you are implementing a registrar server
  and need a specific REGISTER processing
  (for example to add some headers to the response).
 </p>
</div></div>
<div class="function">
<h3 id="prack/1">prack(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(ok)</h3>


<div class="description">

<p>Called when a valid PRACK request is received.</p>
 
  <p>This function is called by NkSIP when a new valid in-dialog PRACK request has to
  be processed locally, in response to a sent reliable provisional response.
  You don't usually need to implement this callback. One possible reason to do it is
  to receive the SDP body from the other party in case it was not present in the INVITE
  (you can also get it from the <a href="#session_update/3" class="seealso">session_update/3</a> callback).</p>
 
  <p><code>Meta</code> will include at least the following parameters: dialog_id, content_type
  and body (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="update/1">update(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>Called when a valid UPDATE request is received.</p>
 
  <p>When a UPDATE request is received, NkSIP will automatically response 481
  <i>Call/Transaction does not exist</i> if it doesn't belong to a current dialog.  
If it does, this function is called.</p>
 
  <p>The request will probably have a SDP body.
  If a <code>ok</code> is replied, a SDP answer is inclued, the session may change  
(and the corresponding callback function will be called).  
If other non 2xx response is replied (like decline) the media is not changed.</p>
 
  <p><code>Meta</code> will include at least the following parameters: dialog_id, content_type
  and body (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new incoming SUBSCRIBE  
request that has an allowed Event type.</p>
 
  <p>If you reply a 2xx response like <code>ok</code>  or <code>accepted</code>, a dialog and a subscription
  will start, and you must inmeditaly send a NOTIFY using
  <a href="nksip_uac.html#notify/3" class="seealso">nksip_uac:notify/3</a>.</p>
 
  <p>You can use the option <code>{expires, integer()}</code> to override the expires present  
in the request, but the new value must be lower, or even 0 to cancel the  
subscription.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, dialog_id, event,
  subscription_id and parsed_expires (see <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_request.xml">nksip_request</url> for details).
 </p>
</div></div>
<div class="function">
<h3 id="resubscribe/1">resubscribe(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new in-subscription SUBSCRIBE  
request, sent in order to refresh the subscription.</p>
 
  <p>You don't usually have to implement this function.
 </p>
</div></div>
<div class="function">
<h3 id="notify/1">notify(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new incoming NOTIFY  
request belonging to a current active subscription.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, dialog_id, event,
  subscription_id, notify_status, content_type and body.
  Field <code>notify_status</code> will have the status of the NOTIFY: <code>active</code>, <code>pending</code> or
  <code>{terminated, Reason::nksip_subscription:terminated_reason()}</code>.</p>
 
  <p>You should always return <code>ok</code>.
 </p>
</div></div>
<div class="function">
<h3 id="message/1">message(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new incoming MESSAGE  
request.</p>
 
  <p>If you reply a 2xx response like <code>ok</code>  or <code>accepted</code>, you are telling
  to the remote party that the message has been received.
  Use a 6xx response (like <code>decline</code>) to tell it has been refused.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, expired,
  content_type and body.
  Field <code>expired</code> will have <code>true</code> if the MESSAGE has already expired.
 </p>
</div></div>
<div class="function">
<h3 id="refer/1">refer(ReqId::id() (see module nksip_request), Meta::meta(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>This function is called by NkSIP to process a new incoming REFER.</p>
 
  <p><code>Meta</code> will include at least the following parameters: aor, dialog_id, event,
  subscription_id and refer_to.
  Field <code>refer_to</code> contains the mandatory <i>Refer-To</i> header.</p>
 
  <p>If you reply a 2xx response like <code>ok</code>  or <code>accepted</code>, a dialog and a subscription
  will start. You must connect to the url in <code>refer_to</code> and send any response  
back to the subscription using {link nksip_uac:notify/3}, according to RFC3515.</p>
 
  <p>You should send <code>ok</code> if the request has been accepte or <code>decline</code> if not.
  If you are going to spend more than a few seconds to reply, you should reply
  <code>accepted</code>, and if the request is not accepted later on, send a  
NOTIFY with appropiate reason.</p>
 
  <p>You can use the functions in <a href="nksip_uac.html" class="seealso">nksip_uac</a> like invite/4, options/4, etc.,
  using parameter <code>refer_subscription_id</code>, and NkSIP will automatically send  
a valid NOTIFY after each provisional or the final response.</p>
 
  <p>This would be a typical implementation:</p>
 
  <p>refer(_ReqId, Meta, _From, #state{id=AppId}=State) -&gt;
      ReferTo = nksip_lib:get_value(refer_to, Meta),
      SubsId = nksip_lib:get_value(subscription_id, Meta),
      Opts = [async, auto_2xx_ack, {refer_subscription_id, SubsId}],
      spawn(fun() -&gt; nksip_uac:invite(AppId, ReferTo, Opts) end),
      {reply, ok, State}.
 </p>
</div></div>
<div class="function">
<h3 id="dialog_update/1">dialog_update(DialogId::id() (see module nksip_dialog), DialogStatus, State::term()) -&gt; call_noreply()</h3>

<ul class="type">
<li><code>DialogStatus = start | target_update | {invite_status, invite_status() (see module nksip_dialog)} | {subscription_status, status() (see module nksip_subscription)} | {stop, stop_reason() (see module nksip_dialog)}</code></li></ul>
<div class="description">

<p>Called when a dialog has changed its state.</p>
 
  <p>A new dialog will be created when you send an INVITE request
  (using <a href="nksip_uac.html#invite/3" class="seealso">nksip_uac:invite/3</a>) and a successful (101-299) response is received,
  or after an INVITE is received and the call to <code>invite/3</code> callback replies
  with a successful response. If the response is provisional (101-199) the dialog
  will be marked as temporary or <i>early</i>, waiting for the final response  
to be confirmed or deleted.</p>
 
  <p>Dialogs will also be created for <em>subscriptions</em>, after a valid NOTIFY is sent or
  received. Any dialog can have multiple usages simultaneously, as much as <i>one</i>  
'INVITE usage' and a unlimited number of 'SUBSCRIBE usages'.</p>
 
  <p>Once the dialog is established, some in-dialog methods
  (like INVITE, UPDATE, SUBSCRIBE and NOTIFY) can update the <code>target</code> of the dialog.</p>
 
  <p>The 'INVITE usage' is destroyed when a valid in-dialog BYE request is sent or received.  
A 'SUBSCRIPTION' usage is destroyed when a NOTIFY with status=terminated is  
received. When no usage is left, the dialog itself is destroyed.</p>
 
  <p>NkSIP will call this function every time a dialog is created, its target is updated  
or it is destroyed.</p>
 
  <p>For INVITE usages, it will be called also when the status of the usage changes,
  as <code>{invite_status, nksip_dialog:invite_status()}</code>.
  For SUBSCRIBE usages, also when the status of that usage changes, as
  {subscription_status, <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_subscription.xml#type-status">nksip_subscription:status()</url>}.
 </p>
</div></div>
<div class="function">
<h3 id="session_update/1">session_update(DialogId::id() (see module nksip_dialog), SessionStatus, State::term()) -&gt; call_noreply()</h3>

<ul class="type">
<li><code>SessionStatus = {start, Local, Remote} | {update, Local, Remote} | stop</code></li><li><code>Local = sdp() (see module nksip_sdp)</code></li><li><code>Remote = sdp() (see module nksip_sdp)</code></li></ul>
<div class="description">

<p>Called when a dialog has updated its SDP session parameters.</p>
 
  <p>When NkSIP detects that, inside an existing dialog, both parties have agreed on
  a specific SDP defined session, it will call this function.
  You can use the functions in <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sdp.xml">nksip_sdp</url> to process the SDP data.</p>
 
  <p>This function will be also called after each new successful SDP negotiation.
 </p>
</div></div>
<div class="function">
<h3 id="ping_update/1">ping_update(PingId::term(), OK::boolean(), State::term()) -&gt; call_noreply()</h3>


<div class="description">

<p>Called when the status of an automatic ping configuration changes.
  See <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sipapp_auto.xml#start_ping-5">nksip_sipapp_auto:start_ping/5</url>.</p>
</div></div>
<div class="function">
<h3 id="register_update/1">register_update(RegId::term(), OK::boolean(), State::term()) -&gt; call_noreply()</h3>


<div class="description">

<p>Called when the status of an automatic registration configuration changes.
  See <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip_sipapp_auto.xml#start_register-5">nksip_sipapp_auto:start_register/5</url>.</p>
</div></div>
<div class="function">
<h3 id="handle_call/1">handle_call(Msg::term(), From::from(), State::term()) -&gt; call_reply(sipreply() (see module nksip))</h3>


<div class="description">

<p>Called when a direct call to the SipApp process is made using
  <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#call-2">nksip:call/2</url> or <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#call-3">nksip:call/3</url>.</p>
</div></div>
<div class="function">
<h3 id="handle_cast/1">handle_cast(Msg::term(), State::term()) -&gt; call_noreply()</h3>


<div class="description">

<p>Called when a direct cast to the SipApp process is made using
  <url href="/home/pete/wefwefwef/docs/other/6491459840/repo/headers-in-uri/.xml/nksip/./nksip.xml#cast-2">nksip:cast/2</url>.</p>
</div></div>
<div class="function">
<h3 id="handle_info/1">handle_info(Msg::term(), State::term()) -&gt; call_noreply()</h3>


<div class="description">

<p>Called when the SipApp process receives an unknown message.</p>
</div></div>
<div class="function">
<h3 id="registrar_store/1">registrar_store(AppId::app_id() (see module nksip), Op::registrar_store_op(), State::term()) -&gt; {reply, term(), term()}</h3>


<div class="description">

<p>Called when a operation database must be done on the registrar database.</p>
 
  <p>The possible values for Op and their allowed reply are:</p>
 
 
    <em>Op</em><em>Response</em><em>Comments</em><br />
    <code>{get, AOR::nksip:aor()}</code>
       <code>[Contact::nksip_registrar:reg_contact()]</code>
       Retrieve all stored contacts for this AOR.<br />
    <code>{put, AOR::nksip:aor(), [Contact::nksip_registrar:reg_contact()], TTL::integer()}</code>
        <code>ok</code>
        Store the list of contacts for this AOR. The record must be
            automatically deleted after TTL seconds.<br />
   <code>{del, AOR::nksip:aor()}</code>
       <code>ok|not_found</code>
       Delete all stored contacts for this AOR, returning <code>ok</code> or
           <code>not_found</code> if the AOR is not found.<br />
   <code>del_all</code>
       <code>ok</code>
       Delete all stored information for this AppId.<br />
 
 
 
  <p>The function must return <code>{reply, Reply, NewState}</code>.
  This default implementation uses the built-in memory database.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
