<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>nksip (nksip) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>nksip</h1>
<h2 class="modsummary">SipApps management module.</h2>
<div class="description">
<p><i>SipApps</i> management module.</p>
 
  <p>This module allows to manage <i>NkSIP application instances</i> or <em>SipApps</em>.  
NkSIP can start any number of SipApps, each one listening on one or several sets of  
ip, port and transport (UDP, TCP or TLS currently).</p>
 
  <p>To register a SipApp, you must first create a <i>callback module</i> using
  behaviour <a href="nksip_sipapp.html" class="seealso">nksip_sipapp</a> (you can also use the <i>default callback module</i>
  included with NkSIP, defined in the same  <code>nksip_sipapp</code> module).
  This behaviour is very similar to OTP standard <code>gen_server</code> behaviour, but
  the only mandatory callback function is <a href="nksip_sipapp.html#init/1" class="seealso">nksip_sipapp:init/1</a>.
  The callback module can also implement a number of
  optional callbacks functions, have a look at <a href="nksip_sipapp.html" class="seealso">nksip_sipapp</a> to find  
the currently available callbacks and default implementation for each of  
these functions.</p>
 
  <p>Once defined the callback module, call <a href="#start/4" class="seealso">start/4</a> to start the SipApp.
  NkSIP will call <code>init/1</code> inmediatly, setting up the inital application's state.</p>
 
  <p>From this moment on, you can start sending requests using the functions in
  <a href="nksip_uac.html" class="seealso">nksip_uac</a>. When a incoming request is received in our SipApp
  (sent from another SIP endpoint or proxy), NkSIP starts a process to manage it.
  This process starts calling specific functions in the SipApp's callback module
  as explained in <a href="nksip_sipapp.html" class="seealso">nksip_sipapp</a>.</p>
 
  <p>Should the SipApp process stop due to an error, it will be automatically restarted
  by its supervisor, but the Erlang application's state would be lost like a standard
  <code>gen_server</code>.</p>
 
  <p>Please notice that it is not necessary to tell NkSIP which kind of SIP element
  your SipApp is implementing. For every request, depending on the return of
  the call to your <a href="nksip_sipapp.html#route/6" class="seealso">nksip_sipapp:route/6</a> callback function
  NkSIP will act as an endpoint, B2BUA or proxy, request by request.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-aor">aor() = {Scheme::scheme(), User::binary(), Domain::binary()}</h3></div>
    <div class="type"><h3 id="type-body">body() = binary() | sdp() (see module nksip_sdp)</h3></div>
    <div class="type"><h3 id="type-call_id">call_id() = binary()</h3></div>
    <div class="type"><h3 id="type-cseq">cseq() = pos_integer()</h3></div>
    <div class="type"><h3 id="type-header">header() = {binary(), binary() | atom() | integer()}</h3></div>
    <div class="type"><h3 id="type-method">method() = 'INVITE' | 'ACK' | 'CANCEL' | 'BYE' | 'REGISTER' | 'OPTIONS' | 'SUBSCRIBE' | 'NOTIFY' | 'PUBLISH' | 'REFER' | 'MESSAGE' | 'INFO' | 'PRACK' | 'UPDATE' | binary()</h3></div>
    <div class="type"><h3 id="type-protocol">protocol() = udp | tcp | tls | binary()</h3></div>
    <div class="type"><h3 id="type-request">request() = #sipmsg{class=undefined | request | response, sipapp_id=undefined | sipapp_id() (see module nksip), method=undefined | method() (see module nksip), ruri=undefined | uri() (see module nksip), vias=undefined | [via() (see module nksip)], from=undefined | uri() (see module nksip), to=undefined | uri() (see module nksip), call_id=undefined | call_id() (see module nksip), cseq=undefined | cseq() (see module nksip), cseq_method=undefined | method() (see module nksip), forwards=undefined | non_neg_integer(), routes=undefined | [uri() (see module nksip)], contacts=undefined | [uri() (see module nksip)], headers=undefined | [header() (see module nksip)], content_type=undefined | [token() (see module nksip_lib)], body=undefined | body() (see module nksip), response=undefined | response_code() (see module nksip), from_tag=undefined | tag() (see module nksip), to_tag=undefined | tag() (see module nksip), auth=[dialog | register | {digest, Real::binary(), ok | fail}], pid=undefined | pid(), transport=undefined | transport() (see module nksip_transport), start=undefined | l_timestamp() (see module nksip_lib), opts=proplist() (see module nksip_lib)}</h3></div>
    <div class="type"><h3 id="type-response">response() = #sipmsg{class=undefined | request | response, sipapp_id=undefined | sipapp_id() (see module nksip), method=undefined | method() (see module nksip), ruri=undefined | uri() (see module nksip), vias=undefined | [via() (see module nksip)], from=undefined | uri() (see module nksip), to=undefined | uri() (see module nksip), call_id=undefined | call_id() (see module nksip), cseq=undefined | cseq() (see module nksip), cseq_method=undefined | method() (see module nksip), forwards=undefined | non_neg_integer(), routes=undefined | [uri() (see module nksip)], contacts=undefined | [uri() (see module nksip)], headers=undefined | [header() (see module nksip)], content_type=undefined | [token() (see module nksip_lib)], body=undefined | body() (see module nksip), response=undefined | response_code() (see module nksip), from_tag=undefined | tag() (see module nksip), to_tag=undefined | tag() (see module nksip), auth=[dialog | register | {digest, Real::binary(), ok | fail}], pid=undefined | pid(), transport=undefined | transport() (see module nksip_transport), start=undefined | l_timestamp() (see module nksip_lib), opts=proplist() (see module nksip_lib)}</h3></div>
    <div class="type"><h3 id="type-response_code">response_code() = 100..699</h3></div>
    <div class="type"><h3 id="type-scheme">scheme() = sip | sips | tel | mailto | binary()</h3></div>
    <div class="type"><h3 id="type-sipapp_id">sipapp_id() = term()</h3></div>
    <div class="type"><h3 id="type-sipreply">sipreply() = sipreply() (see module nksip_reply)</h3></div>
    <div class="type"><h3 id="type-tag">tag() = binary()</h3></div>
    <div class="type"><h3 id="type-uri">uri() = #uri{disp=binary(), scheme=scheme() (see module nksip), user=binary(), pass=binary(), domain=binary(), port=port_number() (see module inet), opts=proplist() (see module nksip_lib), headers=[binary() | header() (see module nksip)], ext_opts=proplist() (see module nksip_lib), ext_headers=[binary() | header() (see module nksip)]}</h3></div>
    <div class="type"><h3 id="type-uri_set">uri_set() = user_uri() (see module nksip) | [user_uri() (see module nksip) | [user_uri() (see module nksip)]]</h3></div>
    <div class="type"><h3 id="type-user_uri">user_uri() = string() | binary() | uri()</h3></div>
    <div class="type"><h3 id="type-via">via() = #via{proto=protocol() (see module nksip), domain=binary(), port=port_number() (see module inet), opts=proplist() (see module nksip_lib)}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/1">start(AppId::sipapp_id(), Module::atom(), Args::term(), Opts::proplist() (see module nksip_lib)) -&gt; ok | {error, Error}</h3>

<ul class="type">
<li><code>Error = invalid_from | invalid_transport | invalid_register | invalid_route | no_matching_tcp | could_not_start_udp | could_not_start_tcp | could_not_start_tls</code></li></ul>
<div class="description">

<p>Starts a new SipApp.
  A <em>SipApp</em> is a SIP application started by NkSIP, listening on one or several
  sets of transport protocol, IP and port of the host. You must supply an <code>AppId</code>
  for the SipApp, a <i>callbacke</i> <code>Module</code> with <a href="nksip_sipapp.html" class="seealso">nksip_sipapp</a> behaviour,
  an <code>Args</code> for calling <code>init/1</code> and a set of <code>Options</code></p>
 
  <p>The recognized options are:<br /><br />
  </p>
       <em>Key</em><em>Type</em><em>Default</em><em>Description</em><br />
       
           <code>from</code>
           <a href="#type-user_uri" class="seealso">user_uri()</a>
           <code>"NkSIP App &lt;sip:user@nksip&gt;"</code>
           Default <i>From</i> to use in the requests
       <br />
       
           <code>pass</code>
           <code>Pass | {Pass, Realm} | [Pass | {Pass, Realm}]</code><br />
               <code>Pass::binary(), Realm::binary()</code>
           
           Passwords to use in case of receiving an <i>authenticate</i> response
           using <a href="nksip_uac.html" class="seealso">nksip_uac</a> functions.<br />
           The first password matching the response's realm will be used,
           or the first without any realm if none matches. <br />
           A hash of the password can be used instead
           (see <a href="nksip_auth.html#make_ha1/3" class="seealso">nksip_auth:make_ha1/3</a>).
       <br />
       
           <code>register</code>
           <a href="#type-user_uri" class="seealso">user_uri()</a>
           
           NkSIP will try to <i>REGISTER</i> the SipApp with this registrar server,
           (i.e. "sips:sip2sip.info"). <br />
           See <a href="nksip_sipapp_auto.html#get_registers/1" class="seealso">nksip_sipapp_auto:get_registers/1</a>
           and <a href="nksip_sipapp.html#register_update/3" class="seealso">nksip_sipapp:register_update/3</a>
       <br />
       
           <code>register_expires</code>
           <code>integer()</code>
           <code>300</code>
           In case of register, registration interval (secs)
       <br />
       
           <code>transports</code>
           
               <code>[{Proto, Ip, Port}]</code><br />
               <code>Proto::protocol()</code><br />
               <code>Ip::inet:ip_address()</code><br />
               <code>Port::inet:port_number()</code>
           
           <code>[{udp,{0,0,0,0},0}, {tls, {0,0,0,0}, 0}]</code>
           The SipApp can start any number of transports.
           If an UDP transport is started, a TCP transport on the same IP and port
           will be started automatically.<br />
           Use <code>{0,0,0,0}</code> to use <i>all</i> available IP addresses and <code>0</code> to use
           any available port
       <br />
       
           <code>listeners</code>
           <code>integer()</code>
           <code>1</code>
           Number of pre-started listeners for TCP and TLS
           (see <url href="http://ninenines.eu/docs/en/ranch/HEAD/guide/introduction">Ranch's</url> documentation)
       <br />
       
           <code>certfile</code>
           <code>string()</code>
           <code>"(privir)/cert.pem"</code>
            Path to the certificate file for TLS
       <br />
       
           <code>keyfile</code>
           <code>string()</code>
           <code>"(privdir)/key.pem"</code>
           Path to the key file for TLS
       <br />
       
           <code>route</code>
           <a href="#type-user_uri" class="seealso">user_uri()</a>
           
            Route (outbound proxy) to use. Generates one or more <code>Route</code> headers
               in every request, for example <code>&lt;sip:1.2.3.4;lr&gt;, &lt;sip:abcd;lr&gt;</code>
               (you will usually append the <code>lr</code> option to use <i>loose routing</i>)
           
       <br />
       
           <code>local_host</code>
           <code>auto|string()|binary()</code>
           <code>auto</code>
           Default host or IP to use in headers like <code>Via</code>, <code>Contact</code> and
           <code>Record-Route</code>.<br />
           If set to <code>auto</code>, NkSIP will use the IP of the
           transport selected in every case. If that transport is listening on all
           addresses (<code>{0,0,0,0}</code>), NkSIP will try to find the best IP, using the first
           valid IP of all the network interfaces in this order: <code>eth0, eth1, en0, en1</code>,
           or any other IP address of the host
       <br />
       
           <code>registrar</code>
           
           
           If present, allows the automatic processing <i>REGISTER</i> requests,
           even if no <code>register/3</code> callback  is defined, using
           <a href="nksip_sipapp.html#register/3" class="seealso">nksip_sipapp:register/3</a>.<br />
           The word <i>REGISTER</i> will also be present in all <i>Allow</i> headers.
           
       <br />
       
           <code>no_100</code>
           
           
           If present, forbids the generation of automatic <code>100-type</code> responses
           if no other response has been generated after 100 msecs
       <br />
   
 
  <p><br /></p>
</div></div>
<div class="function">
<h3 id="stop/1">stop(AppId::sipapp_id()) -&gt; ok | error</h3>


<div class="description">

<p>Stops a started SipApp, stopping any registered transports.</p>
</div></div>
<div class="function">
<h3 id="stop_all/0">stop_all() -&gt; ok</h3>


<div class="description">

<p>Stops all started SipApps.</p>
</div></div>
<div class="function">
<h3 id="get_all/0">get_all() -&gt; [AppId::sipapp_id()]</h3>


<div class="description">

<p>Gets the <code>AppIds</code> of all started SipApps.</p>
</div></div>
<div class="function">
<h3 id="reply/1">reply(From::{reference(), pid()} | {fsm, reference(), pid()}, Reply::term()) -&gt; term()</h3>


<div class="description">

<p>Sends a response from a synchronous callback function.
  (equivalent to <code>gen_server:reply/2</code>)</p>
</div></div>
<div class="function">
<h3 id="call/1">call(AppId::sipapp_id(), Msg::term()) -&gt; any()</h3>


<div class="description">

<p>Sends a synchronous message to the SipApp's process,
  similar to <code>gen_server:call/2</code>.
  The SipApp's callback module must implement <code>handle_call/3</code>.</p>
</div></div>
<div class="function">
<h3 id="call/1-1">call(AppId::sipapp_id(), Msg::term(), Timeout::infinity | pos_integer()) -&gt; any()</h3>


<div class="description">

<p>Sends a synchronous message to the SipApp's process with a timeout,
  similar to <code>gen_server:call/3</code>.
  The SipApp's callback module must implement <code>handle_call/3</code>.</p>
</div></div>
<div class="function">
<h3 id="cast/1">cast(AppId::sipapp_id(), Msg::term()) -&gt; ok</h3>


<div class="description">

<p>Sends an asynchronous message to the SipApp's process,
  similar to <code>gen_server:cast/2</code>.
  The SipApp's callback module must implement <code>handle_cast/2</code>.</p>
</div></div>
<div class="function">
<h3 id="get_pid/1">get_pid(Id::sipapp_id()) -&gt; pid() | not_found</h3>


<div class="description">

<p>Gets the SipApp's process <code>pid()</code>.</p>
</div></div>
<div class="function">
<h3 id="get_port/1">get_port(AppId::sipapp_id(), Proto::protocol()) -&gt; port_number() (see module inet) | not_found</h3>


<div class="description">

<p>Gets SipApp'sfirst listening port on this transport protocol.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
