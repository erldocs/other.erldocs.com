<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gproc (gproc) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gproc</h1>
<h2 class="modsummary">Extended process registry  
This module implements an extended process registry.</h2>
<div class="description">
<p>Extended process registry  
This module implements an extended process registry</p>
 
  <p>For a detailed description, see
  <url href="erlang07-wiger.pdf">erlang07-wiger.pdf</url>.</p>
 
  <p><em>Tuning Gproc performance</em></p>
 
  <p>Gproc relies on a central server and an ordered-set ets table.
  Effort is made to perform as much work as possible in the client without
  sacrificing consistency. A few things can be tuned by setting the following
  application environment variables in the top application of <code>gproc</code>
  (usually <code>gproc</code>):</p>
 
  <p>* <code>{ets_options, list()}</code> - Currently, the options <code>{write_concurrency, F}</code>
    and <code>{read_concurrency, F}</code> are allowed. The default is
    <code>[{write_concurrency, true}, {read_concurrency, true}]</code>
  * <code>{server_options, list()}</code> - These will be passed as spawn options when
    starting the <code>gproc</code> and <code>gproc_dist</code> servers. Default is <code>[]</code>. It is
    likely that <code>{priority, high | max}</code> and/or increasing <code>min_heap_size</code>
    will improve performance.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-context">context() = {scope(), type()} | type()</h3></div>
    <div class="type"><h3 id="type-ctr_incr">ctr_incr() = integer()</h3></div>
    <div class="type"><h3 id="type-ctr_setval">ctr_setval() = integer()</h3></div>
    <div class="type"><h3 id="type-ctr_thr">ctr_thr() = integer()</h3></div>
    <div class="type"><h3 id="type-ctr_update">ctr_update() = <a href="#type-ctr_incr" class="seealso">ctr_incr()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {<a href="#type-ctr_incr" class="seealso">ctr_incr()</a>, <a href="#type-ctr_thr" class="seealso">ctr_thr()</a>, <a href="#type-ctr_setval" class="seealso">ctr_setval()</a>}</h3></div>
    <div class="type"><h3 id="type-headpat">headpat() = {keypat(), pidpat(), ValPat}</h3></div>
    <div class="type"><h3 id="type-increment">increment() = <a href="#type-ctr_incr" class="seealso">ctr_incr()</a> | <a href="#type-ctr_update" class="seealso">ctr_update()</a> | [<a href="#type-ctr_update" class="seealso">ctr_update()</a>]</h3></div>
    <div class="type"><h3 id="type-key">key() = {<a href="#type-type" class="seealso">type()</a>, <a href="#type-scope" class="seealso">scope()</a>, any()}</h3></div>
    <div class="type"><h3 id="type-keypat">keypat() = {sel_type() | sel_var(), l | g | sel_var(), any()}</h3></div>
    <div class="type"><h3 id="type-pidpat">pidpat() = pid() | sel_var()</h3></div>
    <div class="type"><h3 id="type-reg_id">reg_id() = {type(), scope(), any()}</h3></div>
    <div class="type"><h3 id="type-scope">scope() = l | g</h3></div>
    <div class="type"><h3 id="type-sel_pattern">sel_pattern() = [{headpat(), Guards, Prod}]</h3></div>
    <div class="type"><h3 id="type-sel_scope">sel_scope() = scope | all | global | local</h3></div>
    <div class="type"><h3 id="type-sel_type">sel_type() = type() | names | props | counters | aggr_counters</h3></div>
    <div class="type"><h3 id="type-sel_var">sel_var() = DollarVar | '_'</h3></div>
    <div class="type"><h3 id="type-type">type() = n | p | c | a</h3></div>
    <div class="type"><h3 id="type-unique_id">unique_id() = {n | a, scope(), any()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, pid()}</h3>


<div class="description">

<p>Starts the gproc server.</p>
 
  <p>This function is intended to be called from gproc_sup, as part of
  starting the gproc application.</p>
</div></div>
<div class="function">
<h3 id="add_local_name/1">add_local_name(Name) -&gt; term()
</h3>


<div class="description">

<p>Registers a local (unique) name. @equiv reg({n,l,Name})</p>
</div></div>
<div class="function">
<h3 id="add_global_name/1">add_global_name(Name) -&gt; term()
</h3>


<div class="description">

<p>Registers a global (unique) name. @equiv reg({n,g,Name})</p>
</div></div>
<div class="function">
<h3 id="add_local_property/2">add_local_property(Name, Value) -&gt; term()
</h3>


<div class="description">

<p>Registers a local (non-unique) property. @equiv reg({p,l,Name},Value)</p>
</div></div>
<div class="function">
<h3 id="add_global_property/2">add_global_property(Name, Value) -&gt; term()
</h3>


<div class="description">

<p>Registers a global (non-unique) property. @equiv reg({p,g,Name},Value)</p>
</div></div>
<div class="function">
<h3 id="add_local_counter/2">add_local_counter(Name, Initial) -&gt; term()
</h3>


<div class="description">

<p>Registers a local (non-unique) counter. @equiv reg({c,l,Name},Value)</p>
</div></div>
<div class="function">
<h3 id="add_shared_local_counter/2">add_shared_local_counter(Name, Initial) -&gt; term()
</h3>


<div class="description">

<p>Registers a local shared (unique) counter.</p>
</div></div>
<div class="function">
<h3 id="add_global_counter/2">add_global_counter(Name, Initial) -&gt; term()
</h3>


<div class="description">

<p>Registers a global (non-unique) counter. @equiv reg({c,g,Name},Value)</p>
</div></div>
<div class="function">
<h3 id="add_local_aggr_counter/1">add_local_aggr_counter(Name) -&gt; term()
</h3>


<div class="description">

<p>Registers a local (unique) aggregated counter.</p>
</div></div>
<div class="function">
<h3 id="add_global_aggr_counter/1">add_global_aggr_counter(Name) -&gt; term()
</h3>


<div class="description">

<p>Registers a global (unique) aggregated counter.</p>
</div></div>
<div class="function">
<h3 id="lookup_local_name/1">lookup_local_name(Name::any()) -&gt; pid()</h3>


<div class="description">

<p>Lookup a local unique name. Fails if there is no such name.</p>
</div></div>
<div class="function">
<h3 id="lookup_global_name/1">lookup_global_name(Name::any()) -&gt; pid()</h3>


<div class="description">

<p>Lookup a global unique name. Fails if there is no such name.</p>
</div></div>
<div class="function">
<h3 id="lookup_local_aggr_counter/1">lookup_local_aggr_counter(Name::any()) -&gt; integer()</h3>


<div class="description">

<p>Lookup a local (unique) aggregated counter and returns its value.
  Fails if there is no such object.</p>
</div></div>
<div class="function">
<h3 id="lookup_global_aggr_counter/1">lookup_global_aggr_counter(Name::any()) -&gt; integer()</h3>


<div class="description">

<p>Lookup a global (unique) aggregated counter and returns its value.
  Fails if there is no such object.</p>
</div></div>
<div class="function">
<h3 id="lookup_local_properties/1">lookup_local_properties(Property::any()) -&gt; [{pid(), Value}]</h3>


<div class="description">

<p>Look up all local (non-unique) instances of a given Property.
  Returns a list of {Pid, Value} tuples for all matching objects.</p>
</div></div>
<div class="function">
<h3 id="lookup_global_properties/1">lookup_global_properties(Property::any()) -&gt; [{pid(), Value}]</h3>


<div class="description">

<p>Look up all global (non-unique) instances of a given Property.
  Returns a list of {Pid, Value} tuples for all matching objects.</p>
</div></div>
<div class="function">
<h3 id="lookup_local_counters/1">lookup_local_counters(Counter::any()) -&gt; [{pid(), Value::integer()}]</h3>


<div class="description">

<p>Look up all local (non-unique) instances of a given Counter.
  Returns a list of {Pid, Value} tuples for all matching objects.</p>
</div></div>
<div class="function">
<h3 id="lookup_global_counters/1">lookup_global_counters(Counter::any()) -&gt; [{pid(), Value::integer()}]</h3>


<div class="description">

<p>Look up all global (non-unique) instances of a given Counter.
  Returns a list of {Pid, Value} tuples for all matching objects.</p>
</div></div>
<div class="function">
<h3 id="get_env/1">get_env(Scope::scope(), App::atom(), Key::atom()) -&gt; term()</h3>


<div class="description">
<p>Equivalent to <a href="#get_env/4" class="seealso">get_env(Scope, App, Key, [app_env])</a>.</p>
</div></div>
<div class="function">
<h3 id="get_env/1-1">get_env(Scope::scope(), App::atom(), Key::atom(), Strategy) -&gt; term()</h3>

<ul class="type">
<li><code>Strategy = [Alternative]</code></li><li><code>Alternative = app_env | os_env | inherit | {inherit, pid()} | {inherit, unique_id()} | init_arg | {mnesia, ActivityType, Oid, Pos} | {default, term()} | error</code></li></ul>
<div class="description">

<p>Read an environment value, potentially cached as a <code>gproc_env</code> property.</p>
 
  <p>This function first tries to read the value of a cached property,
  <code>{p, Scope, {gproc_env, App, Key}}</code>. If this fails, it will try the provided
  alternative strategy. <code>Strategy</code> is a list of alternatives, tried in order.  
Each alternative can be one of:</p>
 
  <p>* <code>app_env</code> - try <code>application:get_env(App, Key)</code>
  * <code>os_env</code> - try <code>os:getenv(ENV)</code>, where <code>ENV</code> is <code>Key</code> converted into an
    uppercase string
  * <code>{os_env, ENV}</code> - try <code>os:getenv(ENV)</code>
  * <code>inherit</code> - inherit the cached value, if any, held by the parent process.
  * <code>{inherit, Pid}</code> - inherit the cached value, if any, held by <code>Pid</code>.
  * <code>{inherit, Id}</code> - inherit the cached value, if any, held by the process
     registered in <code>gproc</code> as <code>Id</code>.
  * <code>init_arg</code> - try <code>init:get_argument(Key)</code>; expects a single value, if any.
  * <code>{mnesia, ActivityType, Oid, Pos}</code> - try
    <code>mnesia:activity(ActivityType, fun() -&gt; mnesia:read(Oid) end)</code>; retrieve
     the value in position <code>Pos</code> if object found.
  * <code>{default, Value}</code> - set a default value to return once alternatives have
     been exhausted; if not set, <code>undefined</code> will be returned.
  * <code>error</code> - raise an exception, <code>erlang:error(gproc_env, [App, Key, Scope])</code>.</p>
 
  <p>While any alternative can occur more than once, the only one that might make
  sense to use multiple times is <code>{default, Value}</code>.</p>
 
  <p>The return value will be one of:</p>
 
  <p>* The value of the first matching alternative, or <code>error</code> eception,
    whichever comes first
  * The last instance of <code>{default, Value}</code>, or <code>undefined</code>, if there is no
    matching alternative, default or <code>error</code> entry in the list.</p>
 
  <p>The <code>error</code> option can be used to assert that a value has been previously
  cached. Alternatively, it can be used to assert that a value is either cached
  or at least defined somewhere,
  e.g. <code>get_env(l, mnesia, dir, [app_env, error])</code>.</p>
</div></div>
<div class="function">
<h3 id="get_set_env/1">get_set_env(Scope::scope(), App::atom(), Key::atom()) -&gt; term()</h3>


<div class="description">
<p>Equivalent to <a href="#get_set_env/4" class="seealso">get_set_env(Scope, App, Key, [app_env])</a>.</p>
</div></div>
<div class="function">
<h3 id="get_set_env/1-1">get_set_env(Scope::scope(), App::atom(), Key::atom(), Strategy) -&gt; Value</h3>


<div class="description">

<p>Fetch and cache an environment value, if not already cached.</p>
 
  <p>This function does the same thing as <a href="#get_env/4" class="seealso">get_env/4</a>, but also updates the
  cache. Note that the cache will be updated even if the result of the lookup
  is <code>undefined</code>.
 </p>
<p><em>See also:</em> <a href="#get_env/4" class="seealso">get_env/4</a>.</p>
</div></div>
<div class="function">
<h3 id="set_env/1">set_env(Scope::scope(), App::atom(), Key::atom(), Value::term(), Strategy) -&gt; Value</h3>

<ul class="type">
<li><code>Strategy = [Alternative]</code></li><li><code>Alternative = app_env | os_env | {os_env, VAR} | {mnesia, ActivityType, Oid, Pos}</code></li></ul>
<div class="description">

<p>Updates the cached value as well as underlying environment.</p>
 
  <p>This function should be exercised with caution, as it affects the larger  
environment outside gproc. This function modifies the cached value, and then  
proceeds to update the underlying environment (OS environment variable or  
application environment variable).</p>
 
  <p>When the <code>mnesia</code> alternative is used, gproc will try to update any existing
  object, changing only the <code>Pos</code> position. If no such object exists, it will
  create a new object, setting any other attributes (except <code>Pos</code> and the key)
  to <code>undefined</code>.</p>
</div></div>
<div class="function">
<h3 id="reg/1">reg(Key::key()) -&gt; true</h3>


<div class="description">
<p>Equivalent to <a href="#reg/2" class="seealso">reg(Key, default(Key))</a>.</p>
</div></div>
<div class="function">
<h3 id="reg_or_locate/1">reg_or_locate(Key::key()) -&gt; true</h3>


<div class="description">
<p>Equivalent to <a href="#reg_or_locate/2" class="seealso">reg_or_locate(Key, default(Key))</a>.</p>
</div></div>
<div class="function">
<h3 id="default/1">default(X1) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="await/1">await(Key::key()) -&gt; {pid(), Value}</h3>


<div class="description">
<p>Equivalent to <a href="#await/2" class="seealso">await(Key, infinity)</a>.</p>
</div></div>
<div class="function">
<h3 id="await/1-1">await(Key::key(), Timeout) -&gt; {pid(), Value}</h3>

<ul class="type">
<li><code>Timeout = integer() | infinity</code></li></ul>
<div class="description">

<p>Wait for a local name to be registered.
  The function raises an exception if the timeout expires. Timeout must be
  either an interger &gt; 0 or 'infinity'.
  A small optimization: we first perform a lookup, to see if the name
  is already registered. This way, the cost of the operation will be
  roughly the same as of where/1 in the case where the name is already
  registered (the difference: await/2 also returns the value).</p>
</div></div>
<div class="function">
<h3 id="await/1-2">await(Node::node(), Key::key(), Timeout) -&gt; {pid(), Value}</h3>

<ul class="type">
<li><code>Timeout = integer() | infinity</code></li></ul>
<div class="description">

<p>Wait for a local name to be registered on <code>Node</code>.
  This function works exactly like <a href="#await/2" class="seealso">await/2</a>, but queries a remote
  node instead. An exception is thrown if <code>Node</code> cannot be reached. If gproc
  is not running on a given node, this is treated the same as the node being
  down.</p>
</div></div>
<div class="function">
<h3 id="wide_await/1">wide_await(Nodes::[node()], Key::key(), Timeout) -&gt; {pid(), Value}</h3>

<ul class="type">
<li><code>Timeout = integer() | infinity</code></li></ul>
<div class="description">

<p>Wait for a local name to be registered on any of <code>Nodes</code>.
  This function works rather like <a href="#await/2" class="seealso">await/2</a>, but queries all nodes in
  the <code>Nodes</code> list at the same time. The first node to respond with a
  process registered as <code>Key</code> will provide the result. Other results are
  ignored. <code>Key</code> must be a unique name with local scope, i.e. <code>{n,l,Name}</code>.</p>
 
  <p>An exception is thrown upon timeout, or if no node can be reached (if gproc is
  not running on a given node, this is treated the same as the node being down).</p>
</div></div>
<div class="function">
<h3 id="nb_wait/1">nb_wait(Key::key()) -&gt; Ref</h3>


<div class="description">

<p>Wait for a local name to be registered.
  The caller can expect to receive a message,
  {gproc, Ref, registered, {Key, Pid, Value}}, once the name is registered.</p>
</div></div>
<div class="function">
<h3 id="nb_wait/1-1">nb_wait(Node::node(), Key::key()) -&gt; Ref</h3>


<div class="description">

<p>Wait for a local name to be registered on <code>Node</code>.
  The caller can expect to receive a message,
  {gproc, Ref, registered, {Key, Pid, Value}}, once the name is registered.</p>
</div></div>
<div class="function">
<h3 id="cancel_wait/1">cancel_wait(Key::key(), Ref) -&gt; ok</h3>

<ul class="type">
<li><code>Ref = all | reference()</code></li></ul>
<div class="description">

<p>Cancels a previous call to nb_wait/1</p>
 
  <p>If <code>Ref = all</code>, all wait requests on <code>Key</code> from the calling process
  are canceled.</p>
</div></div>
<div class="function">
<h3 id="cancel_wait/1-1">cancel_wait(Node::node(), Key::key(), Ref) -&gt; ok</h3>

<ul class="type">
<li><code>Ref = all | reference()</code></li></ul>
<div class="description">

<p>Cancels a previous call to nb_wait/2</p>
 
  <p>This function works just like <a href="#cancel_wait/2" class="seealso">cancel_wait/2</a>, but talks to a remote
  node.</p>
</div></div>
<div class="function">
<h3 id="cancel_wait_or_monitor/1">cancel_wait_or_monitor(Key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="monitor/1">monitor(Key::key()) -&gt; reference()</h3>


<div class="description">

<p>monitor a registered name
  This function works much like erlang:monitor(process, Pid), but monitors
  a unique name registered via gproc. A message, <code>{gproc, unreg, Ref, Key}</code>  
will be sent to the requesting process, if the name is unregistered or  
the registered process dies.</p>
 
  <p>If the name is not yet registered, the same message is sent immediately.</p>
</div></div>
<div class="function">
<h3 id="demonitor/1">demonitor(Key::key(), Ref::reference()) -&gt; ok</h3>


<div class="description">

<p>Remove a monitor on a registered name
  This function is the reverse of monitor/1. It removes a monitor previously
  set on a unique name. This function always succeeds given legal input.</p>
</div></div>
<div class="function">
<h3 id="reg/1-1">reg(Key::key(), Value) -&gt; true</h3>


<div class="description">

<p>Register a name or property for the current process</p>
 
 
</div></div>
<div class="function">
<h3 id="reg_or_locate/1-1">reg_or_locate(Key::key(), Value) -&gt; {pid(), NewValue}</h3>


<div class="description">

<p>Try registering a unique name, or return existing registration.</p>
 
  <p>This function tries to register the name <code>Key</code>, if available.
  If such a registration object already exists, the pid and value of
  the current registration is returned instead.</p>
</div></div>
<div class="function">
<h3 id="reg_or_locate/1-2">reg_or_locate(Key::key(), Value, Fun::function()) -&gt; {pid(), NewValue}</h3>


<div class="description">

<p>Spawn a process with a registered name, or return existing registration.</p>
 
  <p>This function checks whether a local name is registered; if not, it spawns
  a new process (with <code>spawn(Fun)</code>) and gives it the name.  
The pid and value of the resulting registration is returned.</p>
 
  <p>This function is only available for local registration. While it could
  theoretically be done in the global case, the spawning of a new process
  on a remote node by the leader instance is more problematic.</p>
</div></div>
<div class="function">
<h3 id="reg_shared/1">reg_shared(Key::key()) -&gt; true</h3>


<div class="description">

<p>Register a resource, but don't tie it to a particular process.</p>
 
  <p><code>reg_shared({c,l,C}) -&gt; reg_shared({c,l,C}, 0).</code>
  <code>reg_shared({a,l,A}) -&gt; reg_shared({a,l,A}, undefined).</code></p>
</div></div>
<div class="function">
<h3 id="reg_shared/1-1">reg_shared(Key::key(), Value) -&gt; true</h3>


<div class="description">

<p>Register a resource, but don't tie it to a particular process.</p>
 
  <p>Shared resources are all unique. They remain until explicitly unregistered
  (using <a href="#unreg_shared/1" class="seealso">unreg_shared/1</a>). The types of shared resources currently
  supported are <code>counter</code> and <code>aggregated counter</code>. In listings and query
  results, shared resources appear as other similar resources, except that
  <code>Pid == shared</code>. To wit, update_counter({c,l,myCounter}, shared, 1) would
  increment the shared counter <code>myCounter</code> with 1, provided it exists.</p>
 
  <p>A shared aggregated counter will track updates in exactly the same way as
  an aggregated counter which is owned by a process.</p>
</div></div>
<div class="function">
<h3 id="mreg/1">mreg(T::type(), C::scope(), KVL::[{Key::any(), Value::any()}]) -&gt; true</h3>


<div class="description">

<p>Register multiple {Key,Value} pairs of a given type and scope.</p>
 
  <p>This function is more efficient than calling <a href="#reg/2" class="seealso">reg/2</a> repeatedly.
  It is also atomic in regard to unique names; either all names are registered
  or none are.</p>
</div></div>
<div class="function">
<h3 id="munreg/1">munreg(T::type(), C::scope(), L::[Key::any()]) -&gt; true</h3>


<div class="description">

<p>Unregister multiple Key items of a given type and scope.</p>
 
  <p>This function is usually more efficient than calling <a href="#unreg/1" class="seealso">unreg/1</a>
  repeatedly.</p>
</div></div>
<div class="function">
<h3 id="unreg/1">unreg(Key::key()) -&gt; true</h3>


<div class="description">

<p>Unregister a name or property.</p>
</div></div>
<div class="function">
<h3 id="set_attributes/1">set_attributes(Key::key(), Props::[{atom(), any()}]) -&gt; true</h3>


<div class="description">

<p>Add/modify <code>{Key, Value}</code> attributes associated with a registration.</p>
 
  <p>Gproc registration objects can have <code>{Key, Value}</code> attributes associated with  
them. These are stored in a way that doesn't affect the cost of name lookup.</p>
 
  <p>Attributs can be retrieved using <code>gproc:get_attribute/3</code> or
  <code>gproc:get_attributes/2</code>.</p>
</div></div>
<div class="function">
<h3 id="unreg_shared/1">unreg_shared(Key::key()) -&gt; true</h3>


<div class="description">

<p>Unregister a shared resource.</p>
</div></div>
<div class="function">
<h3 id="set_attributes_shared/1">set_attributes_shared(Key::key(), Props::[{K, V}]) -&gt; true</h3>


<div class="description">

<p>Add/modify <code>{Key, Value}</code> attributes associated with a shared registration.</p>
 
  <p>Gproc registration objects can have <code>{Key, Value}</code> attributes associated with  
them. These are stored in a way that doesn't affect the cost of name lookup.</p>
 
  <p>Attributes can be retrieved using <code>gproc:get_attribute/3</code> or
  <code>gproc:get_attributes/2</code>.</p>
</div></div>
<div class="function">
<h3 id="register_name/1">register_name(Name::key(), Pid::pid()) -&gt; yes | no</h3>


<div class="description">

<p>Behaviour support callback</p>
</div></div>
<div class="function">
<h3 id="unregister_name/1">unregister_name(Key) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <code>unreg / 1</code>.</p>
</div></div>
<div class="function">
<h3 id="select/1">select(Continuation::Arg) -&gt; [Match] | {[Match], Continuation} | '$end_of_table'</h3>

<ul class="type">
<li><code>Arg = Continuation | sel_pattern()</code></li><li><code>Match = {Key, Pid, Value}</code></li></ul>
<div class="description">

<p>Perform a select operation on the process registry</p>
 
  <p>When Arg = Contination, resume a gproc:select/1 operation
  (see <url href="http://www.erlang.org/edoc/doc/stdlib/doc/ets.xml#select-1">ets:select/1</url></p>
 
  <p>When Arg = <code>sel_pattern()</code>, this function executes a select operation,  
emulating ets:select/1</p>
 
  <p><a href="#select/2" class="seealso">select/2</a> offers the opportunity to narrow the search  
(by limiting to only global or local scope, or a single type of object).  
When only a pattern as single argument is given, both global and local scope,  
as well as all types of object can be searched. Note that the pattern may  
still limit the select operation so that scanning the entire table is avoided.</p>
 
  <p>The physical representation in the registry may differ from the above,
  but the select patterns are transformed appropriately. The logical
  representation for the gproc select operations is given by
  <code>headpat()</code>.</p>
</div></div>
<div class="function">
<h3 id="select/1-1">select(Context::context(), Pat::sel_pattern()) -&gt; [{Key, Pid, Value}]</h3>


<div class="description">

<p>Perform a select operation with limited context on the process registry</p>
 
  <p>The physical representation in the registry may differ from the above,  
but the select patterns are transformed appropriately.</p>
 
  <p>Note that limiting the context is just a convenience function, allowing you
  to write a simpler select pattern and still avoid searching the entire
  registry. Whenever variables are used in the head pattern, this will result
  in a wider scan, even if the values are restricted through a guard (e.g.
  <code>select([{'$1','$2','$3'}, [{'==', '$1', p}], ...])</code> will count as a wild
  pattern on the key and result in a full scan). In this case, specifying a
  Context will allow gproc to perform some variable substitution and ensure
  that the scan is limited.</p>
</div></div>
<div class="function">
<h3 id="select/1-2">select(Context::context(), Pat::sel_patten(), Limit::integer()) -&gt; {[Match], Continuation} | '$end_of_table'</h3>


<div class="description">

<p>Like <a href="#select/2" class="seealso">select/2</a> but returns Limit objects at a time.</p>
 
  <p>See <url href="http://www.erlang.org/doc/man/ets.html#select-3">http://www.erlang.org/doc/man/ets.html#select-3</url>.</p>
</div></div>
<div class="function">
<h3 id="select_count/1">select_count(Pat::sel_pattern()) -&gt; [sel_object()]</h3>


<div class="description">
<p>Equivalent to <a href="#select_count/2" class="seealso">select_count(all, Pat)</a>.</p>
</div></div>
<div class="function">
<h3 id="select_count/1-1">select_count(Context::context(), Pat::sel_pattern()) -&gt; [{Key, Pid, Value}]</h3>


<div class="description">

<p>Perform a select_count operation on the process registry.</p>
 
  <p>The physical representation in the registry may differ from the above,
  but the select patterns are transformed appropriately.</p>
</div></div>
<div class="function">
<h3 id="set_value/1">set_value(Key::key(), Value) -&gt; true</h3>


<div class="description">

<p>Sets the value of the registration given by Key</p>
 
  <p>Key is assumed to exist and belong to the calling process.  
If it doesn't, this function will exit.</p>
 
  <p>Value can be any term, unless the object is a counter, in which case
  it must be an integer.</p>
</div></div>
<div class="function">
<h3 id="set_value_shared/1">set_value_shared(Key::key(), Value) -&gt; true</h3>


<div class="description">

<p>Sets the value of the shared registration given by Key</p>
 
  <p>Key is assumed to exist as a shared entity.  
If it doesn't, this function will exit.</p>
 
  <p>Value can be any term, unless the object is a counter, in which case
  it must be an integer.</p>
</div></div>
<div class="function">
<h3 id="get_value/1">get_value(Key) -&gt; Value</h3>


<div class="description">

<p>Reads the value stored with a key registered to the current process.</p>
 
  <p>If no such key is registered to the current process, this function exits.</p>
</div></div>
<div class="function">
<h3 id="get_value/2">get_value(Key, Pid) -&gt; Value</h3>


<div class="description">

<p>Reads the value stored with a key registered to the process Pid.</p>
 
  <p>If <code>Pid == shared</code>, the value of a shared key (see <a href="#reg_shared/1" class="seealso">reg_shared/1</a>)
  will be read.</p>
</div></div>
<div class="function">
<h3 id="get_attribute/2">get_attribute(Key, Attribute::atom()) -&gt; Value</h3>


<div class="description">

<p>Get attribute value of <code>Attr</code> associated with <code>Key</code> for most likely Pid.</p>
 
  <p>The most likely Pid in this case is <code>self()</code> for properties and counters,
  and the current registration holder in case of names or aggregated counters.
  An exception is raised if <code>Key</code> is not registered for the given process.</p>
</div></div>
<div class="function">
<h3 id="get_attribute/2-1">get_attribute(Key, Pid::pid() | shared, Attr::atom()) -&gt; Value</h3>


<div class="description">

<p>Get the attribute value of <code>Attr</code> associated with <code>Key</code> for process Pid.</p>
 
  <p>If <code>Pid == shared</code>, the attribute of a shared key (see <a href="#reg_shared/1" class="seealso">reg_shared/1</a>)
  will be read.</p>
</div></div>
<div class="function">
<h3 id="get_attributes/1">get_attributes(Key::key()) -&gt; [{K, V}]</h3>


<div class="description">

<p>Get attributes associated with registration.</p>
</div></div>
<div class="function">
<h3 id="get_attributes/1-1">get_attributes(Key::key(), Pid::pid() | shared) -&gt; [{K, V}]</h3>


<div class="description">

<p>Returns the list of attributes associated with the registration.</p>
 
  <p>This function raises a <code>badarg</code> exception if there is no corresponding
  registration.
 </p>
</div></div>
<div class="function">
<h3 id="lookup_pid/1">lookup_pid(Key) -&gt; Pid</h3>


<div class="description">

<p>Lookup the Pid stored with a key.
 </p>
</div></div>
<div class="function">
<h3 id="lookup_value/1">lookup_value(Key) -&gt; Value</h3>


<div class="description">

<p>Lookup the value stored with a key.
 </p>
</div></div>
<div class="function">
<h3 id="where/1">where(Key::key()) -&gt; pid()</h3>


<div class="description">

<p>Returns the pid registered as Key</p>
 
  <p>The type of registration must be either name or aggregated counter.
  Otherwise this function will exit. Use <a href="#lookup_pids/1" class="seealso">lookup_pids/1</a> in these
  cases.</p>
</div></div>
<div class="function">
<h3 id="whereis_name/1">whereis_name(Key) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <code>where / 1</code>.</p>
</div></div>
<div class="function">
<h3 id="lookup_pids/1">lookup_pids(Key::key()) -&gt; [pid()]</h3>


<div class="description">

<p>Returns a list of pids with the published key Key</p>
 
  <p>If the type of registration is either name or aggregated counter,  
this function will return either an empty list, or a list of one pid.  
For non-unique types, the return value can be a list of any length.</p>
 
  <p>Note: shared resources are not associated with any pid, and will
  therefore be excluded.</p>
</div></div>
<div class="function">
<h3 id="lookup_values/1">lookup_values(Key::key()) -&gt; [{pid(), Value}]</h3>


<div class="description">

<p>Retrieve the <code>{Pid,Value}</code> pairs corresponding to Key.</p>
 
  <p>Key refer to any type of registry object. If it refers to a unique
  object, the list will be of length 0 or 1. If it refers to a non-unique
  object, the return value can be a list of any length.</p>
</div></div>
<div class="function">
<h3 id="update_counter/1">update_counter(Key::key(), Incr::increment()) -&gt; integer()</h3>


<div class="description">

<p>Updates the counter registered as Key for the current process.</p>
 
  <p>This function works almost exactly like ets:update_counter/3
  (see <url href="http://www.erlang.org/doc/man/ets.html#update_counter-3">http://www.erlang.org/doc/man/ets.html#update_counter-3</url>), but  
will fail if the type of object referred to by Key is not a counter or  
a unique name (update_counter/2 can be performed on names as well, but they  
do not count as counter objects, and do not affect aggregated counters).</p>
 
  <p>Aggregated counters with the same name will be updated automatically.
  The <code>UpdateOp</code> patterns are the same as for <code>ets:update_counter/3</code>, except
  that the position is omitted; in gproc, the value position is always <code>3</code>.</p>
 
  <p>If <code>Key</code> refers to a unique name, the operation will depend on the value
  part of the registration being an integer(). While non-integer values are
  not permitted at all for counter objects, it is the user's responsibility to
  ensure that a name, on which <code>update_counter/2</code> is to be performed, has the
  appropriate value type.</p>
</div></div>
<div class="function">
<h3 id="update_counter/3">update_counter(Key, Pid, Incr) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update_counters/1">update_counters(X1::scope(), Cs::[{key(), pid(), increment()}]) -&gt; [{key(), pid(), integer()}]</h3>


<div class="description">

<p>Update a list of counters</p>
 
  <p>This function is not atomic, except (in a sense) for global counters. For local counters,
  it is more of a convenience function. For global counters, it is much more efficient
  than calling <code>gproc:update_counter/2</code> for each individual counter.</p>
 
  <p>The return value is the corresponding list of <code>[{Counter, Pid, NewValue}]</code>.</p>
</div></div>
<div class="function">
<h3 id="reset_counter/1">reset_counter(Key) -&gt; {ValueBefore, ValueAfter}</h3>

<ul class="type">
<li><code>Key = {c, Scope, Name}</code></li><li><code>Scope = l | g</code></li><li><code>ValueBefore = integer()</code></li><li><code>ValueAfter = integer()</code></li></ul>
<div class="description">

<p>Reads and resets a counter in a "thread-safe" way</p>
 
  <p>This function reads the current value of a counter and then resets it to its
  initial value. The reset operation is done using <a href="#update_counter/2" class="seealso">update_counter/2</a>,
  which allows for concurrent calls to <a href="#update_counter/2" class="seealso">update_counter/2</a> without losing
  updates. Aggregated counters are updated accordingly.</p>
</div></div>
<div class="function">
<h3 id="update_shared_counter/1">update_shared_counter(Key::key(), Incr) -&gt; integer() | [integer()]</h3>

<ul class="type">
<li><code>Incr = IncrVal | UpdateOp | [UpdateOp]</code></li><li><code>UpdateOp = IncrVal | {IncrVal, Threshold, SetValue}</code></li><li><code>IncrVal = integer()</code></li></ul>
<div class="description">

<p>Updates the shared counter registered as Key.</p>
 
  <p>This function works almost exactly like ets:update_counter/3
  (see <url href="http://www.erlang.org/doc/man/ets.html#update_counter-3">http://www.erlang.org/doc/man/ets.html#update_counter-3</url>), but  
will fail if the type of object referred to by Key is not a counter.</p>
 
  <p>Aggregated counters with the same name will be updated automatically.
  The <code>UpdateOp</code> patterns are the same as for <code>ets:update_counter/3</code>, except
  that the position is omitted; in gproc, the value position is always <code>3</code>.</p>
</div></div>
<div class="function">
<h3 id="give_away/1">give_away(From::key(), To::pid() | key()) -&gt; undefined | pid()</h3>


<div class="description">

<p>Atomically transfers the key <code>From</code> to the process identified by <code>To</code>.</p>
 
  <p>This function transfers any gproc key (name, property, counter, aggr counter)  
from one process to another, and returns the pid of the new owner.</p>
 
  <p><code>To</code> must be either a pid or a unique name (name or aggregated counter), but
  does not necessarily have to resolve to an existing process. If there is
  no process registered with the <code>To</code> key, <code>give_away/2</code> returns <code>undefined</code>,
  and the <code>From</code> key is effectively unregistered.</p>
 
  <p>It is allowed to give away a key to oneself, but of course, this operation  
will have no effect.</p>
 
  <p>Fails with <code>badarg</code> if the calling process does not have a <code>From</code> key
  registered.</p>
</div></div>
<div class="function">
<h3 id="goodbye/0">goodbye() -&gt; ok</h3>


<div class="description">

<p>Unregister all items of the calling process and inform gproc  
to forget about the calling process.</p>
 
  <p>This function is more efficient than letting gproc perform these
  cleanup operations.</p>
</div></div>
<div class="function">
<h3 id="send/1">send(Key::process() | key(), Msg::any()) -&gt; Msg</h3>


<div class="description">

<p>Sends a message to the process, or processes, corresponding to Key.</p>
 
  <p>If Key belongs to a unique object (name or aggregated counter), this  
function will send a message to the corresponding process, or fail if there  
is no such process. If Key is for a non-unique object type (counter or  
property), Msg will be send to all processes that have such an object.</p>
 
  <p>Key can also be anything that the erlang:send/2, or '!' operator accepts as a process
  identifier, namely a pid(), an atom(), or <code>{Name::atom(), Node::atom()}</code>.</p>
</div></div>
<div class="function">
<h3 id="bcast/1">bcast(Key::key(), Msg::any()) -&gt; Msg</h3>


<div class="description">
<p>Equivalent to <a href="#bcast/3" class="seealso">bcast(nodes(), Key, Msg)</a>.</p>
</div></div>
<div class="function">
<h3 id="bcast/1-1">bcast(Nodes::[atom()], Key::key(), Msg::any()) -&gt; Msg</h3>


<div class="description">

<p>Sends a message to processes corresponding to Key on Nodes.</p>
 
  <p>This function complements <code>send/2</code> and works on locally registered resources
  that <code>send/2</code> supports. Messages are routed via a special broadcast server
  on each node to ensure that ordering is preserved. Distributed delivery
  is asynchronous and carries the same guarantees as normal message passing
  (with the added proviso that the broadcast server also needs to be available).</p>
<p><em>See also:</em> <a href="#send/2" class="seealso">send/2</a>.</p>
</div></div>
<div class="function">
<h3 id="first/1">first(Context::context()) -&gt; key() | '$end_of_table'</h3>


<div class="description">

<p>Behaves as ets:first(Tab) for a given type of registration.</p>
 
  <p>See <url href="http://www.erlang.org/doc/man/ets.html#first-1">http://www.erlang.org/doc/man/ets.html#first-1</url>.
   The registry behaves as an ordered_set table.</p>
</div></div>
<div class="function">
<h3 id="last/1">last(Context::context()) -&gt; key() | '$end_of_table'</h3>


<div class="description">

<p>Behaves as ets:last(Tab) for a given type of registration.</p>
 
  <p>See <url href="http://www.erlang.org/doc/man/ets.html#last-1">http://www.erlang.org/doc/man/ets.html#last-1</url>.
  The registry behaves as an ordered_set table.</p>
</div></div>
<div class="function">
<h3 id="next/1">next(Context::context(), Key::key()) -&gt; key() | '$end_of_table'</h3>


<div class="description">

<p>Behaves as ets:next(Tab,Key) for a given type of registration.</p>
 
  <p>See <url href="http://www.erlang.org/doc/man/ets.html#next-2">http://www.erlang.org/doc/man/ets.html#next-2</url>.
  The registry behaves as an ordered_set table.</p>
</div></div>
<div class="function">
<h3 id="prev/1">prev(Context::context(), Key::key()) -&gt; key() | '$end_of_table'</h3>


<div class="description">

<p>Behaves as ets:prev(Tab,Key) for a given type of registration.</p>
 
  <p>See <url href="http://www.erlang.org/doc/man/ets.html#prev-2">http://www.erlang.org/doc/man/ets.html#prev-2</url>.
  The registry behaves as an ordered_set table.</p>
</div></div>
<div class="function">
<h3 id="info/1">info(Pid::pid()) -&gt; ProcessInfo</h3>

<ul class="type">
<li><code>ProcessInfo = [{gproc, [{Key, Value}]} | ProcessInfo]</code></li></ul>
<div class="description">

<p>Similar to <code>process_info(Pid)</code> but with additional gproc info.</p>
 
  <p>Returns the same information as process_info(Pid), but with the
  addition of a <code>gproc</code> information item, containing the <code>{Key,Value}</code>
  pairs registered to the process.</p>
</div></div>
<div class="function">
<h3 id="info/1-1">info(Pid::pid(), Item::atom()) -&gt; {Item, Info}</h3>


<div class="description">

<p>Similar to process_info(Pid, Item), but with additional gproc info.</p>
 
  <p>For <code>Item = gproc</code>, this function returns a list of <code>{Key, Value}</code> pairs
  registered to the process Pid. For other values of Item, it returns the
  same as <url href="http://www.erlang.org/doc/man/erlang.html#process_info-2">http://www.erlang.org/doc/man/erlang.html#process_info-2</url>.</p>
</div></div>
<div class="function">
<h3 id="i/0">i() -&gt; ok</h3>


<div class="description">

<p>Similar to the built-in shell command <code>i()</code> but inserts information
  about names and properties registered in Gproc, where applicable.</p>
</div></div>
<div class="function">
<h3 id="audit_process/1">audit_process(Pid::pid()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="table/0">table() -&gt; any()</h3>


<div class="description">
<p>Equivalent to <a href="#table/1" class="seealso">table({all, all})</a>.</p>
</div></div>
<div class="function">
<h3 id="table/1">table(Context::context()) -&gt; any()</h3>


<div class="description">
<p>Equivalent to <a href="#table/2" class="seealso">table(Context, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="table/1-1">table(Context::context(), Opts) -&gt; any()</h3>


<div class="description">

<p>QLC table generator for the gproc registry.
  Context specifies which subset of the registry should be queried.
  See <url href="http://www.erlang.org/doc/man/qlc.html">http://www.erlang.org/doc/man/qlc.html</url>.</p>
 
  <p>NOTE: By default, the gproc table generator will not filter out entries
  belonging to processes that have just died, but which have yet to be cleared
  out of the registry. Use the option <code>check_pids</code> (or <code>{check_pids, true}</code>)
  if you want to filter out dead entries already in the query. There will be
  some overhead associated with doing so, and given that the process monitoring
  is asynchronous, there can never be any guarantee that there are no dead
  entries in the list by the time your program processes it.
 </p>
</div></div></div>

<authors>

<aname>Ulf Wiger</aname>
<email>ulf@wiger.net</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
