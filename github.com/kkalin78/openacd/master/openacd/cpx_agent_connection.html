<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cpx_agent_connection (openacd) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>cpx_agent_connection</h1>
<h2 class="modsummary">?? at the beginning of thier documentation conform to the form  
above with one caveat:  The first argument is always the internal state  
of the connection, and is obviously not sent with the json requests.</h2>
<div class="description">
<p>?? at the beginning of thier documentation conform to the form  
above with one caveat:  The first argument is always the internal state  
of the connection, and is obviously not sent with the json requests.  
Thus, a properly documented project will be useful to agent connection  
and agent client developers.</p>
 
  <p>Request_id is an opaque type sent by the client; it is sent back with  
the reply to enable asynchronous requests.</p>
 
  <p>A json response will have 3 major forms.</p>
 
  <p>A very simple success:
  </p><pre class="sh_erlang"> {
   "request_id": any(),
  	"success":  true
  }</pre><p>
  A success with a result:
  </p><pre class="sh_erlang"> {
   "request_id": any(),
  	"success":  true,
  	"result":   any()
  }</pre><p>
  A failure:
  </p><pre class="sh_erlang"> {
   "request_id":  any(),
  	"success":  false,
  	"message":  string(),
  	"errcode":  string()
  }</pre>
 
  <p><em><marker id="Events">Events</marker></em></p>
 
  <p>A server event is a json object with at least a "command" property.  If  
the command references a specific agent channel, it will also have a  
"channel_id" property.  All other properties are specific to the server  
events.</p>
 
  <p><em><marker id="Erlang_API">Erlang API</marker></em></p>
 
  <p>There are two sides to the erlang API, the connection facing side (such  
as a web or tcp connection), and the api handler side, such as this  
module or plugins handing agent requests.</p>
 
  <p><em><marker id="Agent_Connections">Agent Connections</marker></em></p>
 
  <p>After the login procedure, init/1 should be called, passing in the agent
  record (prefereably after the connection is set).  If a reply of
  <code>{ok, #state{}}</code> is returned, stash the state.  It will be used in the  
encode_cast, and handle_json functions.</p>
 
  <p>Both encode_cast and handle_json have the same return types.
  </p><taglist>
  <dt><code>{ok, json(), state()}</code></dt><item><p>If json() is undefined, no json is
  to be sent.  Otherwise the json should be encoded using
  mochijson2:encode/1 and sent over the wire.</p></item>
  <dt><code>{exit, json(), state()}</code></dt><item><p>the connection should commit
  hari-kari.  If json() is undefined, that's all that needs to happen,
  otherwise json should be sent, then death.</p></item>
  </taglist>
 
  <p><em><marker id="Api_Handlers">Api Handlers</marker></em></p>
 
  <p>Modules intended to handle json calls can do so in two ways.  The first
  is to register a hook to <url href="/home/pete/wefwefwef/docs/other/da213c916b436fb60780c76c0838b382f62bc90c/repo/master/.xml/openacd/./cpx_hooks.xml">agent_api_call</url>.  This hook
  is triggered if the module and function with the appropriate arity is
  not found using the method described below.  The valid return values are
  the same as for the static functions.  The hook is triggered with the
  arguments:
  </p><list>
  <item><p><code>Connection :: #state{}</code>: internal state of connection</p></item>
  <item><p><code>Module :: atom()</code>: Module that was in the json</p></item>
  <item><p><code>Function :: atom()</code>: Function that was in the json</p></item>
  <item><p><code>Args :: [any()]</code>: Arguments list in the json</p></item>
  </list>
 
  <p>The alternative is more efficient, preventing a call to cpx_hooks,
  though there is no custom information passed to the module.  The module
  has an attribute <code>agent_api_functions</code>, which is a list of tuples of
  type <code>{FunctionAtom, Arity}</code>.  The arity must be one more than the  
number of arguments sent with the json request; this is because the  
state of the agent connection is sent as the first argument.</p>
 
  <p>An api handler function (either kind) should return one of the following:
  </p><taglist>
  <dt><code>ok</code></dt><item><p>A simple success json is returned</p></item>
  <dt><code>{ok, json()}</code></dt><item><p>A json success is sent with the given json
  set as the result</p></item>
  <dt><code>{error, bin_string(), bin_string()}}</code></dt><item><p>An error is
  returned</p></item>
  <dt> <code>exit</code></dt><item><p>The connection should exit, likely taking the agent
  fsm with it.  A simple success is returned.</p></item>
  <dt><code>{exit, json()}</code></dt><item><p>The connection should exit, likely taking
  the agent with it.  A success is returned, with the json as the result.
  </p></item>
  </taglist>
 
  <p>Plugins that want to send server events to agents should send one of the
  two arbitrary command messages.
  </p><list>
  <item><p><code>{arbitrary_command, Command, Props}</code></p></item>
  <item><p><code>{arbitrary_command, ChannelPidOrId, Command, Props}</code></p></item>
  </list>
 
  <p>In both cases, <code>Command</code> should be either an atom or binary string.  
Props can be either a json object struct, or a property list that can  
be put into a json object struct.</p>
 
  <p><code>ChannelPidOrId</code> is the channel id either in its pid form, string form,  
or binary string form.  In any form, if the channel does not exist, the  
message is ignored.</p>
 
  <p>When the event is sent, the command property and channelid (if given)  
properties are automatically pre-pended onto the json struct.  The  
result is sent to the connection for encoding and being sent over the  
wire:</p>
 
  <pre class="sh_erlang">{"command": string(),
  "channelid": string(),
  "field1": any(),
  "field2": any(),...
  "fieldN": any()
  }</pre><p>
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-json">json() = {struct, [{binary(), <a href="#type-json" class="seealso">json()</a>}]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| binary()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| integer()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| float()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<a href="#type-json" class="seealso">json()</a>]</h3></div>
    <div class="type"><h3 id="type-release_bias">release_bias() = -1 | 0 | 1</h3></div>
    <div class="type"><h3 id="type-release_code">release_code() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<a href="#type-release_id" class="seealso">release_id()</a>, <a href="#type-release_label" class="seealso">release_label()</a>, <a href="#type-release_bias" class="seealso">release_bias()</a>}</h3></div>
    <div class="type"><h3 id="type-release_id">release_id() = string()</h3></div>
    <div class="type"><h3 id="type-release_label">release_label() = default | string()</h3></div>
    <div class="type"><h3 id="type-security_level">security_level() = agent | supervisor | admin</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="init/1">init(Agent::#agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}) -&gt; {ok, #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>After the connection has been started, this should be called to
  seed the state.</p>
</div></div>
<div class="function">
<h3 id="get_agent/1">get_agent(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}) -&gt; undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}</h3>


<div class="description">

<p>Pull the agent record out of the state.</p>
</div></div>
<div class="function">
<h3 id="encode_cast/1">encode_cast(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Cast::any()) -&gt; {error, any(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}} | {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>When the connection gets a cast it cannot handle, this should be
  called.  It will either return an error, or json to pump out to the
  client.</p>
</div></div>
<div class="function">
<h3 id="handle_json/1">handle_json(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Json::json()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}} | {error, any(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}} | {exit, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>After unwrapping the binary that will hold json, and connection
  should call this.</p>
</div></div>
<div class="function">
<h3 id="logout/1">logout(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}) -&gt; exit</h3>


<div class="description">

<p>?? Logs the agent out.  The result is a simple success.</p>
</div></div>
<div class="function">
<h3 id="set_release/1">set_release(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Release::binary() | false) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}} | {error, any(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Sets the release mode of the agent.  To set an agent in
  a release mode, pass <code>&lt;&lt;"Default"&gt;&gt;</code>, <code>&lt;&lt;"default"&gt;&gt;</code>, or
  <code>&lt;&lt;"Id:Name:Bias"&gt;&gt;</code> as the arguement.  Setting the agent idle is done
  by sending <code>&lt;&lt;"none"&gt;&gt;</code> or <code>false</code>.</p>
</div></div>
<div class="function">
<h3 id="set_state/1">set_state(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Channel::binary(), Statename::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Set the agent channel <code>Channel</code> to the given
  <code>Statename</code> with default state data.  No result property as it either
  worked or didn't.  There will likely be an event as well to set the agent
  state, so it is recommended that no actual change occur on the agent UI
  side until that event is received.</p>
</div></div>
<div class="function">
<h3 id="set_state/1-1">set_state(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, ChannelBin::binary(), StateBin::binary(), StateDataBin::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Set the agent channel <code>Channel</code> to the given
  <code>Statename</code> with the given <code>Statedata</code>.  No result property as it either %% worked or it didn't.  State data will vary based on state.  Furthermore,
  in the case of success, an event is sent later by the agent fsm.  It is
  recommended that no change to the UI occur until that event is received.</p>
</div></div>
<div class="function">
<h3 id="end_wrapup/1">end_wrapup(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, ChanBin::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? End wrapup the agent channel 'Channel'.  This also
  kills the channel, making it available for use again.  No result
  property as it iether worked or didn't.  There will also be an event
  later sent by the agent fsm.  It is recommended that no UI changes
  occur until that event comes in.</p>
</div></div>
<div class="function">
<h3 id="get_avail_agents/1">get_avail_agents(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Get a list of the agents that are currently available.
  Result is:
  </p><pre class="sh_erlang">[{
  	"name":  string(),
  	"profile":  string(),
  	"state":  "idle" | "released"
  }]</pre>
</div></div>
<div class="function">
<h3 id="get_agent_profiles/1">get_agent_profiles(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Get a list of the profiles that are in the system.
  Result is:
  </p><pre class="sh_erlang">[{
  	"name":  string(),
  	"order":  number()
  }]</pre>
</div></div>
<div class="function">
<h3 id="agent_transfer/1">agent_transfer(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, ChannelBin::binary(), Agent::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Transfer the call on the given <code>Channel</code> to <code>Agent</code>
  login name.  No result is sent back as it's a simple success or failure.</p>
</div></div>
<div class="function">
<h3 id="media_call/1">media_call(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Channel::binary(), Command::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? @see media_call/5</p>
</div></div>
<div class="function">
<h3 id="media_call/1-1">media_call(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, ChannelBin::binary(), Command::binary(), Args::[any()]) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Forward a request to the media associated with an
  oncall agent channel.  <code>Command</code> is the name of the request to make.
  <code>Args</code> is a list of arguments to be sent with the <code>Command</code>.  Check the
  documentation of the media modules to see what possible returns there
  are.</p>
</div></div>
<div class="function">
<h3 id="media_cast/1">media_cast(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Channel::binary(), Command::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? @see media_cast/5</p>
</div></div>
<div class="function">
<h3 id="media_cast/1-1">media_cast(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Channel::binary(), Command::binary(), Args::[any()]) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Forward a command to the media associated with an
  oncall agent channel.  <code>Command</code> is the name of the command to send.
  <code>Args</code> is a list of arguments to send with the <code>Command</code>.  There is no
  reply expected, so a simple success is always returned.</p>
</div></div>
<div class="function">
<h3 id="get_queue_transfer_options/1">get_queue_transfer_options(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Channel::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Get the fields and skills an agent can assign to a
  media before transfering it back into queue.  Result:
  </p><pre class="sh_erlang">{
  	"curentVars":  [{
  		string():  string()
 	}],
 	"prompts":  [{
  		"name":  string(),
  		"label":  string(),
  		"regex":  regex_string()
  	}],
  	"skills":[
 		string() | {"atom":  string(),  "value":  string()}
  	]
  }</pre>
</div></div>
<div class="function">
<h3 id="queue_transfer/1">queue_transfer(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, QueueBin::binary(), Channel::binary(), Opts::json()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Transfer the channel's call into <code>Queue</code> with
  the given <code>Opts</code>.  The options is a json object with any number of
  properties that are passed to the media.  If there is a property
  <code>"skills"</code> with a list, the list is interpreted as a set of skills to
  apply to the media.  No result is set as it is merely success or
  failure.</p>
</div></div>
<div class="function">
<h3 id="get_endpoint/1">get_endpoint(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, TypeBin::binary()) -&gt; {ok, json(), #state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}}</h3>


<div class="description">

<p>?? Get the agent's endpoint data for a given module.</p>
</div></div>
<div class="function">
<h3 id="set_endpoint/1">set_endpoint(State::#state{salt=undefined | any(), agent=undefined | #agent{login=string(), id=undefined | string(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=pos_integer(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, channels=dict(), connection=undefined | pid(), supervisor_state=undefined | any()}, Endpoint::binary(), Data::binary()) -&gt; any()</h3>


<div class="description">

<p>?? Sets the agent's endpoint data to the given, well, data.
  Particularly useful if the flash phone is used, as all of the connection
  data will not be available for that until it is started on in the
  browser.
 TODO make this not media specific.</p>
</div></div>
<div class="function">
<h3 id="get_tabs_menu/1">get_tabs_menu(State) -&gt; term()
</h3>


<div class="description">

<p>?? Gathers the tabs an agent can access, and pushes the
  result into the command queue.
  {"command": "set_tabs_menu",
  "tabs": [
      {"label":string(),"href":string()}
  ]}
 TODO freaking special snowflake.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
