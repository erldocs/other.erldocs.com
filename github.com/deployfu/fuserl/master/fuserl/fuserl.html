<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>fuserl (fuserl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>fuserl</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="code_change/3">code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</h3>

<ul class="type">
<li><code>OldVsn = term() | {down, term()}</code></li><li><code>Extra = term()</code></li></ul>
<div class="description">

<p>The analog to Module:code_change/3 in gen_server.</p>
</div></div>
<div class="function">
<h3 id="handle_info/1">handle_info(Msg::any(), State) -&gt; {noreply, NewState} | {noreply, NewState, Timeout} | {stop, Reason, NewState}</h3>


<div class="description">

<p>The analog to Module:handle_info/2 in gen_server.  Note port messages
  are intercepted by fuserlsrv and not forwarded to the module.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(Args) -&gt; {ok, State} | {ok, State, Timeout} | {stop, Reason} | ignore</h3>


<div class="description">

<p>The analog to Module:init/1 in gen_server.</p>
</div></div>
<div class="function">
<h3 id="terminate/2">terminate(Reason, State) -&gt; any()</h3>

<ul class="type">
<li><code>Reason = normal | shutdown | term()</code></li></ul>
<div class="description">

<p>The analog to Module:terminate/2 in gen_server.</p>
</div></div>
<div class="function">
<h3 id="access/2">access(Ctx::#fuse_ctx{}, Inode::integer(), Mask::access_mode(), Cont::continuation(), State) -&gt; {access_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Check file access permissions.  Mask is a bitmask consisting of
  ?F_OK, ?X_OK, ?W_OK, and ?R_OK, which are portably defined in fuserl.hrl .
  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type access_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="create/2">create(Ctx::#fuse_ctx{}, Parent::integer(), Name::binary(), Mode::create_mode(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {create_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_create{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Create and open a file.
  Mode is a bitmask consisting of ?S_XXXXX macros portably defined in
  fuserl.hrl .
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type create_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="flush/2">flush(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {flush_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>This is called on each close () of an opened file, possibly multiple
  times per <a href="#open/4" class="seealso">open</a> call (due to dup () et. al.).
  Fi#fuse_file_info.fh will contain the descriptor
  set in <a href="#open/4" class="seealso">open</a>, if any.
  #fuse_reply_err{err = ok} indicates success.
  This return value is ultimately the return value of close ()
  (unlike <a href="#release/4" class="seealso">release</a>).
  Does *not* necessarily imply an fsync.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type flush_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="forget/2">forget(Ctx::#fuse_ctx{}, Inode::integer(), Nlookup::integer(), Cont::continuation(), State) -&gt; {forget_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_none{}</code></li></ul>
<div class="description">

<p>Forget about an inode.  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type forget_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="fsync/2">fsync(Ctx::#fuse_ctx{}, Inode::integer(), IsDataSync::bool(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {fsync_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Ensure all changes are on permanent storage.  If the IsDataSync is
  true, only the user data should be flushed, not the meta data.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type fsync_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="fsyncdir/2">fsyncdir(Ctx::#fuse_ctx{}, Inode::integer(), IsDataSync::bool(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {fsyncdir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Ensure all directory changes are on permanent storage.
  If the IsDataSync is
  true, only the user data should be flushed, not the meta data.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type fsyncdir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="getattr/2">getattr(Ctx::#fuse_ctx{}, Inode::integer(), Cont::continuation(), State) -&gt; {getattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_attr{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Get the file attributes associated with an inode.  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type getattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="getlk/2">getlk(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Lock::#flock{}, Cont::continuation(), State) -&gt; {getlk_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_lock{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Test for POSIX file lock.  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type getlk_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="getxattr/2">getxattr(Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Size::integer(), Cont::continuation(), State) -&gt; {getxattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_buf{} | #fuse_reply_xattr{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Get the value of an extended attribute.
  If Size is zero, the size of the value should be sent with
  #fuse_reply_xattr{}.
  If Size is non-zero, and the value fits in the buffer, the
  value should be sent with #fuse_reply_buf{}.
  If Size is too small for the value, the erange error should
  be sent.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type getxattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="link/2">link(Ctx::#fuse_ctx{}, Ino::integer(), NewParent::integer(), NewName::binary(), Cont::continuation(), State) -&gt; {link_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_entry{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Create a hard link.  Ino is the existing inode.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type link_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="listxattr/2">listxattr(Ctx::#fuse_ctx{}, Ino::integer(), Size::integer(), Cont::continuation(), State) -&gt; {listxattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_buf{} | #fuse_reply_xattr{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>List extended attribute names.  If Size is zero, the total size
  in bytes of the attribute name list (including null terminators)
  should be sent via #fuse_reply_xattr{}.
  If the Size is non-zero, and the null character separated and terminated
  attribute list is Size or less, the list should be sent with
  #fuse_reply_buf{}.
  If Size is too small for the value, the erange error should
  be sent.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type listxattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="lookup/2">lookup(Ctx::#fuse_ctx{}, ParentInode::integer(), Name::binary(), Cont::continuation(), State) -&gt; {lookup_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_entry{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Lookup a directory entry by name and get its attributes.  Returning
  an entry with inode zero means a negative entry which is cacheable, whereas
  an error of enoent is a negative entry which is not cacheable.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type lookup_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="mkdir/2">mkdir(Ctx::#fuse_ctx{}, ParentInode::integer(), Name::binary(), Mode::stat_mode(), Cont::continuation(), State) -&gt; {mkdir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_entry{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Make a directory.  Mode is a mask composed of the ?S_XXXXX macros
  which are (portably) defined in fuserl.hrl.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type mkdir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="mknod/2">mknod(Ctx::#fuse_ctx{}, ParentInode::integer(), Name::binary(), Mode::stat_mode(), Dev::device(), Cont::continuation(), State) -&gt; {mknod_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>{Major::integer(), Minor::integer()}</code></li><li><code>#fuse_reply_entry{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Create a file node.  Mode is a mask composed of the ?S_XXXXX macros
  which are (portably) defined in fuserl.hrl.  Dev is only valid if the
  created file is a device.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type mknod_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="open/2">open(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {open_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_open{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Open an inode. If noreply is used, eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a>
  should be called with Cont as first argument and the second argument of type
  open_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="opendir/2">opendir(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {opendir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_open{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Open an directory inode. If noreply is used, eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a>
  should be called with Cont as first argument and the second argument of type
  opendir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="read/2">read(Ctx::#fuse_ctx{}, Inode::integer(), Size::integer(), Offset::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {read_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_buf{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Read Size bytes starting at offset Offset. The file descriptor and
  other flags are available in Fi. If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type read_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="readdir/2">readdir(Ctx::#fuse_ctx{}, Inode::integer(), Size::integer(), Offset::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {readdir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_direntrylist{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Read at most Size bytes at offset Offset from the directory identified
  Inode.  Size is <code>real</code> and must be honored: the function
  fuserlsrv:dirent_size/1 can be used to compute the aligned byte size of
  a direntry, and the size of the list is the sum of the individual sizes.
  Offsets, however,
  are <code>fake</code>, and are for the convenience of the implementation to find
  a specific point in the directory stream.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type readdir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="readlink/2">readlink(Ctx::#fuse_ctx{}, Inode::integer(), Cont::continuation(), State) -&gt; {readlink_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_readlink{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Read the contents of a symbolic link.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type readlink_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="release/2">release(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {release_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Called when there are no more references to a file.
  For every <a href="#open/4" class="seealso">open</a> call there is exactly one release call.
  Fi#fuse_file_info.fh will contain the descriptor
  set in <a href="#open/4" class="seealso">open</a>, if any.
  Fi#fuse_file_info.flags will contain the same flags as for
  <a href="#open/4" class="seealso">open</a>.
  #fuse_reply_err{err = ok} indicates success.
  Errors are not reported anywhere; use <a href="#flush/4" class="seealso">flush</a> for that.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type release_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="releasedir/2">releasedir(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {releasedir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Called when there are no more references to a directory.
  For every <a href="#opendir/4" class="seealso">opendir</a> call there is exactly one releasedir call.
  Fi#fuse_file_info.fh will contain the descriptor
  set in <a href="#opendir/4" class="seealso">opendir</a>, if any.
  Fi#fuse_file_info.flags will contain the same flags as for
  <a href="#opendir/4" class="seealso">opendir</a>.
  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type releasedir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="removexattr/2">removexattr(Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Cont::continuation(), State) -&gt; {removexattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Remove an extended attribute.
  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type removexattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="rename/2">rename(Ctx::#fuse_ctx{}, Parent::integer(), Name::binary(), NewParent::integer(), NewName::binary(), Cont::continuation(), State) -&gt; {rename_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Rename a file.  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type rename_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="rmdir/2">rmdir(Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Cont::continuation(), State) -&gt; {rmdir_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Remove a directory.  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type rmdir_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="setattr/2">setattr(Ctx::#fuse_ctx{}, Inode::integer(), Attr::#stat{}, ToSet::integer(), Fi::maybe_fuse_file_info(), Cont::continuation(), State) -&gt; {setattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_file_info{} | null</code></li><li><code>#fuse_reply_attr{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Set file attributes.  ToSet is a bitmask which defines which
  elements of Attr are defined and should be modified.  Possible values
  are defined as ?FUSE_SET_ATTR_XXXX in fuserl.hrl . Fi will be set
  if setattr is invoked from ftruncate under Linux 2.6.15 or later.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type setattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="setlk/2">setlk(Ctx::#fuse_ctx{}, Inode::integer(), Fi::#fuse_file_info{}, Lock::#flock{}, Sleep::bool(), Cont::continuation(), State) -&gt; {setlk_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Set a POSIX file lock.  Sleep indicates whether the operation is
  blocking (true) or nonblocking (false).
  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type setlk_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="setxattr/2">setxattr(Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Value::binary(), Flags::xattr_flags(), Cont::continuation(), State) -&gt; {setxattr_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Set file attributes.
  #fuse_reply_err{err = ok} indicates success.
  Flags is a bitmask consisting of ?XATTR_XXXXX macros portably defined in
  fuserl.hrl .
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called
  with Cont as first argument
  and the second argument of type setxattr_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="statfs/2">statfs(Ctx::#fuse_ctx{}, Inode::integer(), Cont::continuation(), State) -&gt; {statfs_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_statfs{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Get file system statistics.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type statfs_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="symlink/2">symlink(Ctx::#fuse_ctx{}, Link::binary(), Inode::integer(), Name::binary(), Cont::continuation(), State) -&gt; {symlink_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_entry{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Create a symbolic link.  Link is the contents of the link.  Name is
  the name to create.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type symlink_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="write/2">write(Ctx::#fuse_ctx{}, Inode::integer(), Data::binary(), Offset::integer(), Fi::#fuse_file_info{}, Cont::continuation(), State) -&gt; {write_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_write{} | #fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Write data to a file.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type write_async_reply ().</p>
</div></div>
<div class="function">
<h3 id="unlink/2">unlink(Ctx::#fuse_ctx{}, Inode::integer(), Name::binary(), Cont::continuation(), State) -&gt; {unlink_async_reply(), NewState} | {noreply, NewState}</h3>

<ul class="type">
<li><code>#fuse_reply_err{}</code></li></ul>
<div class="description">

<p>Remove a file.  #fuse_reply_err{err = ok} indicates success.
  If noreply is used,
  eventually <a href="fuserlsrv.html#reply/2" class="seealso">fuserlsrv:reply/2</a> should be called with Cont as first argument
  and the second argument of type unlink_async_reply ().</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
