<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>locks_leader (locks) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>locks_leader</h1>
<h2 class="modsummary">Leader election behavior.</h2>
<div class="description">
<p>Leader election behavior</p>
 
  <p>This behavior is inspired by gen_leader, and offers the same API
  except for a few details. The leader election strategy is based on
  the <code>locks</code> library. The leader election group is identified by the
  lock used - by default, <code>[locks_leader, CallbackModule]</code>, but configurable
  using the option <code>{resource, Resource}</code>, in which case the lock name will
  be <code>[locks_leader, Resource]</code>. The lock corresponding to the leader group  
will in the following description be referred to as The Lock.</p>
 
  <p>Each instance is started either as a 'candidate' or a 'worker'.
  Candidates all try to claim a write lock on The Lock, and workers merely
  monitor it. All candidates and workers will find each other through the
  <code>#locks_info{}</code> messages. This means that, unlike gen_leader, the  
locks_leader dynamically adopts new nodes, candidates and workers. It is  
also possible to have multiple candidates and workers on the same node.</p>
 
  <p>The candidate that is able to claim The Lock becomes the leader.
  </p><pre class="sh_erlang">Leader instance:
     Mod:elected(ModState, Info, undefined) -&gt; {ok, Sync, ModState1}.
 
  Other instances:
     Mod:surrendered(ModState, Sync, Info) -&gt; {ok, ModState1}.
  </pre>
 
  <p>If a candidate or worker joins the group, the same function is called,
  but with the Pid of the new member as third argument. It can then
  return either <code>{reply, Sync, ModState1}</code>, in which case only the new
  member will get the Sync message, or <code>{ok, Sync, ModState1}</code>, in which case  
all group members will be notified.</p>
 
  <p><em>Split brain</em></p>
 
  <p>The <code>locks_leader</code> behavior will automatically heal from netsplits and
  ensure that there is only one leader. A candidate that was the leader but
  is forced to surrender, can detect this e.g. by noting in its own state
  when it becomes leader:
  </p><pre lang="erlang">
  surrendered(#state{is_leader = true} = S, Sync, _Info) -&gt;
      %% I was leader; a netsplit has occurred
      {ok, surrendered_after_netsplit(S, Sync, Info)};
  surrendered(S, Sync, _Info) -&gt;
      {ok, normal_surrender(S, Sync, Info)}.
  </pre>
 
  <p>The newly elected candidate normally doesn't know that a split-brain
  has occurred, but can sync with other candidates using e.g. the function
  <a href="#ask_candidates/2" class="seealso">ask_candidates/2</a>, which functions rather like a parallel
  <code>gen_server:call/2</code>.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-election">election()</h3></div>
    <div class="type"><h3 id="type-ldr_options">ldr_options() = [<a href="#type-option" class="seealso">option()</a>]</h3></div>
    <div class="type"><h3 id="type-leader_info">leader_info()</h3></div>
    <div class="type"><h3 id="type-mod_state">mod_state() = any()</h3></div>
    <div class="type"><h3 id="type-msg">msg() = any()</h3></div>
    <div class="type"><h3 id="type-option">option() = {role, candidate | worker} | {resource, any()}</h3></div>
    <div class="type"><h3 id="type-server_ref">server_ref() = atom() | pid()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="record_fields/1">record_fields(X1) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="candidates/1">candidates(St::election()) -&gt; [pid()]</h3>


<div class="description">

<p>Return the current list of candidates.</p>
</div></div>
<div class="function">
<h3 id="new_candidates/1">new_candidates(St::election()) -&gt; [pid()]</h3>


<div class="description">

<p>Return the current list of candidates that have not yet been synced.</p>
 
  <p>This function is mainly indented to be used from within <code>Mod:elected/3</code>,
  once a leader has been elected. One possible use is to contact the
  new candidates to see whether one of them was a leader, which could
  be the case if the candidates appeared after a healed netsplit.</p>
</div></div>
<div class="function">
<h3 id="workers/1">workers(St::election()) -&gt; [pid()]</h3>


<div class="description">

<p>Return the current list of workers.</p>
</div></div>
<div class="function">
<h3 id="leader/1">leader(St::election()) -&gt; pid() | undefined</h3>


<div class="description">

<p>Return the leader pid, or <code>undefined</code> if there is no current leader.</p>
</div></div>
<div class="function">
<h3 id="leader_node/1">leader_node(St::election()) -&gt; node()</h3>


<div class="description">

<p>Return the node of the current leader.</p>
 
  <p>This function is mainly present for compatibility with <code>gen_leader</code>.</p>
</div></div>
<div class="function">
<h3 id="reply/1">reply(From::{pid(), any()}, Reply::any()) -&gt; ok</h3>


<div class="description">

<p>Corresponds to <code>gen_server:reply/2</code>.</p>
 
  <p>Callback modules should use this function instead in order to be future
  safe.</p>
</div></div>
<div class="function">
<h3 id="broadcast/1">broadcast(Msg::any(), St::election()) -&gt; ok</h3>


<div class="description">

<p>Broadcast <code>Msg</code> to all candidates and workers.</p>
 
  <p>This function may only be called from the current leader.</p>
 
  <p>The message will be processed in the <code>Mod:from_leader/3</code> callback.
  Note: You should not use this function from the <code>Mod:elected/3</code> function,
  since it may cause sequencing issues with the broadcast message that is
  (normally) sent once the <code>Mod:elected/3</code> function returns.</p>
</div></div>
<div class="function">
<h3 id="broadcast_to_candidates/1">broadcast_to_candidates(Msg::any(), St::election()) -&gt; ok</h3>


<div class="description">

<p>Broadcast <code>Msg</code> to all (synced) candidates.</p>
 
  <p>This function may only be called from the current leader.</p>
 
  <p>The message will be processed in the <code>Mod:from_leader/3</code> callback.
  Note: You should not use this function from the <code>Mod:elected/3</code> function,
  since it may cause sequencing issues with the broadcast message that is
  (normally) sent once the <code>Mod:elected/3</code> function returns.</p>
</div></div>
<div class="function">
<h3 id="ask_candidates/1">ask_candidates(Req::any(), St::election()) -&gt; {GoodReplies, Errors}</h3>

<ul class="type">
<li><code>GoodReplies = [{pid(), any()}]</code></li><li><code>Errors = [{pid(), any()}]</code></li></ul>
<div class="description">

<p>Send a synchronous request to all candidates.</p>
 
  <p>The request <code>Req</code> will be processed in <code>Mod:handle_call/4</code> and can be
  handled as any other request. The return value separates the good replies
  from the failed (the candidate died or couldn't be reached).</p>
</div></div>
<div class="function">
<h3 id="start_link/1">start_link(Module::atom(), St::any()) -&gt; {ok, pid()}</h3>


<div class="description">

<p>Starts an anonymous locks_leader candidate using <code>Module</code> as callback.</p>
 
  <p>The leader candidate will sync with all candidates using the same
  callback module, on all connected nodes.</p>
</div></div>
<div class="function">
<h3 id="start_link/1-1">start_link(Module::atom(), St::any(), Options::ldr_options()) -&gt; {ok, pid()}</h3>


<div class="description">

<p>Starts an anonymous worker or candidate.</p>
 
  <p>The following options are supported:</p>
 
  <p>* <code>{role, candidate | worker}</code> - A candidate is able to take on the  
leader role, if elected; a worker simply follows the elections and  
receives broadcasts from the leader.</p>
 
  <p>* <code>{resource, Resource}</code> - The name of the lock used for the election
  is normally <code>[locks_leader, Module]</code>, but with this option, it can be
  changed into <code>[locks_leader, Resource]</code>. Note that, under the rules of
  the locks application, a lock name must be a list.</p>
</div></div>
<div class="function">
<h3 id="start_link/1-2">start_link(Reg::atom(), Module::atom(), St::any(), Options::ldr_options()) -&gt; {ok, pid()}</h3>


<div class="description">

<p>Starts a locally registered worker or candidate.</p>
 
  <p>Note that only one registered instance of the same name (using the  
built-in process registry) can exist on a given node. However, it is  
still possible to have multiple instances of the same election group  
on the same node, either anonymous, or registered under different names.</p>
 
  <p>For a description of the options, see <a href="#start_link/3" class="seealso">start_link/3</a>.</p>
</div></div>
<div class="function">
<h3 id="leader_call/1">leader_call(Name::server_ref(), Request::term()) -&gt; term()</h3>


<div class="description">

<p>Make a synchronous call to the leader.</p>
 
  <p>This function is similar to <code>gen_server:call/2</code>, but is forwarded to
  the leader by the leader candidate <code>L</code> (unless, of course, it is the
  leader, in which case it handles it directly). If the leader should die
  before responding, this function will raise an <code>error({leader_died,...})</code>
  exception.</p>
</div></div>
<div class="function">
<h3 id="leader_call/1-1">leader_call(Name::server_ref(), Request::term(), Timeout::integer() | infinity) -&gt; term()</h3>


<div class="description">

<p>Make a timeout-guarded synchronous call to the leader.</p>
 
  <p>This function is similar to <code>gen_server:call/3</code>, but is forwarded to
  the leader by the leader candidate <code>L</code> (unless, of course, it is the
  leader, in which case it handles it directly). If the leader should die
  before responding, this function will raise an <code>error({leader_died,...})</code>
  exception.</p>
</div></div>
<div class="function">
<h3 id="leader_reply/2">leader_reply(From, Reply) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="leader_cast/1">leader_cast(L::server_ref(), Msg::term()) -&gt; ok</h3>


<div class="description">

<p>Make an asynchronous cast to the leader.</p>
 
  <p>This function is similar to <code>gen_server:cast/2</code>, but is forwarded to
  the leader by the leader candidate <code>L</code> (unless, of course, it is the
  leader, in which case it handles it directly). No guarantee is given
  that the cast actually reaches the leader (i.e. if the leader dies, no
  attempt is made to resend to the next elected leader).</p>
</div></div>
<div class="function">
<h3 id="info/1">info(L) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="info/2">info(L, Item) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="call/1">call(L::server_ref(), Request::any()) -&gt; any()</h3>


<div class="description">

<p>Make a <code>gen_server</code>-like call to the leader candidate <code>L</code>.</p>
</div></div>
<div class="function">
<h3 id="call/1-1">call(L::server_ref(), Request::any(), Timeout::integer() | infinity) -&gt; any()</h3>


<div class="description">

<p>Make a timeout-guarded <code>gen_server</code>-like call to the leader
  candidate <code>L</code>.</p>
</div></div>
<div class="function">
<h3 id="cast/1">cast(L::server_ref(), Msg::any()) -&gt; ok</h3>


<div class="description">

<p>Make a <code>gen_server</code>-like cast to the leader candidate <code>L</code>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
