<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>plain_fsm (plain_fsm) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>plain_fsm</h1>
<h2 class="modsummary">A behaviour/support library for writing plain Erlang FSMs.</h2>
<div class="description">
<p>A behaviour/support library for writing plain Erlang FSMs.</p>
 
  <p>This module implements an OTP behaviour for writing plain Erlang FSMs,
  alleviating a long-standing gripe of mine that the OTP behaviours, for all
  their power, force programmers into a coding style that is very much
  different from that taught in the Basic Erlang Course (or the book, or
  online tutorials, ...) -- the type of programming that made us want to
  use Erlang in the first place.</p>
 
  <p>Only in my old age have I begun to understand fully what a sacrifice
  this is. See e.g. my presentation <url href="http://www.infoq.com/presentations/Death-by-Accidental-Complexity">Death by Accidental Complexity (QCon SF 2010)</url>
  for a more detailed discussion of the issues involved.
  (Slides also available in the <code>doc/</code> directory of this repos)</p>
 
  <p>The requirements that drove us away from plain Erlang programming
  in the first place were:
  </p><list>
   <item><p><em>The need to support system messages</em> to control upgrade,
     state inspection, shutdown, etc. The plain_fsm library solves this in a
     reasonable way, I think.</p></item>
   <item><p><em>The need for debugging support</em>. The debugging support in
     e.g. gen_server is, I believe, rendered obsolete by the new powerful
     trace support (and dbg) in later versions of OTP.</p></item>
   <item><p>In the case of gen_server, <em>reducing the need to reinvent the
     wheel</em>, a valid point, but more so for e.g. the client side of
     gen_server:call(). In a protocol state machine, the only thing that
     really needs reusing is the handling of system messages.</p></item>
  </list><p>
  </p>
 
  <p>However, the behaviours provided by OTP for FSM programming,
  <code>gen_server</code> and <code>gen_fsm</code> (<code>gen_server</code>
  is perhaps a more common choice than <code>gen_fsm</code>), both have the
  distinct drawback that you cannot normally start with a classic
  Erlang design and then migrate to a behaviour without significant
  code rewrite. In addition, the two behaviours are semantically different
  from the classic Erlang design</p>
 
  <p><em>Using plain_fsm</em></p>
 
  <p>First, write your state machine without worrying about OTP system
  messages. Once you're happy with it, figure out where you really want
  to handle system messages. Normally, it will suffice to do it in a fairly
  stable state. A good rule of thumb is that the top-level state machine
  should handle system messages, while the transient (sub-) states
  shouldn't</p>
 
  <p>In the states where you want to handle system messages, you have
  three choices:</p>
 
  <p><em>(A) Insert the system messages in the receive clause:</em></p>
 
  <pre class="sh_erlang">
  idle(S) -&gt;
     Parent = plain_fsm:info(parent),
     receive
        {system, From, Req} -&gt;
           plain_fsm:handle_system_msg(
               Req, From, S, fun(S1) -&gt; idle(S1) end);
        {'EXIT', Parent, Reason} -&gt;
           plain_fsm:parent_EXIT(Reason, S);
        ... %% your original code here
     end.
  </pre>
 
  <p>This has the advantage that everyone can understand what's going on.
  The part that plain_fsm.erl helps you with is the set of functions
  <code>system_code_change()</code>, <code>system_continue()</code>,
  <code>system_shutdown()</code>, <code>format_status()</code>, which
  are required callbacks when you handle system messages directly.</p>
 
  <p><em>(B) Handle system messages and unknown messages together:</em></p>
 
  <pre class="sh_erlang">
  idle(S) -&gt;
     Parent = plain_fsm:info(parent),
     receive
        ... %% your original code here
        Msg -&gt;
           plain_fsm:handle_msg(Msg, State, fun(S1) -&gt; idle(S1) end)
     end.
  </pre>
 
  <p>This is quite convenient if the receive statement already has a
  'catch-all' clause, discarding unknown messages.
  <code>plain_fsm:handle_msg/3</code> will handle system messages properly
  and ignore any other message.</p>
 
  <p><em>(C) Write a pseudo wrapper function around your receive clause:</em></p>
 
  <pre class="sh_erlang">
  idle(S) -&gt;
     plain_fsm:extended_receive(
        receive
           ... %% your original code
        end).
  </pre>
 
  <p>The function <code>plain_fsm:extended_receive/1</code> is replaced
  in a <i>parse_transform</i> into something that looks very much like
  the previous program (A). The code, as it reads, requires the reader to
  know that the transformation takes place, otherwise the semantics
  would be confusing (you cannot solve the problem using a real function
  that way.) On the plus side, this is a fairly small violation of both
  the original code and Erlang's semantics.</p>
 
  <p><i>Note that for this to work, you must include "plain_fsm.hrl"
  in your module.</i></p>
 
  <p><em>Example</em>
  </p><p>In the module <url href="../../src/fsm_example.erl">fsm_example.erl</url>
  (included in the plain_fsm package), we choose to handle system
  messages in the idle state. The example code is runnable, and supports
  suspend, resume, status inspection, and code change.</p>
  <p>Imagine that the code initially looked like this:</p>
  <pre class="sh_erlang">
  idle(S) -&gt;
      receive
  	a -&gt;
  	    io:format("going to state a~n", []),
  	    a(S);
  	b -&gt;
  	    io:format("going to state b~n", []),
  	    b(S)
      after 10000 -&gt;
  	    io:format("timeout in idle~n", []),
  	    idle(S)
      end).
  </pre>
 
  <p>The change required to handle system messages is as follows:</p>
  <pre class="sh_erlang">
  idle(S) -&gt;
      plain_fsm:extended_receive(
        receive
            a -&gt;
                io:format("going to state a~n", []),
                a(S);
            b -&gt;
                io:format("going to state b~n", []),
                b(S)
        after 10000 -&gt;
                io:format("timeout in idle~n", []),
                idle(S)
        end).
  </pre>
 
  <p>In addition, we change the start function from, in this case:</p>
  <pre class="sh_erlang">
  spawn_link() -&gt;
      spawn_link(fun() -&gt;
                         process_flag(trap_exit, true),
                         idle(mystate)
                 end).
  </pre>
  <p>Is changed into:</p>
  <pre class="sh_erlang">
  spawn_link() -&gt;
      plain_fsm:spawn_link(?MODULE, fun() -&gt;
                                            process_flag(trap_exit,true),
                                            idle(mystate)
                                    end).
  </pre>
  <p>See also <a href="#spawn/2" class="seealso">spawn/2</a> and <a href="#spawn_opt/3" class="seealso">spawn_opt/3</a>
  for information on other possible start functions.</p>
  <p>To be fully compliant, you also need to supply a code_change/3 function.
  See <a href="#behaviour_info/1" class="seealso">behaviour_info/1</a> for details.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="behaviour_info/1">behaviour_info(Other::atom()) -&gt; term()</h3>


<div class="description">

<p>Defines which functions this behaviour expects to be exported from
  the user's callback module. plain_fsm requires only code_change/3 to
  be present. The semantics of <code>Mod:code_change/3</code> are as follows:
  </p><pre class="sh_erlang">
    code_change(OldVsn, State, Extra) -&gt; {ok, NewState}.
  </pre><p>
  </p><p>The above code is just like it would look like in a gen_server callback
  module.</p>
  <pre class="sh_erlang">
    code_change(OldVsn, State, Extra) -&gt; {ok, NewState, Options}.
  </pre>
  <p>where <code>Options</code> may be any of </p>
  <list>
   <item><p><code>{mod, module()}</code>, allowing you to switch callback
    modules during a code change.</p></item>
   <item><p><code>{name, name()}</code>, allowing you to rename the process
    (note that you have to handle name registration yourself.)</p></item>
   <item><p><code>{cont, atom() | function(1)}</code>, allowing you to provide
    another continuation (point of entry into your own code after the
    code change.)</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="spawn/1">spawn(Mod::atom(), StartF::function()) -&gt; pid()</h3>


<div class="description">

<p>Equivalent to <code>proc_lib:spawn(StartF)</code>. This function also
  initializes the plain_fsm meta-data.</p>
</div></div>
<div class="function">
<h3 id="spawn_link/1">spawn_link(Mod::atom(), StartF::function()) -&gt; pid()</h3>


<div class="description">

<p>Equivalent to <code>proc_lib:spawn_link(StartF)</code>.
  This function also initializes the plain_fsm meta-data.</p>
</div></div>
<div class="function">
<h3 id="spawn_opt/1">spawn_opt(Mod::atom(), StartF::function(), Opts::list()) -&gt; pid()</h3>


<div class="description">

<p>Equivalent to <code>proc_lib:spawn_opt(StartF, Opts)</code>.
  This function also initializes the plain_fsm meta-data.</p>
</div></div>
<div class="function">
<h3 id="spawn_opt/1-1">spawn_opt(Node::atom(), Mod::atom(), StartF::function(), Opts::list()) -&gt; pid()</h3>


<div class="description">

<p>Equivalent to <code>proc_lib:spawn_opt(Node, StartF, Opts)</code>.
  This function also initializes the sysFsm meta-data.</p>
</div></div>
<div class="function">
<h3 id="start_opt/1">start_opt(Mod::atom(), InitF::function(), Timeout::integer(), Opts::list()) -&gt; {ok, pid()} | {error, Reason}</h3>


<div class="description">

<p>Similar to <code>proc_lib:start(M,F,A, Timeout, Opts)</code>.</p>
 
  <p>This function works in a similar fashion to <code>proc_lib:start/5</code>,
  but takes a fun instead of a <code>{M,F,A}</code> argument.</p>
 
  <p><code>InitF()</code> may return one of the following:</p>
 
  <p>* <code>{reply, Reply, Cont}</code>, where Reply will be sent back to the parent,
    and <code>Cont</code> is a continuation function with no arguments.
  * <code>{noreply, Cont}</code>, which sends no ack message back to the parent (presumably,
    this is done elsewhere in the code then).</p>
</div></div>
<div class="function">
<h3 id="store_name/1">store_name(Name::term()) -&gt; ok</h3>


<div class="description">

<p>stores an internal name for the FSM
       (for <code>sys:get_status()</code>).
  This can be used if the FSM were started as an anonymous process
  (the only kind currently supported).
  Note that this function does not register the name. The name stored
  is the one that shows up in sys:get_status/1. No restriction is made
  here regarding the data type.</p>
</div></div>
<div class="function">
<h3 id="current_function/0">current_function() -&gt; {Module, Function, Arity}</h3>


<div class="description">

<p>Virtual function for extracting the current function.
   </p><p>This function call is expanded by the <code>plain_fsm</code> parse transform
   into the name and arity (<code>{Module, Function, Arity}</code>) of the current
   function. It cannot be used from code that hasn't been transformed.
   </p>
</div></div>
<div class="function">
<h3 id="info/1">info(What::atom()) -&gt; term()</h3>

<ul class="type">
<li><code>What = debug | name | mod | parent</code></li></ul>
<div class="description">

<p>retrieves meta-data for the plain_fsm process.
   </p><p>Description of available meta-data:</p>
    <pre class="sh_erlang">
      debug : See the manual for sys.erl
      name  : Internal name, normally the same as the registered name.
              initially undefined, can be set via plain_fsm:store_name/1.
      mod   : Name of the callback module.
      parent: The pid() of the parent process.
    </pre>
</div></div>
<div class="function">
<h3 id="extended_receive/1">extended_receive(Expr) -&gt; VOID</h3>


<div class="description">

<p>Virtual function used to wrap receive clauses.
  </p><p>This function cannot be called directly, but is intended as a syntactic
  wrapper around a receive clause. It will be transformed at compile time
  to a set of receive patterns handling system messages and parent
  termination according to the OTP rules. The transform requires that
  the surrounding function has exactly one argument (the "State" or
  "Loop Data".)</p>
  <p>To trigger the parse_transform, include the file
  <code>plain_fsm.hrl</code> (found in <code>plain_fsm/inc/</code>) in
  your module, and the Erlang compiler must be able to find the module
  <code>plain_fsm_xform.beam</code>. If <code>erlc</code> is used, this is
  accomplished by adding <code>-pa .../plain_fsm/ebin</code> to the
  <code>erlc</code> command.</p>
</div></div>
<div class="function">
<h3 id="hibernate/1">hibernate(M::atom(), F::atom(), A::[IntState]) -&gt; NEVER_RETURNS</h3>


<div class="description">

<p>Virtual function used to wrap a call to the BIF erlang:hibernate/3.
  </p><p>This function cannot be called directly, but translates to the call
  <code>erlang:hibernate(plain_fsm,wake_up,[data_vsn(),Module,M,F,A])</code>
  where <code>Module:data_vsn()</code> and <code>Module:code_change/3</code>
  are expected to exist (the parse_transform will add and export the
  function <code>data_vsn() -&lt; 0</code>, if it doesn't already exist.)</p>
  <p>The function <code>plain_fsm:wake_up/5</code> will begin by calling
  <code>Module:data_vsn()</code>, and if it is the same as before, simply
  call <code>apply(M,F,A)</code>. Otherwise, <code>Module:code_change(OldVsn,
  IntState, hibernate)</code> will be called first. This allows a plain_fsm
  behaviour module to be "bootstrapped" to a new version during hibernation.
  </p>
</div></div>
<div class="function">
<h3 id="wake_up/5">wake_up(OldVsn, Module, M, F, A) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="tail_apply/5">tail_apply(F::Fun, OldVsn, Module, ContF, S) -&gt; NEVER_RETURNS</h3>


<div class="description">

<p>Helper function to dispatch blocking calls as tail calls.
  During code change, it can be a problem that processes lie in blocking
  calls - say, e.g., to <code>gen_tcp:connect(...)</code>. If the module is reloaded,  
the calling function will still be on the call stack, and may eventually  
get the process killed (as the VM only holds two versions of the module).</p>
 
  <p>This function is most easily called using the macro
  <code>?tail_apply(F, ContF, S)</code>, which expands to
  </p><pre class="sh_erlang">
  plain_fsm:tail_apply(F, ?MODULE:data_vsn(), ?MODULE, ContF, S)
  </pre>
 
  <p>In this case, <code>?MODULE:data_vsn()</code> will have been automatically
  generated by plain_fsm, or is manually updated whenever the internal
  representation of the state <code>S</code> is changed.</p>
 
  <p><code>ContF</code> represents an exported function in the calling module,
  <code>ContF(Status, Result, S)</code>     
Status :: ok | error     
Result :: fun() | any()</p>
 
  <p>If the call to <code>Fun()</code> fails, the exception (throw, error or exit) will
  be caught, and <code>Result</code> will be a fun (arity 0), which can be called  
to "re-throw" the exception. This way, the continuation function can  
catch exceptions in its own try/catch pattern.</p>
 
  <p>'Status' will be <code>error</code> if <code>Fun()</code> fails, otherwise <code>ok</code>.</p>
 
  <p>Thus, the simplest implementation of <code>ContF</code> would be:
  </p><pre class="sh_erlang">
  ContF(ok, Result, S) -&gt;
      handle_result(Result, S);
  ContF(error, E, _S) -&gt;
      E().
  </pre>
 
  <p>Note that this solution does not throw away the call stack, as
  e.g. a call to <code>hibernate/3</code> does. Thus, it is basically only
  tail-recursive as regards the calling function, placing
  plain_fsm:tail_apply/5 on the call stack rather than a function
  in the user module.</p>
</div></div>
<div class="function">
<h3 id="parent_EXIT/2">parent_EXIT(Reason, State) -&gt; EXIT</h3>


<div class="description">

<p>Handles parent termination properly.
  </p><p>This function is called when the parent of a plain_fsm instance dies.
  The OTP rules state that the child should die with the same reason
  as the parent (especially in the case of Reason='shutdown'.)</p>
</div></div>
<div class="function">
<h3 id="handle_system_msg/4">handle_system_msg(Req, From, State, Cont::cont()) -&gt; NEVER_RETURNS</h3>


<div class="description">

<p>Called when the process receives a system message.
  </p><p>This function never returns. If the program handles system messages
  explicitly, this function can be called to handle them in the plain_fsm
  way. Example:</p>
  <pre class="sh_erlang">
  idle(S) -&gt;
    receive
       {system, From, Req} -&gt;
           plain_fsm:handle_system_msg(Req, From, S, fun(S1) -&gt;
                                                            idle(S1)
                                                     end);
       ...
    end.
  </pre>
  <p>The <code>Cont</code> argument should be either a fun with one argument
  (the new state), which jumps back into the user code in the proper place,
  or it can be the name of a function (in this case, 'idle'). In the latter
  case, the function in question must be exported; in the former case, this
  is not necessary.</p>
</div></div>
<div class="function">
<h3 id="handle_msg/3">handle_msg(Other::Msg, State, Cont::cont()) -&gt; NEVER_RETURNS</h3>


<div class="description">

<p>Called in a "catch-all" clause within a receive statement.
  </p><p>This function never returns. It will handle system messages
  properly and ignore anything else.
  Example:</p>
  <pre class="sh_erlang">
  idle(S) -&gt;
    receive
       ...
       Msg -&gt;
           plain_fsm:handle_msg(Msg, S, fun(S1) -&gt;
                                                 idle(S1)
                                        end)
    end.
  </pre>
 
  <p>Note that this function should <i>only</i> be used if it is known
  to be safe to discard unknown messages. In most state machines there should
  be at least <i>one</i> state where unknown messages are discarded; in
  these states, the handle_msg/3 function can be a convenient way to
  handle both unknown messages and system messages.</p>
 
  <p>The <code>Cont</code> argument should be either a fun with one argument
  (the new state), which jumps back into the user code in the proper place,
  or it can be the name of a function (in this case, 'idle'). In the latter
  case, the function in question must be exported; in the former case, this
  is not necessary.</p>
</div></div></div>

<authors>

<aname>Ulf Wiger,</aname>
<email>ulf.wiger@ericsson.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
