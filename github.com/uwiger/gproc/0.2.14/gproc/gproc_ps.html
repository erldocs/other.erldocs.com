<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gproc_ps (gproc) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gproc_ps</h1>
<h2 class="modsummary">Gproc Publish/Subscribe patterns  
This module implements a few convenient functions for publish/subscribe.</h2>
<div class="description">
<p>Gproc Publish/Subscribe patterns  
This module implements a few convenient functions for publish/subscribe.</p>
 
  <p>Publish/subscribe with Gproc relies entirely on gproc properties and counters.  
This makes for a very concise implementation, as the monitoring of subscribers and  
removal of subscriptions comes for free with Gproc.</p>
 
  <p>Using this module instead of rolling your own (which is easy enough) brings the
  benefit of consistency, in tracing and debugging.
  The implementation can also serve to illustrate how to use gproc properties and
  counters to good effect.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-event">event() = any()</h3></div>
    <div class="type"><h3 id="type-msg">msg() = any()</h3></div>
    <div class="type"><h3 id="type-scope">scope() = l | g</h3></div>
    <div class="type"><h3 id="type-status">status() = 1 | 0</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="subscribe/1">subscribe(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Subscribe to events of type <code>Event</code></p>
 
  <p>Any messages published with <code>gproc_ps:publish(Scope, Event, Msg)</code> will be  
delivered to the current process, along with all other subscribers.</p>
 
  <p>This function creates a property, <code>{p,Scope,{gproc_ps_event,Event}}</code>, which  
can be searched and displayed for debugging purposes.</p>
 
  <p>Note that, as with <a href="gproc.html#reg/1" class="seealso">gproc:reg/1</a>, this function will raise an
  exception if you try to subscribe to the same event twice from the same
  process.</p>
</div></div>
<div class="function">
<h3 id="subscribe_cond/1">subscribe_cond(Scope::scope(), Event::event(), Spec::undefined | match_spec() (see module ets)) -&gt; true</h3>


<div class="description">

<p>Subscribe conditionally to events of type <code>Event</code></p>
 
  <p>This function is similar to <a href="#subscribe/2" class="seealso">subscribe/2</a>, but adds a condition  
in the form of a match specification.</p>
 
  <p>The condition is tested by the <a href="#publish_cond/3" class="seealso">publish_cond/3</a> function  
and a message is delivered only if the condition is true. Specifically,  
the test is:</p>
 
  <p><code>ets:match_spec_run([Msg], ets:match_spec_compile(Cond)) == [true]</code></p>
 
  <p>In other words, if the match_spec returns true for a message, that message
  is sent to the subscriber. For any other result from the match_spec, the
  message is not sent. <code>Cond == undefined</code> means that all messages will be
  delivered (that is, <code>publish_cond/3</code> will treat 'normal' subscribers just
  like <a href="#publish/3" class="seealso">publish/3</a> does, except that <code>publish/3</code> strictly speaking
  ignores the Value part of the property completely, whereas <code>publish_cond/3</code>  
expects it to be either undefined or a valid match spec).</p>
 
  <p>This means that <code>Cond=undefined</code> and <code>Cond=[{'_',[],[true]}]</code> are  
equivalent.</p>
 
  <p>Note that, as with <a href="gproc.html#reg/1" class="seealso">gproc:reg/1</a>, this function will raise an
  exception if you try to subscribe to the same event twice from the same
  process.</p>
</div></div>
<div class="function">
<h3 id="change_cond/1">change_cond(Scope::scope(), Event::event(), Spec::undefined | match_spec() (see module ets)) -&gt; true</h3>


<div class="description">

<p>Change the condition specification of an existing subscription.</p>
 
  <p>This function atomically changes the condition spec of an existing
  subscription (see <a href="#subscribe_cond/3" class="seealso">subscribe_cond/3</a>). An exception is raised if  
the subscription doesn't already exist.</p>
 
  <p>Note that this function can also be used to change a conditional subscription
  to an unconditional one (by setting <code>Spec = undefined</code>), or a 'normal'
  subscription to a conditional one.</p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Remove subscribtion created using <code>subscribe(Scope, Event)</code></p>
 
  <p>This removes the property created through <code>subscribe/2</code>.</p>
</div></div>
<div class="function">
<h3 id="publish/1">publish(Scope::scope(), Event::event(), Msg::msg()) -&gt; ok</h3>


<div class="description">

<p>Publish the message <code>Msg</code> to all subscribers of <code>Event</code></p>
 
  <p>The message delivered to each subscriber will be of the form:</p>
 
  <p><code>{gproc_ps_event, Event, Msg}</code></p>
 
  <p>The function uses <code>gproc:send/2</code> to send a message to all processes which have a
  property <code>{p,Scope,{gproc_ps_event,Event}}</code>.</p>
</div></div>
<div class="function">
<h3 id="publish_cond/1">publish_cond(Scope::scope(), Event::event(), Msg::msg()) -&gt; msg()</h3>


<div class="description">

<p>Publishes the message <code>Msg</code> to conditional subscribers of <code>Event</code></p>
 
  <p>The message will be delivered to each subscriber provided their respective
  condition tests succeed.
 </p>
<p><em>See also:</em> <a href="#subscribe_cond/3" class="seealso">subscribe_cond/3</a>.</p>
</div></div>
<div class="function">
<h3 id="list_subs/1">list_subs(Scope::scope(), Event::event()) -&gt; [pid()]</h3>


<div class="description">

<p>List the pids of all processes subscribing to <code>Event</code></p>
 
  <p>This function uses <code>gproc:select/2</code> to find all properties indicating a subscription.</p>
</div></div>
<div class="function">
<h3 id="create_single/1">create_single(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Creates a single-shot subscription entry for Event</p>
 
  <p>Single-shot subscriptions behave similarly to the <code>{active,once}</code> property of sockets.
  Once a message has been published, the subscription is disabled, and no more messages
  will be delivered to the subscriber unless the subscription is re-enabled using
  <code>enable_single/2</code>.</p>
 
  <p>The function creates a gproc counter entry, <code>{c,Scope,{gproc_ps_event,Event}}</code>, which
  will have either of the values <code>0</code> (disabled) or <code>1</code> (enabled). Initially, the value
  is <code>1</code>, meaning the subscription is enabled.</p>
 
  <p>Counters are used in this case, since they can be atomically updated by both the
  subscriber (owner) and publisher. The publisher sets the counter value to <code>0</code> as soon
  as it has delivered a message.</p>
</div></div>
<div class="function">
<h3 id="delete_single/1">delete_single(Scope::scope(), Event::event()) -&gt; true</h3>


<div class="description">

<p>Deletes the single-shot subscription for Event</p>
 
  <p>This function deletes the counter entry representing the single-shot description.
  An exception will be raised if there is no such subscription.</p>
</div></div>
<div class="function">
<h3 id="disable_single/1">disable_single(Scope::scope(), Event::event()) -&gt; integer()</h3>


<div class="description">

<p>Disables the single-shot subscription for Event</p>
 
  <p>This function changes the value of the corresponding gproc counter to <code>0</code> (disabled).</p>
 
  <p>The subscription remains (e.g. for debugging purposes), but with a 'disabled' status.  
This function is insensitive to concurrency, using 'wrapping' ets counter update ops.  
This guarantees that the counter will have either the value 1 or 0, depending on which  
update happened last.</p>
 
  <p>The return value indicates the previous status.</p>
</div></div>
<div class="function">
<h3 id="enable_single/1">enable_single(Scope::scope(), Event::event()) -&gt; integer()</h3>


<div class="description">

<p>Enables the single-shot subscription for Event</p>
 
  <p>This function changes the value of the corresponding gproc counter to <code>1</code> (enabled).</p>
 
  <p>After enabling, the subscriber will receive the next message published for <code>Event</code>,  
after which the subscription is automatically disabled.</p>
 
  <p>This function is insensitive to concurrency, using 'wrapping' ets counter update ops.  
This guarantees that the counter will have either the value 1 or 0, depending on which  
update happened last.</p>
 
  <p>The return value indicates the previous status.</p>
</div></div>
<div class="function">
<h3 id="tell_singles/1">tell_singles(Scope::scope(), Event::event(), Msg::msg()) -&gt; [pid()]</h3>


<div class="description">

<p>Publish <code>Msg</code> to all single-shot subscribers of <code>Event</code></p>
 
  <p>The subscriber status of each active subscriber is changed to <code>0</code> (disabled) before  
delivering the message. This reduces the risk that two different processes will be able  
to both deliver a message before disabling the subscribers. This could happen if the  
context switch happens just after the select operation (finding the active subscribers)  
and before the process is able to update the counters. In this case, it is possible  
that more than one can be delivered.</p>
 
  <p>The way to prevent this from happening is to ensure that only one process publishes
  for <code>Event</code>.</p>
</div></div>
<div class="function">
<h3 id="list_singles/1">list_singles(Scope::scope(), Event::event()) -&gt; [{pid(), status()}]</h3>


<div class="description">

<p>Lists all single-shot subscribers of Event, together with their status</p>
</div></div>
<div class="function">
<h3 id="notify_single_if_true/1">notify_single_if_true(Scope::scope(), Event::event(), F::() -&gt; boolean(), Msg::msg()) -&gt; ok</h3>


<div class="description">

<p>Create/enable a single subscription for event; notify at once if F() -&gt; true</p>
 
  <p>This function is a convenience function, wrapping a single-shot pub/sub around a
  user-provided boolean test. <code>Msg</code> should be what the publisher will send later, if the
  immediate test returns <code>false</code>.</p>
</div></div></div>

<authors>

<aname>Ulf Wiger</aname>
<email>ulf@wiger.net</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
