<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>eunit_addons (eunit_addons) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>eunit_addons</h1>
<h2 class="modsummary">   
Eunit addons make it easier to work with tests that require   
some kind of setup/cleanup to be performed before/after each test.</h2>
<div class="description">
<p>   
Eunit addons make it easier to work with tests that require   
some kind of setup/cleanup to be performed before/after each test.</p>
  
   Include the following in your eunit test suite and you should be
   on your way.  You don't have to include the
   eunit/include/eunit.hrl, since that's automatically included
   by the line below:
   <pre class="sh_erlang">       -include_lib("eunit_addons/include/eunit_addons.hrl").</pre>
  
   <p>This adds a set of macros which help you write eunit tests.</p>
  
   <em><marker id="Run_all_..._test/1_functions_with_setup/cleanup">Run all ..._test/1 functions with setup/cleanup</marker></em>
   Benefits of these macros:
   <list>
       <item><p>They make it easier to work with setup/cleanup
           before/after eunit tests (like eunit fixtures, but easier).</p></item>
       <item><p>They provide readable test names (same as the function
           name) to the eunit printout.</p></item>
       <item><p>They make it easy to set timeouts for test cases.</p></item>
       <item><p>The tests get isolated from each other.</p></item>
   </list>
  
   <p>NOTE: Use one of the ?WITH_SETUP macros with fewer parameters (if
         possible), since these don't require that the list of tests
         to be run are be specified but rather deduce that from the
         test module itself.  However, the version of the macro which
         has the <code>Tests</code> parameter might be useful when there are         
different groups of tests in one module which require         
different setup.</p>
  
   <p>The <code>{spawn,Test}</code> feature of eunit is used to achieve test isoloation.</p>
  
   <em><marker id="Run_all_..._test/1_functions_(with_default_timeouts)">Run all ..._test/1 functions (with default timeouts)</marker></em>
   This:
   <pre class="sh_erlang">       ?WITH_SETUP(SetupFun, CleanupFun)</pre>
   is equivalent to:
   <pre class="sh_erlang">       ?WITH_SETUP(SetupFun, CleanupFun, 120, 30)</pre><p>   
See ?WITH_SETUP/4 for details.</p>
  
   Example: Run all functions named <code>..._test/1</code> in the current module
   with default timeouts.  Start a server as part of the setup.
   The <code>..._test_/0</code> function is a test generator (this is how eunit
   works; it must be named <code>..._test_/0</code>).  The ?WITH_SETUP macro will
   only look for functions named <code>..._test/1</code> and run these.
   <pre class="sh_erlang">       my_server_test_() -&gt;
           ?WITH_SETUP(fun() -&gt;
                           {ok, Pid} = my_server:start_link(),
                           Pid
                       end,
                       fun(Pid) -&gt;
                           my_server:stop(Pid)
                       end).
  
       returns_foo_test(Pid) -&gt;
           foo = my_server:get_foo(Pid).
  
       returns_bar_test(Pid) -&gt;
           bar = my_server:get_bar(Pid).</pre>
   In the above example, functions are called in this order:
   <pre class="sh_erlang">       setup fun() -&gt; Pid1
       returns_foo_test(Pid1)
       cleanup fun(Pid1)
  
       setup fun() -&gt; Pid2
       returns_bar_test(Pid2)
       cleanup fun(Pid2)</pre>
  
   <em><marker id="Run_all_..._test/1_functions_(with_user-defined_timeouts)">Run all ..._test/1 functions (with user-defined timeouts)</marker></em>
   This:
   <pre class="sh_erlang">       ?WITH_SETUP(SetupFun, CleanupFun, ForAllTimeout, PerTcTimeout)</pre>
   is equivalent to:
   <pre class="sh_erlang">       ?WITH_SETUP(SetupFun, CleanupFun, ForAllTimeout, PerTcTimeout,
                   ListOfAllTestFunctionsInModuleWithArityOne)</pre><p>   
See ?WITH_SETUP/5 for details.</p>
  
   Example: Run all functions named <code>..._test/1</code> in the current module
   with user-defined timeouts.  Start a server as part of the setup.
   The <code>..._test_/0</code> function is a test generator (this is how eunit
   works; it must be named <code>..._test_/0</code>).  This ?WITH_SETUP macro will
   run all tests in <code>Tests</code>.
   <pre class="sh_erlang">       my_server_test_() -&gt;
           ?WITH_SETUP(fun() -&gt;
                           {ok, Pid} = my_server:start_link(),
                           Pid
                       end,
                       fun(Pid) -&gt;
                           my_server:stop(Pid)
                       end,
                       120,  % timeout for all tests
                       60).  % timeout for each test
  
       returns_foo_test(Pid) -&gt;
           foo = my_server:get_foo(Pid).
  
       returns_bar_test(Pid) -&gt;
           bar = my_server:get_bar(Pid).</pre>
   In the above example, functions are called in this order:
   <pre class="sh_erlang">       setup fun() -&gt; Pid1
       returns_foo_test(Pid1)
       cleanup fun(Pid1)
  
       setup fun() -&gt; Pid2
       returns_bar_test(Pid2)
       cleanup fun(Pid2)</pre>
  
   <em><marker id="Run_a_subset_of_test_functions_(with_user-defined_timeouts)">Run a subset of test functions (with user-defined timeouts)</marker></em>
   <pre class="sh_erlang">       ?WITH_SETUP(SetupFun, CleanupFun, ForAllTimeout, PerTcTimeout, Tests)
           SetupFun = () -&gt; State
           CleanupFun = (State) -&gt; void()
           State = term()
           ForAllTimeout = integer()
           PerTcTimeout = integer()
           Tests = [Test]
           Test = atom()</pre>
  
   <p>Runs <code>SetupFun</code> before and <code>CleanupFun</code> after each <code>Test</code>.
   <code>SetupFun</code> is a zero-argument fun which may do any setup that has
   to be done before the test is performed.  The result of this fun,
   <code>State</code>, is passed to each of the <code>Tests</code> as well as the
   <code>CleanupFun</code>.  The <code>CleanupFun</code> is supposed to take care of any
   cleanup after the test and is called regardless of whether the
   test was successful or not.  Each <code>Test</code> must be a function of
   arity 1 (the parameter is the output from the <code>SetupFun</code>).</p>
  
   <p><code>ForAllTimeout</code> is the maximum time (in seconds) all the <code>Tests</code>
   are allowed to take.  <code>PerTcTimeout</code> is the maximum time (in
   seconds) a single <code>Test</code> is allowed to take.</p>
  
   <p><code>Tests</code> is a list of names of functions (arity 1).  Each of these
   <code>Test</code> functions will be passed the output from the <code>SetupFun</code>.</p>
  
   Example: Run a selected number of tests using user-defined timeouts:
   <pre class="sh_erlang">       my_server_foo_test_() -&gt;
           ?WITH_SETUP(fun setup_before_foo/0,
                       fun cleanup_after_foo/1,
                       120,  % timeout for all tests
                       60,   % timeout for each test
                       [returns_foo_test,   % run only `foo' tests
                        sets_foo_test]).
  
       returns_foo_test(Pid) -&gt;
           foo = my_server:get_foo(Pid).
  
       sets_foo_test(Pid) -&gt;
           my_server:set_foo(Pid, foo2).
           foo2 = my_server:get_foo(Pid).
  
       my_server_bar_test_() -&gt;
           ?WITH_SETUP(fun setup_before_bar/0,
                       fun cleanup_after_bar/1,
                       120,  % timeout for all tests
                       60,   % timeout for each test
                       [returns_bar_test]). % run only `bar' tests
  
       returns_bar_test(Pid) -&gt;
           bar = my_server:get_bar(Pid).</pre>
   In the above example, functions are called in this order:
   <pre class="sh_erlang">       %% foo tests
       setup_before_foo() -&gt; Pid1
       returns_foo_test(Pid1)
       cleanup_after_foo(Pid1)
  
       setup_before_foo() -&gt; Pid2
       sets_foo_test(Pid2)
       cleanup_after_foo(Pid2)
  
       %% bar tests
       setup_before_foo() -&gt; Pid3
       returns_bar_test(Pid3)
       cleanup_after_bar(Pid3)</pre></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="get_tests_with_setup/1">get_tests_with_setup(Module) -&gt; [{Fn, Arity}]</h3>

<ul class="type">
<li><code>Fn = atom()</code></li><li><code>Arity = integer()</code></li></ul>
<div class="description">

<p>Return a list of tests which require a setup (..._test/1).</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
