<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gpb_compile (gpb) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gpb_compile</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="file/1">file(File) -&gt; ok | {error, Reason}</h3>


<div class="description">
<p>Equivalent to <a href="#file/2" class="seealso">file(File, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="file/2">file(File, Opts1::Opts) -&gt; CompRet</h3>

<ul class="type">
<li><code>File = string()</code></li><li><code>Opts = [Opt]</code></li><li><code>Opt = {type_specs, boolean()} | type_specs | {verify, optionally | always | never} | {copy_bytes, true | false | auto | integer() | float()} | {strings_as_binaries, boolean()} | strings_as_binaries | {defs_as_proplists, boolean()} | defs_as_proplists | {descriptor, boolean()} | descriptor | {maps, boolean()} | maps | {nif, boolean()} | nif | {load_nif, LoadNif} | {i, directory()} | {o, directory()} | {o_erl, directory()} | {o_hrl, directory()} | {o_nif_cc, directory()} | binary | to_msg_defs | return | return_warnings | return_errors | report | report_warnings | report_errors | include_as_lib | use_packages | {msg_name_prefix, string() | atom()} | {msg_name_suffix, string() | atom()} | {module_name_prefix, string() | atom()} | {module_name_suffix, string() | atom()}</code></li><li><code>CompRet = ModRet | BinRet | ErrRet</code></li><li><code>ModRet = ok | {ok, Warnings}</code></li><li><code>BinRet = {ok, ModuleName, Code} | {ok, ModuleName, Code, Warnings}</code></li><li><code>ErrRet = {error, Reason} | {error, Reason, Warnings}</code></li><li><code>ModuleName = atom()</code></li><li><code>Code = binary() | ErlAndNifCode</code></li><li><code>ErlAndNifCode = [CodeType]</code></li><li><code>CodeType = {erl, binary()} | {nif, NifCcText}</code></li><li><code>NifCcText = binary()</code></li><li><code>LoadNif = string()</code></li></ul>
<div class="description">

<p>  
Compile a .proto file to a .erl file and to a .hrl file.</p>
 
  <p>The generated .erl file will use the <code>gpb</code> module for runtime  
support for encoding and decoding.</p>
 
  <p>The File must not include path to the .proto file. Example:  
"SomeDefinitions.proto" is ok, while "/path/to/SomeDefinitions.proto"  
is not ok.</p>
 
  <p>The .proto file is expected to be found in a directories specified by an
  <code>{i,directory()}</code> option. It is possible to specify <code>{i,directory()}</code>  
several times, they will be search in the order specified.</p>
 
  <p>The <code>{type_specs,boolean()}</code> option enables or disables <code>::Type()</code>
  annotations in the generated .hrl file. Default is currently
  <code>false</code>. If you set it to <code>true</code>, you may get into troubles for
  messages referencing other messages, when compiling the generated
  files. The <code>type_specs</code> option is equivalent to <code>{type_specs,true}</code>.</p>
 
  <p>The <code>verify</code> option whether or not to generate code for verifying
  that, during encoding, values are of correct type and within range.
  The <code>verify</code> option can have the following values:
  </p><taglist>
     <dt><code>always</code></dt><item><p>Generate code that unconditionally
         verifies values.</p></item>
     <dt><code>never</code></dt><item><p>Generate code that never verifies
         values time. Encoding will fail if a value of the wrong
         type is supplied. This includes forgetting to set a required
         message field. Encoding may silently truncate values out of
         range for some types.</p></item>
     <dt><code>optionally</code></dt><item><p>Generate an <code>encode_msg/2</code> that accepts
         the run-time option <code>verify</code> or <code>{verify,boolean()}</code> for specifying
         whether or not to verify values.</p></item>
  </taglist>
 
  <p>Erlang value verfication either succeeds or crashes with the <code>error</code>
  <code>{gpb_type_error,Reason}</code>. Regardless of the <code>verify</code> option,
  a function, <code>verify_msg/1</code> is always generated.</p>
 
  <p>The <code>copy_bytes</code> option specifies whether when decoding data of
  type <code>bytes</code> (or strings if the <code>strings_as_binaries</code> is set), the
  decoded bytes should be copied or not.  Copying requires the
  <code>binary</code> module, which first appeared in Erlang R14A. When not
  copying decoded bytes, they will become sub binaries of the larger
  input message binary. This may tie up the memory in the input
  message binary longer than necessary after it has been
  decoded. Copying the decoded bytes will avoid creating sub
  binaries, which will in make it possible to free the input message
  binary earlier. The <code>copy_bytes</code> option can have the following values:
  </p><taglist>
    <dt><code>false</code></dt><item><p>Never copy bytes/(sub-)binaries.</p></item>
    <dt><code>true</code></dt><item><p>Always copy bytes/(sub-)binaries.</p></item>
    <dt><code>auto</code></dt><item><p>Copy bytes/(sub-)binaries if the beam vm,
            on which the compiler (this module) is running,
            has the <code>binary:copy/1</code> function. (This is the default)</p></item>
    <dt>integer() | float()</dt><item><p>Copy the bytes/(sub-)binaries if the
            message this many times or more larger than the size of the
            bytes/(sub-)binary.</p></item>
  </taglist>
 
  <p>The <code>strings_as_binaries</code> option specifies whether strings should
  be returned from decoding as strings (list of unicode code points),
  or as binaries (UTF-8 encoded). The <code>copy_bytes</code> option applies
  to strings as well, when the <code>strings_as_binaries</code> option is set.  
Upon encoding, both binaries and lists are accepted.</p>
 
  <p>The <code>defs_as_proplists</code> option changes the generated introspection
  functions <code>find_msg_def</code> and <code>get_msg_defs</code> to return the description
  of each message field as a proplist, instead of as a <code>#field{}</code> record.
  The purpose is to make the generated code completely independent
  of gpb, at compile-time (it is already independent at run-time).
  The keys of the proplist are the names of the record fields in the
  <code>#field{}</code> record.  See also <a href="gpb.html#type-proplists_to_field_records" class="seealso">gpb:proplists_to_field_records()</a>  
and related functions for conversion functions between these two  
formats.</p>
 
  <p>The <code>descriptor</code> option specifies whether or not to generate a
  function, descriptor/0, which returns a binary that describes the
  proto file(s) contents according to the protobuf's <code>descriptor.proto</code>.
  The default is to not generate such a description.  The generated
  description binary is most likely not identical to what <code>protoc</code>  
would generate, but the contents is roughly equivalent.</p>
 
  <p>The <code>{o,directory()}</code> option specifies directory to use for storing
  the generated <code>.erl</code> and <code>.hrl</code> files. Default is the same
  directory as for the proto <code>File</code>.</p>
 
  <p>The <code>{o_erl,directory()}</code>, <code>{o_hrl,directory()}</code>, <code>{o_nif_cc,directory()}</code>,
  options specify output directory for where to generate the <code>.erl</code>
  and <code>.hrl</code> files respectively, and for the NIF C++ file,
  if the <code>nif</code> option is specified. The <code>{o_erl,directory()}</code> option
  overrides any <code>{o,directory()}</code> option, and similarly for the  
other file-type specific output options.</p>
 
  <p>The <code>maps</code> option will generate a protobuf encoder/decoder that
  uses maps instead of records. It will not generate any <code>.hrl</code> file,
  and the functions <code>encode_msg</code>, <code>merge_msgs</code> and <code>verify_msg</code> will
  take the message name as an additional parameter. The introspection
  will generate message field descriptions as maps instead of as
  <code>#field{}</code> records, unless, of course <code>defs_as_proplists</code> is specified,
  in which case they will be proplists instead. This option is not
  compatible with the <code>nif</code> option.</p>
 
  <p>The <code>nif</code> option will cause the compiler to generate code which
  decoding code is nif C++ code. The generated can be linked with the
  Google protobuf C++ library.  Read the file <code>README.nif-cc</code> for
  more info. This option is not compatible with the <code>maps</code> option;  
the generated C++ decoding code would still create records.</p>
 
  <p>The <code>binary</code> option will cause the generated and compiled code be
  returned as a binary. No files will be written. The return value
  will be on the form <code>{ok,Mod,Code}</code> or <code>{ok,Mod,Code,Warnings}</code>
  if the compilation is succesful. This option may be useful
  e.g. when generating test cases. In case the <code>nif</code> option is set,
  the <code>Code</code> will be a list of tuples: <code>{erl,binary()}</code> which
  contains the erlang object byte code, and <code>{nif,binary()}</code> which  
contains the C++ code. You will have to compile the C++ code with a  
C++ compiler, before you can use the erlang code.</p>
 
  <p>The <code>to_msg_defs</code> option will result in <code>{ok,MsgDefs}</code> or
  <code>{ok,MsgDefs,Warns}</code> being returned if the compilation is succesful.
  The returned message definitions can be used with the
  <a href="#msg_defs/2" class="seealso">msg_defs/2</a> or <a href="#msg_defs/3" class="seealso">msg_defs/3</a> functions.</p>
 
  <taglist>
    <dt><code>report_errors</code>/<code>report_warnings</code></dt>
    <item><p>Causes errors/warnings to be printed as they occur.</p></item>
    <dt><code>report</code></dt>
    <item><p>This is a short form for both <code>report_errors</code> and
        <code>report_warnings</code>.</p></item>
    <dt><code>return_errors</code></dt>
    <item><p>If this flag is set, then  <code>{error,ErrorList,WarningList}</code> is
        returned when there are errors.</p></item>
    <dt><code>return_warnings</code></dt>
    <item><p>If  this  flag  is set, then an extra field containing <code>WarningList</code>
        is added to the tuples returned on success.</p></item>
    <dt><code>return</code></dt>
    <item><p>This is a short form for both <code>return_errors</code> and
        <code>return_warnings</code>.</p></item>
  </taglist>
 
  <p>See <a href="#format_error/1" class="seealso">format_error/1</a> for a way to turn an error <i>Reason</i> to  
plain text.</p>
 
  <p>If the <code>include_as_lib</code> option is set, the generated code will include  
gpb.hrl as a library, which is necessary if dependencies are managed with  
Rebar. Otherwise, the header file is included directly and must be located  
in the path, which is default behaviour.</p>
 
  <p>The <code>use_packages</code> option instructs gpb to prepend the name of a package  
to every message it contains. If no package is defined, nothing will be  
prepended. This enables the reference of messages in other packages which  
would otherwise not be possible. However, for reasons of backward  
compatibility, this option is disabled by default.</p>
 
  <p>The <code>{msg_name_prefix,Prefix}</code> will add <code>Prefix</code> (a string or an atom)
  to each message. This might be useful for resolving colliding names,
  when incorporating several protocol buffer definitions into the same
  project. The <code>{msg_name_suffix,Suffix}</code> works correspondingly.</p>
 
  <p>The <code>{module_name_prefix,Prefix}</code> will add <code>Prefix</code> (a string or an atom)
  to the generated code and defintion files. The <code>{module_name_suffix,Suffix}</code>
  works correspondingly.</p>
</div></div>
<div class="function">
<h3 id="msg_defs/2">msg_defs(Mod, Defs) -&gt; CompRet</h3>


<div class="description">
<p>Equivalent to <a href="#msg_defs/3" class="seealso">msg_defs(Mod, Defs, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="msg_defs/3">msg_defs(Mod, Defs0::Defs, Opts0::Opts) -&gt; CompRet</h3>

<ul class="type">
<li><code>Mod = atom()</code></li><li><code>Defs = [Def]</code></li><li><code>Def = {{enum, EnumName}, Enums} | {{msg, MsgName}, MsgFields}</code></li><li><code>EnumName = atom()</code></li><li><code>Enums = [{Name, integer()}]</code></li><li><code>Name = atom()</code></li><li><code>MsgName = atom()</code></li><li><code>MsgFields = [#field{}]</code></li></ul>
<div class="description">

<p>
  Compile a list of pre-parsed definitions to file or to a binary.
  See <a href="#file/2" class="seealso">file/2</a> for information on options and return values.</p>
</div></div>
<div class="function">
<h3 id="format_error/2">format_error(Reason::{error, Reason} | Reason) -&gt; io_list()</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Produce a plain-text error message from a reason returned by
  for instance <a href="#file/2" class="seealso">file/2</a> or <a href="#msg_defs/2" class="seealso">msg_defs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="format_warning/1">format_warning(X::Reason) -&gt; io_list()</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Produce a plain-text error message from a reason returned by
  for instance <a href="#file/2" class="seealso">file/2</a> or <a href="#msg_defs/2" class="seealso">msg_defs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="c/0">c() -&gt; no_return()</h3>


<div class="description">

<p>Command line interface for the compiler.
  With no proto file to compile, print a help message and exit.</p>
</div></div>
<div class="function">
<h3 id="c/1">c(Files::[string() | atom()]) -&gt; no_return()</h3>


<div class="description">

<p>This function is intended as a command line interface for the compiler.
  Call it from the command line as follows:
  </p><pre class="sh_erlang">     erl &lt;erlargs&gt; [gpb-opts] -s gpb_compile c File.proto ...
     erl &lt;erlargs&gt; -s gpb_compile c File.proto ... -extra [gpb-opts]</pre><p>
  The <code>&lt;erlargs&gt;</code> can be <code>-noshell -noinput +B -boot start_clean -pa SomeDir</code></p>
 
  <p>The following options are supported:
  </p><taglist>
    <dt><code>-IDir</code> <code>-I Dir</code></dt>
    <item><p>Specify include directory.
        Option may be specified more than once to specify
        several include directories.</p></item>
    <dt><code>-o Dir</code></dt>
    <item><p>Specify output directory for where to generate
        the <i>ProtoFile</i>.erl and <i>ProtoFile</i>.hrl</p></item>
    <dt><code>-o-erl Dir</code> | <code>-o-hrl Dir</code> | <code>-o-nif-cc Dir</code></dt>
    <item><p>Specify output directory for where to generate
        the <i>ProtoFile</i>.erl and <i>ProtoFile</i>.hrl respectively,
        and for the NIF C++ file, if the <code>-nif</code> option is specified.
        The <code>-o-erl Dir</code> option overrides any <code>-o Dir</code> option, and
        similarly for the other file-type specific output options.</p></item>
    <dt><code>-v optionally | always | never</code></dt>
    <item><p>Specify how the generated encoder should
        verify the message to be encoded.</p></item>
    <dt><code>-nif</code></dt>
    <item><p>Generate nifs for linking with the protobuf C(++) library.</p></item>
    <dt><code>-load_nif FunctionDefinition</code></dt>
    <item><p>Specify <code>FunctionDefinition</code> as the text that defines the
        function <code>load_nif/0</code>.  This is called as the <code>on_load</code>
        hook for loading the NIF.  See also the doc for the <code>load_nif</code>
        option in the <a href="#file/2" class="seealso">file/2</a> function.</p></item>
    <dt><code>-c true | false | auto | integer() | float()</code></dt>
    <item><p>Specify how or when the generated decoder should
        copy fields of type <code>bytes</code>. See the <code>copy_bytes</code> option
        for the function <a href="#file/2" class="seealso">file/2</a> for more info.</p></item>
    <dt><code>-strbin</code></dt>
    <item><p>Specify that decoded strings should be returend as binaries,
        instead of as strings (lists).</p></item>
    <dt><code>-pldefs</code></dt>
    <item><p>Specify that introspection functions shall return proplists
        instead of <code>#field{}</code> records, to make the generated code
        completely free of even compile-time dependencies to gpb.</p></item>
    <dt><code>-msgprefix Prefix</code></dt>
    <item><p>Prefix each message with <code>Prefix</code>. This can be useful to
        when including different sub-projects that have colliding
        message names.</p></item>
    <dt><code>-modprefix Prefix</code></dt>
    <item><p>Prefix each module with <code>Prefix</code>. Normally the module name of
        the generated code is based on the name of the <code>.proto</code> file.
        This option prepends a prefix to the module name, which can be
        useful when including different sub-projects that have
        colliding proto file names.</p></item>
    <dt><code>-msgsuffix Suffix</code></dt>
    <item><p>Sufffix each message name with <code>Suffix</code>.</p></item>
    <dt><code>-modsuffix Suffix</code></dt>
    <item><p>Suffix each module name with <code>Suffix</code>.</p></item>
    <dt><code>-il</code></dt>
    <item><p>Generate code that include gpb.hrl using <code>-include_lib</code>
        instad of <code>-include</code>, which is the default.</p></item>
    <dt><code>-type</code></dt>
    <item><p>Enables <code>::Type()</code> annotations in the generated .hrl file.</p></item>
    <dt><code>-descr</code></dt>
    <item><p>Generate self-description information.</p></item>
    <dt><code>-maps</code></dt>
    <item><p>Generate code that will accept and produce maps instead of
        records. No .hrl file will be generated. See the <code>maps</code> option
        for the function <a href="#file/2" class="seealso">file/2</a> for more info.</p></item>
    <dt><code>--help</code> or <code>-h</code></dt>
    <item><p>Show help.</p></item>
    <dt><code>--version</code> or <code>-V</code></dt>
    <item><p>Show the version number of gpb.</p></item>
  </taglist><p>
  If several files are specified, each is compiled individually, no
  checking is done for instance for multiply defined messages or
  fields across files, such as the <code>protoc</code> does.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
