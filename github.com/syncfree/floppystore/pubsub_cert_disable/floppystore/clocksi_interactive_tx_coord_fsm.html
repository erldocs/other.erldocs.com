<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>clocksi_interactive_tx_coord_fsm (floppystore) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>clocksi_interactive_tx_coord_fsm</h1>
<h2 class="modsummary">The coordinator for a given Clock SI interactive transaction.</h2>
<div class="description">
<p>The coordinator for a given Clock SI interactive transaction.
       It handles the state of the tx and executes the operations sequentially
       by sending each operation to the responsible clockSI_vnode of the
       involved key. when a tx is finalized (committed or aborted, the fsm
       also finishes.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-cache_id">cache_id() = <a href="ets.html#type-tid" class="seealso">ets:tid()</a></h3></div>
    <div class="type"><h3 id="type-crdt">crdt() = term()</h3></div>
    <div class="type"><h3 id="type-key">key() = term()</h3></div>
    <div class="type"><h3 id="type-log">log() = term()</h3></div>
    <div class="type"><h3 id="type-op">op() = {term(), term()}</h3></div>
    <div class="type"><h3 id="type-op_id">op_id() = {integer() &gt;= 0, node()}</h3></div>
    <div class="type"><h3 id="type-operation">operation() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#operation{op_number = any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload = undefined | <a href="#type-payload" class="seealso">payload()</a>}</h3></div>
    <div class="type"><h3 id="type-partition_id">partition_id() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-payload">payload() = term()</h3></div>
    <div class="type"><h3 id="type-preflist">preflist() = <a href="riak_core_apl.html#type-preflist" class="seealso">riak_core_apl:preflist()</a></h3></div>
    <div class="type"><h3 id="type-reason">reason() = atom()</h3></div>
    <div class="type"><h3 id="type-snapshot">snapshot() = term()</h3></div>
    <div class="type"><h3 id="type-snapshot_time">snapshot_time() = <a href="vectorclock.html#type-vectorclock" class="seealso">vectorclock:vectorclock()</a></h3></div>
    <div class="type"><h3 id="type-tx">tx() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#transaction{snapshot_time = undefined | <a href="#type-snapshot_time" class="seealso">snapshot_time()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_pid = undefined | pid(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec_snapshot_time = any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;txn_id = undefined | <a href="#type-txid" class="seealso">txid()</a>}</h3></div>
    <div class="type"><h3 id="type-txid">txid() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#tx_id{snapshot_time = any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server_pid = undefined | pid()}</h3></div>
    <div class="type"><h3 id="type-type">type() = atom()</h3></div>
    <div class="type"><h3 id="type-val">val() = term()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/2">start_link(From, Clientclock) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_link/1">start_link(From) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="finish_op/3">finish_op(From, Key, Result) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stop/1">stop(Pid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="init/1">init(X1) -&gt; term()
</h3>


<div class="description">

<p>Initialize the state.</p>
</div></div>
<div class="function">
<h3 id="create_transaction_record/1">create_transaction_record(ClientClock::snapshot_time() | ignore) -&gt; {tx(), txid()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="perform_singleitem_read/1">perform_singleitem_read(Key::key(), Type::type()) -&gt; {ok, val()} | {error, reason()}</h3>


<div class="description">

<p>This is a standalone function for directly contacting the read
       server located at the vnode of the key being read.  This read
       is supposed to be light weight because it is done outside of a
       transaction fsm and directly in the calling thread.</p>
</div></div>
<div class="function">
<h3 id="perform_singleitem_update/1">perform_singleitem_update(Key::key(), Type::type(), Params::{op(), term()}) -&gt; {ok, {txid(), [], snapshot_time()}} | {error, term()}</h3>


<div class="description">

<p>This is a standalone function for directly contacting the update
       server vnode.  This is lighter than creating a transaction
       because the update/prepare/commit are all done at one time</p>
</div></div>
<div class="function">
<h3 id="perform_read/4">perform_read(Args, Updated_partitions, Transaction, Sender) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="perform_update/4">perform_update(Args, Updated_partitions, Transaction, Sender) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="execute_op/3">execute_op(X1, Sender, SD0) -&gt; term()
</h3>


<div class="description">

<p>Contact the leader computed in the prepare state for it to execute the
       operation, wait for it to finish (synchronous) and go to the prepareOP
        to execute the next operation.</p>
</div></div>
<div class="function">
<h3 id="prepare/1">prepare(SD0) -&gt; term()
</h3>


<div class="description">

<p>this state sends a prepare message to all updated partitions and goes
       to the "receive_prepared"state.</p>
</div></div>
<div class="function">
<h3 id="prepare_2pc/1">prepare_2pc(SD0) -&gt; term()
</h3>


<div class="description">

<p>state called when 2pc is forced independently of the number of partitions
       involved in the txs.</p>
</div></div>
<div class="function">
<h3 id="process_prepared/2">process_prepared(ReceivedPrepareTime, S0) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="receive_prepared/2">receive_prepared(X1, S0) -&gt; term()
</h3>


<div class="description">

<p>in this state, the fsm waits for prepare_time from each updated
       partitions in order to compute the final tx timestamp (the maximum
       of the received prepare_time).</p>
</div></div>
<div class="function">
<h3 id="single_committing/2">single_committing(X1, S0) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="committing_single/3">committing_single(X1, Sender, SD0) -&gt; term()
</h3>


<div class="description">

<p>There was only a single partition with an update in this transaction
       so the transaction has already been committed
       so just wait for the commit message from the client</p>
</div></div>
<div class="function">
<h3 id="committing_2pc/3">committing_2pc(X1, Sender, SD0) -&gt; term()
</h3>


<div class="description">

<p>after receiving all prepare_times, send the commit message to all
       updated partitions, and go to the "receive_committed" state.
       This state expects other process to sen the commit message to
       start the commit phase.</p>
</div></div>
<div class="function">
<h3 id="committing/3">committing(X1, Sender, SD0) -&gt; term()
</h3>


<div class="description">

<p>after receiving all prepare_times, send the commit message to all
       updated partitions, and go to the "receive_committed" state.
       This state is used when no commit message from the client is
       expected</p>
</div></div>
<div class="function">
<h3 id="receive_committed/2">receive_committed(X1, S0) -&gt; term()
</h3>


<div class="description">

<p>the fsm waits for acks indicating that each partition has successfully
 	committed the tx and finishes operation.
       Should we retry sending the committed message if we don't receive a
       reply from every partition?
       What delivery guarantees does sending messages provide?</p>
</div></div>
<div class="function">
<h3 id="abort/1">abort(SD0) -&gt; term()
</h3>


<div class="description">

<p>when an error occurs or an updated partition
  does not pass the certification check, the transaction aborts.</p>
</div></div>
<div class="function">
<h3 id="abort/2">abort(X1, SD0) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="reply_to_client/1">reply_to_client(SD) -&gt; term()
</h3>


<div class="description">

<p>when the transaction has committed or aborted,
        a reply is sent to the client that started the transaction.</p>
</div></div>
<div class="function">
<h3 id="handle_info/3">handle_info(Info, StateName, StateData) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_event/3">handle_event(Event, StateName, StateData) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_sync_event/4">handle_sync_event(Event, From, StateName, StateData) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="code_change/4">code_change(OldVsn, StateName, State, Extra) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="terminate/3">terminate(Reason, SN, SD) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
