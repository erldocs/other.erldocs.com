<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gl_async_bully (gl_async_bully) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gl_async_bully</h1>
<h2 class="modsummary">Attempts to implement the 'Asynchronous Bully Algorithm' from
  Scott D.</h2>
<div class="description">
<p>Attempts to implement the 'Asynchronous Bully Algorithm' from
  Scott D. Stoller's 1997 paper 'Leader Election in Distributed
  Systems with Crash Failures'
  <url href="http://www.cs.sunysb.edu/~stoller/leader-election.html">http://www.cs.sunysb.edu/~stoller/leader-election.html</url></p>
 
  <p><em><marker id="Notes">Notes</marker></em></p><p>    
Our failure detector is built on erlang:monitor_node to detect    
peer nodes as they connect and disconnect from us. On receiving    
an up message from a peer we then monitor the leader election    
control process on the new node (in the case that we are    
interested in setting a FD on that node).</p>
 
  <p><em><marker id="Protocols">Protocols</marker></em></p><p>    
1) Leader election.       
XXX - fill in rest of section.</p>
 
  <p><em><marker id="Ideas">Ideas</marker></em></p><p>    
* Calls currently need to pass through the local node in order to      
get to the leader. If this serialization of client calls      
through the local node causes problems due to the high message      
volume swamping the control messages, it may be necessary to      
introduce an ets table containing the current identity of the      
leader, or a second process that tracks the leader identity and      
forwards calls appropriately.</p>
 
    <p>* Another plan would be to split the control functionality into a      
separate registered process. leader_call traffic could be split      
into a third process if needed. This would give a process model      
of control, message routing and API client processing in      
separate processes. Would be tricky to implement and require      
complex coordination.</p>
 
  <p><em><marker id="Callback_API">Callback API</marker></em></p><p>
     <code>init(Arguments) -&gt; {ok, State} | {stop, Reason} | ignore</code></p>
 
     <p>Initialize the callback module's state.</p>
 
     <pre class="sh_erlang">handle_call(Msg, From, CI::cluster_info(), State) -&gt;
                                                     {reply, Reply, NewState} |
                                                     {noreply, NewState} |
                                                     {stop, Reply, Reason, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Handle message from <code>gl_async_bully:call/2</code>.</p>
 
     <pre class="sh_erlang">handle_leader_call(Msg, From, CI::cluster_info(), State) -&gt;
                                                     {reply, Reply, NewState} |
                                                     {reply, Reply, Broadcast, NewState} |
                                                     {noreply, NewState} |
                                                     {stop, Reply, Reason, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Handle message from <code>gl_async_bully:leader_call/2,3</code> if this node is the
     leader. The callback can return <code>{reply, Reply, Broadcast, NewState}</code>
     and the <code>Broadcast</code> message will be sent to all peers. The method of
     broadcast can be varied by using <code>leader_call/3</code>.</p>
 
     <pre class="sh_erlang">from_leader(Msg, CI::cluster_info(), State) -&gt;
                                                     {ok, NewState} |
                                                     {stop, Reason, NewState}</pre><p>     
Handle an event from the leader.</p>
 
     <pre class="sh_erlang">handle_cast(Msg, CI::cluster_info(), State) -&gt;
                                                     {ok, NewState} |
                                                     {ok, Broadcast, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Handle message from <code>gl_async_bully:cast/2</code>. If the node is the leader,
     it can use the <code>{ok, BroasCast, NewState}</code> return type to broadcast to     
the other peers.</p>
 
     <pre class="sh_erlang">handle_leader_cast(Msg, CI::cluster_info(), State) -&gt;
                                                     {ok, NewState} |
                                                     {ok, Broadcast, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Handle message from <code>gl_async_bully:leader_cast/2</code> if this node is the
     leader.
     See the note for <code>handle_cast/2</code> for details on the <code>{ok, Broadcast,
     NewState}</code> return type.</p>
 
     <pre class="sh_erlang">handle_info(Msg, CI::cluster_info(), State) -&gt;
                                                     {ok, NewState} |
                                                     {ok, Broadcast, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Handle a message not sent via a call or a cast.
     See the note for <code>handle_cast/2</code> for details on the <code>{ok, Broadcast,
     NewState}</code> return type.</p>
 
     <pre class="sh_erlang">elected(CI::cluster_info, State) -&gt;
                                                     {ok, NewState} |
                                                     {ok, Broadcast, NewState} |
                                                     {stop, Reason, NewState}</pre><p>
     Called when this node becomes the leader.
     See the note for <code>handle_cast/2</code> for details on the <code>{ok, Broadcast,
     NewState}</code> return type.</p>
 
     <pre class="sh_erlang">surrendered(Leader::node(), CI::cluster_info, State) -&gt;
                                                     {ok, NewState} |
                                                     {stop, Reason, NewState}</pre>
 
     <p>Called when a different node is elected leader.</p>
 
     <pre class="sh_erlang">code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</pre><p>     
Called to convert callback state when code is changed.</p>
 
     <pre class="sh_erlang">terminate(Reason, CI::cluster_info(), State) -&gt; void()</pre><p>
     Called when the gl_async_bully process is about to terminate. Any
     cleanup should be done here. The return value is ignored.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-cluster_info">cluster_info()</h3></div>
    <div class="type"><h3 id="type-lc_proto">lc_proto() = leader_only | local_sync</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/4">start_link(Name, Mod, Arg, Net) -&gt; term()
</h3>


<div class="description">

<p>Start the gl_async_bully process.
  <code>Name</code> is the registered name the nodes will use, <code>Mod</code> is the callback
  module, <code>Arg</code> are the arguments to the callback module and <code>Net</code> is the
  list of candidate leaders.</p>
</div></div>
<div class="function">
<h3 id="role/1">role(X1::cluster_info()) -&gt; leader | follower</h3>


<div class="description">

<p>Get the processes' role in the cluster.</p>
</div></div>
<div class="function">
<h3 id="leader/1">leader(X1::cluster_info()) -&gt; node()</h3>


<div class="description">

<p>Extract the leader from the cluster info.</p>
</div></div>
<div class="function">
<h3 id="peers/1">peers(X1::cluster_info()) -&gt; [node()]</h3>


<div class="description">

<p>Extract the peers from the cluster info.</p>
</div></div>
<div class="function">
<h3 id="live_peers/1">live_peers(CI::cluster_info()) -&gt; [node()]</h3>


<div class="description">

<p>Extract the live peers from the cluster info.</p>
</div></div>
<div class="function">
<h3 id="broadcast/1">broadcast(Msg::term(), CI::cluster_info()) -&gt; ok</h3>


<div class="description">

<p>Broadcast a message to all alive peers.</p>
</div></div>
<div class="function">
<h3 id="to_follower/1">to_follower(FNode::node(), Msg::term(), CI::cluster_info()) -&gt; ok</h3>


<div class="description">

<p>Send a message to follower <code>FNode</code>.</p>
</div></div>
<div class="function">
<h3 id="to_followers/1">to_followers(Msg::term(), CI::cluster_info()) -&gt; ok</h3>


<div class="description">

<p>Send a message to all followers.</p>
</div></div>
<div class="function">
<h3 id="to_other_followers/1">to_other_followers(ExceptNode::node(), Msg::term(), CI::cluster_info()) -&gt; ok</h3>


<div class="description">

<p>Send a message to allow followers except for <code>ExceptNode</code>.</p>
</div></div>
<div class="function">
<h3 id="leader_call/1">leader_call(Name::atom(), Msg::term()) -&gt; any()</h3>


<div class="description">

<p>Make a call to the leader, proxied through local process</p>
</div></div>
<div class="function">
<h3 id="leader_call/1-1">leader_call(Name::atom(), Msg::term(), Proto::lc_proto()) -&gt; any()</h3>


<div class="description">

<p>Make a call to the leader, proxied through local process</p>
</div></div>
<div class="function">
<h3 id="leader_cast/1">leader_cast(Name::atom() | cluster_info(), Msg::term()) -&gt; any()</h3>


<div class="description">

<p>Make a cast to the leader</p>
</div></div>
<div class="function">
<h3 id="call/1">call(Name::atom(), Msg::term()) -&gt; any()</h3>


<div class="description">

<p>Make a call to the local async_bully process</p>
</div></div>
<div class="function">
<h3 id="cast/1">cast(Name::atom(), Msg::term()) -&gt; any()</h3>


<div class="description">

<p>Make a cast to the local async_bully process</p>
</div></div>
<div class="function">
<h3 id="reply/2">reply(From, Msg) -&gt; term()
</h3>


<div class="description">

<p>Equivalent of gen_server/gen_fsm reply/2</p>
</div></div>
<div class="function">
<h3 id="format_status/2">format_status(Fmt, X2) -&gt; term()
</h3>


<div class="description">

<p>gen_fsm:format_status/2 callback.</p>
 
  <p>Examines internal state to give easier to read output for
  sys:get_status(Some gl_async_bully process).</p>
</div></div></div>

<authors>

<aname>Geoff Cant</aname>
<email>nem@erlang.geek.nz</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
