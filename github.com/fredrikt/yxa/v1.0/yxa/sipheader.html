<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sipheader (yxa) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sipheader</h1>
<h2 class="modsummary">     Various functions for parsing headers or formatting             
headers for printing.</h2>
<div class="description">
<p>     Various functions for parsing headers or formatting             
headers for printing.</p>
  
   <p>Note: some functions do several passes over the same string() to   
parse it, e.g. 1 pass to find start and end delimiter and one pass   
for reading the the elements from start to end index, and probably   
a additional scan to reach the remainder of the string.   
This performance can be improved, by using a accumulator equiped   
parser that returns the Match and Rest part of the string, in a   
single scan.</p>
  
   Note: elements are often only partially parsed - this reduces the
   amount of parsing done on entries which will only be passed along,
   but while this improves performance it increases the need for later
   exception handling.
  </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="comma/1">comma(String) -&gt; [string()]</h3>


<div class="description">

<p>    split a comma separated string into separate strings,
           along the commas (don't include them). Each substring is
           cleared of any preceding or trailing spaces. example:
           "foo, bar, zop, \"quoted, hi\"" -&gt; ["foo","bar","zop",
           "\"quoted, hi\""]
 </p>
</div></div>
<div class="function">
<h3 id="expires/1">expires(Header) -&gt; Expires</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li><li><code>Expires = [string()]</code></li></ul>
<div class="description">

<p>    Get the value of the "Expires" header.</p>
</div></div>
<div class="function">
<h3 id="to/1">to(Header::In) -&gt; {DisplayName, URI}</h3>

<ul class="type">
<li><code>In = [string()] | #keylist{}</code></li><li><code>DisplayName = none | string()</code></li><li><code>URI = #sipurl{}</code></li></ul>
<div class="description">

<p>    Parse To: header data.</p>
<p><em>See also:</em> <a href="#name_header/1" class="seealso">name_header/1</a>.</p>
</div></div>
<div class="function">
<h3 id="from/1">from(Header::In) -&gt; {DisplayName, URI}</h3>

<ul class="type">
<li><code>In = [string()] | #keylist{}</code></li><li><code>DisplayName = none | string()</code></li><li><code>URI = #sipurl{}</code></li></ul>
<div class="description">

<p>    Parse From: header data.</p>
<p><em>See also:</em> <a href="#name_header/1" class="seealso">name_header/1</a>.</p>
</div></div>
<div class="function">
<h3 id="contact/1">contact(Header) -&gt; [#contact{}]</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Return the parsed Contact: header from Header.</p>
</div></div>
<div class="function">
<h3 id="route/1">route(Header) -&gt; [#contact{}]</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Return the parsed Route: header from Header.</p>
</div></div>
<div class="function">
<h3 id="record_route/1">record_route(Header) -&gt; [#contact{}]</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Return the parsed Record-Route: header from Header.</p>
</div></div>
<div class="function">
<h3 id="via/1">via(Header::In) -&gt; [#via{}]</h3>

<ul class="type">
<li><code>In = #keylist{} | [string()]</code></li><li><code>Reason = unparseable_via | term()</code></li></ul>
<div class="description">

<p>    Parse Via: header data.</p>
</div></div>
<div class="function">
<h3 id="topvia/1">topvia(Header) -&gt; #via{} | none</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    get the first Via entry from Header</p>
</div></div>
<div class="function">
<h3 id="via_print/1">via_print(Via) -&gt; [ViaStr]</h3>

<ul class="type">
<li><code>Via = #via{}</code></li><li><code>ViaStr = string()</code></li></ul>
<div class="description">

<p>    Print via record() or list() of via record().</p>
</div></div>
<div class="function">
<h3 id="via_params/1">via_params(Via) -&gt; dict()</h3>

<ul class="type">
<li><code>Via = #via{}</code></li></ul>
<div class="description">

<p>    convert parameters stored in Via to a dictionary</p>
</div></div>
<div class="function">
<h3 id="contact_print/1">contact_print(Contacts) -&gt; [string()]</h3>

<ul class="type">
<li><code>Contacts = [#contact{}]</code></li></ul>
<div class="description">

<p>    Take a list of contact records, and return a list of those
           contacts as strings</p>
</div></div>
<div class="function">
<h3 id="auth_print/1">auth_print(Auth) -&gt; [string()]</h3>


<div class="description">
<p>Equivalent to <a href="#auth_print/2" class="seealso">auth_print(Auth, false)</a>.</p>
</div></div>
<div class="function">
<h3 id="auth_print/2">auth_print(Auth, Stale) -&gt; [string()]</h3>

<ul class="type">
<li><code>Auth = {Realm, Nonce, Opaque}</code></li><li><code>Realm = string()</code></li><li><code>Nonce = string()</code></li><li><code>Opaque = string()</code></li><li><code>Stale = true | false</code></li></ul>
<div class="description">

<p>    Generate the value of an WWW-Authenticate that we need
           when challenging a REGISTER, or a Proxy-Authenticate that
           we put in other challenges of a request.</p>
</div></div>
<div class="function">
<h3 id="auth/1">auth(In) -&gt; dict()</h3>

<ul class="type">
<li><code>In = string()</code></li></ul>
<div class="description">

<p>    Parse an authorization header. Note : In is a string like
           "Digest username=\"test\",realm=\"example.org\" ...", a
           SIP message can have multiple of those header values in
           it. This function only handles one at a time. XXX We
           should preserve the type in the repsonse as well. Define
           a new record for parsed authentication data and use that.</p>
</div></div>
<div class="function">
<h3 id="param_to_dict/1">param_to_dict(Param) -&gt; dict()</h3>

<ul class="type">
<li><code>Param = [string()]</code></li></ul>
<div class="description">

<p>    Convert SIP parameter strings into a dictionary.</p>
</div></div>
<div class="function">
<h3 id="dict_to_param/1">dict_to_param(Dict) -&gt; [string()]</h3>

<ul class="type">
<li><code>Dict = dict()</code></li></ul>
<div class="description">

<p>    convert a dictionary containing parameters back into a
           "name=value" format - the inverse of param_to_dict/1</p>
</div></div>
<div class="function">
<h3 id="httparg/1">httparg(String) -&gt; dict()</h3>


<div class="description">

<p>    Make dict out of parameters separated by ampersand (<code>&</code>).
           Note : Only used in admin_www. Perhaps move there?</p>
</div></div>
<div class="function">
<h3 id="cseq/1">cseq(Header::In) -&gt; {Seq, Method} | {unparseable, String}</h3>

<ul class="type">
<li><code>In = #keylist{} | [string()]</code></li><li><code>Seq = integer()</code></li><li><code>Method = string()</code></li></ul>
<div class="description">

<p>    Parse CSeq: header data.</p>
</div></div>
<div class="function">
<h3 id="cseq_print/2">cseq_print(X1::{Seq, Method}) -&gt; string()</h3>

<ul class="type">
<li><code>Seq = integer()</code></li><li><code>Method = string()</code></li></ul>
<div class="description">

<p>    Print data parsed with cseq/1.</p>
</div></div>
<div class="function">
<h3 id="callid/1">callid(Header) -&gt; string()</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Get Call-Id: from header.</p>
</div></div>
<div class="function">
<h3 id="build_header_binary/1">build_header_binary(Header) -&gt; binary()</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Build a SIP header we can combine with a first line and
           body to create a message to send out on the wire. We try
           to prioritize speed here, so we don't spend extra cycles
           making the resulting data uniformed. We might return a
           list of lists of binaries, or just binaries.</p>
</div></div>
<div class="function">
<h3 id="get_tag/1">get_tag(X1::[String]) -&gt; Tag</h3>

<ul class="type">
<li><code>Tag = string() | none</code></li></ul>
<div class="description">

<p>    Get From- or To-tag from from- or to-header value. Note :
           This function really ought to parse String using
           contact:new() in order to not be fooled by $&gt; appearing
           more than once, tag= not written in lowercase etc.</p>
</div></div>
<div class="function">
<h3 id="dialogid/1">dialogid(Header) -&gt; {CallID, FromTag, ToTag}</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li><li><code>CallId = string()</code></li><li><code>FromTag = string()</code></li><li><code>ToTag = string()</code></li></ul>
<div class="description">

<p>    Get what in RFC3261 is referred to as a dialog ID. This
           will be the same for all requests in a dialog. Note
           though that the ToTag might be 'none' and later get set.</p>
</div></div>
<div class="function">
<h3 id="via_sentby/1">via_sentby(Via) -&gt; {Proto, Host, Port}</h3>

<ul class="type">
<li><code>Via = #via{}</code></li><li><code>Proto = string()</code></li><li><code>Host = string()</code></li><li><code>Port = integer()</code></li></ul>
<div class="description">

<p>    Extract sent-by part of a via record()</p>
</div></div>
<div class="function">
<h3 id="get_server_transaction_id/1">get_server_transaction_id(Request) -&gt; Id</h3>

<ul class="type">
<li><code>Request = #request{}</code></li><li><code>Id = term() | is_2543_ack | error</code></li></ul>
<div class="description">

<p>    Turn a request into a transaction id, that can be stored
           in our transaction state database together with a
           reference to the process handling this request (server
           transaction handler) if this is a new transaction, or
           looked up in the database to find an existing handler if
           this is a resend of the same request or an ACK to a
           non-2xx response to INVITE. This is specified in RFC3261
           #17.2.3 (Matching Requests to Server Transactions).</p>
</div></div>
<div class="function">
<h3 id="get_client_transaction_id/1">get_client_transaction_id(Response) -&gt; Id</h3>

<ul class="type">
<li><code>Response = #response{}</code></li><li><code>Id = term() | error</code></li></ul>
<div class="description">

<p>    When we receive a response, we use this function to get an
           Id which we look up in our transaction state database to
           see if we have a client transaction handler that should
           get this response. This is specified in RFC3261 #17.1.3
           (Matching Responses to Client Transactions).</p>
</div></div>
<div class="function">
<h3 id="get_server_transaction_ack_id_2543/1">get_server_transaction_ack_id_2543(Request) -&gt; Id</h3>

<ul class="type">
<li><code>Request = #request{}</code></li><li><code>Id = term() | error</code></li></ul>
<div class="description">

<p>    When we receive an ACK that has no RFC3261 Via branch
           parameter, we use this function to get an Id that we then
           look up in our transaction state database to try and find
           an existing server transaction that this ACK should be
           delivered to. This is specified in RFC3261 #17.2.3
           (Matching Requests to Server Transactions). Note : When
           using this function, you have to make sure the To-tag of
           this ACK matches the To-tag of the response you think
           this might be the ACK for!
           Note : RFC3261 #17.2.3 relevant text : The ACK request
           matches a transaction if the Request- URI, From tag,
           Call-ID, CSeq number (not the method), and top Via header
           field match those of the INVITE request which created the
           transaction, and the To tag of the ACK matches the To tag
           of the response sent by the server transaction.
           Note : We are supposed to do the comparison of for
           example, the URI, according to the matching rules for
           URIs but that would require us to do a full table scan
           for every ACK. XXX perhaps we should divide the Id into
           two parts - one that is byte-by-byte and used as table
           index, and another part for elements that require more
           exhaustive matching.</p>
</div></div>
<div class="function">
<h3 id="get_via_branch/1">get_via_branch(TopVia) -&gt; Branch</h3>

<ul class="type">
<li><code>Branch = string() | none</code></li></ul>
<div class="description">

<p>    Get the branch from the TopVia parameters, and then remove
           any YXA loop cookie from it. This function should
           typically only be called on a Via that matches this proxy
           so that should be ok - we won't be altering anyone elses
           branches.</p>
</div></div>
<div class="function">
<h3 id="remove_loop_cookie/1">remove_loop_cookie(Branch) -&gt; Branch | NewBranch</h3>

<ul class="type">
<li><code>Branch = string() | none</code></li><li><code>NewBranch = string()</code></li></ul>
<div class="description">

<p>    Removes our special YXA loop cookie from a branch, if it
           really is an YXA generated branch.</p>
</div></div>
<div class="function">
<h3 id="get_via_branch_full/1">get_via_branch_full(Via) -&gt; Branch</h3>

<ul class="type">
<li><code>Via = #via{}</code></li><li><code>Branch = string() | none</code></li></ul>
<div class="description">

<p>    Get the whole Via branch (inclusive any loop cookie) from
           Via.</p>
</div></div>
<div class="function">
<h3 id="via_is_equal/2">via_is_equal(A, B) -&gt; true | false</h3>

<ul class="type">
<li><code>A = #via{}</code></li><li><code>B = #via{}</code></li></ul>
<div class="description">

<p>    Compare two Via records according to the rules in RFC3261
           20.42 (Via)</p>
</div></div>
<div class="function">
<h3 id="via_is_equal/3">via_is_equal(A, B, T::CmpList) -&gt; true | false</h3>

<ul class="type">
<li><code>A = #via{}</code></li><li><code>B = #via{}</code></li><li><code>CmpList = [proto | host | port | parameters]</code></li></ul>
<div class="description">

<p>    Compare one or more parts of two Via records according to
           RFC3261 20.42.</p>
</div></div>
<div class="function">
<h3 id="is_supported/2">is_supported(Extension, Header) -&gt; true | false</h3>

<ul class="type">
<li><code>Extension = string()</code></li><li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Check if Extension appears in a Supported: header.</p>
</div></div>
<div class="function">
<h3 id="is_required/2">is_required(Extension, Header) -&gt; true | false</h3>

<ul class="type">
<li><code>Extension = string()</code></li><li><code>Header = #keylist{}</code></li></ul>
<div class="description">

<p>    Check if Extension appears in a Required: header.</p>
</div></div>
<div class="function">
<h3 id="event_package/1">event_package(Header) -&gt; EventPackage</h3>

<ul class="type">
<li><code>Header = #keylist{}</code></li><li><code>EventPackage = string()</code></li></ul>
<div class="description">

<p>    Get the Event package name from Header.</p>
</div></div></div>

<authors>

<aname>Magnus Ahltorp</aname>
<email>ahltorp@nada.kth.se</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
