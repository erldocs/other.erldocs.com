<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gen_refac (wrangler) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gen_refac</h1>
<h2 class="modsummary">This module defines the gen_refac behaviour.</h2>
<div class="description">
<p>This module defines the <code>gen_refac</code> behaviour. It provides a  
high-level abstraction of the logic work-flow of a refactoring  
process. A user-interactive refactoring  
process in Emacs generally works in the following way : the user first  
selects the focus of interest by either pointing the cursor to a  
particular program entity or by highlighting, then invokes the  
refactoring command; in case that the refactoring needs certain  
initial inputs from the user, it will prompt the user to input  
the values from the mini-buffer. After all these interactions,  
the refactor engine starts the pre-condition checking to  
make sure that performing the refactoring initiated by the user  
will not change the behaviour of the program; the refactorer  
continues to carry out the program transformation if the pre-condition  
passes, otherwise aborts the refactoring process and returns the reason  
for failure.</p>
 
  <p>The idea behind this module is that the user module provides functions
  to handle different parts of the refactoring process that is particular
  to that refactoring, while <code>gen_refac</code> handles the parts that are common  
to all refactorings.</p>
 
  <p>The user module should export:
  </p><pre class="sh_erlang">     input_par_prompts()
       ===&gt; [string()]</pre><p>
   <code>input_par_prompts</code> returns the list of prompt strings to be used when
    the refactorer asks the user for input. There should be one
    prompt string for each input.
  </p><pre class="sh_erlang">     select_focus(Args::#args{})
        ===&gt; none|{ok, term()}|{error, Reason}</pre><p>
   <code>select_pars</code> returns the focus of interest selected by the user.
    This function should return <code>none</code> if no focus selection is needed;
    <code>{error, Reason}</code> if the user didn't select the kind of entity
    expected; or <code>{ok, term()</code> when a valid focus of interest has been
    selected.
   </p><pre class="sh_erlang">      check_pre_cond(Args::#args{})
        ===&gt; ok | {error, Reason}</pre><p>
    This function checks whether the pre-conditions of the refactoring
    hold, and returns <code>ok</code> if the pre-condition checking passes, otherwise
    <code>{error, Reason}</code>.
   </p><pre class="sh_erlang">      selective()
        ===&gt; true | false</pre><p>
    This function should returns <code>true</code> if the user is allowed to browse
    through and select the changes to be made.
  </p><pre class="sh_erlang">     transform(Args::#args())
       ===&gt; {ok, [{{filename(),filename()} syntaxTree()}] | {error, Reason}}</pre><p>
    Function <code>transform</code> carries out the transformation part of the
    refactorings. If the refactoring succeeds, it returns the list of
    file names together with their new AST (only files that have been
    changed need to be returned); otherwise <code>{error, Reason}</code>.</p>
 
  <p>Record <code>args</code> defines the data structure that is passed through, and also modified by, the different phases
  of the refactoring.
   </p><pre class="sh_erlang">      -record(args,{current_file_name :: filename(),         %% the file name of the current Erlang buffer.
                    cursor_pos        :: pos(),              %% the current cursor position.
                    highlight_range   :: {pos(), pos()},     %% the start and end location of the highlighted code if there is any.
                    user_inputs       :: [string()],         %% the data inputted by the user.
                    focus_sel         :: any(),              %% the focus of interest selected by the user.
                    selective         :: boolean(),          %% selective refactoring or not.
                    search_paths      ::[dir()|filename()],  %% the list of directories or files which specify the scope of the project.
                    tabwidth =8        ::integer()           %% the number of white spaces denoted by a tab key.
                   }).</pre>
 
  <p>Some example refactorings implemented using the Wrangler API:
 <item><p>
 <url href="file:refac_swap_function_arguments.erl">Swap arguments of a function;</url>.
 </p></item>
 <item><p>
 <url href="file:refac_remove_an_argument.erl">Remove an argument of a function;</url>.
 </p></item>
 <item><p>
 <url href="file:refac_keysearch_to_keyfind.erl">Replace the uses of lists:keysearch/3 with lists:keyfind/3; </url>
 </p></item>
 <item><p>
 <url href="file:refac_specialise_a_function.erl">Specialise a function definition; </url>
 </p></item>
 <item><p>
 <url href="file:refac_apply_to_remote_call.erl">Apply to remote function call; </url>
 </p></item>
 <item><p>
 <url href="file:refac_add_an_import_attribute.erl">Introduce an import attribute; </url>
 </p></item>
 <item><p>
 <url href="file:refac_remove_an_import_attribute.erl">Remove an import attribute;</url>
 </p></item>
 <item><p>
 <url href="file:refac_batch_rename_fun.erl">Batch renaming of function names from camelCaseto camel_case. </url>
 </p></item>
 <item><p>
 <url href="file:inspec_examples.erl">A collection of code inspectors written using the Wrangler API. </url>
 </p></item></p>
 
  <p><em><marker id="How_to_apply_an_own-defined_refactoring">How to apply an own-defined refactoring</marker></em></p><p>
  To invoke a user's own-defined <code>gen_refac</code> refactoring, select menu item Wrangler -&gt; Refactor -&gt; Apply Adhoc Refactoring,  
Wrangler will then prompt you to input the name of the callback module, and the values for parameters needed by the  
refactoring.</p>
 
  <p><em><marker id="How_to_add_an_own-defined_refactoring_to_the_menu">How to add an own-defined refactoring to the menu</marker></em>
  To add a user-defined <code>gen_refac</code> refactoring to the <code>My gen_refac Refacs</code> menu, set the file buffer implementing the
  refactoring as the current buffer, then select Wrangler -&gt; Refactor -&gt; Add to My gen_refac Refacs.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-dir">dir() = string()</h3></div>
    <div class="type"><h3 id="type-filename">filename() = string()</h3></div>
    <div class="type"><h3 id="type-pos">pos() = {integer(), integer()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="run_refac/1">run_refac(Module::module() | string() | tuple(), Args::[term()]) -&gt; {ok, string()} | {change_set, [{string(), string()}], module(), #args{current_file_name=undefined | filename(), cursor_pos=undefined | pos(), highlight_range=undefined | {pos(), pos()}, user_inputs=undefined | [string()], focus_sel=undefined | any(), selective=undefined | boolean(), search_paths=undefined | [dir() | filename()], tabwidth=integer()}} | {error, term()}</h3>


<div class="description">

<p>The interface function for invoking a refactoring defined
  in module <code>ModName</code>.</p>
</div></div></div>

<authors>

<aname>Huiqing Li</aname>
<email>H.Li@kent.ac.uk</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
