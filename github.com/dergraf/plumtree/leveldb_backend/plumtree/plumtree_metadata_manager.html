<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>plumtree_metadata_manager (plumtree) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>plumtree_metadata_manager</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-metadata_broadcast">metadata_broadcast() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#metadata_broadcast{pkey = undefined | <a href="#type-metadata_pkey" class="seealso">metadata_pkey()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj = undefined | <a href="#type-metadata_object" class="seealso">metadata_object()</a>}</h3></div>
    <div class="type"><h3 id="type-metadata_context">metadata_context() = <a href="dvvset.html#type-vector" class="seealso">dvvset:vector()</a></h3></div>
    <div class="type"><h3 id="type-metadata_iterator">metadata_iterator()</h3></div>
    <div class="type"><h3 id="type-metadata_key">metadata_key() = any()</h3></div>
    <div class="type"><h3 id="type-metadata_keymatch">metadata_keymatch() = fun((<a href="#type-metadata_key" class="seealso">metadata_key()</a>) -> boolean())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| undefined</h3></div>
    <div class="type"><h3 id="type-metadata_modifier">metadata_modifier() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun(([<a href="#type-metadata_value" class="seealso">metadata_value()</a> | <a href="#type-metadata_tombstone" class="seealso">metadata_tombstone()</a>] | undefined) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-metadata_value" class="seealso">metadata_value()</a>)</h3></div>
    <div class="type"><h3 id="type-metadata_object">metadata_object() = {metadata, <a href="dvvset.html#type-clock" class="seealso">dvvset:clock()</a>}</h3></div>
    <div class="type"><h3 id="type-metadata_pkey">metadata_pkey() = {<a href="#type-metadata_prefix" class="seealso">metadata_prefix()</a>, <a href="#type-metadata_key" class="seealso">metadata_key()</a>}</h3></div>
    <div class="type"><h3 id="type-metadata_prefix">metadata_prefix() = {binary() | atom(), binary() | atom()}</h3></div>
    <div class="type"><h3 id="type-metadata_tombstone">metadata_tombstone() = '$deleted'</h3></div>
    <div class="type"><h3 id="type-metadata_value">metadata_value() = any()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, pid()} | ignore | {error, term()}</h3>


<div class="description">

<p>Same as start_link([]).</p>
</div></div>
<div class="function">
<h3 id="get/1">get(PKey::metadata_pkey()) -&gt; metadata_object() | undefined</h3>


<div class="description">

<p>Reads the value for a prefixed key. If the value does not exist <code>undefined</code> is
  returned. otherwise a Dotted Version Vector Set is returned. When reading the value
  for a subsequent call to put/3 the context can be obtained using
  plumtree_metadata_object:context/1. Values can obtained w/ plumtree_metadata_object:values/1.</p>
</div></div>
<div class="function">
<h3 id="get/1-1">get(Node::node(), PKey::metadata_pkey()) -&gt; metadata_object() | undefined</h3>


<div class="description">

<p>Same as get/1 but reads the value from <code>Node</code></p>
</div></div>
<div class="function">
<h3 id="size/1">size(FullPrefix::metadata_prefix()) -&gt; integer()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(FullPrefix::metadata_prefix()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(FullPrefix::metadata_prefix()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="iterator/0">iterator() -&gt; metadata_iterator()</h3>


<div class="description">

<p>Returns a full-prefix iterator: an iterator for all full-prefixes that have keys stored under them
  When done with the iterator, iterator_close/1 must be called</p>
</div></div>
<div class="function">
<h3 id="iterator/1">iterator(FullPrefix::binary() | atom() | metadata_prefix()) -&gt; metadata_iterator()</h3>


<div class="description">

<p>Returns a sub-prefix iterator for a given prefix.
  When done with the iterator, iterator_close/1 must be called</p>
</div></div>
<div class="function">
<h3 id="iterator/1-1">iterator(FullPrefix::metadata_prefix(), KeyMatch::metadata_keymatch()) -&gt; metadata_iterator()</h3>


<div class="description">

<p>Return an iterator for keys stored under a prefix. If KeyMatch is undefined then  
all keys will may be visted by the iterator. Otherwise only keys matching KeyMatch will be  
visited.</p>
 
  <p>KeyMatch has to be a function taking the key as parameter  
and returns either true or false, this can be used to iterate  
over some subset of keys</p>
 
  <p>When done with the iterator, iterator_close/1 must be called</p>
</div></div>
<div class="function">
<h3 id="remote_iterator/1">remote_iterator(Node::node()) -&gt; metadata_iterator()</h3>


<div class="description">

<p>Create an iterator on <code>Node</code>. This allows for remote iteration by having
  he iterator created iterates all full-prefixes. Once create the rest of the
  iterator API may be used as usual. When done with the iterator, iterator_close/1
  must be called</p>
</div></div>
<div class="function">
<h3 id="remote_iterator/1-1">remote_iterator(Node::node(), Prefix::metadata_prefix() | binary() | atom() | undefined) -&gt; metadata_iterator()</h3>


<div class="description">

<p>Create an iterator on <code>Node</code>. When <code>Perfix</code> is not a full prefix,
  the iterator created iterates all sub-prefixes under <code>Prefix</code>. Otherse,
  the iterator iterates all keys under a prefix. Once created the rest of the
  iterator API may be used as usual. When done with the iterator,
  iterator_close/1 must be called</p>
</div></div>
<div class="function">
<h3 id="iterate/1">iterate(Iterator::metadata_iterator()) -&gt; metadata_iterator()</h3>


<div class="description">

<p>advance the iterator by one key, full-prefix or sub-prefix</p>
</div></div>
<div class="function">
<h3 id="iterator_prefix/1">iterator_prefix(Metadata_iterator::metadata_iterator()) -&gt; metadata_prefix() | undefined | binary() | atom()</h3>


<div class="description">

<p>return the full-prefix or prefix being iterated by this iterator. If the iterator is a
  full-prefix iterator undefined is returned.</p>
</div></div>
<div class="function">
<h3 id="iterator_value/1">iterator_value(Metadata_iterator::metadata_iterator()) -&gt; {metadata_key(), metadata_object()} | metadata_prefix() | binary() | atom()</h3>


<div class="description">

<p>return the key and object or the prefix pointed to by the iterator</p>
</div></div>
<div class="function">
<h3 id="iterator_done/1">iterator_done(Metadata_iterator::metadata_iterator()) -&gt; boolean()</h3>


<div class="description">

<p>returns true if there are no more keys or prefixes to iterate over</p>
</div></div>
<div class="function">
<h3 id="iterator_close/1">iterator_close(Metadata_iterator::metadata_iterator()) -&gt; ok</h3>


<div class="description">

<p>Closes the iterator. This function must be called on all open iterators</p>
</div></div>
<div class="function">
<h3 id="put/1">put(PKey::metadata_pkey(), Context::metadata_context() | undefined, ValueOrFun::metadata_value() | metadata_modifier()) -&gt; metadata_object()</h3>


<div class="description">

<p>Sets the value of a prefixed key. The most recently read context (see get/1)
  should be passed as the second argument to prevent unneccessary siblings.</p>
</div></div>
<div class="function">
<h3 id="merge/1">merge(Node::node(), X2::{metadata_pkey(), undefined | metadata_context()}, Obj::metadata_object()) -&gt; boolean()</h3>


<div class="description">

<p>same as merge/2 but merges the object on <code>Node</code></p>
</div></div>
<div class="function">
<h3 id="broadcast_data/1">broadcast_data(Metadata_broadcast::metadata_broadcast()) -&gt; {{metadata_pkey(), metadata_context()}, metadata_object()}</h3>


<div class="description">

<p>Deconstructs are broadcast that is sent using <code>plumtree_metadata_manager</code> as the
  handling module returning the message id and payload.</p>
</div></div>
<div class="function">
<h3 id="merge/1-1">merge(X1::{metadata_pkey(), undefined | metadata_context()}, Obj::undefined | metadata_object()) -&gt; boolean()</h3>


<div class="description">

<p>Merges a remote copy of a metadata record sent via broadcast w/ the local view
  for the key contained in the message id. If the remote copy is causally older than
  the current data stored then <code>false</code> is returned and no updates are merged. Otherwise,
  the remote copy is merged (possibly generating siblings) and <code>true</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="is_stale/1">is_stale(X1::{metadata_pkey(), metadata_context()}) -&gt; boolean()</h3>


<div class="description">

<p>Returns false if the update (or a causally newer update) has already been
  received (stored locally).</p>
</div></div>
<div class="function">
<h3 id="graft/1">graft(X1::{metadata_pkey(), metadata_context()}) -&gt; stale | {ok, metadata_object()} | {error, term()}</h3>


<div class="description">

<p>returns the object associated with the given key and context (message id) if
  the currently stored version has an equal context. otherwise stale is returned.
  because it assumed that a grafted context can only be causally older than the local view
  a stale response means there is another message that subsumes the grafted one</p>
</div></div>
<div class="function">
<h3 id="exchange/1">exchange(Peer::node()) -&gt; {ok, pid()} | {error, term()}</h3>


<div class="description">

<p>Trigger an exchange</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
