<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>plumtree_metadata (plumtree) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>plumtree_metadata</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-delete_opts">delete_opts() = []</h3></div>
    <div class="type"><h3 id="type-fold_opts">fold_opts() = <a href="#type-it_opts" class="seealso">it_opts()</a></h3></div>
    <div class="type"><h3 id="type-get_opt">get_opt() = <a href="#type-get_opt_default_val" class="seealso">get_opt_default_val()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-get_opt_resolver" class="seealso">get_opt_resolver()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-get_opt_allow_put" class="seealso">get_opt_allow_put()</a></h3></div>
    <div class="type"><h3 id="type-get_opt_allow_put">get_opt_allow_put() = {allow_put, boolean()}</h3></div>
    <div class="type"><h3 id="type-get_opt_default_val">get_opt_default_val() = {default, <a href="#type-metadata_value" class="seealso">metadata_value()</a>}</h3></div>
    <div class="type"><h3 id="type-get_opt_resolver">get_opt_resolver() = {resolver, <a href="#type-metadata_resolver" class="seealso">metadata_resolver()</a>}</h3></div>
    <div class="type"><h3 id="type-get_opts">get_opts() = [<a href="#type-get_opt" class="seealso">get_opt()</a>]</h3></div>
    <div class="type"><h3 id="type-it_opt">it_opt() = <a href="#type-it_opt_resolver" class="seealso">it_opt_resolver()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-it_opt_default" class="seealso">it_opt_default()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-it_opt_keymatch" class="seealso">it_opt_keymatch()</a></h3></div>
    <div class="type"><h3 id="type-it_opt_default">it_opt_default() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{default, <a href="#type-metadata_value" class="seealso">metadata_value()</a> | <a href="#type-it_opt_default_fun" class="seealso">it_opt_default_fun()</a>}</h3></div>
    <div class="type"><h3 id="type-it_opt_default_fun">it_opt_default_fun() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun((<a href="#type-metadata_key" class="seealso">metadata_key()</a>) -> <a href="#type-metadata_value" class="seealso">metadata_value()</a>)</h3></div>
    <div class="type"><h3 id="type-it_opt_keymatch">it_opt_keymatch() = {match, term()}</h3></div>
    <div class="type"><h3 id="type-it_opt_resolver">it_opt_resolver() = {resolver, <a href="#type-metadata_resolver" class="seealso">metadata_resolver()</a> | lww}</h3></div>
    <div class="type"><h3 id="type-it_opts">it_opts() = [<a href="#type-it_opt" class="seealso">it_opt()</a>]</h3></div>
    <div class="type"><h3 id="type-iterator">iterator() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<a href="plumtree_metadata_manager.html#type-metadata_iterator" class="seealso">plumtree_metadata_manager:metadata_iterator()</a>, <a href="#type-it_opts" class="seealso">it_opts()</a>}</h3></div>
    <div class="type"><h3 id="type-metadata_key">metadata_key() = any()</h3></div>
    <div class="type"><h3 id="type-metadata_modifier">metadata_modifier() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun(([<a href="#type-metadata_value" class="seealso">metadata_value()</a> | <a href="#type-metadata_tombstone" class="seealso">metadata_tombstone()</a>] | undefined) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-metadata_value" class="seealso">metadata_value()</a>)</h3></div>
    <div class="type"><h3 id="type-metadata_prefix">metadata_prefix() = {binary() | atom(), binary() | atom()}</h3></div>
    <div class="type"><h3 id="type-metadata_resolver">metadata_resolver() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun((<a href="#type-metadata_value" class="seealso">metadata_value()</a> | <a href="#type-metadata_tombstone" class="seealso">metadata_tombstone()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-metadata_value" class="seealso">metadata_value()</a> | <a href="#type-metadata_tombstone" class="seealso">metadata_tombstone()</a>) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#type-metadata_value" class="seealso">metadata_value()</a>)</h3></div>
    <div class="type"><h3 id="type-metadata_tombstone">metadata_tombstone() = '$deleted'</h3></div>
    <div class="type"><h3 id="type-metadata_value">metadata_value() = any()</h3></div>
    <div class="type"><h3 id="type-put_opts">put_opts() = []</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="get/1">get(FullPrefix::metadata_prefix(), Key::metadata_key()) -&gt; metadata_value() | undefined</h3>


<div class="description">

<p>same as get(FullPrefix, Key, [])</p>
</div></div>
<div class="function">
<h3 id="get/1-1">get(FullPrefix::metadata_prefix(), Key::metadata_key(), Opts::get_opts()) -&gt; metadata_value()</h3>


<div class="description">

<p>Retrieves the local value stored at the given prefix and key.</p>
 
  <p>get/3 can take the following options:
   * default: value to return if no value is found, <code>undefined</code> if not given.
   * resolver:  A function that resolves conflicts if they are encountered. If not given
                last-write-wins is used to resolve the conflicts
   * allow_put: whether or not to write and broadcast a resolved value. defaults to <code>true</code>.</p>
 
  <p>NOTE: an update will be broadcast if conflicts are resolved and
  <code>allow_put</code> is <code>true</code>. any further conflicts generated by
  concurrenct writes during resolution are not resolved</p>
</div></div>
<div class="function">
<h3 id="fold/1">fold(Fun::({metadata_key(), [metadata_value() | metadata_tombstone()] | metadata_value() | metadata_tombstone()}, any()) -&gt; any(), Acc0::any(), FullPrefix::metadata_prefix()) -&gt; any()</h3>


<div class="description">

<p>same as fold(Fun, Acc0, FullPrefix, []).</p>
</div></div>
<div class="function">
<h3 id="fold/1-1">fold(Fun::({metadata_key(), [metadata_value() | metadata_tombstone()] | metadata_value() | metadata_tombstone()}, any()) -&gt; any(), Acc0::any(), FullPrefix::metadata_prefix(), Opts::fold_opts()) -&gt; any()</h3>


<div class="description">

<p>Fold over all keys and values stored under a given prefix/subprefix. Available
  options are the same as those provided to iterator/2.</p>
</div></div>
<div class="function">
<h3 id="to_list/1">to_list(FullPrefix::metadata_prefix()) -&gt; [{metadata_key(), [metadata_value() | metadata_tombstone()] | metadata_value() | metadata_tombstone()}]</h3>


<div class="description">

<p>same as to_list(FullPrefix, [])</p>
</div></div>
<div class="function">
<h3 id="to_list/1-1">to_list(FullPrefix::metadata_prefix(), Opts::fold_opts()) -&gt; [{metadata_key(), [metadata_value() | metadata_tombstone()] | metadata_value() | metadata_tombstone()}]</h3>


<div class="description">

<p>Return a list of all keys and values stored under a given prefix/subprefix. Available
  options are the same as those provided to iterator/2.</p>
</div></div>
<div class="function">
<h3 id="iterator/1">iterator(FullPrefix::metadata_prefix()) -&gt; iterator()</h3>


<div class="description">

<p>same as iterator(FullPrefix, []).</p>
</div></div>
<div class="function">
<h3 id="iterator/1-1">iterator(FullPrefix::metadata_prefix(), Opts::it_opts()) -&gt; iterator()</h3>


<div class="description">

<p>Return an iterator pointing to the first key stored under a prefix</p>
 
  <p>iterator/2 can take the following options:
    * resolver: either the atom <code>lww</code> or a function that resolves conflicts if they
                are encounted (see get/3 for more details). Conflict resolution
                is performed when values are retrieved (see itr_value/1 and itr_key_values/1).
                If no resolver is provided no resolution is performed. The default is to
                not provide a resolver.
    * allow_put: whether or not to write and broadcast a resolved value. defaults to <code>true</code>.
    * default: Used when the value an iterator points to is a tombstone. default is
               either an arity-1 function or a value. If a function, the key the iterator
               points to is passed as the argument and the result is returned in place
               of the tombstone. If default is a value, the value is returned in place of
               the tombstone. This applies when using functions such as itr_values/1 and
               itr_key_values/1.
    * match: A tuple containing erlang terms and '_'s. Match can be used to iterate
             over a subset of keys -- assuming the keys stored are tuples</p>
</div></div>
<div class="function">
<h3 id="itr_next/1">itr_next(X1::iterator()) -&gt; iterator()</h3>


<div class="description">

<p>Advances the iterator</p>
</div></div>
<div class="function">
<h3 id="itr_close/1">itr_close(X1::iterator()) -&gt; ok</h3>


<div class="description">

<p>Closes the iterator</p>
</div></div>
<div class="function">
<h3 id="itr_done/1">itr_done(X1::iterator()) -&gt; boolean()</h3>


<div class="description">

<p>Returns true if there is nothing more to iterate over</p>
</div></div>
<div class="function">
<h3 id="itr_key_values/1">itr_key_values(X1::iterator()) -&gt; {metadata_key(), [metadata_value() | metadata_tombstone()] | metadata_value() | metadata_tombstone()}</h3>


<div class="description">

<p>Return the key and value(s) pointed at by the iterator. Before
  calling this function, check the iterator is not complete w/ itr_done/1. If a resolver
  was passed to iterator/0 when creating the given iterator, siblings will be resolved
  using the given function or last-write-wins (if <code>lww</code> is passed as the resolver). If
  no resolver was used then no conflict resolution will take place. If conflicts are
  resolved, the resolved value is written to local metadata and a broadcast is submitted
  to update other nodes in the cluster if <code>allow_put</code> is <code>true</code>. If <code>allow_put</code> is <code>false</code>  
the values are resolved but are not written or broadcast. A single value is returned as the second  
element of the tuple in the case values are resolved. If no resolution takes place then a list of  
values will be returned as the second element (even if there is only a single sibling).</p>
 
  <p>NOTE: if resolution may be performed this function must be called at most once
  before calling itr_next/1 on the iterator (at which point the function can be called
  once more).</p>
</div></div>
<div class="function">
<h3 id="itr_key/1">itr_key(X1::iterator()) -&gt; metadata_key()</h3>


<div class="description">

<p>Return the key pointed at by the iterator. Before
  calling this function, check the iterator is not complete w/ itr_done/1.
  No conflict resolution will be performed as a result of calling this function.</p>
</div></div>
<div class="function">
<h3 id="itr_values/1">itr_values(X1::iterator()) -&gt; [metadata_value() | metadata_tombstone()]</h3>


<div class="description">

<p>Return all sibling values pointed at by the iterator. Before
  calling this function, check the iterator is not complete w/ itr_done/1.
  No conflict resolution will be performed as a result of calling this function.</p>
</div></div>
<div class="function">
<h3 id="itr_value/1">itr_value(X1::iterator()) -&gt; metadata_value() | metadata_tombstone() | {error, conflict}</h3>


<div class="description">

<p>Return a single value pointed at by the iterator. If there are conflicts and
  a resolver was specified in the options when creating this iterator, they will be
  resolved. Otherwise, and error is returned. If conflicts are resolved, the resolved
  value is written locally and a broadcast is performed to update other nodes
  in the cluster if <code>allow_put</code> is <code>true</code> (the default value). If <code>allow_put</code> is <code>false</code>,  
values are resolved but not written or broadcast.</p>
 
  <p>NOTE: if resolution may be performed this function must be called at most once
  before calling itr_next/1 on the iterator (at which point the function can be called
  once more).</p>
</div></div>
<div class="function">
<h3 id="itr_default/1">itr_default(It::iterator()) -&gt; metadata_tombstone() | metadata_value() | it_opt_default_fun()</h3>


<div class="description">

<p>Returns the value returned when an iterator points to a tombstone. If the default
  used when creating the given iterator is a function it will be applied to the current
  key the iterator points at. If no default was provided the tombstone value was returned.
  This function should only be called after checking itr_done/1.</p>
</div></div>
<div class="function">
<h3 id="prefix_hash/1">prefix_hash(Prefix::metadata_prefix() | binary() | atom()) -&gt; binary() | undefined</h3>


<div class="description">

<p>Return the local hash associated with a full-prefix or prefix. The hash value is
  updated periodically and does not always reflect the most recent value. This function
  can be used to determine when keys stored under a full-prefix or prefix have changed.
  If the tree has not yet been updated or there are no keys stored the given
  (full-)prefix. <code>undefined</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="put/1">put(FullPrefix::metadata_prefix(), Key::metadata_key(), ValueOrFun::metadata_value() | metadata_modifier()) -&gt; ok</h3>


<div class="description">

<p>same as put(FullPrefix, Key, Value, [])</p>
</div></div>
<div class="function">
<h3 id="put/1-1">put(FullPrefix::metadata_prefix(), Key::metadata_key(), ValueOrFun::metadata_value() | metadata_modifier(), Opts::put_opts()) -&gt; ok</h3>


<div class="description">

<p>Stores or updates the value at the given prefix and key locally and then  
triggers a broadcast to notify other nodes in the cluster. Currently, there  
are no put options</p>
 
  <p>NOTE: because the third argument to this function can be a metadata_modifier(),
  used to resolve conflicts on write, metadata values cannot be functions.
  To store functions in metadata wrap them in another type like a tuple.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(FullPrefix::metadata_prefix(), Key::metadata_key()) -&gt; ok</h3>


<div class="description">

<p>same as delete(FullPrefix, Key, [])</p>
</div></div>
<div class="function">
<h3 id="delete/1-1">delete(FullPrefix::metadata_prefix(), Key::metadata_key(), Opts::delete_opts()) -&gt; ok</h3>


<div class="description">

<p>Removes the value associated with the given prefix and key locally and then  
triggers a broradcast to notify other nodes in the cluster. Currently there are  
no delete options</p>
 
  <p>NOTE: currently deletion is logical and no GC is performed.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
