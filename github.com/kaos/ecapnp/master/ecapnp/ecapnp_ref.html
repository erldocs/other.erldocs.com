<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ecapnp_ref (ecapnp) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>ecapnp_ref</h1>
<h2 class="modsummary">Read/Write/Allocate references.</h2>
<div class="description">
<p>Read/Write/Allocate references.</p>
 
  <p>Everything reference.
  Which is almost everything in Cap'n Proto :p.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-ref">ref() = <a href="ecapnp.html#type-ref" class="seealso">ecapnp:ref()</a></h3></div>
    <div class="type"><h3 id="type-ref_kind">ref_kind() = <a href="ecapnp.html#type-ref_kind" class="seealso">ecapnp:ref_kind()</a></h3></div>
    <div class="type"><h3 id="type-segment_id">segment_id() = <a href="ecapnp.html#type-segment_id" class="seealso">ecapnp:segment_id()</a></h3></div>
    <div class="type"><h3 id="type-word_count">word_count() = <a href="ecapnp.html#type-word_count" class="seealso">ecapnp:word_count()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="alloc/1">alloc(SegmentId::segment_id(), Size::integer(), Builder::pid()) -&gt; ref()</h3>


<div class="description">

<p>Allocate data for a reference.</p>
 
  <p>The allocated data is left empty.</p>
</div></div>
<div class="function">
<h3 id="alloc/1-1">alloc(Kind::ref_kind(), SegmentId::segment_id(), Size::integer(), Builder::pid()) -&gt; ref()</h3>


<div class="description">

<p>Allocate data for a reference of a specific kind.</p>
 
  <p>The reference will be written to the first word of the allocated
  data, by <a href="#set/2" class="seealso">set/2</a>.
 </p>
<p><em>See also:</em> <a href="#alloc/3" class="seealso">alloc/3</a>, <a href="#set/2" class="seealso">set/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set/2">set(Kind, Ref) -&gt; term()
</h3>


<div class="description">

<p>Set reference kind.</p>
 
  <p>Updates the reference kind and writes it to the segment data at
  <code>Ref.pos</code>.
 </p>
<p><em>See also:</em> <a href="#alloc/4" class="seealso">alloc/4</a>.</p>
</div></div>
<div class="function">
<h3 id="get/1">get(SegmentId::segment_id(), Pos::integer(), Data::pid() | binary()) -&gt; ref()</h3>


<div class="description">

<p>Get reference from segment data.</p>
 
  <p>Read segment, and parse it for a reference pointer.</p>
 
  <p>Will follow far pointers.
 </p>
<p><em>See also:</em> <a href="#get/4" class="seealso">get/4</a>.</p>
</div></div>
<div class="function">
<h3 id="get/1-1">get(SegmentId::segment_id(), Pos::integer(), Data::pid() | binary(), FollowFar::boolean()) -&gt; ref()</h3>


<div class="description">

<p>Get reference from segment data.</p>
 
  <p>Read segment, and parse it for a reference pointer.</p>
 
  <p>The resulting reference may be a far pointer, unless <code>FollowFar</code> is <code>true</code>.
 </p>
<p><em>See also:</em> <a href="#read_segment/5" class="seealso">read_segment/5</a>, <a href="/home/pete/wefwefwef/docs/other/9865547026/repo/master/.xml/ecapnp/./ecapnp_data.xml.html#get_segment/4" class="seealso">ecapnp_data:get_segment/4</a>.</p>
</div></div>
<div class="function">
<h3 id="refresh/1">refresh(Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Reread reference from message.</p>
</div></div>
<div class="function">
<h3 id="ptr/1">ptr(Idx::integer(), Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Get indexed reference (unintialized).</p>
 
  <p>NOTICE: That by 'uninitialized', the returned reference is a null  
reference, regardless of what data currently is in the segment.</p>
 
  <p>That is, for structs, get a reference for pointer <code>Idx</code>, while for
  lists, get a reference for the element at <code>Idx</code> (either a pointer
  or a "unpositioned" ref pointing to where a inlineComposite element
  holds its data).</p>
</div></div>
<div class="function">
<h3 id="read_struct_data/1">read_struct_data(Align::integer(), Len::integer(), Ref::ref()) -&gt; binary()</h3>


<div class="description">

<p>Read from data section of a struct ref.</p>
 
  <p><code>Align</code> is number of bits into the data section to read from, and
  <code>Len</code> is number of bits to read.</p>
</div></div>
<div class="function">
<h3 id="read_struct_data/1-1">read_struct_data(FAlign::integer(), Len::integer(), Ref::ref(), Default::any()) -&gt; binary() | any()</h3>


<div class="description">

<p>Read from data section of a struct ref.</p>
 
  <p><code>Align</code> is number of bits into the data section to read from, and
  <code>Len</code> is number of bits to read.</p>
</div></div>
<div class="function">
<h3 id="read_struct_ptr/1">read_struct_ptr(Idx::integer(), Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Read a refeference from the pointer section of struct ref.</p>
</div></div>
<div class="function">
<h3 id="read_struct_ptr/1-1">read_struct_ptr(Idx::integer(), Ref::ref(), Default::any()) -&gt; ref() | any()</h3>


<div class="description">

<p>Read a refeference from the pointer section of struct ref.</p>
</div></div>
<div class="function">
<h3 id="read_list/1">read_list(Ref::ref()) -&gt; [ref()] | [binary()]</h3>


<div class="description">

<p>Read elements from a list ref.</p>
</div></div>
<div class="function">
<h3 id="read_list/1-1">read_list(Ref::ref(), Default::any()) -&gt; [ref()] | [binary()] | any()</h3>


<div class="description">

<p>Read elements from a list ref.</p>
</div></div>
<div class="function">
<h3 id="read_list_refs/3">read_list_refs(Ref, ElementRefKind, Default) -&gt; term()
</h3>


<div class="description">

<p>Read elements from a list ref, forcing the result into a list of refs.</p>
</div></div>
<div class="function">
<h3 id="read_text/1">read_text(Ref::ref()) -&gt; binary()</h3>


<div class="description">

<p>Read text.</p>
 
  <p>NOTICE: The required trailing <code>NULL</code> byte is silently dropped when
  reading the text.</p>
</div></div>
<div class="function">
<h3 id="read_text/1-1">read_text(Ref::ref(), Default::any()) -&gt; binary() | any()</h3>


<div class="description">

<p>Read text.</p>
 
  <p>NOTICE: The required trailing <code>NULL</code> byte is silently dropped when
  reading the text.</p>
</div></div>
<div class="function">
<h3 id="read_data/1">read_data(Ref::ref()) -&gt; binary()</h3>


<div class="description">

<p>Read data.</p>
</div></div>
<div class="function">
<h3 id="read_data/1-1">read_data(Ref::ref(), Default::any()) -&gt; binary() | any()</h3>


<div class="description">

<p>Read data.</p>
</div></div>
<div class="function">
<h3 id="write_struct_data/1">write_struct_data(FAlign::integer(), Len::integer(), Value::binary(), Ref::ref()) -&gt; ok</h3>


<div class="description">

<p>Write to struct data section.</p>
</div></div>
<div class="function">
<h3 id="write_struct_ptr/1">write_struct_ptr(Ptr::ref(), Ref::ref()) -&gt; ok</h3>


<div class="description">

<p>Write pointer reference.</p>
 
  <p><code>Ptr</code> must be a pointer from <code>Ref</code> (i.e. the pointer is within the
  data bounds of the reference).</p>
</div></div>
<div class="function">
<h3 id="write_text/1">write_text(Text::binary(), Ptr::ref(), Ref::ref()) -&gt; ok</h3>


<div class="description">

<p>Write text.</p>
 
  <p>Allocates data for <code>Text</code> and updates the <code>Ptr</code> in <code>Ref</code> to point  
to the newly allocated (and updated) data.</p>
 
  <p>NOTICE: An additional <code>NULL</code> byte is appended to <code>Text</code> to stay
  conformant with Cap'n Proto specifications.</p>
</div></div>
<div class="function">
<h3 id="write_data/1">write_data(Data::binary(), Ptr::ref(), Ref::ref()) -&gt; ok</h3>


<div class="description">

<p>Write data.</p>
 
  <p>Allocates data for <code>Data</code> and updates the <code>Ptr</code> in <code>Ref</code> to point
  to the newly allocated (and updated) data.</p>
</div></div>
<div class="function">
<h3 id="alloc_data/1">alloc_data(Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Allocate data for reference.</p>
 
  <p>The number of words allocated is deduced from the passed <code>Ref</code>erence.</p>
 
  <p>Returns an updated reference with the offset field updated to point
  at the newly allocated data.</p>
</div></div>
<div class="function">
<h3 id="alloc_data/1-1">alloc_data(Size::word_count(), Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Allocate data for reference.</p>
</div></div>
<div class="function">
<h3 id="alloc_list/1">alloc_list(Idx::integer(), List_ref::ref_kind(), Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Allocate data for list.</p>
 
  <p><code>Kind</code> should be a <code>#list_ref{}</code> describing the list to
  allocate; but for <code>inlineComposite</code> lists, the <code>#list_ref.size</code>
  field should point to a <code>#struct_ref{}</code> describing the list element
  type, and <code>#list_ref.count</code> should still be the number of elements
  rather than the total word count.
 </p>
<p><em>See also:</em> <a href="#alloc_data/1" class="seealso">alloc_data/1</a>.</p>
</div></div>
<div class="function">
<h3 id="write_list/1">write_list(Idx::integer(), ElementIdx::integer(), Value::binary(), Ref::ref()) -&gt; ok</h3>


<div class="description">

<p>Write list element.</p>
</div></div>
<div class="function">
<h3 id="follow_far/1">follow_far(Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Resolve a far pointer.</p>
 
  <p>Usually this is done automatically when reading ref's.</p>
</div></div>
<div class="function">
<h3 id="copy/1">copy(Ref::ref()) -&gt; binary()</h3>


<div class="description">

<p>Make a deep copy of a reference.</p>
 
  <p>Recursively follows all pointers and copies them as well. So
  copying a root object will effectively defragment a fragmented
  message.</p>
</div></div>
<div class="function">
<h3 id="paste/1">paste(X1::binary(), Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Allocate space and write data for reference.</p>
 
  <p>All data, both data section and pointers section, and any data that  
those may refer to (good for saving off a deep copy of another  
object).</p>
 
  <p>Note: <code>Data</code> should be whole words (8 bytes). Any fraction of a
  word will be truncated.</p>
</div></div>
<div class="function">
<h3 id="null_ref/1">null_ref(Ref::ref()) -&gt; ref()</h3>


<div class="description">

<p>Get a null pointer.</p>
 
  <p>The up-side with this function in contrast to using a default
  <code>#ref{}</code> record on its own is that the null reference returned by
  this function knows about the schema and segment data of the
  message for which it was based.</p>
</div></div>
<div class="function">
<h3 id="create_ptr/2">create_ptr(Offset, Ref) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Andreas Stenius</aname>
<email>kaos@astekk.se</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
