<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>erlydb_base (erl4db) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>erlydb_base</h1>
<h2 class="modsummary">erlydb_base is the base module that all modules that ErlyDB generates  
extend.</h2>
<div class="description">
<p>erlydb_base is the base module that all modules that ErlyDB generates  
extend.</p>
 
  <p>Generated modules inherit many of erlydb_base's exported functions  
directly, but some of the functions in erlydb_base undergo  
changes before they attain their final forms the generated modules.  
For an exact description of how each function in  
erlydb_base is used in generated modules, refer to the function's  
documentation.</p>
 
  <p>You can override some of the default code generation behavior by  
providing your own implementations for some of erlydb_base's functions in  
generated modules.  
This is useful for telling ErlyDB about relations (one-to-many  
and many-to-many) and mappings between Erlang modules and database tables  
and fields.</p>
 
  <p>Starting from ErlyWeb 0.6, you can add arbitrary metadata to database
  fields as well as define specific fields to be read-only.
  For more information, see <a href="#fields/0" class="seealso">fields/0</a>.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-extras_expr">extras_expr()</h3></div>
    <div class="type"><h3 id="type-record">record()</h3></div>
    <div class="type"><h3 id="type-where_expr">where_expr()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="relations/0">relations() -&gt; [{one_to_many, [atom()]} | {many_to_many, [atom()]}]</h3>


<div class="description">

<p>Return the list of relations of the module. By overriding the function,
    you can tell ErlyDB what relations the module has. Possible relations
    are {one_to_many, [atom()]} and {many_to_many, [atom()]}. This function
    returns a list of such relations.
 </p>
</div></div>
<div class="function">
<h3 id="fields/0">fields() -&gt; '*' | [atom()]</h3>


<div class="description">

<p>Return the list of fields that ErlyDB should use for the module.  
You can override this function to specify which  
database fields from the table besides the id field should be exposed  
to records from the module.  
The '*' atom indicates all fields, which is the default setting.</p>
 
  <p>Starting from ErlyWeb 0.6, you can add arbitrary metadata to each field
  by describing it as a tuple of the form
  <code>{FieldName::atom(), Attributes::[term()]}</code>. To retrieve the list of
  attributes for a field in a given model, you can call
  <code>erlydb_field:attributes(Model:db_field(FieldName))</code>.</p>
 
  <p>If the list of attributes contains the atom <code>read_only</code>, ErlyDB  
excludes the field from INSERT and UPDATE statements.</p>
 
  <p>It is also possible to add transient fields which do not exist in the  
database schema. To add transient fields it is currently necessary to  
overwrite the fields/0 function with the complete list of persistent  
fields plus the transient fields in any desired order (which also will be  
effective in the generated model functions), e.g.:</p>
 
  <p><code>fields() -&gt; [mydbfield, {mytransientfield, [transient]}, mydbfield2]</code></p>
 
  <p>Note: You are free to call the fields() function from other modules  
to create arbitrary field set relations.  
For example, in a module called 'artist', you could have the function</p>
 
  <p><code>fields() -&gt; person:fields() ++ [genre, studio]</code>
 </p>
</div></div>
<div class="function">
<h3 id="table/0">table() -&gt; atom()</h3>


<div class="description">

<p>Return the name of the table that holds the records for this module.
    By default, the table name is identical to the Module's name, but you
    can override this to use a different table name.
 </p>
</div></div>
<div class="function">
<h3 id="type_field/0">type_field() -&gt; atom()</h3>


<div class="description">

<p>Return the column that identifies the types of the records in a table.
    This is useful when storing records from multiple modules in a single
    table, where each module uses a different subset of fields.
    If you override this function, in most cases you should also override
    fields/0.
 </p>
</div></div>
<div class="function">
<h3 id="db_table/1">db_table(Module::atom()) -&gt; atom()</h3>


<div class="description">

<p>Get the table name for the module.
 </p>
</div></div>
<div class="function">
<h3 id="db_num_fields/1">db_num_fields(NumFields::integer()) -&gt; integer()</h3>


<div class="description">

<p>Get the number of fields for the module.</p>
 
  <p>In generated modules, this function takes 0 parameters.
 </p>
</div></div>
<div class="function">
<h3 id="db_fields/1">db_fields(Fields::[erlydb_field()]) -&gt; [erlydb_field()]</h3>


<div class="description">

<p>Get a list of <a href="erlydb_field.html" class="seealso">erlydb_field</a> records representing the database   
fields for the module.</p>
 
  <p>In generated modules, this function takes 0 parameters.
 </p>
</div></div>
<div class="function">
<h3 id="db_field_names/1">db_field_names(FileNames::[atom()]) -&gt; [atom()]</h3>


<div class="description">

<p>Get the module's database fields' names as atoms.</p>
 
  <p>In generated modules, this function takes 0 parameters.
 </p>
</div></div>
<div class="function">
<h3 id="db_field_names_str/1">db_field_names_str(FieldNameStrs::[string()]) -&gt; [string()]</h3>


<div class="description">

<p>Get the module's database fields' names as strings.</p>
 
  <p>In generated modules, this function takes 0 parameters.
 </p>
</div></div>
<div class="function">
<h3 id="db_field_names_bin/1">db_field_names_bin(FieldNamesBin::[binary()]) -&gt; [binary()]</h3>


<div class="description">

<p>Get the module's database fields' names as binaries.</p>
 
  <p>In generated modules, this function takes 0 parameters.
 </p>
</div></div>
<div class="function">
<h3 id="db_field/1">db_field(Module::atom(), FieldName::string() | atom()) -&gt; erlydb_field() | exit(Err)</h3>


<div class="description">

<p>Get the <a href="erlydb_field.html" class="seealso">erlydb_field</a> record matching the given field name.    
If the field isn't found, this function exits.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="db_pk_fields/1">db_pk_fields(Fields::[erlydb_field()]) -&gt; [erlydb_field()]</h3>


<div class="description">

<p>Return the list of fields (see @link erlydb_field)
  for which <code>erlydb_field:key(Field) == primary</code> is true.</p>
 
  <p>In generated modules, the 'Fields' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="is_new/1">is_new(Rec::record()) -&gt; boolean()</h3>


<div class="description">

<p>Check if the record has been saved in the database.
 </p>
</div></div>
<div class="function">
<h3 id="is_new/1-1">is_new(Rec::record(), Val::boolean()) -&gt; NewRec::record()</h3>


<div class="description">

<p>Set the record's 'is_new' field to the given value.
 </p>
</div></div>
<div class="function">
<h3 id="get_module/1">get_module(Rec::record()) -&gt; atom()</h3>


<div class="description">

<p>Get the name of the module to which the record belongs.
 </p>
</div></div>
<div class="function">
<h3 id="to_iolist/1">to_iolist(Module::atom(), Recs::record() | [record()]) -&gt; [iolist()] | [[iolist()]]</h3>


<div class="description">
<p>Equivalent to <a href="#to_iolist/3" class="seealso">to_iolist(Module, Recs, fun field_to_iolist/2)</a>.</p>
</div></div>
<div class="function">
<h3 id="to_iolist/1-1">to_iolist(Module::atom(), Rec::record() | [Rec::record()], ToIolistFun::to_iolist_function()) -&gt; [iolist()] | [[iolist()]]</h3>


<div class="description">

<p>If Recs is a single record, convert each of a record's fields into  
an iolist  
and return the list of the converted records. If Recs is a list of records,  
to_iolist is recursively called on each record, and the list of results is  
returned.</p>
 
  <p>ToIoListFun is a function that accepts an <a href="erlydb_field.html" class="seealso">erlydb_field</a> structure
  and a field value and returns an iolist (see <a href="#field_to_iolist/2" class="seealso">field_to_iolist/2</a>  
for an example).</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="field_to_iolist/1">field_to_iolist(Val::term()) -&gt; iolist()</h3>


<div class="description">

<p>A helper function used for converting field values to iolists.
 </p>
</div></div>
<div class="function">
<h3 id="field_to_iolist/2">field_to_iolist(Val::term, Field::erlydb_field()) -&gt; iolist()</h3>


<div class="description">

<p>This function converts standard ErlyDB field values to iolists.
  This is its source code:
  </p><pre class="sh_erlang"> 	Type = 	if
         		Field =:= undefined -&gt; undefined;
      			true -&gt; erlydb_field:erl_type(Field)
     		end,
 
   case Val of
  	Bin when is_binary(Bin) -&gt; Val;
  	List when is_list(List) -&gt; Val;
  	Int when is_integer(Int) -&gt; integer_to_list(Val);
  	Float when is_float(Float) -&gt; float_to_list(Val);
 
   {datetime, {{_Year,_Month,_Day},{_Hour,_Minute,_Second}} = DateTime} -&gt;
         format_datetime(DateTime);
   {{_Year,_Month,_Day},{_Hour,_Minute,_Second}} = DateTime when Type =:= datetime -&gt;
         format_datetime(DateTime);
 	{date, {_Year,_Month,_Day} = Date} -&gt; format_date(Date);
   {_Year,_Month,_Day} = Date when Type =:= date -&gt; format_date(Date);
 	{time, {_Hour,_Minute,_Second} = Time}  -&gt; format_time(Time);
   {_Hour,_Minute,_Second} = Time when Type =:= time -&gt; format_time(Time);
 
  	undefined -&gt; [];
  	_Other -&gt;
  	    io_lib:format("~p", [Val])
     end.</pre><p>
 </p>
</div></div>
<div class="function">
<h3 id="new/1">new(Module::atom()) -&gt; record()</h3>


<div class="description">

<p>Create a new record with all fields set to 'undefined'.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.</p>
 
  <p>Generated modules also have the function new/N, where N is the number of
  fields the module uses (as returned from db_num_fields/0), minus
  1 if the module has an 'identity' primary key field, which is initialized
  by the DBMS. This function lets you create a new record and initialize
  its fields with a single call. Note that fields that end with '_id' have
  a special property: they accept either a literal id value, or a record
  from a related table that has an 'id' primary key. For example, if the
  'project' module had the fields 'name' and 'language_id',
  <code>project:new("ErlyWeb", Erlang)</code> would be equivalent to
  <code>project:new("ErlyWeb", language:id(Erlang))</code>.
 </p>
</div></div>
<div class="function">
<h3 id="new_with/1">new_with(Module::atom(), Fields::proplist()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Create a new record, setting its field values  
according to the key/value pairs in the Fields property list.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
<p><em>See also:</em> <a href="#set_fields/3" class="seealso">set_fields/3</a>.</p>
</div></div>
<div class="function">
<h3 id="new_with/1-1">new_with(Module::atom(), Fields::proplist(), ToFieldFun::function()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Similar to <a href="#new_with/2" class="seealso">new_with/2</a>, but uses the ToFieldFun to convert
  property list values to field values before setting them. ToFieldFun
  accepts an <a href="erlydb_field.html" class="seealso">erlydb_field</a> record and the original value and returns  
the new value.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="new_from_strings/1">new_from_strings(Module::atom(), Fields::[{atom() | list(), list()}]) -&gt; record() | exit(Err)</h3>


<div class="description">
<p>Equivalent to <a href="#new_with/3" class="seealso">new_with(Module, Fields, fun field_from_string/2)</a>.</p>
<p><em>See also:</em> <a href="#field_from_string/2" class="seealso">field_from_string/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_fields/1">set_fields(Module::atom(), Record::record(), Fields::proplist()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Set the record's fields according to the name/value pairs in the  
property list, e.g.</p>
 
  <pre class="sh_erlang">  Language1 = language:set_fields(Language, [{name,"Erlang"},
                      {creation_year, 1981}])</pre>
 
  <p>The property list can have keys that are either strings or atoms.  
If a field name doesn't match an existing field for this record,  
this function exits.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="set_fields/1-1">set_fields(Module::atom(), Record::record(), Fields::proplist(), ToFieldFun::function()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Set the record's fields using according to the property list
  name/value pairs,
  after first converting the values using the ToFieldFun. ToFieldFun accepts
  an <a href="erlydb_field.html" class="seealso">erlydb_field</a> record and the original value and returns the new  
value.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="set_fields_from_strs/1">set_fields_from_strs(Module::atom(), Record::record(), Fields::proplist()) -&gt; record() | exit(Err)</h3>


<div class="description">
<p>Equivalent to <a href="#set_fields/4" class="seealso">set_fields(Module, Record, Fields,
	   fun field_from_string/2)</a>.</p>
<p><em>See also:</em> <a href="#field_from_string/2" class="seealso">field_from_string/2</a>.</p>
</div></div>
<div class="function">
<h3 id="field_from_string/1">field_from_string(ErlyDbField::erlydb_field(), Str::list()) -&gt; term() | exit(Err)</h3>


<div class="description">

<p>A helper function for converting values encoded as strings to their  
corresponding Erlang types.</p>
 
  <p>This function assumes field values are formatted according to the logic in
  <a href="#field_to_iolist/2" class="seealso">field_to_iolist/2</a>. In addition, it checks the following ranges:</p>
 
  <p>second: 0-59<br />
  minute: 0-59<br />
  hour: 0-23<br />
  day: 1-31<br />
  month: 1-12<br />
  year: 1-9999<br />
 </p>
</div></div>
<div class="function">
<h3 id="save/1">save(Rec::record()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Save an object by executing a INSERT or UPDATE query.  
This function returns a modified tuple representing  
the saved record or throws an exception if an error occurs.</p>
 
  <p>With MySQL, for INSERT statements for records with identity primary keys,  
this function sets the primary key field to the value returned from  
calling "SELECT last_insert_id()".</p>
 
  <p>You can override the return value by implementing the after_save
  hook.
 </p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(Rec::record() | [record()]) -&gt; NumInserts::integer() | exit(Err)</h3>


<div class="description">

<p>Insert one or more records into the database.</p>
 
  <p>If you don't need to get the saved records' auto-generated ids, this
  function is much more
  efficient than calling save/1 on each record as this function saves
  the entire list of records in one INSERT statement.
 </p>
</div></div>
<div class="function">
<h3 id="update/2">update(Module, Props) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#update/3" class="seealso">update(Module, Props, undefined)</a>.</p>
</div></div>
<div class="function">
<h3 id="update/1">update(Module::atom(), Props::proplist(), Where::where_expr()) -&gt; NumUpdated::integer() | exit(Err)</h3>


<div class="description">

<p>Execute an UPDATE statement against the module's database table  
and return the number of rows updated.</p>
 
  <p>'Props' is a list of 2 element tuples, where the first element is an  
atom representing the field's name, and the second value is an ErlSQL  
expression representing its value.</p>
 
  <p>'Where' is an ErlSQL 'where' expression.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.</p>
 
  <p>Example:
  Calling <code>person:update([{name,&lt;&lt;"Jane"&gt;&gt;}, {age, {age, '+', 1}}],
  {id,'=',7})</code>
  would yield the statement <code>UPDATE person SET name='Jane', age=age+1
  WHERE id=7</code>.</p>
 
  <p>The UPDATE statement is executed in a transactional context.
 </p>
</div></div>
<div class="function">
<h3 id="increment/2">increment(Module, Fields) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#increment/3" class="seealso">increment(Module, Fields, undefined)</a>.</p>
</div></div>
<div class="function">
<h3 id="increment/1">increment(Module::atom(), Fields::[atom()], Where::where_expr()) -&gt; NumRowsUpdated::integer()</h3>


<div class="description">

<p>Increment the values for the listed fields in the module's table.
  This executes the query
  </p><pre class="sh_erlang">  UPDATE [table] SET [field1] = [field1] + 1, [field2] = [field2] + 1...
  WHERE [where_expr]</pre><p>
 </p>
</div></div>
<div class="function">
<h3 id="decrement/2">decrement(Module, Fields) -&gt; term()
</h3>


<div class="description">
<p>Equivalent to <a href="#decrement/3" class="seealso">decrement(Module, Fields, undefined)</a>.</p>
</div></div>
<div class="function">
<h3 id="decrement/3">decrement(Module, Fields, Where) -&gt; term()
</h3>


<div class="description">

<p>Similar to <a href="#increment/3" class="seealso">increment/3</a>, but decrements the fields' values.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(Rec::record()) -&gt; ok | exit(Err)</h3>


<div class="description">

<p>Delete the record from the database. To facilitate the after_delete  
hook, this function expects a single record to be deleted.</p>
 
  <p>You can override the return value by implementing the after_delete
  hook.
 </p>
</div></div>
<div class="function">
<h3 id="delete_id/1">delete_id(Module::atom(), Id::integer()) -&gt; NumDeleted::integer()</h3>


<div class="description">
<p>Equivalent to <a href="#delete_where/2" class="seealso">delete_where(Module, {id, '=', Id})</a>.</p>
</div></div>
<div class="function">
<h3 id="delete_where/1">delete_where(Module::atom(), Where::where_expr()) -&gt; NumDeleted::integer() | exit(Err)</h3>


<div class="description">

<p>Delete all records matching the Where expressions,  
and return the number of deleted records.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="delete_all/1">delete_all(Module::atom()) -&gt; NumDeleted::integer() | exit(Err)</h3>


<div class="description">

<p>Delete all records from the module and return the number of records  
actually deleted.</p>
 
  <p>Needless to say, use this function with extreme care.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="transaction/1">transaction(Module::atom(), Fun::function()) -&gt; {atomic, Result::term()} | {aborted, Details}</h3>


<div class="description">

<p>Execute a transaction using the module's driver settings, as defined
  by the parameters passed to <a href="erlydb.html#code_gen/3" class="seealso">erlydb:code_gen/3</a>.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="before_save/1">before_save(Rec::record()) -&gt; record()</h3>


<div class="description">

<p>A hook that gets called before a record is saved.</p>
 
  <p>By default, this function returns the original record. You can implement
  this function in the target module to override the default behavior.
 </p>
</div></div>
<div class="function">
<h3 id="after_save/1">after_save(Rec::record()) -&gt; record()</h3>


<div class="description">

<p>A hook that gets called after a record is saved.</p>
 
  <p>By default, this function returns the original record. You can implement
  this function in the target module to override the default behavior.
 </p>
</div></div>
<div class="function">
<h3 id="before_delete/1">before_delete(Rec::record()) -&gt; record()</h3>


<div class="description">

<p>A hook that gets called before a record is deleted.</p>
 
  <p>By default, this function returns the original record. You can implement
  this function in the target module to override the default behavior.
 </p>
</div></div>
<div class="function">
<h3 id="after_delete/1">after_delete(X1::{Rec::record(), NumDeleted::integer()}) -&gt; integer()</h3>


<div class="description">

<p>A hook that gets called after a record is deleted.</p>
 
  <p>By default, this function returns an integer indicating the number of rows  
deleted.</p>
 
  <p>You can implement
  this function in the target module to override the default behavior.
 </p>
</div></div>
<div class="function">
<h3 id="after_fetch/1">after_fetch(Rec::record()) -&gt; record()</h3>


<div class="description">

<p>A hook that gets called after a record is fetched from the database.</p>
 
  <p>By default, this function returns the original record. You can implement
  this function in the target module to override the default behavior.
 </p>
</div></div>
<div class="function">
<h3 id="find/1">find(Module::atom(), Where::where_expr(), Extras::extras_expr()) -&gt; [record()] | exit(Err)</h3>


<div class="description">

<p>Find records for the module. The Where and Extras clauses are,
   by default, ErlSQL expressions (see <a href="erlsql.html" class="seealso">erlsql</a>).
   Example Where expressions are<br />
   <code>{name,'=',"Joe"}</code><br />
   and<br />
   <code>{{age,'&gt;',26},'and',{country,like,"Australia"}}</code></p>
 
   <p>Example Extras expressions are<br />
   <code>{limit, 7}</code><br />
   and<br />
   <code>[{limit, 4,5}, {order_by, [name, {age, desc}, {height, asc}]}]</code></p>
 
   <p>The main benefits of using ErlSQL are<br />
   - It protects against SQL injection attacks by quoting all string
     values.<br />
   - It simplifies embedding runtime variables in SQL expressions
     by automatically stringifying
     values such as numbers, atoms, dates and times.<br />   
- It's more efficient than string concatenation because it generates     
iolists of binaries, which generally consume less memory than     
strings.</p>
 
  <p>Some drivers (e.g. the MySQL driver), let you use string and binary
  expressions directly when you pass the {allow_unsafe_statements, true}
  option to
  <a href="erlydb.html#code_gen/3" class="seealso">erlydb:code_gen/3</a>. This usage is discouraged, however, because it  
makes you vulnerable to SQL injection attacks if you don't properly  
encode all your strings.</p>
 
  <p>During code generation, ErlyDB creates a few derivatives from this function  
in target modules:</p>
 
  <pre class="sh_erlang">    find()  %% returns all records
    find(Where)
    find_with(Extras)
    find(Where, Extras)</pre>
 
  <p>(Note that in generated modules, the 'Module' parameter is omitted.)</p>
 
  <p>ErlyDB creates similar derivatives for all find_x and aggregate functions
  in erlydb_base (e.g. find_first(), find_first(Where),
  find_first_with(Extras), find_first(Where, Extras)...).
 </p>
</div></div>
<div class="function">
<h3 id="find_first/1">find_first(Modue::atom(), Where::where_expr(), Extras::extras_expr()) -&gt; record() | undefined | exit(Err)</h3>


<div class="description">

<p>Find the first record for the module according to the Where and  
Extras expressions. If no records match the conditions, the function  
returns 'undefined'.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
<p><em>See also:</em> <a href="#find/3" class="seealso">find/3</a>.</p>
</div></div>
<div class="function">
<h3 id="find_max/1">find_max(Module::atom(), Max::integer(), Where::where_expr(), Extras::extras_expr()) -&gt; [record()] | exit(Err)</h3>


<div class="description">

<p>Find up to Max records from the module according    
to the Where and Extras expressions.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
<p><em>See also:</em> <a href="#find/3" class="seealso">find/3</a>.</p>
</div></div>
<div class="function">
<h3 id="find_range/1">find_range(Module::atom(), First::integer(), Max::integer(), Where::where_expr(), Extras::extras_expr()) -&gt; [record()] | exit(Err)</h3>


<div class="description">

<p>Find up to Max records, starting from offset First,    
according to the Where and Extras expressions.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
<p><em>See also:</em> <a href="#find/3" class="seealso">find/3</a>.</p>
</div></div>
<div class="function">
<h3 id="find_id/1">find_id(Module::atom(), Id::term()) -&gt; Rec | exit(Err)</h3>


<div class="description">

<p>Find the record with the given id value.</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="aggregate/1">aggregate(Module::atom(), AggFunc::atom(), Field::atom(), Where::where_expr(), Extras::extras_expr()) -&gt; integer() | float() | exit(Err)</h3>


<div class="description">

<p>ErlyDB uses this function to generate derivative functions in
  target modules for calculating aggregate values for database
  fields. Drivative functions have the form <code>Module:FuncName(Field)</code>,
  where 'Module' is the module name, 'FuncName' is 'count', 'avg',
  'sum', 'min', 'max' or 'stddev', and Field is the name of the field.
  Derivative functions also have variations as described in <a href="#find/3" class="seealso">find/3</a>.</p>
 
  <p>For example, in a module called 'person', ErlyDB  
would generate the following functions:</p>
 
  <pre class="sh_erlang">    person:count(Field)
    person:count(Field, Where)
    person:count_with(Field, Extras)
    person:count(Field, Where, Extras)
    person:avg(Field)
    ...</pre><p>
  where Field can be any field in the person module (such as 'age', 'height',
  etc.).
 </p>
<p><em>See also:</em> <a href="#find/3" class="seealso">find/3</a>.</p>
</div></div>
<div class="function">
<h3 id="count/1">count(Module::atom()) -&gt; integer() | exit(Err)</h3>


<div class="description">

<p>A shortcut for counting all the records for a module. In generated  
modules, this function lets you can call Module:count() instead of  
Module:count('*').</p>
 
  <p>In generated modules, the 'Module' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="get/1">get(Idx::integer(), Rec::record()) -&gt; term()</h3>


<div class="description">

<p>A generic getter function ErlyDB uses to generate getters, e.g.
  person:name(Person), for all of a module's database fields.
 </p>
</div></div>
<div class="function">
<h3 id="set/1">set(Idx::integer(), Rec::record(), NewVal::term()) -&gt; record()</h3>


<div class="description">

<p>A generic setter function ErlyDB uses to generate setters, e.g.
  person:name(Person, NewName), for all of a module's database fields.
 </p>
</div></div>
<div class="function">
<h3 id="driver/1">driver(Driver::term()) -&gt; term()</h3>


<div class="description">

<p>Get the driver settings, defined in the call to
  <a href="erlydb.html#code_gen/3" class="seealso">erlydb:code_gen/3</a>, ErlyDB uses for the module.</p>
 
  <p>In generated modules, the 'Driver' parameter is omitted.
 </p>
</div></div>
<div class="function">
<h3 id="set_related_one_to_many/1">set_related_one_to_many(Rec::record(), PkFkFields::proplist(), Other::record()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Set the foreign key fields of a record from a module having a  
many-to-one relation to the primary key values of the Other record.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses it to generate  
special setters for related records in modules that define many-to-one  
relations.</p>
 
  <p>For example, if you had a module 'bone' that defined the relation
  <code>{many_to_one, [dog]}</code>, and the 'dog' module had a single primary key
  field called 'id', ErlyDB would add the
  function <code>bone:dog(Bone, Dog)</code>
  to the 'bone' module. This function would be equivalent to
  <code>bone:dog_id(Bone, dog:id(Dog))</code>, with an extra check to verify  
that Dog is saved in the database.</p>
 
  <p>If 'dog' had more than one primary key field, this function would
  set the values for all foreign key fields in the 'bone' record
  to the values of the 'dog' record's corresponding primary key
  values.
 </p>
</div></div>
<div class="function">
<h3 id="find_related_one_to_many/1">find_related_one_to_many(OtherModule::atom(), PkFkfields::proplist(), Rec::record()) -&gt; record() | exit(Err)</h3>


<div class="description">

<p>Find the related record for a record from a module having a  
many-to-one relation.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses it to generate  
special 'find' functions for related records in modules  
defining many-to-one relations.</p>
 
  <p>For example, if you had a module 'bone' that defined the relation
  <code>{many_to_one, [dog]}</code>, and 'dog' had a single primary key field called
  'id', ErlyDB would add the function <code>bone:dog(Bone)</code>
  to the 'bone' module. This function would be equivalent to
  <code>dog:find({id,</code>=',bone:dog_id(Bone)}).'.</p>
 
  <p>This function works as expected when the related module has multiple
  primary key fields.
 </p>
</div></div>
<div class="function">
<h3 id="find_related_many_to_one/1">find_related_many_to_one(OtherModule::atom(), PkFks::term(), Rec::record(), Where::where_expr(), Extras::extras_expr()) -&gt; [record()] | exit(Err)</h3>


<div class="description">

<p>Find the set of related records in a one-to-many relation.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses this function  
to generate special 'find' functions in modules that define  
one-to-many relations.</p>
 
  <p>For example, if you had a module 'dog' that defined the relation
  <code>{one_to_many, [bone]}</code>, ErlyDB would add the following  
functions to the 'dog' module:</p>
 
  <pre class="sh_erlang">  dog:bones(Dog)
  dog:bones(Dog, Where)
  dog:bones_with(Dog, Extras)
  dog:bones(Dog, Where, Extras)
 
  dog:bones_first(Dog)
  dog:bones_first(Dog, Where)
  dog:bones_first_with(Dog, Extras)
  dog:bones_first(Dog, Where, Extras)
 
  dog:bones_max(Dog, Max)
  dog:bones_max(Dog, Max, Where)
  dog:bones_max_with(Dog, Max, Extras)
  dog:bones_max(Dog, Max, Where, Extras)
 
  dog:bones_range(Dog, First, Max)
  dog:bones_range(Dog, First, Max, Where)
  dog:bones_range_with(Dog, First, Max, Extras)
  dog:bones_range(Dog, First, Max, Where, Extras)</pre><p>
 </p>
<p><em>See also:</em> <a href="#find/3" class="seealso">find/3</a>, <a href="#find_first/3" class="seealso">find_first/3</a>, <a href="#find_max/4" class="seealso">find_max/4</a>, <a href="#find_range/5" class="seealso">find_range/5</a>.</p>
</div></div>
<div class="function">
<h3 id="aggregate_related_many_to_one/1">aggregate_related_many_to_one(OtherModule::atom(), PkFks::term(), AggFunc::atom(), Rec::record(), Field::atom(), Where::where_expr(), Extras::extras_expr()) -&gt; float() | integer() | exit(Err)</h3>


<div class="description">

<p>Get aggregate statistics about fields from related records in  
one-to-many relations.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses this function  
to generate special aggregate functions in modules that define  
one-to-many relations.</p>
 
  <p>For example, if you had a module 'dog' that defined the relation
  <code>{one_to_many, [bone]}</code>, ErlyDB would add the following  
functions to the 'dog' module:</p>
 
  <pre class="sh_erlang">  dog:avg_of_bones(Dog, Field)
  dog:avg_of_bones(Dog, Field, Where)
  dog:avg_of_bones_with(Dog, Field, Extras)
  dog:avg_of_bones(Dog, Field, Where, Extras)</pre>
 
  <p>where 'Field' is the name of the field in the 'bone' module (e.g. 'size').</p>
 
  <p>ErlyDB generates similar derivatives for all aggregate functions listed in
  <a href="#aggregate/5" class="seealso">aggregate/5</a>.
 </p>
<p><em>See also:</em> <a href="#aggregate/5" class="seealso">aggregate/5</a>.</p>
</div></div>
<div class="function">
<h3 id="add_related_many_to_many/1">add_related_many_to_many(JoinTable::atom(), Rec::record(), OtherRec::record() | [record()]) -&gt; {ok, NumAdded} | exit(Err)</h3>


<div class="description">

<p>Add a related record in a many-to-many relation.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses this function  
to generate special add_[RelatedModule] functions in modules that define  
many-to-many relations.</p>
 
  <p>For instance, if you had a module 'student' that defined the relation
  <code>{many_to_many, [class]}</code>, and both 'student' and 'class' had a single
  primary key field called 'id', ErlyDB would add the function
  <code>student:add_class(Student, Class)</code> to the 'student' module. This  
function would insert the row [class:id(Class), student:id(Student)] to  
the class_student table, where the first column is 'class_id'  
and the second column is 'student_id'.</p>
 
  <p>If either module has multiple primary key fields, all those fields are
  mapped to foreign keys in the many-to-many relation table.
 </p>
</div></div>
<div class="function">
<h3 id="remove_related_many_to_many/1">remove_related_many_to_many(JoinTable::atom(), Rec::record(), OtherRec::record()) -&gt; NumRemoved::interger() | exit(Err)</h3>


<div class="description">

<p>Remove a related record in a many-to-many relation.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses this function  
to generate special remove_[RelatedModule] functions in modules that define  
many-to-many relations.</p>
 
  <p>For instance, if you had a module 'student' that defined the relation
  <code>{many_to_many, [class]}</code>, and module 'class' and 'student' had a single
  primary key field called 'id', ErlyDB would add the function
  <code>student:remove_class(Student, Class)</code> to the 'student' module. This  
function would remove the row [class:id(Class), student:id(Student)]  
from the class_student table, where the first column is 'class_id'  
the second column is 'student_id'.</p>
 
  <p>This function expects a single record to be removed.
 </p>
</div></div>
<div class="function">
<h3 id="remove_related_many_to_many_all/1">remove_related_many_to_many_all(JoinTable::atom(), OtherTable::atom(), Rec::record(), Where::where_clause(), Extras::extras_clause()) -&gt; {ok, NumDeleted} | exit(Err)</h3>


<div class="description">

<p>Remove all related recorded according to a Where and Extras clause  
in a many-to-many relation.</p>
 
  <p>This function isn't meant to be used directly; ErlyDB uses this function  
to generate special remove_all_[RelatedModuleAsPlural] functions in  
modules that define many-to-many relations.</p>
 
  <p>For instance, if you had a module 'student' that defined the relation
  <code>{many_to_many, [class]}</code>, and module 'class' and 'student' had a single
  primary key field called 'id', ErlyDB would add the function
  <code>student:remove_all_classes(Student, Where, Extras)</code> to the 'student'  
module. This function would remove [class:id(Class), student:id(Student)]  
rows from the class_student table according to the Where and Extras clauses.</p>
 
  <p>In addition to student:remove_all_classes/3, ErlyDB would generate  
additional variations. This would be the full list:</p>
 
  <pre class="sh_erlang">  student:remove_all_classes(Student)
  student:remove_all_classes(Student, Where)
  student:remove_all_classes_with(Student, Extras)
  student:remove_all_classes(Student, Where, Extras)</pre>
 
  <p>Limitation: for self-referencing many-to-many relations, all variations
  accepting a Where clause are currently not generated.
 </p>
</div></div>
<div class="function">
<h3 id="is_related/3">is_related(JoinTable, Rec, OtherRec) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="find_related_many_to_many/1">find_related_many_to_many(OtherModule::atom(), JoinTable::atom(), Rec::record(), Where::where_clause(), Extras::extras_clause()) -&gt; [record()] | exit(Err)</h3>


<div class="description">

<p>This function works as <a href="#find_related_many_to_one/4" class="seealso">find_related_many_to_one/4</a>, but
  for modules defining many-to-many relations.
 </p>
<p><em>See also:</em> <a href="#find_related_many_to_one/4" class="seealso">find_related_many_to_one/4</a>.</p>
</div></div>
<div class="function">
<h3 id="aggregate_related_many_to_many/1">aggregate_related_many_to_many(OtherModule::atom(), JoinTable::atom(), AggFunc::atom(), Rec::record(), Field::atom(), Where::where_clause(), Extras::extras_clause()) -&gt; [term()] | exit(Err)</h3>


<div class="description">

<p>This function works as <a href="#aggregate_related_many_to_one/5" class="seealso">aggregate_related_many_to_one/5</a>, but
  for modules defining many-to-many relations.
 </p>
<p><em>See also:</em> <a href="#aggregate_related_many_to_one/5" class="seealso">aggregate_related_many_to_one/5</a>.</p>
</div></div></div>

<authors>

<aname>Yariv Sadan</aname>
<email>yarivvv@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
