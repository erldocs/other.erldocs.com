<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>lhttpc (lhttpc) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>lhttpc</h1>
<h2 class="modsummary">Main interface to the lightweight http client.</h2>
<div class="description">
<p>Main interface to the lightweight http client.
   See <a href="#request/4" class="seealso">request/4</a>, <a href="#request/5" class="seealso">request/5</a> and <a href="#request/6" class="seealso">request/6</a> functions.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-poolsize">poolsize() = integer() &gt;= 0 | atom()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/0">start() -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Start the application.
  This is a helper function that will call <code>application:start(lhttpc)</code> to
  allow the library to be started using the <code>-s</code> flag.
  For instance:
  <code>$ erl -s crypto -s ssl -s lhttpc</code></p>
 
  <p>For more info on possible return values the <code>application</code> module.</p>
</div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Stops the application.
  This is a helper function that will call <code>application:stop(lhttpc)</code>.</p>
 
  <p>For more info on possible return values the <code>application</code> module.</p>
</div></div>
<div class="function">
<h3 id="add_pool/1">add_pool(Name) -&gt; {ok, Pid} | {error, Reason}</h3>

<ul class="type">
<li><code>Name = atom()</code></li><li><code>Pid = pid()</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p>Add a new named httpc_manager pool to the supervisor tree</p>
</div></div>
<div class="function">
<h3 id="add_pool/1-1">add_pool(Name::atom(), ConnTimeout::non_neg_integer()) -&gt; {ok, pid()} | {error, term()}</h3>


<div class="description">

<p>Add a new httpc_manager to the supervisor tree</p>
</div></div>
<div class="function">
<h3 id="add_pool/1-2">add_pool(Name::atom(), ConnTimeout::non_neg_integer(), PoolSize::poolsize()) -&gt; {ok, pid()} | {error, term()}</h3>


<div class="description">

<p>Add a new httpc_manager to the supervisor tree</p>
</div></div>
<div class="function">
<h3 id="delete_pool/1">delete_pool(PoolPid::atom() | pid()) -&gt; ok</h3>


<div class="description">

<p>Delete a pool</p>
</div></div>
<div class="function">
<h3 id="request/4">request(URL, Method, Hdrs, Timeout) -&gt; Result</h3>

<ul class="type">
<li><code>URL = string()</code></li><li><code>Method = string() | atom()</code></li><li><code>Hdrs = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</code></li><li><code>StatusCode = integer()</code></li><li><code>ReasonPhrase = string()</code></li><li><code>ResponseBody = binary()</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a request without a body.
  Would be the same as calling <a href="#request/5" class="seealso">request/5</a> with an empty body,
  <code>request(URL, Method, Hdrs, [], Timeout)</code> or
  <code>request(URL, Method, Hdrs, &lt;&lt;&gt;&gt;, Timeout)</code>.</p>
<p><em>See also:</em> <a href="#request/9" class="seealso">request/9</a>.</p>
</div></div>
<div class="function">
<h3 id="request/5">request(URL, Method, Hdrs, Body::RequestBody, Timeout) -&gt; Result</h3>

<ul class="type">
<li><code>URL = string()</code></li><li><code>Method = string() | atom()</code></li><li><code>Hdrs = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>RequestBody = iodata()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</code></li><li><code>StatusCode = integer()</code></li><li><code>ReasonPhrase = string()</code></li><li><code>ResponseBody = binary()</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a request with a body.
  Would be the same as calling <a href="#request/6" class="seealso">request/6</a> with no options,
  <code>request(URL, Method, Hdrs, Body, Timeout, [])</code>.</p>
<p><em>See also:</em> <a href="#request/9" class="seealso">request/9</a>.</p>
</div></div>
<div class="function">
<h3 id="request/6">request(URL, Method, Hdrs, Body::RequestBody, Timeout, Options) -&gt; Result</h3>

<ul class="type">
<li><code>URL = string()</code></li><li><code>Method = string() | atom()</code></li><li><code>Hdrs = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>RequestBody = iodata()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Options = [Option]</code></li><li><code>Option = {connect_timeout, Milliseconds | infinity} | {connect_options, [ConnectOptions]} | {send_retry, integer()} | {partial_upload, WindowSize} | {partial_download, PartialDownloadOptions} | {proxy, ProxyUrl} | {proxy_ssl_options, SslOptions} | {pool, LhttcPool}</code></li><li><code>Milliseconds = integer()</code></li><li><code>ConnectOptions = term()</code></li><li><code>WindowSize = integer() | infinity</code></li><li><code>PartialDownloadOptions = [PartialDownloadOption]</code></li><li><code>PartialDowloadOption = {window_size, WindowSize} | {part_size, PartSize}</code></li><li><code>ProxyUrl = string()</code></li><li><code>SslOptions = [any()]</code></li><li><code>LhttcPool = pid() | atom()</code></li><li><code>PartSize = integer() | infinity</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {ok, UploadState} | {error, Reason}</code></li><li><code>StatusCode = integer()</code></li><li><code>ReasonPhrase = string()</code></li><li><code>ResponseBody = binary() | pid() | undefined</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a request with a body.
  Would be the same as calling </p><pre class="sh_erlang">
  #lhttpc_url{host = Host, port = Port, path = Path, is_ssl = Ssl} = lhttpc_lib:parse_url(URL),
  request(Host, Port, Path, Ssl, Method, Hdrs, Body, Timeout, Options).
  </pre><p>
 
  <code>URL</code> is expected to be a valid URL:
  <code>scheme://host[:port][/path]</code>.</p>
<p><em>See also:</em> <a href="#request/9" class="seealso">request/9</a>.</p>
</div></div>
<div class="function">
<h3 id="request/9">request(Host, Port, Ssl, Path, Method, Hdrs, Body::RequestBody, Timeout, Options) -&gt; Result</h3>

<ul class="type">
<li><code>Host = string()</code></li><li><code>Port = integer()</code></li><li><code>Ssl = boolean()</code></li><li><code>Path = string()</code></li><li><code>Method = string() | atom()</code></li><li><code>Hdrs = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>RequestBody = iodata()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Options = [Option]</code></li><li><code>Option = {connect_timeout, Milliseconds | infinity} | {connect_options, [ConnectOptions]} | {send_retry, integer()} | {partial_upload, WindowSize} | {partial_download, PartialDownloadOptions} | {proxy, ProxyUrl} | {proxy_ssl_options, SslOptions} | {pool, LhttcPool}</code></li><li><code>Milliseconds = integer()</code></li><li><code>WindowSize = integer()</code></li><li><code>PartialDownloadOptions = [PartialDownloadOption]</code></li><li><code>PartialDowloadOption = {window_size, WindowSize} | {part_size, PartSize}</code></li><li><code>ProxyUrl = string()</code></li><li><code>SslOptions = [any()]</code></li><li><code>LhttcPool = pid() | atom()</code></li><li><code>PartSize = integer() | infinity</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</code></li><li><code>StatusCode = integer()</code></li><li><code>ReasonPhrase = string()</code></li><li><code>ResponseBody = binary() | pid() | undefined</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a request with a body.</p>
 
  <p>Instead of building and parsing URLs the target server is specified with
  a host, port, weither SSL should be used or not and a path on the server.
  For instance, if you want to request http://example.com/foobar you would
  use the following:<br />
  <code>Host</code> = <code>"example.com"</code><br />
  <code>Port</code> = <code>80</code><br />
  <code>Ssl</code> = <code>false</code><br />
  <code>Path</code> = <code>"/foobar"</code><br />
  <code>Path</code> must begin with a forward slash <code>/</code>.</p>
 
  <p><code>Method</code> is either a string, stating the HTTP method exactly as in the
  protocol, i.e: <code>"POST"</code> or <code>"GET"</code>. It could also be an atom, which is  
then coverted to an uppercase (if it isn't already) string.</p>
 
  <p><code>Hdrs</code> is a list of headers to send. Mandatory headers such as
  <code>Host</code>, <code>Content-Length</code> or <code>Transfer-Encoding</code> (for some requests)  
are added automatically.</p>
 
  <p><code>Body</code> is the entity to send in the request. Please don't include entity
  bodies where there shouldn't be any (such as for <code>GET</code>).</p>
 
  <p><code>Timeout</code> is the timeout for the request in milliseconds.</p>
 
  <p><code>Options</code> is a list of options.</p>
 
  <p>Options:</p>
 
  <p><code>{connect_timeout, Milliseconds}</code> specifies how many milliseconds the  
client can spend trying to establish a connection to the server. This  
doesn't affect the overall request timeout. However, if it's longer than  
the overall timeout it will be ignored. Also note that the TCP layer my  
choose to give up earlier than the connect timeout, in which case the  
client will also give up. The default value is infinity, which means that  
it will either give up when the TCP stack gives up, or when the overall  
request timeout is reached.</p>
 
  <p><code>{connect_options, Options}</code> specifies options to pass to the socket at
  connect time. This makes it possible to specify both SSL options and
  regular socket options, such as which IP/Port to connect from etc.
  Some options must not be included here, namely the mode, <code>binary</code>
  or <code>list</code>, <code>{active, boolean()}</code>, <code>{active, once}</code> or <code>{packet, Packet}</code>.  
These options would confuse the client if they are included.  
Please note that these options will only have an effect on *new*  
connections, and it isn't possible for different requests  
to the same host uses different options unless the connection is closed  
between the requests. Using HTTP/1.0 or including the "Connection: close"  
header would make the client close the connection after the first  
response is received.</p>
 
  <p><code>{send_retry, N}</code> specifies how many times the client should retry
  sending a request if the connection is closed after the data has been
  sent. The default value is <code>1</code>. If <code>{partial_upload, WindowSize}</code>  
(see below) is specified, the client cannot retry after the first part  
of the body has been sent since it doesn't keep the whole entitity body  
in memory.</p>
 
  <p><code>{partial_upload, WindowSize}</code> means that the request entity body will be
  supplied in parts to the client by the calling process. The <code>WindowSize</code>
  specifies how many parts can be sent to the process controlling the socket
  before waiting for an acknowledgement. This is to create a kind of
  internal flow control if the network is slow and the client process is
  blocked by the TCP stack. Flow control is disabled if <code>WindowSize</code> is
  <code>infinity</code>. If <code>WindowSize</code> is an integer, it must be &gt;= 0. If partial
  upload is specified and no <code>Content-Length</code> is specified in <code>Hdrs</code> the
  client will use chunked transfer encoding to send the entity body.
  If a content length is specified, this must be the total size of the entity
  body.
  The call to <a href="#request/6" class="seealso">request/6</a> will return <code>{ok, UploadState}</code>. The
  <code>UploadState</code> is supposed to be used as the first argument to the <a href="#send_body_part/2" class="seealso">send_body_part/2</a> or <a href="#send_body_part/3" class="seealso">send_body_part/3</a> functions to send body parts.  
Partial upload is intended to avoid keeping large request bodies in  
memory but can also be used when the complete size of the body isn't known  
when the request is started.</p>
 
  <p><code>{partial_download, PartialDownloadOptions}</code> means that the response body
  will be supplied in parts by the client to the calling process. The partial
  download option <code>{window_size, WindowSize}</code> specifies how many part will be
  sent to the calling process before waiting for an acknowledgement. This is
  to create a kind of internal flow control if the calling process is slow to
  process the body part and the network and server are considerably faster.
  Flow control is disabled if <code>WindowSize</code> is <code>infinity</code>. If <code>WindowSize</code>
  is an integer it must be &gt;=0. The partial download option <code>{part_size,
  PartSize}</code> specifies the size the body parts should come in. Note however
  that if the body size is not determinable (e.g entity body is termintated
  by closing the socket) it will be delivered in pieces as it is read from
  the wire. There is no caching of the body parts until the amount reaches
  body size. If the body size is bounded (e.g <code>Content-Length</code> specified or
  <code>Transfer-Encoding: chunked</code> specified) it will be delivered in <code>PartSize</code>
  pieces. Note however that the last piece might be smaller than <code>PartSize</code>.
  Size bounded entity bodies are handled the same way as unbounded ones if
  <code>PartSize</code> is <code>infinity</code>. If <code>PartSize</code> is integer it must be &gt;= 0.
  If <code>{partial_download, PartialDownloadOptions}</code> is specified the
  <code>ResponseBody</code> will be a <code>pid()</code> unless the response has no body
  (for example in case of <code>HEAD</code> requests). In that case it will be be
  <code>undefined</code>. The functions <a href="#get_body_part/1" class="seealso">get_body_part/1</a> and
  <a href="#get_body_part/2" class="seealso">get_body_part/2</a> can be used to read body parts in the calling  
process.</p>
 
  <p><code>{proxy, ProxyUrl}</code> if this option is specified, a proxy server is used as  
an intermediary for all communication with the destination server. The link  
to the proxy server is established with the HTTP CONNECT method (RFC2817).  
Example value: {proxy, "http://john:doe@myproxy.com:3128"}</p>
 
  <p><code>{proxy_ssl_options, SslOptions}</code> this is a list of SSL options to use for
  the SSL session created after the proxy connection is established. For a
  list of all available options, please check OTP's ssl module manpage.</p>
</div></div>
<div class="function">
<h3 id="send_body_part/2">send_body_part(UploadState, BodyPart) -&gt; Result</h3>

<ul class="type">
<li><code>BodyPart = iodata() | binary()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = {error, Reason} | UploadState</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used. The default timeout, <code>infinity</code>
  will be used. Notice that if <code>WindowSize</code> is infinity, this call will never
  block.
  Would be the same as calling
  <code>send_body_part(UploadState, BodyPart, infinity)</code>.</p>
</div></div>
<div class="function">
<h3 id="send_body_part/3">send_body_part(UploadState, BodyPart, Timeout) -&gt; Result</h3>

<ul class="type">
<li><code>BodyPart = iodata() | binary()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = {error, Reason} | UploadState</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends a body part to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used.
  <code>Timeout</code> is the timeout for the request in milliseconds.</p>
 
  <p>If the window size reaches 0 the call will block for at maximum Timeout
  milliseconds. If there is no acknowledgement received during that time the
  the request is cancelled and <code>{error, timeout}</code> is returned.</p>
 
  <p>As long as the window size is larger than 0 the function will return  
immediately after sending the body part to the request handling process.</p>
 
  <p>The <code>BodyPart</code> <code>http_eob</code> signals an end of the entity body, the request
  is considered sent and the response will be read from the socket. If
  there is no response within <code>Timeout</code> milliseconds, the request is
  canceled and <code>{error, timeout}</code> is returned.</p>
</div></div>
<div class="function">
<h3 id="send_trailers/2">send_trailers(UploadState, Trailers) -&gt; Result</h3>

<ul class="type">
<li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends trailers to an ongoing request when <code>{partial_upload,
  WindowSize}</code> is used and no <code>Content-Length</code> was specified. The default
  timout <code>infinity</code> will be used. Plase note that after this the request is
  considered complete and the response will be read from the socket.
  Would be the same as calling
  <code>send_trailers(UploadState, BodyPart, infinity)</code>.</p>
</div></div>
<div class="function">
<h3 id="send_trailers/3">send_trailers(UploadState, Trailers, Timeout) -&gt; Result</h3>

<ul class="type">
<li><code>Trailers = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li><li><code>Timeout = integer() | infinity</code></li><li><code>Result = {ok, {{StatusCode, ReasonPhrase}, Hdrs, ResponseBody}} | {error, Reason}</code></li><li><code>Reason = connection_closed | connect_timeout | timeout</code></li></ul>
<div class="description">

<p>Sends trailers to an ongoing request when
  <code>{partial_upload, WindowSize}</code> is used and no <code>Content-Length</code> was
  specified.
  <code>Timeout</code> is the timeout for sending the trailers and reading the  
response in milliseconds.</p>
 
  <p>Sending trailers also signals the end of the entity body, which means
  that no more body parts, or trailers can be sent and the response to the
  request will be read from the socket. If no response is received within
  <code>Timeout</code> milliseconds the request is canceled and <code>{error, timeout}</code> is
  returned.</p>
</div></div>
<div class="function">
<h3 id="get_body_part/1">get_body_part(HTTPClient::pid()) -&gt; Result</h3>

<ul class="type">
<li><code>Result = {ok, BodyPart} | {ok, {http_eob, Trailers}}</code></li><li><code>BodyPart = binary()</code></li><li><code>Trailers = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li></ul>
<div class="description">

<p>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used. The default timeout,
  <code>infinity</code> will be used.
  Would be the same as calling
  <code>get_body_part(HTTPClient, infinity)</code>.</p>
</div></div>
<div class="function">
<h3 id="get_body_part/1-1">get_body_part(HTTPClient::pid(), Timeout) -&gt; Result</h3>

<ul class="type">
<li><code>Timeout = integer() | infinity</code></li><li><code>Result = {ok, BodyPart} | {ok, {http_eob, Trailers}}</code></li><li><code>BodyPart = binary()</code></li><li><code>Trailers = [{Header, Value}]</code></li><li><code>Header = string() | binary() | atom()</code></li><li><code>Value = string() | binary()</code></li></ul>
<div class="description">

<p>Reads a body part from an ongoing response when
  <code>{partial_download, PartialDownloadOptions}</code> is used.
  <code>Timeout</code> is the timeout for reading the next body part in milliseconds.
  <code>http_eob</code> marks the end of the body. If there were Trailers in the
  response those are returned with <code>http_eob</code> as well.
  If it evers returns an error, no further calls to this function should
  be done.</p>
</div></div></div>

<authors>

<aname>Oscar Hellström</aname>
<email>oscar@hellstrom.st</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
