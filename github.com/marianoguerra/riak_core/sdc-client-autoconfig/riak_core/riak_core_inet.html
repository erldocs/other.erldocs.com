<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_core_inet (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_core_inet</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-binding">binding() = {<a href="#type-ip_address" class="seealso">ip_address()</a>, <a href="#type-portnum" class="seealso">portnum()</a>}</h3></div>
    <div class="type"><h3 id="type-cidr">cidr() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-ifaddr">ifaddr() = {string(), [<a href="#type-ifopt" class="seealso">ifopt()</a>]}</h3></div>
    <div class="type"><h3 id="type-ifflag">ifflag() = up<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| broadcast<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| loopback<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| pointtopoint<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| running<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| multicast</h3></div>
    <div class="type"><h3 id="type-ifopt">ifopt() = {flag, [<a href="#type-ifflag" class="seealso">ifflag()</a>]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {addr, <a href="#type-ip_address" class="seealso">ip_address()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {netmask, <a href="#type-ip_address" class="seealso">ip_address()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {broadaddr, <a href="#type-ip_address" class="seealso">ip_address()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {dstaddr, <a href="#type-ip_address" class="seealso">ip_address()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {hwaddr, [byte()]}</h3></div>
    <div class="type"><h3 id="type-ip_address">ip_address() = <a href="inet.html#type-ip_address" class="seealso">inet:ip_address()</a></h3></div>
    <div class="type"><h3 id="type-ipv6_class">ipv6_class() = loopback<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| unspecified<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {ipv4_mapped, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {ipv4_compatible, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {link_local, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {site_local, bitstring(), binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {documentation, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {'6to4', binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {orchid, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {multicast, atom(), atom(), binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, binary()}</h3></div>
    <div class="type"><h3 id="type-maybe">maybe(T) = T | undefined</h3></div>
    <div class="type"><h3 id="type-portnum">portnum() = <a href="inet.html#type-port_number" class="seealso">inet:port_number()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="valid_host_ip/1">valid_host_ip(IP::string() | ip_address()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="normalize_ip/1">normalize_ip(IP::string() | ip_address()) -&gt; {ok, ip_address()}</h3>


<div class="description">

<p>Convert IP address the tuple form</p>
</div></div>
<div class="function">
<h3 id="determine_netmask_len/1">determine_netmask_len(Ifaddrs::[ifaddr()], SeekIP::string() | ip_address()) -&gt; maybe(pos_integer())</h3>


<div class="description">

<p>Given the result of inet:getifaddrs() and an IP a client has
       connected to, attempt to determine the appropriate subnet mask.  If
       the IP the client connected to cannot be found, undefined is returned.</p>
</div></div>
<div class="function">
<h3 id="addr_to_binary/1">addr_to_binary(X1::ip_address()) -&gt; binary()</h3>


<div class="description">

<p>Turns an IP address tuple into its equivalent binary format.</p>
</div></div>
<div class="function">
<h3 id="cidr_len/1">cidr_len(Bin::binary()) -&gt; cidr()</h3>


<div class="description">

<p>Given a netmask as a binary, return the CIDR length.</p>
</div></div>
<div class="function">
<h3 id="mask_address/1">mask_address(Addr::ip_address(), Maskbits::cidr()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>Get the subnet mask as an integer, stolen from an old post on
       erlang-questions.</p>
</div></div>
<div class="function">
<h3 id="rfc1918/1">rfc1918(IP::ip_address()) -&gt; pos_integer() | false</h3>


<div class="description">

<p>return RFC1918 mask for IP or false if not in RFC1918 range</p>
</div></div>
<div class="function">
<h3 id="is_rfc1918/1">is_rfc1918(IP::ip_address()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_matching_address/1">get_matching_address(IP::ip_address(), CIDR::cidr(), Listener::binding() | [binding()]) -&gt; maybe(binding())</h3>


<div class="description">

<p>Find the right address to serve given the IP the node connected to.
       Ideally, it will choose an IP in the same subnet, but it will fall
       back to the 'closest' subnet (at least up to a class A). Then it will
       just try to find anything that matches the IP's RFC 1918 status (ie.
       public or private). Localhost will never be 'guessed', but it can be
       directly matched.</p>
</div></div>
<div class="function">
<h3 id="get_matching_address/1-1">get_matching_address(IP::ip_address(), CIDR::cidr(), MyIPs::[ifaddr()], Tail::binding() | [binding()]) -&gt; maybe(binding())</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="v6_routable/1">v6_routable(X1::ipv6_class(), X2::ipv6_class()) -&gt; boolean()</h3>


<div class="description">

<p>Guesses whether two addresses are routable based on their
       address class and configuration. Even if this returns true,
       two addresses may not be routable, additional information will
       need to be checked.</p>
</div></div>
<div class="function">
<h3 id="classify_v6/1">classify_v6(Addr::string() | binary() | ipv6_address() (see module inet)) -&gt; ipv6_class()</h3>


<div class="description">

<p>Classifies an IPv6 address according to the numerous RFCs on
       the topic. This will return an atom (in the case of singleton
       addresses) or a tuple where the first element is atom of the
       class name.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
