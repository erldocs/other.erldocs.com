<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>pose_code (pose) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>pose_code</h1>
<h2 class="modsummary">Intuitive module loader, used by pose_command.</h2>
<div class="description">
<p>Intuitive module loader, used by <a href="pose_command.html" class="seealso">pose_command</a>.  Only loads
  one module at a time.  Use <a href="pose_command.html#load_command/1" class="seealso">pose_command:load_command/1</a> to  
load a command inclusive of any submodules.</p>
 
  <list>
  <item><p> <a href="#Basic_Load_Process" class="seealso">Basic Load Process</a> </p></item>
  <item><p> <a href="#Purge_Handling" class="seealso">Purge Handling</a> </p></item>
  <item><p> <a href="#Warnings" class="seealso">Warnings</a> </p></item>
  <item><p> <a href="#Packaged_Modules" class="seealso">Packaged Modules</a> </p></item>
  <item><p> <a href="#Pose_Namespace" class="seealso">Pose Namespace</a> </p></item>
  </list>
 
  <p><em><marker id="Basic_Load_Process">Basic Load Process</marker></em></p>
 
  <p>Each Erlang module is treated as a potential executable command in <code>pose</code>.
  A call to <code>pose_code:load_module/1` results in a search of the
  directories listed on the current `PATH</code> environment variable, with a  
twist:</p>
 
  <p>For each directory on <code>PATH</code> that ends in <code>ebin\</code>, and for which the
  current user has write access, <code>pose</code> will look for a parallel <code>src\</code>
  directory, and if found, search for a matching <code>.erl</code> file therein.</p>
 
  <p>If an associated <code>.erl</code> file is found, and it is newer that the <code>.beam</code>
  file, or if an <code>.erl</code> file is found for which no <code>.beam</code> file appears,
  the <code>.erl</code> file will be compiled to its <code>ebin\</code> directory.  If this  
compilation is successful, the module will be loaded.  
Otherwise, an error is returned.</p>
 
  <p>If no associated <code>.erl</code> file is found, the <code>.beam</code> file on the <code>PATH</code>
  is loaded.  If no <code>.beam</code> file is found, the search continues to the
  next directory on <code>PATH</code>, returning an error if no <code>.beam</code> file can be
  found or compiled from source before the <code>PATH</code> is exhausted.</p>
 
  <p><em><marker id="Purge_Handling">Purge Handling</marker></em></p>
 
  <p>Whenever a new binary is obtained by <code>pose_code</code>, a <code>code:soft_purge/1</code>
  is called, and on a <code>true</code> result, current code for the binary is made
  old (<code>code:delete/1</code>) and the binary is loaded as current code.</p>
 
  <p>In the event of a <code>false</code> result from <code>code:soft_purge/1</code>, a message is
  broadcast to all active processes of the form
  <code>{purging, PurgePid, Module}</code>, where 'PurgePid' is the <code>pid()</code> of the  
process initiating the purge, and 'Module' is the atom identifying the  
module to be purged.</p>
 
  <p>In order to take advantage of this broadcast, and escape being killed
  for lingering in old code, <code>pose</code>-compatible modules should begin with
  a case clause in message loops to respond to <code>purging</code> messages with a  
fully-qualified call to the loop function.  As per the following example:</p>
 
  <pre class="sh_erlang">
  loop(...) -&gt;
    receive
      {purging, _Pid, _Mod} -&gt; ?MODULE:loop(...);
                    *     *     *
    end.
  </pre>
 
  <p><em><marker id="Warnings">Warnings</marker></em></p>
 
  <p>Load may return successfully with either a 2-tuple, <code>{module, Module}</code>
  or a 3-tuple <code>{module, Module, Warning}</code>.  In the later case, the
  <code>Warning</code> may be either of:</p>
 
  
   <code>flat_pkg</code> 
   The module was compiled under Erlang's flat namespace, and no
       <code>-package</code> directive was found indicating that <code>pose</code> could
       recompile the module under the <a href="#Pose_Namespace" class="seealso">Pose Namespace</a>.
       Flat-package modules are considered unsafe, as there may be
       other module binaries or source files with the same name elsewhere
       in the file system.<br />
   <code>diff_path</code> 
   The module was compiled under a namespace that matches the namespace
       of old code loaded from a different file path.  That is, the current
       and old code in the system originate from different points in the
       file system.  Such a <i>namespace collision</i> can occur when
       flat-package modules with the same name are loaded from different
       points in the file system.<br />
  
 
  <p><em><marker id="Packaged_Modules">Packaged Modules</marker></em></p>
 
  <p>Erlang provides for namespace management through an experimental
  packages feature.  As implemented in Erlang, the package of a module
  is expressed as a dot-separated path in the <code>-module</code> directive.
  For instance, a package <code>fum</code> in the <code>fee.foo</code> package (where <code>fee.foo</code>
  is a subpackage of <code>fee</code>), would be declared as:</p>
 
  <pre class="sh_erlang">
  -module(fee.foo.fum).
  </pre>
 
  <p>The package hierarchy, in turn, corresponds to the file hierarchy of
  a module relative to the current code path.  So, continuing our example,
  if the current code path includes <code>/home/user/project/ebin</code>, the
  compiled <code>fee.foo.fum</code> module would traditionally be sought at
  <code>/home/user/project/ebin/fee/foo/fum.beam</code>.</p>
 
  <p><em><marker id="Pose_Namespace">Pose Namespace</marker></em></p>
 
  <p>Unlike standard Erlang, <code>pose</code> looks for a module by unpackaged filename,
  and upon finding such a file, loads it, returning the fully-qualified
  packaged module name.  This means that <code>pose</code> would look for <code>fum</code> (per
  our example above), as <code>/home/user/project/ebin/fum.beam</code>, and then
  upon successfully loading same, would return
  <code>{module, 'fee.foo.fum'}</code>.</p>
 
  <p>Additionally, <code>pose</code> uses a <code>-package</code> directive to identify
  <code>pose</code>-compatible files that have been compiled in the flat namespace
  standard to Erlang and then recompile those files with a package
  assigned by <code>pose</code> so as to ensure that each such package is uniqely  
identified in the namespace of the currently running node.</p>
 
  <p>Users can take advantage of the <code>-package</code> directive by including the
  following pattern in their <code>pose</code>-compatible modules.</p>
 
  <pre class="sh_erlang">
  -define(module, fum).
 
  % BEGIN POSE PACKAGE PATTERN
  -ifndef(package).
  -module(?module).
  -package(default).
  -else.
  -module(?package.?module).
  -package(?package).
  -endif.
  % END POSE PACKAGE PATTERN
  </pre>
 
  <p>A similar pattern is used to facilitiate calls to functions of Erlang/OTP
  libraries and other user modules.  In addition to being considered woefully
  bad practice--as it imports all exported functions of another module into
  the current module's namespace--the <code>import/1</code> compiler directive was  
dropped entirely as of R16A01, its only real purpose having been as a  
kludge to enable packages to call functions in unpackaged modules.</p>
 
  <p>For the purposes of <code>pose</code>-compatible modules, we make our <code>import/1</code>
  directives conditional.  They are safely ignored by development tools and
  standard compilation, only coming into play as a function of just-in-time
  packaging when <code>pose</code> is running under Erlang/OTP R15.</p>
 
  <pre class="sh_erlang">
  % BEGIN POSE PACKAGE IMPORTS
  -ifdef(package).
  -import(gen_command).
  -endif.
  % END POSE PACKAGE IMPORTS
  </pre>
 
  <p>When <code>pose</code> sees that a module has been compiled with a <code>-package</code>
  attribute of <code>default</code>, it recompiles the module with the macro <code>?package</code>  
set to a path unique to that module and the other modules in the same  
directory.</p>
 
  <p>This allows modules to be developed in the flat namespace recognized by
  all existing Erlang development tools, while ensuring that those same
  modules will run in their own unique namespace when loaded in a
  <code>pose</code>-compatible system.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-directory">directory() = <a href="file.html#type-filename" class="seealso">file:filename()</a></h3></div>
    <div class="type"><h3 id="type-error">error() = atom() | {atom(), <a href="#type-error" class="seealso">error()</a>}</h3></div>
    <div class="type"><h3 id="type-load_err">load_err() = {load, <a href="#type-error" class="seealso">error()</a>} | {slurp, <a href="#type-error" class="seealso">error()</a>} | <a href="#type-error" class="seealso">error()</a></h3></div>
    <div class="type"><h3 id="type-load_mod_rtn">load_mod_rtn() = {module, module()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {module, module(), <a href="#type-load_warn" class="seealso">load_warn()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {error, <a href="#type-load_err" class="seealso">load_err()</a>}</h3></div>
    <div class="type"><h3 id="type-load_warn">load_warn() = diff_path | flat_pkg</h3></div>
    <div class="type"><h3 id="type-search_path">search_path() = [<a href="#type-directory" class="seealso">directory()</a>]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="load_module/1">load_module(Command::command() (see module pose), Path::search_path()) -&gt; load_mod_rtn()</h3>


<div class="description">

<p>Locate command on search path supplied by <code>Path</code> parameter,
  compiling and loading updated module as necessary.</p>
</div></div></div>

<authors>

<aname>Beads D. Land-Trujillo</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
