<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>folded_int (folded_int) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>folded_int</h1>
<h2 class="modsummary">Handles the encoding and decoding of folded integers in binary strings.</h2>
<div class="description">
<p>Handles the encoding and decoding of folded integers in binary strings. A folded integer is  
an integer that is encoded into a variable-length byte sequence, depending on its value. Smaller  
values consume less bytes.</p>
 
  <p><em><marker id="Format">Format</marker></em></p>
 
  <p>The format of a folded integer is a variable number of segment bytes. Each segment byte consists  
of one carry bit and seven value bits. The carry bit is the high-order bit and the value is  
stored in the seven least significant bits. If written as a C struct, a segment byte would look  
like this:</p>
 
  <pre class="sh_erlang">  typedef struct {
    union {
      struct {
        unsigned value:7;
        unsigned carry:1;
      };
      uint8_t bits;
    };
  } fi_segment_t;</pre>
 
  <p>To encode an integer, the integer is broken up into seven-bit segments and written in  
little-endian byte order (LSB first). Each byte, except for the last one, will have the carry bit  
set. The last byte (containing the most significant bits) does not have the carry bit set, which  
demarcates the end of a folded integer in a binary.</p>
 
  <p><em><marker id="Encoding_Example">Encoding Example</marker></em></p>
 
  <p>To help understand the format of a folded integer, here is an example of encoding the value
  <code>16#DEADBEEF</code> as a folded integer.</p>
 
   <list>
     <item><p>       
Begin by considering the value's binary representation:</p>
 
       <pre class="sh_erlang">11011110 10101101 10111110 11101111</pre>
    </item>
    <item><p>       
Next, divide the value into seven-bit segments:</p>
 
       <pre class="sh_erlang"><em>000</em>1101 1110101 0110110 1111101 1101111</pre>
 
       The high-order bits need to be padded with zeros (shown in bold) to make each segment
       contain seven bits.
    </item>
    <item><p>       
Before being written to a binary, carry bits (shown in bold) must be added to each segments.       
Note that each segment except for the one containing the high-order bits has its carry bit       
set.</p>
 
       <pre class="sh_erlang"><em>0</em>0001101 <em>1</em>1110101 <em>1</em>0110110 <em>1</em>1111101 <em>1</em>1101111</pre>
    </item>
    <item><p>       
The bytes have to be reversed before being serialized in order match the little-endian       
format:</p>
 
       <pre class="sh_erlang">11101111 11111101 10110110 11110101 00001101</pre>
 
       All that's left to do is send the bytes whereever they need to be serialized.
     </item>
  </list>
 
  <p>In the above example, <code>16#DEADBEEF</code> serializes to <code>16#EFFDB6F50D</code>, which consumes an extra byte
  when compared to its 32-bit representation (but three less bytes when compared to its 64-bit
  representation).  Smaller numbers, such as <code>42</code> consume less space than their 32- or 64-bit
  representations. In fact, any number smaller than <code>2,097,152</code> will consume less space than a full  
32-bit integer.</p>
 
 
  <p><em><marker id="Limitations">Limitations</marker></em></p>
 
  <p>The <code>folded_int</code> module currently only handles unsigned integers. To use signed integers, you
  must map them to unsigned integers using something like zig-zag encoding. There is also no
  attempt to protect against malicious binary strings, such as an endless sequence of bit segments
  with the carry bits set.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="consume/1">consume(X::binary()) -&gt; {pos_integer(), binary()} | false</h3>


<div class="description">

<p>Consumes a folded integer from a binary string.</p>
 
  <p>It returns a tuple consisting of the decoded integer and the rest of the binary string. For  
example:</p>
 
     <pre class="sh_erlang">     {Int, Tail} = folded_int:consume(&lt;&lt;0:1, 42:7, "foo"&gt;&gt;).
     Int.  % =&gt; 42
     Tail. % =&gt; &lt;&lt;"foo"&gt;&gt;</pre>
 
  <p>If a folded integer can't be consumed from the binary string, then it returns <code>false</code>. This
  happens when the binary string is empty (<code>&lt;&lt;&gt;&gt;</code>) or contains an incomplete folded integer (all
  the carry bits are set).  If the binary string contains exactly one folded integer with no extra
  bytes, the return value will be the decoded integer and an empty binary string (<code>{N, &lt;&lt;&gt;&gt;}</code>).</p>
 
  <p><em>Warning:</em> No attempt is made to protect against overflows in the case of a long
  string of bytes with set carry bits.</p>
</div></div>
<div class="function">
<h3 id="encode/1">encode(N::pos_integer()) -&gt; binary()</h3>


<div class="description">

<p>Encodes an integer as a variable-length binary string.</p>
 
     <pre class="sh_erlang">        folded_int:encode(42). % =&gt; &lt;&lt;0:1, 42:7&gt;&gt;</pre>
</div></div>
<div class="function">
<h3 id="decode/1">decode(X::binary()) -&gt; pos_integer()</h3>


<div class="description">

<p>Decodes an integer from a variable-length binary string. The binary string passed as an
  argument must be a valid folded integer. If the binary is missing any bytes or contains extra
  bytes, <code>decode/1</code> will throw an error. If you need to consume folded integers from a binary
  string of unknown length, use <a href="#consume/1" class="seealso">consume/1</a> instead.</p>
 
     <pre class="sh_erlang">     folded_int:decode(&lt;&lt;1:1, 0:7, 0:1, 2:7&gt;&gt;).  % =&gt; 256
     folded_int:decode(&lt;&lt;1:1, 0:7&gt;&gt;).            % =&gt; error (underflow)
     folded_int:decode(&lt;&lt;0:0, 42:7, "foo"&gt;&gt;).    % =&gt; error (overflow)</pre>
</div></div></div>

<authors>

<aname>David Cuddeback</aname>
<email>david@astoundlabs.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
