<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cow_http_hd (cowlib) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>cow_http_hd</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-etag">etag() = {weak | strong, binary()}</h3></div>
    <div class="type"><h3 id="type-media_type">media_type() = {binary(), binary(), [{binary(), binary()}]}</h3></div>
    <div class="type"><h3 id="type-qvalue">qvalue() = 0..1000</h3></div>
    <div class="type"><h3 id="type-websocket_version">websocket_version() = 0..255</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="parse_accept/1">parse_accept(Accept::binary()) -&gt; [{media_type(), qvalue(), [binary() | {binary(), binary()}]}]</h3>


<div class="description">

<p>Parse the Accept header.</p>
</div></div>
<div class="function">
<h3 id="parse_accept_charset/1">parse_accept_charset(Charset::binary()) -&gt; [{binary(), qvalue()}]</h3>


<div class="description">

<p>Parse the Accept-Charset header.</p>
</div></div>
<div class="function">
<h3 id="parse_accept_encoding/1">parse_accept_encoding(Encoding::binary()) -&gt; [{binary(), qvalue()}]</h3>


<div class="description">

<p>Parse the Accept-Encoding header.</p>
</div></div>
<div class="function">
<h3 id="parse_accept_language/1">parse_accept_language(LanguageRange::binary()) -&gt; [{binary(), qvalue()}]</h3>


<div class="description">

<p>Parse the Accept-Language header.</p>
</div></div>
<div class="function">
<h3 id="parse_accept_ranges/1">parse_accept_ranges(AcceptRanges::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Accept-Ranges header.</p>
</div></div>
<div class="function">
<h3 id="parse_age/1">parse_age(Age::binary()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>Parse the Age header.</p>
</div></div>
<div class="function">
<h3 id="parse_allow/1">parse_allow(Allow::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Allow header.</p>
</div></div>
<div class="function">
<h3 id="parse_authorization/1">parse_authorization(X1::binary()) -&gt; {basic, binary(), binary()} | {bearer, binary()} | {digest, [{binary(), binary()}]}</h3>


<div class="description">

<p>Parse the Authorization header.</p>
 
  <p>We support Basic, Digest and Bearer schemes only.</p>
 
  <p>In the Digest case we do not validate that the mandatory
  fields are present. When parsing auth-params, we do not
  accept BWS characters around the "=".</p>
</div></div>
<div class="function">
<h3 id="parse_cache_control/1">parse_cache_control(CacheControl::binary()) -&gt; [binary() | {binary(), binary()} | {binary(), non_neg_integer()} | {binary(), [binary()]}]</h3>


<div class="description">

<p>Parse the Cache-Control header.</p>
 
  <p>In the fields list case, we do not support escaping, which shouldn't be needed anyway.</p>
</div></div>
<div class="function">
<h3 id="parse_connection/1">parse_connection(Connection::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Connection header.</p>
</div></div>
<div class="function">
<h3 id="parse_content_encoding/1">parse_content_encoding(ContentEncoding::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Content-Encoding header.</p>
</div></div>
<div class="function">
<h3 id="parse_content_language/1">parse_content_language(ContentLanguage::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Content-Language header.</p>
 
  <p>We do not support irregular deprecated tags that do not match the ABNF.</p>
</div></div>
<div class="function">
<h3 id="parse_content_length/1">parse_content_length(ContentLength::binary()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>Parse the Content-Length header.</p>
 
  <p>The value has at least one digit, and may be followed by whitespace.</p>
</div></div>
<div class="function">
<h3 id="parse_content_range/1">parse_content_range(X1::binary()) -&gt; {bytes, non_neg_integer(), non_neg_integer(), non_neg_integer() | '*'} | {bytes, '*', non_neg_integer()} | {binary(), binary()}</h3>


<div class="description">

<p>Parse the Content-Range header.</p>
</div></div>
<div class="function">
<h3 id="parse_content_type/1">parse_content_type(X1::binary()) -&gt; media_type()</h3>


<div class="description">

<p>Parse the Content-Type header.</p>
</div></div>
<div class="function">
<h3 id="parse_date/1">parse_date(Date::binary()) -&gt; datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the Date header.</p>
</div></div>
<div class="function">
<h3 id="parse_etag/1">parse_etag(X1::binary()) -&gt; etag()</h3>


<div class="description">

<p>Parse the ETag header.</p>
</div></div>
<div class="function">
<h3 id="parse_expect/1">parse_expect(X1::binary()) -&gt; continue</h3>


<div class="description">

<p>Parse the Expect header.</p>
</div></div>
<div class="function">
<h3 id="parse_expires/1">parse_expires(Expires::binary()) -&gt; datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the Expires header.</p>
 
  <p>Recipients must interpret invalid date formats as a date
  in the past. The value "0" is commonly used.</p>
</div></div>
<div class="function">
<h3 id="parse_host/1">parse_host(Host::binary()) -&gt; {binary(), 0..65535 | undefined}</h3>


<div class="description">

<p>Parse the Host header.</p>
 
  <p>We only seek to have legal characters and separate the  
host and port values. The number of segments in the host  
or the size of each segment is not checked.</p>
 
  <p>There is no way to distinguish IPv4 addresses from regular  
names until the last segment is reached therefore we do not  
differentiate them.</p>
 
  <p>The following valid hosts are currently rejected: IPv6
  addresses with a zone identifier; IPvFuture addresses;
  and percent-encoded addresses.</p>
</div></div>
<div class="function">
<h3 id="parse_if_match/1">parse_if_match(IfMatch::binary()) -&gt; '*' | [etag()]</h3>


<div class="description">

<p>Parse the If-Match header.</p>
</div></div>
<div class="function">
<h3 id="parse_if_modified_since/1">parse_if_modified_since(IfModifiedSince::binary()) -&gt; datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the If-Modified-Since header.</p>
</div></div>
<div class="function">
<h3 id="parse_if_none_match/1">parse_if_none_match(IfNoneMatch::binary()) -&gt; '*' | [etag()]</h3>


<div class="description">

<p>Parse the If-None-Match header.</p>
</div></div>
<div class="function">
<h3 id="parse_if_range/1">parse_if_range(IfRange::binary()) -&gt; etag() | datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the If-Range header.</p>
</div></div>
<div class="function">
<h3 id="parse_if_unmodified_since/1">parse_if_unmodified_since(IfModifiedSince::binary()) -&gt; datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the If-Unmodified-Since header.</p>
</div></div>
<div class="function">
<h3 id="parse_last_modified/1">parse_last_modified(LastModified::binary()) -&gt; datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the Last-Modified header.</p>
</div></div>
<div class="function">
<h3 id="parse_max_forwards/1">parse_max_forwards(MaxForwards::binary()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>Parse the Max-Forwards header.</p>
</div></div>
<div class="function">
<h3 id="parse_pragma/1">parse_pragma(X1::binary()) -&gt; cache | no_cache</h3>


<div class="description">

<p>Parse the Pragma header.</p>
 
  <p>Legacy header kept for backward compatibility with HTTP/1.0 caches.  
Only the "no-cache" directive was ever specified, and only for  
request messages.</p>
 
  <p>We take a large shortcut in the parsing of this header, expecting
  an exact match of "no-cache".</p>
</div></div>
<div class="function">
<h3 id="parse_proxy_authenticate/1">parse_proxy_authenticate(ProxyAuthenticate::binary()) -&gt; [{basic, binary()} | {bearer | digest | binary(), [{binary(), binary()}]}]</h3>


<div class="description">

<p>Parse the Proxy-Authenticate header.</p>
 
  <p>Alias of parse_www_authenticate/1 due to identical syntax.</p>
</div></div>
<div class="function">
<h3 id="parse_proxy_authorization/1">parse_proxy_authorization(ProxyAuthorization::binary()) -&gt; {basic, binary(), binary()} | {bearer, binary()} | {digest, [{binary(), binary()}]}</h3>


<div class="description">

<p>Parse the Proxy-Authorization header.</p>
 
  <p>Alias of parse_authorization/1 due to identical syntax.</p>
</div></div>
<div class="function">
<h3 id="parse_range/1">parse_range(X1::binary()) -&gt; {bytes, [{non_neg_integer(), non_neg_integer() | infinity} | neg_integer()]} | {binary(), binary()}</h3>


<div class="description">

<p>Parse the Range header.</p>
</div></div>
<div class="function">
<h3 id="parse_retry_after/1">parse_retry_after(RetryAfter::binary()) -&gt; non_neg_integer() | datetime() (see module calendar)</h3>


<div class="description">

<p>Parse the Retry-After header.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_accept/1">parse_sec_websocket_accept(SecWebSocketAccept::binary()) -&gt; binary()</h3>


<div class="description">

<p>Dummy parsing function for the Sec-WebSocket-Accept header.</p>
 
  <p>The argument is returned without any processing. This value is
  expected to be matched directly by the client so no parsing is
  needed.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_extensions/1">parse_sec_websocket_extensions(SecWebSocketExtensions::binary()) -&gt; [{binary(), [binary() | {binary(), binary()}]}]</h3>


<div class="description">

<p>Parse the Sec-WebSocket-Extensions request header.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_key/1">parse_sec_websocket_key(SecWebSocketKey::binary()) -&gt; binary()</h3>


<div class="description">

<p>Dummy parsing function for the Sec-WebSocket-Key header.</p>
 
  <p>The argument is returned without any processing. This value is
  expected to be prepended to a static value, the result of which
  hashed to form a new base64 value returned in Sec-WebSocket-Accept,
  therefore no parsing is needed.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_protocol_req/1">parse_sec_websocket_protocol_req(SecWebSocketProtocol::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Sec-WebSocket-Protocol request header.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_protocol_resp/1">parse_sec_websocket_protocol_resp(X1::binary()) -&gt; binary()</h3>


<div class="description">

<p>Parse the Sec-Websocket-Protocol response header.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_version_req/1">parse_sec_websocket_version_req(SecWebSocketVersion::binary()) -&gt; websocket_version()</h3>


<div class="description">

<p>Parse the Sec-WebSocket-Version request header.</p>
</div></div>
<div class="function">
<h3 id="parse_sec_websocket_version_resp/1">parse_sec_websocket_version_resp(SecWebSocketVersion::binary()) -&gt; [websocket_version()]</h3>


<div class="description">

<p>Parse the Sec-WebSocket-Version response header.</p>
</div></div>
<div class="function">
<h3 id="parse_te/1">parse_te(TE::binary()) -&gt; {trailers | no_trailers, [{binary(), qvalue()}]}</h3>


<div class="description">

<p>Parse the TE header.</p>
 
  <p>This function does not support parsing of transfer-parameter.</p>
</div></div>
<div class="function">
<h3 id="parse_trailer/1">parse_trailer(Trailer::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Trailer header.</p>
</div></div>
<div class="function">
<h3 id="parse_transfer_encoding/1">parse_transfer_encoding(TransferEncoding::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Transfer-Encoding header.</p>
 
  <p>This function does not support parsing of transfer-parameter.</p>
</div></div>
<div class="function">
<h3 id="parse_upgrade/1">parse_upgrade(Upgrade::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the Upgrade header.</p>
 
  <p>It is unclear from the RFC whether the values here are  
case sensitive.</p>
 
  <p>We handle them in a case insensitive manner because they
  are described as case insensitive in the Websocket RFC.</p>
</div></div>
<div class="function">
<h3 id="parse_vary/1">parse_vary(Vary::binary()) -&gt; '*' | [binary()]</h3>


<div class="description">

<p>Parse the Vary header.</p>
</div></div>
<div class="function">
<h3 id="parse_www_authenticate/1">parse_www_authenticate(Authenticate::binary()) -&gt; [{basic, binary()} | {bearer | digest | binary(), [{binary(), binary()}]}]</h3>


<div class="description">

<p>Parse the WWW-Authenticate header.</p>
 
  <p>Unknown schemes are represented as the lowercase binary  
instead of an atom. Unlike with parse_authorization/1,  
we do not crash on unknown schemes.</p>
 
  <p>When parsing auth-params, we do not accept BWS characters around the "=".</p>
</div></div>
<div class="function">
<h3 id="parse_x_forwarded_for/1">parse_x_forwarded_for(XForwardedFor::binary()) -&gt; [binary()]</h3>


<div class="description">

<p>Parse the X-Forwarded-For header.</p>
 
  <p>This header has no specification but *looks like* it is  
a list of tokens.</p>
 
  <p>This header is deprecated in favor of the Forwarded header.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
