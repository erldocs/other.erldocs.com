<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>yazl (zipperl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>yazl</h1>
<h2 class="modsummary">YAZL 'yazzle' (Yet Another Zipper List): 
A mutable list with a current focus position.</h2>
<div class="description">
<p>YAZL '<i>yazzle</i>' (Yet Another Zipper List): 
A mutable list with a current focus position.</p>

 <p>A yazl supports operations normally found in 
mutable doubly-linked lists, such as read, update, 
insert, delete and incremental bi-directional traversal. 
Local operations in the neighbourhood of the focus 
are executed in O(1) constant time. 
The yazl also provides global operations and index-based 
random access, typically with an O(n) performance penalty.</p>

 <p>The focus may be between two elements of the list, or at one of the ends.
 The descriptions used here are slightly different from a true zipper,
 because the focus is between elements, not at a current element
 [<i>Functional Pearl: The Zipper</i>, GÃ©rard Huet, 1997].</p>

 <p>We describe lists as being ordered left-to-right,
 like western writing, with the excuse that this bias is already
 present in Erlang with the names <i>foldl</i>, <i>foldr</i>.</p>

 <p>The position of the current element is either a 1-based positive integer,
 or an end marker: <code>endl</code>, for the beginning, or <code>endr</code> for the end. 
The current value is after (to the right of) the focus, if it exists. 
There is no current value for empty lists, 
or non-empty lists with the focus after the right end.</p>

 <p>Functions on single values and lists of values are not overloaded,
 they are given distinct names (<i>e.g.</i><code>insert</code>/<code>inserts</code>),
 so that yazls can have lists as regular elements
 (<i>i.e.</i> lists of lists).</p>

 <em><marker id="Usage">Usage</marker></em>

 <em><marker id="Create,_Import,_Export">Create, Import, Export</marker></em>

 <p>Create yazls from lists using <code>new</code>, <code>from_list</code> and <code>from_lists</code>.
 Test if a term appears to be a yazl with <code>is_yazl</code>.
 Recover the underlying list with <code>to_list</code>.</p>

 <em><marker id="Query">Query</marker></em>

 <p>Test if the yazl is empty with <code>is_empty</code>.
 Get the total length of the underlying list using <code>size</code>.
 Read the value at the current focus position using <code>get</code> or <code>gets</code>.
 Find the current focus location using <code>position</code>, 
which may return a 1-based integer index, or an ending marker.</p>

 <em><marker id="Move">Move</marker></em>

 <p>Movement functions change the focus position,
 but do not change the content of the list.
 Movements return special flags <code>endl</code> or <code>endr</code>
 if an operation would take the focus
 beyond the beginning or end of the list.
 Client code can implement cyclic behaviour by using
 these flags in conjunction with the <code>moveto</code> function.</p>

 <p>Move the focus with <code>move</code>, <code>moves</code>, <code>moveto</code>.
 The <code>move</code> function changes focus to the next or previous elements.
 The <code>moves</code> function jumps multiple steps relative to the current focus.
 The <code>moveto</code> function jump to absolute positions based on 
a specific index, or the beginning or end of the list.</p>

 <em><marker id="Search">Search</marker></em>

 <p>Move the focus by searching with <code>find</code>, <code>finds</code>,
 <code>moveuntil</code> and <code>movewhile</code>.
 The <code>find</code> function will search for the next or previous
 occurrence of a value. The <code>finds</code> function searches for the
 next or previous occurrence of a sequence of values.
 The <code>moveuntil</code> (<code>movewhile</code>) functions search until a 
boolean predicate function of the current value becomes true (false).</p>

 <em><marker id="Update">Update</marker></em>

 <p>Write the value at the current focus position using <code>set</code>.</p>

 <p>Add new values on either side of the current focus,
 or at the head or tail of the underlying list, using
 <code>insert</code> and <code>inserts</code>.</p>

 <p>Delete the element at the current focus position using <code>delete</code>.
 Delete from the focus to one of the ends using the <code>truncate</code>.</p>

 <p>Reverse the whole list while keeping the same focus
 using <code>reverse</code> - note this is constant time O(1).</p>

 <em><marker id="Function_Application">Function Application</marker></em>

 <p>Apply a <i>map</i> function while leaving the focus unchanged.</p>

 <em><marker id="Efficiency">Efficiency</marker></em>

 <p>The implementation is efficient constant time, O(1):
 for local operations at the focus: <br />
 <code>new, from_list/1, move, get, set, insert,
  delete, reverse, truncate</code>.</p>

 <p>Incremental operations will incur a cost proportional
 to the distance from the focus to the target position:<br />
 <code>from_list/2, from_lists, gets, sets, moves, moveto, moveuntil,
 find, finds, inserts</code>.</p>

 Global operations will incur a cost proportional to the
 length of the underlying list O(n): <br />
 <code>to_list, size, position</code>.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-direction">direction() = ldir | rdir</h3></div>
    <div class="type"><h3 id="type-empty_yazl">empty_yazl() = {[], []}</h3></div>
    <div class="type"><h3 id="type-ending">ending() = endl | endr</h3></div>
    <div class="type"><h3 id="type-index">index() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-maybe">maybe(A) = ending() | A</h3></div>
    <div class="type"><h3 id="type-position">position() = <a href="#type-maybe" class="seealso">maybe</a>(<a href="#type-index" class="seealso">index()</a>)</h3></div>
    <div class="type"><h3 id="type-predicate">predicate/0</h3></div>
    <div class="type"><h3 id="type-yazl">yazl(A) = {[A], [A]}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="opposite/1">opposite(X1::direction()) -&gt; direction()</h3>


<div class="description">

<p>Type utility: get the opposite of a direction.</p>
</div></div>
<div class="function">
<h3 id="ending/1">ending(X1::direction()) -&gt; ending()</h3>


<div class="description">

<p>Type utility: get the end in a specific direction.</p>
</div></div>
<div class="function">
<h3 id="new/0">new() -&gt; empty_yazl()</h3>


<div class="description">

<p>Constructor: create a new empty yazl.</p>
</div></div>
<div class="function">
<h3 id="from_list/1">from_list(A::[A]) -&gt; yazl(A)</h3>


<div class="description">

<p>Constructor: create a yazl with focus before the first element
 of a list. If the list is empty, the empty yazl is returned.
 Equivalent to calling <code>from_list/2</code> with position argument <code>endl</code>.</p>
</div></div>
<div class="function">
<h3 id="from_list/1-1">from_list(I::position(), A::[A]) -&gt; yazl(A)</h3>


<div class="description">

<p>Constructor: create a yazl with focus at the
 beginning, at the end, or before the Ith element of a list.
 The index is 1-based, so the first element is 1,
 and the last index is equal to the length of the list.
 To position at the beginning of the list, pass <code>endl</code>.
 To position at the end of the list, pass <code>endr</code>.
 It is an error to pass an integer less than 1,
 or greater than the length of the list,
 so passing 1 with the empty list is an error.
 If the list is empty, the empty yazl is returned.
 The position for the index is implicitly to the right,
 so for a non-empty list,
 passing <code>endl</code> is the same as passing 1.</p>
</div></div>
<div class="function">
<h3 id="from_lists/2">from_lists(A::[A], A::[A]) -&gt; yazl(A)</h3>


<div class="description">

<p>Constructor: create a yazl with focus between two sublists.
 The underlying list will be the concatenation of the two lists.
 The focus will be after (right of) the last element of the first list,
 and before (left of) the first element of the second list.
 If both lists are empty, the empty yazl is returned.</p>
</div></div>
<div class="function">
<h3 id="is_yazl/1">is_yazl(X1::term()) -&gt; boolean()</h3>


<div class="description">

<p>Test if a term appears to be a yazl.</p>
</div></div>
<div class="function">
<h3 id="is_empty/1">is_empty(X1::yazl(term())) -&gt; boolean()</h3>


<div class="description">

<p>Test if a yazl is empty.</p>
</div></div>
<div class="function">
<h3 id="size/1">size(X1::yazl(term())) -&gt; non_neg_integer()</h3>


<div class="description">

<p>Get the length of the underlying list.
 If the yazl is empty, the size is 0.
 The performance is O(n).</p>
</div></div>
<div class="function">
<h3 id="position/1">position(X1::direction(), X2::yazl(term())) -&gt; position()</h3>


<div class="description">

<p>Get the one-based index of the position to
 the right or left of the current focus.
 Indices are 1-based.
 If the yazl is empty, or focus is at the beginning of
 a non-empty list, then the left index is <code>endl</code>.
 If the yazl is at the end of a non-empty list,
 then the right index is <code>endr</code>.
 The performance is proportional to the position in the list.
 If the focus is at <code>endl</code> it is O(1),
 but if the focus is at the last element, it is O(n).</p>
</div></div>
<div class="function">
<h3 id="to_list/1">to_list(X1::yazl(A)) -&gt; [A]</h3>


<div class="description">

<p>Recover the underlying list.
 If the yazl is empty, the result is the empty list.
 The cost is proportional to the position in the list.
 If the focus is at <code>endl</code> it is O(1),
 but if the focus is at <code>endr</code> it is O(n).</p>
</div></div>
<div class="function">
<h3 id="to_lists/1">to_lists(Z::yazl(A)) -&gt; {[A], [A]}</h3>


<div class="description">

<p>Recover the underlying sublists before and after the focus.
 If the yazl is empty, the result is two empty lists.
 The underlying list is equal to the concatenation of the two lists.
 The cost is proportional to the position in the list.
 If the focus is at <code>endl</code> it is O(1),
 but if the focus is at <code>endr</code> it is O(n).</p>
</div></div>
<div class="function">
<h3 id="get/1">get(X1::direction(), X2::yazl(A)) -&gt; maybe(A)</h3>


<div class="description">

<p>Get the value of the element to the right or
 left of the current focus.
 If the operation would overrun the begining or end
 of the list, return <code>endr</code> or <code>endl</code>.
 This is fast constant time O(1).</p>
</div></div>
<div class="function">
<h3 id="gets/1">gets(Dir::direction(), N::integer(), Z::yazl(A)) -&gt; [A]</h3>


<div class="description">

<p>Get the values of elements to the right or
 left of the current focus.
 Getting zero elements returns the empty list.
 Getting a negative number of elements,
 returns elements from the other direction.
 If the operation would overrun the begining or end
 of the list, return <code>endr</code> or <code>endl</code>.
 Performance is proportional to the length of the requested sublist.</p>
</div></div>
<div class="function">
<h3 id="move/1">move(X1::direction(), X2::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Move the focus one step to the right or left.
 If the operation would overrun the begining or end
 of the list, return <code>endr</code> or <code>endl</code>.</p>

 Traditional function <code>next(...)</code>,
 is equivalent to the curried form <code>move( rdir, ... )</code>.
 Traditional function <code>prev(...)</code>,
 is equivalent to the curried form <code>move( ldir, ... )</code>.
 This is fast constant time O(1).
</div></div>
<div class="function">
<h3 id="moves/1">moves(Dir::direction(), I::integer(), Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Move the focus multiple steps to the right or left.
 If the yazl is empty, or the steps would
 overrun the beginning or end of the list,
 then return <code>endr</code> or <code>endl</code>.</p>

 <p>Moving a zero offset leaves the yazl unchanged.</p>

 Negative offsets are converted to the equivalent positive
 offset in the other direction, which may return an
 unexpected opposite end value,
 e.g. <code>moves(rdir,-2,Z)</code> may return <code>endl</code>.
</div></div>
<div class="function">
<h3 id="moveto/1">moveto(I::position(), Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Move to the beginning or end of the list,
 or an absolute index position within the list.
 The position is <code>endr</code> or <code>endl</code>,
 or a 1-based integer signifying a index,
 <i>i.e.</i> focus before the given index.
 If the index offset would overrun the beginning
 or end of the list, then return <code>endr</code> or <code>endl</code>.</p>
</div></div>
<div class="function">
<h3 id="find/1">find(Dir::direction(), A, Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Search for the first occurrence of a value.
 If the search is successful, return a yazl that
 focuses before (right search) or after (left search)
 the found element.
 If the search does not find the value,
 then it returns <code>endr</code> or <code>endl</code>.</p>
</div></div>
<div class="function">
<h3 id="finds/1">finds(X1::direction(), A::[A], Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Search for the first sequence of values
 that match a given non-empty list.
 If the search is successful, return a yazl that
 focuses before (right search) or after (left search)
 the found list of elements.
 If the search does not find the value,
 then it returns <code>endr</code> or <code>endl</code>.</p>

 A search for an empty list is a no-op
 that returns the original yazl
 (following the convention of <code>lists:prefix</code>
  that the empty list is a prefix of all lists).
</div></div>
<div class="function">
<h3 id="moveuntil/1">moveuntil(X1::direction(), Pred::predicate(A), Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Search for the first occurrence of a value
 that satisfies a boolean predicate function.
 If the search is successful, it returns a yazl
 that focuses before the found element.
 If the search does not find the value,
 then it returns <code>endr</code> or <code>endl</code>.</p>

 Note this is equivalent to <code>movewhile</code>
 using the negation of the predicate.
</div></div>
<div class="function">
<h3 id="movewhile/1">movewhile(Dir::direction(), Pred::predicate(A), Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Search for the first occurrence of a value
 that does not satisfy a boolean predicate function.
 If the search is successful, it returns a yazl that
 focuses before the found element.
 If the search does not find the value,
 then it returns <code>endr</code> or <code>endl</code>.
 Note this is equivalent to <code>moveuntil</code>
 using the negation of the predicate.</p>
</div></div>
<div class="function">
<h3 id="set/1">set(X1::direction(), A, X3::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Set the value of the element to the right or
 left of the current focus.
 If the operation would overrun the begining or end
 of the list, return <code>endr</code> or <code>endl</code>.
 This is fast constant time O(1).</p>
</div></div>
<div class="function">
<h3 id="sets/1">sets(Dir::direction(), A::[A], Z::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Set values of elements to the right or
 left of the current focus.
 Setting the empty list is a no-op,
 and returns the original yazl.
 If the operation would overrun the begining or end
 of the list, return <code>endr</code> or <code>endl</code>.
 Performance is proportional to the length of the requested sublist.</p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(X1::direction() | ending(), A, X3::yazl(A)) -&gt; yazl(A)</h3>


<div class="description">

<p>Insert a value to the right or left of the current focus,
 or at the beginning (prepend) or end (append) of the whole list.
 Whether it is to the left or right
 does not affect the final content of the list,
 just the final position of the focus
 relative to the inserted sequence.
 This is fast constant time O(1).</p>
</div></div>
<div class="function">
<h3 id="inserts/1">inserts(X1::direction(), A::[A], Z::yazl(A)) -&gt; yazl(A)</h3>


<div class="description">

<p>Insert a sequence of values to the left or right
 of the current focus, or at the beginning (prepend)
 or end (append) of the whole list.
 Whether it is inserted to the left or right
 does not affect the final content of the list,
 just the final position of the focus
 relative to the inserted sequence.
 Inserting an empty sequence does not change the underlying list.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(X1::direction(), X2::yazl(A)) -&gt; maybe(yazl(A))</h3>


<div class="description">

<p>Delete the value to the right or left of the focus.
 If the yazl is empty, or the focus is already
 at the beginning or end of a list, then return <code>endr</code> or <code>endl</code>.
 This is fast constant time O(1).</p>
</div></div>
<div class="function">
<h3 id="truncate/1">truncate(X1::direction(), X2::yazl(A)) -&gt; yazl(A)</h3>


<div class="description">

<p>Delete the indicated sublist.
 If the yazl is empty, return the empty yazl.
 For right, the focus will be positioned after the
 last element of the left sublist.
 For left, the focus will be positioned before the
 first element of the right sublist.
 This is fast constant time O(1).</p>
</div></div>
<div class="function">
<h3 id="reverse/1">reverse(X1::yazl(A)) -&gt; yazl(A)</h3>


<div class="description">

<p>Reverse the list maintaining focus.
 If the yazl is empty, the result is the empty yazl.
 If the yazl is not empty, the current values to the
 right and left will be switched
 This is fast constant time O(1), compared to O(n) for ordinary list.</p>
</div></div>
<div class="function">
<h3 id="map/1">map(Fun::(A) -&gt; B, X2::yazl(A)) -&gt; yazl(B)</h3>


<div class="description">

<p>Apply a map while leaving the focus unchanged.
 If the yazl is empty it will be unchanged.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
