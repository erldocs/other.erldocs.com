<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ora (erlora) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>ora</h1>
<h2 class="modsummary">This module implements client interface to a port program
        communicating with an Oracle 10g client.</h2>
<div class="description">
<p>This module implements client interface to a port program
        communicating with an Oracle 10g client.
  </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-date_time">date_time() = {{Y, M, D}, {H, Mi, S}}</h3></div>
    <div class="type"><h3 id="type-ora_error">ora_error() = {Class, ErrCode::integer(), Err::string()}</h3></div>
    <div class="type"><h3 id="type-timeout">timeout() = infinity | integer()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/0">start() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start/1">start(Args) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="connect/1">connect(ConnectionStr::string(), Options) -&gt; Result</h3>

<ul class="type">
<li><code>Options = [Option]</code></li><li><code>Option = {autocommit, boolean()} | {max_rows, integer()} | {query_cache_size, integer()}</code></li><li><code>Result = {ok, ConnectionPid::pid()} | {error, Reason::ora_error()}</code></li></ul>
<div class="description">

<p>Spawns an erlang control process that will open a port
       to a c-process that uses the ORACLE OCCI API to open a connection
       to the database.  <code>ConnectionStr</code> can contain
       "user/password@database" connection string.  <code>max_rows</code> option limits
       the max number of elements in the list of rows returned by a select
       statement.  <code>query_cache_size</code> controls the size of the driver's cache
       that stores prepared query statements.  Its default value is 50.
       The port program can be started with the "-d" flag by
       specifying {mod, {ora, [{debug, true}]}} option in the ora.app file.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
    ( {connect, ConnectionStr, Options} ) -&gt; ok | {error, Reason::ora_error()}
        ConnectStr = string()
        Options    = [Option]
        Option     = {autocommit,       true|false} |
                     {max_rows,         integer()}  |
                     {query_cache_size, integer()}</pre>
</div></div>
<div class="function">
<h3 id="disconnect/1">disconnect(ConnectionReferense::pid()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Disconnects from the database and terminates both the erlang
       control process and the database handling c-process.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
    ( disconnect ) -&gt; ok | {error, Reason::ora_reason()}</pre>
</div></div>
<div class="function">
<h3 id="rollback/1">rollback(ConnectionReference::pid()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Rolls back an open transaction.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
    ( rollback ) -&gt; ok | {error, Reason::ora_reason()}</pre>
<p><em>See also:</em> <a href="#commit/3" class="seealso">commit/3</a>.</p>
</div></div>
<div class="function">
<h3 id="commit/1">commit(ConnectionReference::pid()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Commits or rollbacks a transaction. Needed on connections
       where automatic commit is turned off.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
    ( commit ) -&gt; ok | {error, Reason::ora_reason()}</pre>
</div></div>
<div class="function">
<h3 id="describe_table/1">describe_table(ConnectionReference::pid(), Table::string()) -&gt; {ok, FieldNames} | {error, Reason}</h3>

<ul class="type">
<li><code>Table = string()</code></li><li><code>Fields = [{FieldName::string(), Datatype, Size::integer()}]</code></li><li><code>Datatype = integer | float | string | date</code></li><li><code>Reason = ora_error()</code></li></ul>
<div class="description">

<p>Queries the database to find out the datatypes of the Table.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
    ( {describe, Table} ) -&gt;
            {ok, Fields} | {error, Reason}
 
  Note: Rows will be an empty list, because the select statement
        for the describe_table command will not return any data records.</pre>
</div></div>
<div class="function">
<h3 id="select_sql/1">select_sql(ConnectionReference::pid(), QueryID, Query, BindVars) -&gt; Result</h3>

<ul class="type">
<li><code>QueryID = atom()</code></li><li><code>Query = string() | binary()</code></li><li><code>BindVars = [BindVar]</code></li><li><code>BindVar = integer() | float() | string() | date_time()</code></li><li><code>Result = {ok, FieldNames, Rows, Continue} | {error, Reason::ora_error()}</code></li><li><code>Continue = eof | continue</code></li><li><code>FieldNames = [FieldName::string()] | []</code></li><li><code>Rows = [Row::tuple()]</code></li></ul>
<div class="description">

<p>Executes a SELECT SQL query. The result set is returned (up to N
       defined by the {max_rows, N} connect
       option, in which case select_next/2 can be used to fetch next N records),
       otherwise the number of affected rows is returned.
       The Query should be an SQL string. QueryID is an atom that causes the
       driver to cache the prepared SQL statement associated with QueryID.
       That internal cache size is controlled by the session's <code>query_cache_size</code>
       parameter.  When <code>select_sql</code> is used to fetch large datasets that
       return more than <code>max_rows</code> records, <code>{ok, _, _, continue}</code> tuple is returned
       indicating that there is more data in the cursor, otherwise <code>{ok, _, _, eof}</code>
       is returned.  In the former case the next record list can be fetched using
       the same <code>select_sql</code> function call as the driver remembers the state
       of the open cursor associated with the QueryID.  Also successive calls
       of this function will return an empty list of FieldNames, since the field names
       can be obtained from the first call of the function.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
  ( {select_sql, QueryID, Query, BindVars} ) -&gt;
          {ok, FieldNames, Rows, eof}      |   % For a select query with resultset &lt; max_rows
          {ok, FieldNames, Rows, continue} |   % For a select query with remaining records in a cursor
          {ok, OutParams::list()}          |   % For plsql block
          {error, Reason}</pre>
</div></div>
<div class="function">
<h3 id="execute_sql/1">execute_sql(ConnectionReference::pid(), QueryID, Query, BindVars) -&gt; Result</h3>

<ul class="type">
<li><code>QueryID = atom()</code></li><li><code>Query = string() | binary()</code></li><li><code>BindVars = [BindVar]</code></li><li><code>BindVar = integer() | float() | string() | date_time()</code></li><li><code>Result = {ok, NRows::integer()} | {error, Reason::ora_error()}</code></li><li><code>Continue = eof | continue</code></li><li><code>FieldNames = [FieldName::string()] | []</code></li><li><code>Rows = [Row::tuple()]</code></li></ul>
<div class="description">

<p>Executes an UPDATE/DELETE/INSERT SQL query.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
  ( {execute_sql, QueryID, Query, BindVars} ) -&gt;
          {ok, FieldNames, Rows, eof}      |   % For a select query with resultset &lt; max_rows
          {ok, FieldNames, Rows, continue} |   % For a select query with remaining records in a cursor
          {ok, NRows::integer()}           |   % For insert, update, delete query
          {ok, OutParams::list()}          |   % For plsql block
          {error, Reason}</pre>
<p><em>See also:</em> <a href="#select_sql/4" class="seealso">select_sql/4</a>.</p>
</div></div>
<div class="function">
<h3 id="free_sql/1">free_sql(ConnectionReference::pid(), QueryID::atom()) -&gt; ok</h3>


<div class="description">

<p>Releases resources allocated by QueryID associated with a former
       call to <code>execute_sql/4</code>.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
  ( {free_sql, QueryID} ) -&gt; ok</pre>
</div></div>
<div class="function">
<h3 id="prepare_plsql/1">prepare_plsql(ConnectionReference::pid(), QueryID::atom(), Query, OutVars) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Query = string() | binary()</code></li><li><code>OutVars = {out, ParamNum::integer(), ParamType}</code></li><li><code>ParamType = integer | float | date | {string, Size::integer()}</code></li></ul>
<div class="description">

<p>Prepares a PL/SQL block for subsequent execution using
       <code>execute_plsql/3</code>.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
  ( {prepare_plsql, QueryID, Query, OutVars} ) -&gt; ok | {error, Reason}</pre>
</div></div>
<div class="function">
<h3 id="execute_plsql/1">execute_plsql(ConnectionReference::pid(), QueryID::atom(), BindVars) -&gt; {ok, OutValues} | {error, Reason}</h3>

<ul class="type">
<li><code>BindVars = {in, ParamNum::integer(), Value}</code></li><li><code>Value = integer() | float() | date_time() | string()</code></li><li><code>OutValues = [{OutParamNum::integer(), Value}]</code></li></ul>
<div class="description">

<p>Executes a PL/SQL block previously prepared using <code>prepare_plsql/4</code>.
  </p><pre class="sh_erlang">  Erlang -&gt; C -&gt; Erlang port matshaling spec:
  ( {execute_plsql, QueryID, BindVars} ) -&gt;
       {ok, OutValues} | {error, Reason}</pre>
</div></div></div>

<authors>

<aname>Serge Aleynikov</aname>
<email>saleyn@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
