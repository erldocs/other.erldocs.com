<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper_symb (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper_symb</h1>
<h2 class="modsummary">Symbolic datatypes handling functions.</h2>
<div class="description">
<p>Symbolic datatypes handling functions.</p>
  
   <em><marker id="Symbolic_datatypes">Symbolic datatypes</marker></em>
   When writing properties that involve abstract data types, such as dicts or
   sets, it is usually best to avoid dealing with the ADTs' internal
   representation directly. Working, instead, with a symbolic representation of
   the ADT's construction process (series of API calls) has several benefits:
   <list>
   <item><p>Failing testcases are easier to read and understand. Compare:
     </p><pre class="sh_erlang">         {call,sets,from_list,[[1,2,3]]}</pre><p>
     with:
     </p><pre class="sh_erlang">         {set,3,16,16,8,80,48,
              {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
              {{[],[3],[],[],[],[],[2],[],[],[],[],[1],[],[],[],[]}}}</pre></item>
   <item><p>Failing testcases are easier to shrink.</p></item>
   <item><p>It is especially useful when testing the datatype itself: Certain
     implementation errors may depend on some particular selection and
     ordering of API calls, thus it is important to cover the entire ADT
     construction API.</p></item>
   </list>
  
   PropEr supports the symbolic representation of datatypes, using the
   following syntax:
   <taglist>
   <dt><code>{call,Module,Function,Arguments}</code></dt>
   <item><p>This represents a call to the API function <code>Module:Function</code> with
     arguments <code>Arguments</code>. Each of the arguments may be a symbolic call itself
     or contain other symbolic calls in lists or tuples of arbitrary
     depth.</p></item>
   <tag id="$call"><code>{'$call',Module,Function,Arguments}</code></tag>
   <item><p>Identical to the above, but gets evaluated automatically before being
     applied to a property.</p></item>
   <tag id="var"><code>{var,</code><code>var_id()</code><code>}</code></tag>
   <item><p>This contruct serves as a placeholder for values that are not known at
     type construction time. It will be replaced by the actual value of the
     variable during evaluation.</p></item>
   </taglist>
  
   <p>When including the PropEr header file, all
   <a href="#index" class="seealso">API functions</a> of this module are automatically
   imported, unless <code>PROPER_NO_IMPORTS</code> is defined.</p>
  
   <em><marker id="Auto-ADT">Auto-ADT</marker></em><p>
   To simplify the symbolic testing of ADTs, PropEr comes with the Auto-ADT
   subsystem: An opaque native type, if exported from its module, is assumed
   to be an abstract data type, causing PropEr to ignore its internal
   representation and instead construct symbolic instances of the type. The
   API functions used in these symbolic instances are extracted from the ADT's
   defining module, which is expected to contain one or more <code>-spec</code>ed and
   exported functions that can be used to construct instances of the ADT.
   Specifically, PropEr will use all functions that return at least one
   instance of the ADT. As with recursive native types, the base case is
   automatically detected (in the case of ADTs, calls to functions like
   <code>new/0</code> and <code>from_list/1</code> would be considered the base case). The produced
   symbolic calls will be <a href="#$call" class="seealso">$call tuples</a>, which are
   automatically evaluated, thus no call to <a href="#eval/1" class="seealso">eval/1</a> is required inside
   the property. Produced instances are guaranteed to evaluate successfully.
   Parametric ADTs are supported, so long as they appear fully instantiated
   inside <code>?FORALL</code>s.</p>
  
   <p>ADTs hard-coded in the Erlang type system (<code>array</code>, <code>dict</code>, <code>digraph</code>,
   <code>gb_set</code>, <code>gb_tree</code>, <code>queue</code>, and <code>set</code>) are automatically detected and
   handled as such. PropEr also accepts parametric versions of the above ADTs
   in <code>?FORALL</code>s (<code>array/1</code>, <code>dict/2</code>, <code>gb_set/1</code>, <code>gb_tree/2</code>, <code>queue/1</code>,
   <code>set/1</code>, also <code>orddict/2</code> and <code>ordset/1</code>). If you would like to use these
   parametric versions in <code>-type</code> and <code>-spec</code> declarations as well, to better
   document your code and facilitate spec testing, you can include the
   complementary header file <code>proper/include/proper_param_adts.hrl</code>, which
   provides the corresponding <code>-type</code> definitions. Please note that Dialyzer   
currenty treats these the same way as their non-parametric counterparts.</p>
  
   The use of Auto-ADT is currently subject to the following limitations:
   <list>
   <item><p>In the ADT's <code>-opaque</code> declaration, as in all types' declarations,
     only type variables should be used as parameters in the LHS. None of
     these variables can be the special <code>_</code> variable and no variable should
     appear more than once in the parameters.</p></item>
   <item><p>ADTs inside specs can only have simple variables as parameters. These
     variables cannot be bound by any is_subtype constraint. Also, the special
     <code>_</code> variable is not allowed in ADT parameters. If this would result in
     singleton variables, as in the specs of functions like <code>new/0</code>, use
     variable names that begin with an underscore.</p></item>
   <item><p>Specs that introduce an implicit binding among the parameters of an
     ADT are rejected, e.g.:
     </p><pre class="sh_erlang">         -spec foo(mydict(T,S),mydict(S,T)) -&gt; mydict(T,S).</pre><p>
     This includes using the same type variable twice in the parameters of
     an ADT.</p></item>
   <item><p>While parsing the return type of specs in search of ADT references,
     PropEr only recurses into tuples, unions and lists; all other constructs
     are ignored. This prohibits, among others, indirect references to the ADT
     through other custom types and records.</p></item>
   <item><p>When encountering a union in the return type, PropEr will pick the
     first choice that can return an ADT. This choice must be distinguishable
     from the others either by having a unique term structure or by having a
     unique tag (if it's a tagged tuple).</p></item>
   <item><p>When parsing multi-clause specs, only the first clause is considered.
     </p></item>
   <item><p>The only spec constraints we accept are <code>is_subtype</code> constraints whose
     first argument is a simple, non-<code>_</code> variable. It is not checked whether or
     not these variables actually appear in the spec. The second argument of an
     <code>is_subtype</code> constraint cannot contain any non-<code>_</code> variables. Multiple
     constraints for the same variable are not supported.</p></item>
   <item><p> Unexported opaques and opaques with no suitable specs to serve as API
     calls are silently discarded. Those will be treated like ordinary types.
     </p></item>
   <item><p>Unexported or unspecced functions are silently rejected.</p></item>
   <item><p>Functions with unsuitable return values are silently rejected.</p></item>
   <item><p>Specs that make bad use of variables are silently rejected.</p></item>
   </list>
  
   For an example on how to write Auto-ADT-compatible parametric specs, see
   the <code>examples/stack</code> module, which contains a simple implementation of a
   stack, or the <code>proper/proper_dict module</code>, which wraps the <code>STDLIB</code> <code>dict</code>
   ADT.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-symb_term">symb_term() = term()</h3></div>
    <div class="type"><h3 id="type-var_id">var_id() = atom() | integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-var_values">var_values() = [{<a href="#type-var_id" class="seealso">var_id()</a>, term()}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="eval/1">eval(SymbTerm::symb_term()) -&gt; term()</h3>


<div class="description">
<p>Equivalent to <a href="#eval/2" class="seealso">eval([], SymbTerm)</a>.</p>
</div></div>
<div class="function">
<h3 id="eval/1-1">eval(VarValues::var_values(), SymbTerm::symb_term()) -&gt; term()</h3>


<div class="description">

<p>Intended for use inside the property-testing code, this function
  evaluates a symbolic instance <code>SymbTerm</code>. It also accepts a proplist
  <code>VarValues</code> that maps variable names to values, which is used to replace any
  <a href="#var" class="seealso">var tuples</a> inside <code>SymbTerm</code> before proceeding with its
  evaluation.</p>
</div></div>
<div class="function">
<h3 id="defined/1">defined(SymbTerm::symb_term()) -&gt; boolean()</h3>


<div class="description">

<p>Returns true if the <code>SymbTerm</code> symbolic instance can be successfully
  evaluated (its evaluation doesn't raise an error or exception).</p>
</div></div>
<div class="function">
<h3 id="well_defined/1">well_defined(SymbType::raw_type() (see module proper_types)) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>An attribute which can be applied to any symbolic generator <code>SymbType</code>
  that may produce invalid sequences of operations when called. The resulting
  generator is guaranteed to only produce well-defined symbolic instances.</p>
</div></div>
<div class="function">
<h3 id="pretty_print/1">pretty_print(SymbTerm::symb_term()) -&gt; string()</h3>


<div class="description">
<p>Equivalent to <a href="#pretty_print/2" class="seealso">pretty_print([], SymbTerm)</a>.</p>
</div></div>
<div class="function">
<h3 id="pretty_print/1-1">pretty_print(VarValues::var_values(), SymbTerm::symb_term()) -&gt; string()</h3>


<div class="description">

<p>Similar in calling convention to <a href="#eval/2" class="seealso">eval/2</a>, but returns a string
  representation of the call sequence <code>SymbTerm</code> instead of evaluating it.</p>
</div></div></div>

<authors>

<aname>Manolis Papadakis</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
