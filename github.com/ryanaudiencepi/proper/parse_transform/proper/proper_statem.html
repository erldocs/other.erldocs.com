<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper_statem (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper_statem</h1>
<h2 class="modsummary">This module defines the proper_statem behaviour, useful for testing
   stateful reactive systems whose internal state and side-effects are
   specified via an abstract state machine.</h2>
<div class="description">
<p>This module defines the <code>proper_statem</code> behaviour, useful for testing
   stateful reactive systems whose internal state and side-effects are
   specified via an abstract state machine. Given a callback module
   implementing the <code>proper_statem</code> behaviour (i.e. defining an abstract state   
machine of the system under test), PropEr can generate random symbolic   
sequences of calls to that system.   
As a next step, generated symbolic calls are actually performed, while   
monitoring the system's responses to ensure it behaves as expected. Upon   
failure, the shrinking mechanism attempts to find a minimal sequence of   
calls provoking the same error.</p>
  
   <p>When including the <code>"proper/include/proper.hrl"</code> header file,
   all <a href="#index" class="seealso">API functions </a> of proper_statem are automatically
   imported, unless <code>PROPER_NO_IMPORTS</code> is defined.</p>
  
   <em><marker id="The_role_of_commands">The role of commands</marker></em>
   Testcases generated for testing a stateful system are lists of symbolic API
   calls to that system. Symbolic representation has several benefits, which
   are listed here in increasing order of importance:
   <list>
   <item><p>Generated testcases are easier to read and understand.</p></item>
   <item><p>Failing testcases are easier to shrink.</p></item>
   <item><p>The generation phase is side-effect free and this results in
     repeatable testcases, which is essential for correct shrinking.</p></item>
   </list><p>
   Since the actual results of symbolic calls are not known at generation time,
   we use symbolic variables (<code>symb_var()</code>) to refer to them.
   A command (<code>command()</code>) is a symbolic term, used to bind a symbolic   
variable to the result of a symbolic call. For example:</p>
  
   <pre class="sh_erlang">      [{set, {var,1}, {call,erlang,put,[a,42]}},
       {set, {var,2}, {call,erlang,erase,[a]}},
       {set, {var,3}, {call,erlang,put,[b,{var,2}]}}]</pre>
  
   <p>is a command sequence that could be used to test the process dictionary.
   In this example, the first call stores the pair <code>{a,42}</code> in the process
   dictionary, while the second one deletes it. Then, a new pair <code>{b,{var,2}}</code>
   is stored. <code>{var,2}</code> is a symbolic variable bound to the result of
   <code>erlang:erase/1</code>. This result is not known at generation time, since none of
   these operations is performed at that time. After evaluating the command
   sequence at runtime, the process dictionary will eventually contain the
   pair <code>{b,42}</code>.</p>
  
   <em><marker id="The_abstract_model-state">The abstract model-state</marker></em>
   In order to be able to test impure code, we need a way to track its
   internal state (at least the useful part of it). To this end, we use an
   abstract state machine representing the possible configurations of the
   system under test. When referring to the <i>model state</i>, we mean the
   state of the abstract state machine. The <i>model state</i> can be either
   symbolic or dynamic:
   <list>
   <item><p>During command generation, we use symbolic variables to bind the
   results of symbolic calls. Therefore, the model state might
   (and usually does) contain symbolic variables and/or symbolic calls, which
   are necessary to operate on symbolic variables. Thus, we refer to it as
   symbolic state. For example, assuming that the internal state of the
   process dictionary is modeled as a proplist, the model state after
   generating the previous command sequence will be <code>[{b,{var,2}}]</code>.</p></item>
   <item><p>During runtime, symbolic calls are evaluated and symbolic variables are
   replaced by their corresponding real values. Now we refer to the state as
   dynamic state. After running the previous command sequence, the model state
   will be <code>[{b,42}]</code>.</p></item>
   </list>
  
   <em><marker id="The_callback_functions">The callback functions</marker></em>
   The following functions must be exported from the callback module
   implementing the abstract state machine:
   <list>
   <item><p><code>initial_state() ::</code> <code>symbolic_state()</code>
     </p><p>Specifies the symbolic initial state of the state machine. This state
     will be evaluated at command execution time to produce the actual initial
     state. The function is not only called at command generation time, but
     also in order to initialize the state every time the command sequence is
     run (i.e. during normal execution, while shrinking and when checking a
     counterexample). For this reason, it should be deterministic and
     self-contained.</p></item>
   <item><p><code>command(S::</code><code>symbolic_state()</code><code>) ::</code> <code>proper_types:type()</code>
     </p><p>Generates a symbolic call to be included in the command sequence,
     given the current state <code>S</code> of the abstract state machine. However,
     before the call is actually included, a precondition is checked. This
     function will be repeatedly called to produce the next call to be
     included in the test case.</p></item>
   <item><p><code>precondition(S::</code><code>symbolic_state()</code><code>,
                     Call::</code><code>symb_call()</code><code>) :: boolean()</code>
     </p><p>Specifies the precondition that should hold so that <code>Call</code> can be
     included in the command sequence, given the current state <code>S</code> of the
     abstract state machine. In case precondition doesn't hold, a new call is
     chosen using the <code>command/1</code> generator. If preconditions are very strict,
     it will take a lot of tries for PropEr to randomly choose a valid command.
     Testing will be stopped in case the <code>constraint_tries</code> limit is reached
     (see the 'Options' section in the <a href="proper.html" class="seealso">proper</a> module documentation).
     Preconditions are also important for correct shrinking of failing
     testcases. When shrinking command sequences, we try to eliminate commands
     that do not contribute to failure, ensuring that all preconditions still
     hold. Validating preconditions is necessary because during shrinking we
     usually attempt to perform a call with the system being in a state
     different from the state it was when initially running the test.</p></item>
   <item><p><code>postcondition(S::</code><code>dynamic_state()</code><code>,
                      Call::</code><code>symbolic_call()</code><code>,
                      Res::term()) :: boolean()</code>
     </p><p>Specifies the postcondition that should hold about the result <code>Res</code> of
     performing <code>Call</code>, given the dynamic state <code>S</code> of the abstract state
     machine prior to command execution. This function is called during
     runtime, this is why the state is dynamic.</p></item>
   <item><p><code>next_state(S::</code><code>symbolic_state()</code> <code>|</code> <code>dynamic_state()</code><code>,
                   Res::term(),
                   Call::</code><code>symbolic_call()</code><code>) ::</code>
          <code>symbolic_state()</code> <code>|</code> <code>dynamic_state()</code>
     </p><p>Specifies the next state of the abstract state machine, given the
     current state <code>S</code>, the symbolic <code>Call</code> chosen and its result <code>Res</code>. This
     function is called both at command generation and command execution time
     in order to update the model state, therefore the state <code>S</code> and the
     result <code>Res</code> can be either symbolic or dynamic.</p></item>
   </list>
  
   <em><marker id="The_property_used">The property used</marker></em>
   Each test consists of two phases:
   <list>
   <item><p>As a first step, PropEr generates random symbolic command sequences
     deriving information from the callback module implementing the abstract
     state machine. This is the role of <a href="#commands/1" class="seealso">commands/1</a> generator.</p></item>
   <item><p>As a second step, command sequences are executed so as to check that
     the system behaves as expected. This is the role of
     <a href="#run_commands/2" class="seealso">run_commands/2</a>, a function that evaluates a symbolic command
     sequence according to an abstract state machine specification.</p></item>
   </list>
  
   <p>These two phases are encapsulated in the following property, which can be   
used for testing the process dictionary:</p>
  
   <pre class="sh_erlang">      prop_pdict() -&gt;
          ?FORALL(Cmds, proper_statem:commands(?MODULE),
                  begin
                      {_History, _State, Result} = proper_statem:run_commands(?MODULE, Cmds),
                      cleanup(),
                      Result =:= ok
                  end).</pre>
  
   <p>When testing impure code, it is very important to keep each test   
self-contained. For this reason, almost every property for testing stateful   
systems contains some clean-up code. Such code is necessary to put the   
system in a known state, so that the next test can be executed   
independently from previous ones.</p>
  
   <em><marker id="Parallel_testing">Parallel testing</marker></em><p>
   After ensuring that a system's behaviour can be described via an abstract
   state machine when commands are executed sequentially, it is possible to
   move to parallel testing. The same state machine can be used to generate
   command sequences that will be executed in parallel to test for race
   conditions. A parallel testcase (<code>parallel_testcase()</code>) consists of   
a sequential and a parallel component. The sequential component is a   
command sequence that is run first to put the system in a random state.   
The parallel component is a list of command sequences that are executed in   
parallel, each of them in a separate newly-spawned process. After running a   
parallel testcase, PropEr uses the state machine specification to check if   
the results observed could have been produced by a possible serialization   
of the parallel component. If no such serialization is possible, then an   
atomicity violation has been detected. In this case, the shrinking   
mechanism attempts to produce a counterexample that is minimal in terms of   
concurrent operations. Properties for parallel testing are very similar to   
those used for sequential testing.</p>
  
   <pre class="sh_erlang">      prop_parallel_testing() -&gt;
          ?FORALL(Testcase, proper_statem:parallel_commands(?MODULE),
                  begin
                      {_Sequential, _Parallel, Result} = proper_statem:run_parallel_commands(?MODULE, Testcase),
                      cleanup(),
                      Result =:= ok
                  end).</pre>
  
   <p>Please note that, in case of strict preconditions, PropEr might not be
   able to generate a suitable parallel component for each test. In this
   case, an <code>"f"</code> is printed on screen to inform the user that a test case   
will be executed sequentially.</p>
  
   Also note that the actual interleaving of commands of the parallel
   component depends on the Erlang scheduler, which is too deterministic.
   For PropEr to be able to detect race conditions, the code of the system
   under test should be instrumented with <code>erlang:yield/0</code> calls to the
   scheduler.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-command">command() = {set, <a href="#type-symb_var" class="seealso">symb_var()</a>, <a href="#type-symb_call" class="seealso">symb_call()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {init, <a href="#type-symbolic_state" class="seealso">symbolic_state()</a>}</h3></div>
    <div class="type"><h3 id="type-command_list">command_list() = [<a href="#type-command" class="seealso">command()</a>]</h3></div>
    <div class="type"><h3 id="type-dynamic_state">dynamic_state() = term()</h3></div>
    <div class="type"><h3 id="type-fun_name">fun_name() = atom()</h3></div>
    <div class="type"><h3 id="type-history">history() = [{<a href="#type-dynamic_state" class="seealso">dynamic_state()</a>, term()}]</h3></div>
    <div class="type"><h3 id="type-mod_name">mod_name() = atom()</h3></div>
    <div class="type"><h3 id="type-parallel_history">parallel_history() = [{<a href="#type-command" class="seealso">command()</a>, term()}]</h3></div>
    <div class="type"><h3 id="type-parallel_testcase">parallel_testcase() = {<a href="#type-command_list" class="seealso">command_list()</a>, [<a href="#type-command_list" class="seealso">command_list()</a>]}</h3></div>
    <div class="type"><h3 id="type-statem_result">statem_result() = ok<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| initialization_error<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {precondition, false | <a href="proper.html#type-exception" class="seealso">proper:exception()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {postcondition, false | <a href="proper.html#type-exception" class="seealso">proper:exception()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="proper.html#type-exception" class="seealso">proper:exception()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| no_possible_interleaving</h3></div>
    <div class="type"><h3 id="type-symb_call">symb_call() = {call, <a href="#type-mod_name" class="seealso">mod_name()</a>, <a href="#type-fun_name" class="seealso">fun_name()</a>, [term()]}</h3></div>
    <div class="type"><h3 id="type-symb_var">symb_var() = {var, integer() &gt;= 1}</h3></div>
    <div class="type"><h3 id="type-symbolic_state">symbolic_state() = term()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="behaviour_info/1">behaviour_info(Attribute::callbacks) -&gt; [{fun_name(), arity()}]</h3>


<div class="description">

<p>Specifies the callback functions that should be exported from a module
  implementing the <code>proper_statem</code> behaviour.</p>
</div></div>
<div class="function">
<h3 id="commands/1">commands(Mod::mod_name()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A special PropEr type which generates random command sequences,
  according to an absract state machine specification. The function takes as
  input the name of a callback module, which contains the state machine
  specification. The initial state is computed by <code>Mod:initial_state/0</code>.</p>
</div></div>
<div class="function">
<h3 id="commands/1-1">commands(Mod::mod_name(), InitialState::symbolic_state()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Similar to <a href="#commands/1" class="seealso">commands/1</a>, but generated command sequences always
  start at a given state. In this case, the first command is always
  <code>{init,InitialState}</code> and is used to correctly initialize the state
  every time the command sequence is run (i.e. during normal execution,
  while shrinking and when checking a counterexample). In this case,
  <code>Mod:initial_state/0</code> is never called.</p>
</div></div>
<div class="function">
<h3 id="more_commands/1">more_commands(N::pos_integer(), CmdType::type() (see module proper_types)) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Increases the expected length of command sequences generated from
  <code>CmdType</code> by a factor <code>N</code>.</p>
</div></div>
<div class="function">
<h3 id="parallel_commands/1">parallel_commands(Mod::mod_name()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A special PropEr type which generates parallel testcases,
  according to an absract state machine specification. The function takes as
  input the name of a callback module, which contains the state machine
  specification. The initial state is computed by <code>Mod:initial_state/0</code>.</p>
</div></div>
<div class="function">
<h3 id="parallel_commands/1-1">parallel_commands(Mod::mod_name(), InitialState::symbolic_state()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Similar to <a href="#parallel_commands/1" class="seealso">parallel_commands/1</a>, but generated command sequences
  always start at a given state.</p>
</div></div>
<div class="function">
<h3 id="run_commands/1">run_commands(Mod::mod_name(), Cmds::command_list()) -&gt; {history(), dynamic_state(), statem_result()}</h3>


<div class="description">

<p>Evaluates a given symbolic command sequence <code>Cmds</code> according to the
   state machine specified in <code>Mod</code>. The result is a triple of the form<br />
   <code>{History, DynamicState, Result}</code>, where:
  </p><list>
  <item><p><code>History</code> contains the execution history of all commands that were
    executed without raising an exception. It contains tuples of the form
    {<code>dynamic_state()</code>, <code>term()</code>}, specifying the state prior to
    command execution and the actual result of the command.</p></item>
  <item><p><code>DynamicState</code> contains the state of the abstract state machine at
    the moment when execution stopped.</p></item>
  <item><p><code>Result</code> specifies the outcome of command execution. It can be
    classified in one of the following categories:
    </p><list>
    <item><p><em>ok</em>
      </p><p>All commands were successfully run and all postconditions were true.
      </p></item>
    <item><p><em>initialization error</em>
      </p><p>There was an error while evaluating the initial state.</p></item>
    <item><p><em>postcondition error</em>
      </p><p>A postcondition was false or raised an exception.</p></item>
    <item><p><em>precondition error</em>
      </p><p>A precondition was false or raised an exception.</p></item>
    <item><p><em>exception</em>
      </p><p>An exception was raised while running a command.</p></item>
    </list></item>
  </list>
</div></div>
<div class="function">
<h3 id="run_commands/1-1">run_commands(Mod::mod_name(), Cmds::command_list(), Env::var_values() (see module proper_symb)) -&gt; {history(), dynamic_state(), statem_result()}</h3>


<div class="description">

<p> Similar to <a href="#run_commands/2" class="seealso">run_commands/2</a>, but also accepts an environment,
  used for symbolic variable evaluation during command execution. The
  environment consists of <code>{Key::atom(), Value::term()}</code> pairs. Keys may be
  used in symbolic variables (i.e. <code>{var,Key}</code>) whithin the command sequence
  <code>Cmds</code>. These symbolic variables will be replaced by their corresponding
  <code>Value</code> during command execution.</p>
</div></div>
<div class="function">
<h3 id="run_parallel_commands/1">run_parallel_commands(Mod::mod_name(), Testcase::parallel_testcase()) -&gt; {history(), [parallel_history()], statem_result()}</h3>


<div class="description">

<p>Runs a given parallel testcase according to the state machine
  specified in <code>Mod</code>. The result is a triple of the form<br />
  <code>{Sequential_history, Parallel_history, Result}</code>, where:
  </p><list>
  <item><p><code>Sequential_history</code> contains the execution history of the
    sequential component.</p></item>
  <item><p><code>Parallel_history</code> contains the execution history of each of the
    concurrent tasks.</p></item>
  <item><p><code>Result</code> specifies the outcome of the attemp to serialize command
    execution, based on the results observed. It can be one of the following:
    </p><list><item><p> <code>ok</code> </p></item><item><p> <code>no_possible_interleaving</code> </p></item></list><p> </p></item>
  </list>
</div></div>
<div class="function">
<h3 id="run_parallel_commands/1-1">run_parallel_commands(Mod::mod_name(), X2::parallel_testcase(), Env::var_values() (see module proper_symb)) -&gt; {history(), [parallel_history()], statem_result()}</h3>


<div class="description">

<p>Similar to <a href="#run_parallel_commands/2" class="seealso">run_parallel_commands/2</a>, but also accepts an
  environment used for symbolic variable evaluation, exactly as described in
  <a href="#run_commands/3" class="seealso">run_commands/3</a>.</p>
</div></div>
<div class="function">
<h3 id="command_names/1">command_names(Cmds::command_list()) -&gt; [mfa()]</h3>


<div class="description">

<p>Extracts the names of the commands from a given command sequence, in
  the form of MFAs. It is useful in combination with functions such as
  <a href="proper.html#aggregate/2" class="seealso">proper:aggregate/2</a> in order to collect statistics about command
  execution.</p>
</div></div>
<div class="function">
<h3 id="state_after/1">state_after(Mod::mod_name(), Cmds::command_list()) -&gt; symbolic_state()</h3>


<div class="description">

<p>Returns the symbolic state after running a given command sequence,
  according to the state machine specification found in <code>Mod</code>. The commands
  are not actually executed.</p>
</div></div>
<div class="function">
<h3 id="zip/2">zip(A::[A], B::[B]) -&gt; [{A, B}]</h3>


<div class="description">

<p>Behaves like <code>lists:zip/2</code>, but the input lists do no not necessarily
  have equal length. Zipping stops when the shortest list stops. This is
  useful for zipping a command sequence with its (failing) execution history.</p>
</div></div></div>

<authors>

<aname>Eirini Arvaniti</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
