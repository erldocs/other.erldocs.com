<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>blist (jhn_stdlib) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>blist</h1>
<h2 class="modsummary">     
String Processing Functions for binary encoded strings.</h2>
<div class="description">
<p>     
String Processing Functions for binary encoded strings.</p>
  
     <p>This is a drop in replacement for the lists module in stdlib     
working on binaries interpreted as strings of octets in Latin1.</p>
  
     <p>The module generates ref binaries as much as possible so if     
copies are more suitable apply binary/copy/1 on the result.</p>
  
     All functions in the stblib lists that would operate on tuples
     operate on equally sized octet blobs binaries.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-thing">thing() = atom() | integer() | float() | string() | binary()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="all/1">all(Pred::(byte()) -&gt; boolean(), X2::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if Pred(Elem) returns true for all elements Elem in String,
    otherwise false.</p>
</div></div>
<div class="function">
<h3 id="any/1">any(Pred::(byte()) -&gt; boolean(), X2::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if Pred(Elem) returns true for at least one element
    Elem in String.</p>
</div></div>
<div class="function">
<h3 id="append/1">append(Binaries::[binary()]) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a String in which all the sub-strings of ListOfStrings have
    been appended.</p>
</div></div>
<div class="function">
<h3 id="append/1-1">append(Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a new list String3 which is made from the elements of
    String1 followed by the elements of String2.</p>
</div></div>
<div class="function">
<h3 id="concat/1">concat(List::[thing()]) -&gt; binary()</h3>


<div class="description">

<p>
    Concatenates the text representation of the elements of Things.
    The elements of Things can be atoms, integers, floats, strings,
    or binaries.</p>
</div></div>
<div class="function">
<h3 id="delete/1">delete(Elt::char(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a copy of String1 where the first element matching Elem is
    deleted, if there is such an element.</p>
</div></div>
<div class="function">
<h3 id="dropwhile/1">dropwhile(Pred::(byte()) -&gt; boolean(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Drops elements Elem from String1 while Pred(Elem) returns true and
    returns the remaining string.</p>
</div></div>
<div class="function">
<h3 id="duplicate/1">duplicate(N::pos_integer(), Char::byte()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a string which contains N copies of the term Elem.</p>
</div></div>
<div class="function">
<h3 id="filter/1">filter(Pred::(byte()) -&gt; boolean(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    String2 is a string of all elements Elem in String1 for which
    Pred(Elem) returns true.</p>
</div></div>
<div class="function">
<h3 id="flatlength/1">flatlength(IOList::iolist()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>
    Equivalent to length(iolist_to_binary(DeepString)), but more efficient.</p>
</div></div>
<div class="function">
<h3 id="flatmap/1">flatmap(Fun::(byte()) -&gt; binary(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Takes a function from As to strings of Bs, and a string of As (String1)
    and produces a string of Bs by applying the function to every element
    in String1 and appending the resulting strings.</p>
</div></div>
<div class="function">
<h3 id="flatten/1">flatten(IOList::iolist()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a flattened version of DeepString.</p>
</div></div>
<div class="function">
<h3 id="flatten/1-1">flatten(IOList::iolist(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a flattened version of DeepString with the tail Tail appended.</p>
</div></div>
<div class="function">
<h3 id="foldl/1">foldl(Fun::(byte(), Acc) -&gt; Acc, Acc, X3::binary()) -&gt; Acc</h3>


<div class="description">

<p>
    Calls Fun(Elem, AccIn) on successive elements A of String, starting
    with AccIn == Acc0. Fun/2 must return a new accumulator which is passed
    to the next call. The function returns the final value of the accumulator.
    Acc0 is returned if the string is empty.</p>
</div></div>
<div class="function">
<h3 id="foldr/1">foldr(Fun::(byte(), Acc) -&gt; Acc, Acc, Binary::binary()) -&gt; Acc</h3>


<div class="description">

<p>
    Like foldl/3, but the string is traversed from right to left.</p>
</div></div>
<div class="function">
<h3 id="foreach/1">foreach(Fun::(byte()) -&gt; term(), X2::binary()) -&gt; ok</h3>


<div class="description">

<p>
    Calls Fun(Elem) for each element Elem in String. This function is
    used for its side effects and the evaluation order is defined to be
    the same as the order of the elements in the string.</p>
</div></div>
<div class="function">
<h3 id="keydelete/1">keydelete(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a copy of BlobSequence1 where the first occurrence of a
    blob whose Nth element compares equal to Key is deleted, if there
    is such a blob.</p>
</div></div>
<div class="function">
<h3 id="keyfind/1">keyfind(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; binary() | false</h3>


<div class="description">

<p>
    Searches the list of tuples BlobSequence for a tuple whose Nth element
   compares equal to Key. Returns Blob if such a tuple is found,
    otherwise false.</p>
</div></div>
<div class="function">
<h3 id="keymap/1">keymap(F::(byte()) -&gt; byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a sequence of blobs where, for each blob in BlobSequence1,
    the Nth element Octet of the blob has been replaced with the result
    of calling Fun(Octet).</p>
</div></div>
<div class="function">
<h3 id="keymember/1">keymember(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if there is a blob in BlobSequence whose Nth element
    compares equal to Key, otherwise false.</p>
</div></div>
<div class="function">
<h3 id="keymerge/1">keymerge(N::pos_integer(), Size::pos_integer(), Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging BlobSequence1 and
    BlobSequence2. The merge is performed on the Nth element of each blob.
    Both BlobSequence1 and BlobSequence2 must be key-sorted prior to
    evaluating this function. When two blobs compare equal, the blob
   from BlobSequence1 is picked before the tuple from BlobSequence2.</p>
</div></div>
<div class="function">
<h3 id="keyreplace/1">keyreplace(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary(), Item::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a copy of BlobSequence1 where the first occurrence of a T
    blob whose Nth element compares equal to Key is replaced with NewBlob,
    if there is such a blob T.</p>
</div></div>
<div class="function">
<h3 id="keysearch/1">keysearch(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; {value, binary()} | false</h3>


<div class="description">

<p>
    Searches the sequence of blobs BlobSequence for a blob whose Nth
    element compares equal to Key. Returns {value, Blob} if such a blob
    is found, otherwise false.</p>
</div></div>
<div class="function">
<h3 id="keysort/1">keysort(N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary containing the sorted elements of the blob sequence
    BlobSequence1. Sorting is performed on the Nth element of the blobs.
    The sort is stable.</p>
</div></div>
<div class="function">
<h3 id="keystore/1">keystore(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary(), Item::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a copy of BlobSequence1 where the first occurrence of a blob
    T whose Nth element compares equal to Key is replaced with NewBlob,
    if there is such a tuple T. If there is no such blob T a copy of
    BlobSequence1 where NewBlob has been appended to the end is returned.</p>
</div></div>
<div class="function">
<h3 id="keytake/1">keytake(Key::byte(), N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; {value, binary(), binary()} | false</h3>


<div class="description">

<p>
    Searches the sequence of blobs BlobSequence1 for a blob whose Nth
    element compares equal to Key. Returns {value, Blob, BlobSequence2}
    if such a tuple is found, otherwise false. BlobSequence2 is a copy
    of BlobSequence1 where the first occurrence of Blob has been removed.</p>
</div></div>
<div class="function">
<h3 id="last/1">last(Binary::binary()) -&gt; byte()</h3>


<div class="description">

<p>
    Returns the last octet in the binary.</p>
</div></div>
<div class="function">
<h3 id="map/1">map(F::(byte()) -&gt; byte(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Takes a function from octets to octets, and a binary produces binary
    by applying the function to every octet in the binary. This function
    is used to obtain the return values. The evaluation order is
    implementation dependent.</p>
</div></div>
<div class="function">
<h3 id="mapfoldl/1">mapfoldl(Fun::(byte(), Acc) -&gt; {byte(), Acc}, Acc, Binary::binary()) -&gt; {binary(), Acc}</h3>


<div class="description">

<p>
    mapfoldl combines the operations of map/2 and foldl/3 into one pass.</p>
</div></div>
<div class="function">
<h3 id="mapfoldr/1">mapfoldr(Fun::(byte(), Acc) -&gt; {byte(), Acc}, Acc, Binary::binary()) -&gt; {binary(), Acc}</h3>


<div class="description">

<p>
    mapfoldr combines the operations of map/2 and foldr/3 into one pass</p>
</div></div>
<div class="function">
<h3 id="max/1">max(X1::binary()) -&gt; byte()</h3>


<div class="description">

<p>
    Returns the first octet of the binary that compares greater than
    or equal to all other octets in the binary.</p>
</div></div>
<div class="function">
<h3 id="member/1">member(C::char(), X2::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if Elem matches some element of Binary, otherwise false.</p>
</div></div>
<div class="function">
<h3 id="merge/1">merge(Binaries::[binary()]) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging all the sub-binaries of
    ListOfBinaries. All sub-binaries must be sorted prior to evaluating
    this function. When two octets compare equal, the octets from the
    sub-binary with the lowest position in ListOfBinaries is picked
    before the other octet.</p>
</div></div>
<div class="function">
<h3 id="merge/1-1">merge(B1::binary(), B2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1 and Binary2.
    Both Binary1 and Binary2 must be sorted prior to evaluating this function.
    When two octets compare equal, the octet from Binary1 is picked
    before the octet from Binary2.</p>
</div></div>
<div class="function">
<h3 id="merge/1-2">merge(Pred::(byte(), byte()) -&gt; boolean(), B1::binary(), B2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1 and Binary2.
    Both Binary1 and Binary2 must be sorted according to the ordering
    function Fun prior to evaluating this function. Fun(A, B) should
    return true if A compares less than or equal to B in the ordering,
    false otherwise. When two octets compare equal, the octet from Binary1
    is picked before the octet from Binary2.</p>
</div></div>
<div class="function">
<h3 id="merge3/1">merge3(B1::binary(), B2::binary(), B3::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1, Binary2 and Binary3.
   All of Binary1, Binary2 and Binary3 must be sorted prior to evaluating
   this function. When two octets compare equal, the octet from Binary1,
   if there is such an octet, is picked before the other octet, otherwise
   the octet from Binary2 is picked before the octet from Binary3.</p>
</div></div>
<div class="function">
<h3 id="min/1">min(X1::binary()) -&gt; byte()</h3>


<div class="description">

<p>
    Returns the first octet of Binary that compares less than or equal
    to all other octets of Binary.</p>
</div></div>
<div class="function">
<h3 id="nth/1">nth(Pos::pos_integer(), Binary::binary()) -&gt; byte()</h3>


<div class="description">

<p>
    Returns the Nth octet of Binary. One based.</p>
</div></div>
<div class="function">
<h3 id="nthtail/1">nthtail(Pos::pos_integer(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the Nth tail of Binary, that is, the sub-binary of Binary
    starting at N+1 and continuing up to the end of the binary.</p>
</div></div>
<div class="function">
<h3 id="partition/1">partition(Pred::(byte()) -&gt; boolean(), Binary::binary()) -&gt; {binary(), binary()}</h3>


<div class="description">

<p>
    Partitions Binary into two binaries, where the first binary contains
    all octets for which Pred(Octet) returns true, and the second binary
    contains all octets for which Pred(Octet) returns false.</p>
</div></div>
<div class="function">
<h3 id="prefix/1">prefix(Binary1::binary(), Binary2::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if Binary1 is a prefix of Binary2, otherwise false.</p>
</div></div>
<div class="function">
<h3 id="reverse/1">reverse(X1::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a string with the elements in String1 in reverse order.</p>
</div></div>
<div class="function">
<h3 id="reverse/1-1">reverse(Binary::binary(), Tail::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a string with the elements in String1 in reverse order,
    with the tail Tail appended.</p>
</div></div>
<div class="function">
<h3 id="seq/1">seq(From::byte(), To::byte()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a sequence of integers which starts with From and contains the
    successive results of adding 1 to the previous element, until To has
    been reached number encompassed by the sequence. Wraps to zero when
    it reaches 255.</p>
</div></div>
<div class="function">
<h3 id="seq/1-1">seq(From::byte(), To::byte(), Incr::byte()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a sequence of integers which starts with From and contains the
    successive results of adding Incr to the previous element, until To has
    been reached or passed (in the latter case, To is not an element of
    the sequence). Wraps to zero when it reaches 255.</p>
</div></div>
<div class="function">
<h3 id="sort/1">sort(Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary containing the sorted octets of Binary1.</p>
</div></div>
<div class="function">
<h3 id="sort/1-1">sort(Fun::(byte(), byte()) -&gt; boolean(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary containing the sorted octets of Binary1, according
    to the ordering function Fun. Fun(A, B) should return true if A
    compares less than or equal to B in the ordering, false otherwise.</p>
</div></div>
<div class="function">
<h3 id="split/1">split(N::non_neg_integer(), Binary::binary()) -&gt; {binary(), binary()}</h3>


<div class="description">

<p>
    Splits Binary1 into Binary2 and Binary3. Binary2 contains the first
    N octets and Binary3 the rest of the octets (the Nth tail).</p>
</div></div>
<div class="function">
<h3 id="splitwith/1">splitwith(Pred::(byte()) -&gt; boolean(), Binary::binary()) -&gt; {binary(), binary()}</h3>


<div class="description">

<p>    
Partitions Binary into two binaries according to Pred.    
splitwith/2 behaves as if it is defined as follows:</p>
 
    <p>splitwith(Pred, Binary) -&gt;
        {takewhile(Pred, Binary), dropwhile(Pred, Binary)}.</p>
</div></div>
<div class="function">
<h3 id="sublist/1">sublist(Binary::binary(), Len::pos_integer()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sub-binary of Binary1 starting at position 1 and with
    (max) Len octets. It is not an error for Len to exceed the length
    of the binary, in that case the whole binary is returned.</p>
</div></div>
<div class="function">
<h3 id="sublist/1-1">sublist(Binary::binary(), Start::pos_integer(), Len::pos_integer()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sub-binary of Binary1 starting at Start and with (max)
    Len octets. It is not an error for Start+Len to exceed the length
    of the binary.</p>
</div></div>
<div class="function">
<h3 id="subtract/1">subtract(Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a new binary Binary3 which is a copy of Binary1, subjected
    to the following procedure: for each octet in Binary2, its first
    occurrence in Binary1 is deleted.</p>
</div></div>
<div class="function">
<h3 id="suffix/1">suffix(Binary1::binary(), Binary2::binary()) -&gt; boolean()</h3>


<div class="description">

<p>
    Returns true if Binary1 is a suffix of Binary2, otherwise false.</p>
</div></div>
<div class="function">
<h3 id="sum/1">sum(Binary::binary()) -&gt; integer()</h3>


<div class="description">

<p>
    Returns the sum of the octets in binary.</p>
</div></div>
<div class="function">
<h3 id="takewhile/1">takewhile(Pred::(byte()) -&gt; boolean(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Takes octet Octet from Binary1 while Pred(Octet) returns true,
    that is, the function returns the longest prefix of the binary
    for which all octets satisfy the predicate.</p>
</div></div>
<div class="function">
<h3 id="ukeymerge/1">ukeymerge(N::pos_integer(), Size::pos_integer(), Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging BlobSequence1 and
    BlobSequence2. The merge is performed on the Nth octet of each blob.
    Both BlobSequence1 and BlobSequence2 must be key-sorted without
    duplicates prior to evaluating this function. When two blobs compare
    equal, the blob from BlobSequence1 is picked and the one from
    BlobSequence2 deleted.</p>
</div></div>
<div class="function">
<h3 id="ukeysort/1">ukeysort(N::pos_integer(), Size::pos_integer(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary containing the sorted octets of the binary
    BlobSequence1 where all but the first blob of the blobs comparing
    equal have been deleted. Sorting is performed on the Nth element
    of the blobs.</p>
</div></div>
<div class="function">
<h3 id="umerge/1">umerge(Binaries::[binary()]) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging all the sub-binaries of
    ListOfBinaries. All sub-binaries must be sorted and contain no
    duplicates prior to evaluating this function. When two elements compare
    equal, the element from the sub-binaries with the lowest position in
    ListOfBinaries is picked and the other one deleted.</p>
</div></div>
<div class="function">
<h3 id="umerge/1-1">umerge(B1::binary(), B2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1 and Binary2.
    Both Binary1 and Binary2 must be sorted and contain no duplicates
    prior to evaluating this function. When two octets compare equal,
    the octet from Binary1 is picked and the one from Binary2 deleted.</p>
</div></div>
<div class="function">
<h3 id="umerge/1-2">umerge(Pred::(byte(), byte()) -&gt; boolean(), B1::binary(), B2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1 and Binary2.
    Both Binary1 and Binary2 must be sorted according to the ordering
    function Fun and contain no duplicates prior to evaluating this
    function. Fun(A, B) should return true if A compares less than or
     equal to B in the ordering, false otherwise. When two octets compare
     equal, the octet from Binary1 is picked and the one from Binary2 deleted.</p>
</div></div>
<div class="function">
<h3 id="umerge3/1">umerge3(B1::binary(), B2::binary(), B3::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns the sorted binary formed by merging Binary1, Binary2 and
    Binary3. All of Binary1, Binary2 and Binary3 must be sorted and
    contain no duplicates prior to evaluating this function. When two
    octets compare equal, the octet from Binary1 is picked if there is
    such an octet, otherwise the octet from Binary2 is picked, and the
    other one deleted.</p>
</div></div>
<div class="function">
<h3 id="unzip/1">unzip(Binary::binary()) -&gt; {binary(), binary()}</h3>


<div class="description">

<p>
    "Unzips" a binary of two octet blobs into two binarys, where the first
    binary contains the first octet of each blob, and the second binary
    contains the second octet of each blob.</p>
</div></div>
<div class="function">
<h3 id="unzip3/1">unzip3(Binary::binary()) -&gt; {binary(), binary(), binary()}</h3>


<div class="description">

<p>
    "Unzips" a binary of three octet blobs into three binarys, where the first
     binary contains the first octet of each blob, the second binary
     contains the second octet of each blob, and the third binary
     contains the third octet of each blob.</p>
</div></div>
<div class="function">
<h3 id="usort/1">usort(Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary containing the sorted octets of Binary1 where all
    but the first octet of the octets comparing equal have been deleted.</p>
</div></div>
<div class="function">
<h3 id="usort/1-1">usort(Fun::(byte(), byte()) -&gt; boolean(), Binary::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    Returns a binary which contains the sorted octets of Binary1 where
    all but the first octet of the octets comparing equal according to
    the ordering function Fun have been deleted. Fun(A, B) should return
    true if A compares less than or equal to B in the ordering,
    false otherwise.</p>
</div></div>
<div class="function">
<h3 id="zip/1">zip(Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    "Zips" two binaries of equal length into one binary of two-blobs,
     where the first octet of each blob is taken from the first binary
     and the second octet is taken from corresponding octet in the
     second binary.</p>
</div></div>
<div class="function">
<h3 id="zip3/1">zip3(Binary1::binary(), Binary2::binary(), Binary3::binary()) -&gt; binary()</h3>


<div class="description">

<p>
    "Zips" three binaries of equal length into one binary of three-blobs,
    where the first octet of each blob is taken from the first binary,
    the second octet is taken from corresponding octet in the second binary,
    and the third octet is taken from the corresponding octet in the
    third binary.</p>
</div></div>
<div class="function">
<h3 id="zipwith/1">zipwith(Fun::(byte(), byte()) -&gt; binary(), Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">

<p>    
Combine the octets of two binarys of equal length into one binary.    
For each pair X, Y of binary octets from the two binarys, the binary    
in the result binary will be Combine(X, Y).</p>
 
    <p><code>zipwith(fun(X, Y) -&gt; &lt;&lt;X, Y&gt;&gt; end, Binary1, Binary2)</code> is equivalent
    to zip(Binary1, Binary2).</p>
</div></div>
<div class="function">
<h3 id="zipwith3/1">zipwith3(Fun::(byte(), byte(), byte()) -&gt; binary(), Binary1::binary(), Binary2::binary(), Binary3::binary()) -&gt; binary()</h3>


<div class="description">

<p>    
Combine the octets of three binarys of equal length into one binary.    
For each triple X, Y, Z of binary octets from the thre binarys, the binary    
in the result binary will be Combine(X, Y, Z).</p>
 
    <p><code>zipwith(fun(X, Y, Z) -&gt; &lt;&lt;X, Y, Z&gt;&gt; end, Binary1, Binary2, Binary3)</code> is
    equivalent to zip(Binary1, Binary2. Binary3).</p>
</div></div></div>

<authors>

<aname>Jan Henry Nystrom</aname>
<email>JanHenryNystrom@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
