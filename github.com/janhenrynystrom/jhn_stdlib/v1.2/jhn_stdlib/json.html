<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>json (jhn_stdlib) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>json</h1>
<h2 class="modsummary">    
A JSON to and from erlang terms library based on rfc4627.</h2>
<div class="description">
<p>    
A JSON to and from erlang terms library based on rfc4627.</p>
  
    <p>JSON is represented as follows:</p>
  
    <p>text  : object | array
    object: {[{string, value}*]}
    array : [value*]
    string: atom | <code>&lt;&lt;octet*&gt;&gt;</code>    
number: integer | float    
true  : 'true'    
false : 'false'    
null  : 'null'</p>
  
    <p>Strings can be represented by atoms when generating JSON, but will not    
not be generated when converting JSON to erlang. It can be specified    
what encoding is used for the strings with latin1 being the default    
when encoding but UTF-8 when decoding since otherwise it might fail.    
All atoms are assumed to be in latin1 and can not be specified.</p>
  
    <p>The encoding of a JSON text is determined and can be specified when    
convering from Erlang terms with the deafult being UTF-8.</p>
  
    <p>When converting Erlang terms to JSON iolists are generated but    
it can generate a binary if so instructed.</p>
  
    <p>latin1 is defined in ISO-8859-1.    
UTF formats are defined in Unicode 5.0 (ISBN 0-321-48091-0).</p>
  
   Only supports R16 and later.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-encoding">encoding() = utf8<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {utf16, little | big}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {utf32, little | big}</h3></div>
    <div class="type"><h3 id="type-json">json() = <a href="#type-json_text" class="seealso">json_text()</a></h3></div>
    <div class="type"><h3 id="type-json_array">json_array() = [<a href="#type-json_value" class="seealso">json_value()</a>]</h3></div>
    <div class="type"><h3 id="type-json_object">json_object() = {[{<a href="#type-json_string" class="seealso">json_string()</a>, <a href="#type-json_value" class="seealso">json_value()</a>}]}</h3></div>
    <div class="type"><h3 id="type-json_string">json_string() = atom() | string()</h3></div>
    <div class="type"><h3 id="type-json_text">json_text() = <a href="#type-json_object" class="seealso">json_object()</a> | <a href="#type-json_array" class="seealso">json_array()</a></h3></div>
    <div class="type"><h3 id="type-json_value">json_value() = false<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| true<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| null<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| number()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-json_string" class="seealso">json_string()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-json_object" class="seealso">json_object()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-json_array" class="seealso">json_array()</a></h3></div>
    <div class="type"><h3 id="type-opt">opt() = {atom_strings, boolean()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {atom_keys, boolean()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {existing_atom_keys, boolean()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bom<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| binary<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| iolist<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {plain_string, <a href="#type-plain_format" class="seealso">plain_format()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {encoding, <a href="#type-encoding" class="seealso">encoding()</a>}</h3></div>
    <div class="type"><h3 id="type-plain_format">plain_format() = latin1 | <a href="#type-encoding" class="seealso">encoding()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="encode/1">encode(Term::json()) -&gt; iolist()</h3>


<div class="description">

<p>
    Encodes the structured Erlang term as an iolist.
    Equivalent of encode(Term, []) -&gt; JSON.</p>
</div></div>
<div class="function">
<h3 id="encode/1-1">encode(Term::json(), Opts::[opt()] | #opts{encoding=encoding(), plain_string=plain_format(), atom_strings=boolean(), atom_keys=boolean(), existing_atom_keys=boolean(), bom=boolean(), return_type=iolist | binary, orig_call=any()}) -&gt; iolist() | binary()</h3>


<div class="description">

<p>
    Encodes the structured Erlang term as an iolist or binary.
    Encode will give an exception if the erlang term is not well formed.
    Options are:
      binary -&gt; a binary is returned
      iolist -&gt; a iolist is returned
      bom -&gt; a UTF byte order mark is added at the head of the encoding
      {atom_strings, Bool} -&gt; determines if atoms for strings are allowed
      {plain_string, Format} -&gt; what format the strings are encoded in
      {encoding, Encoding} -&gt; what encoding is used for the resulting JSON</p>
</div></div>
<div class="function">
<h3 id="decode/1">decode(Binary::binary()) -&gt; json()</h3>


<div class="description">

<p>
    Decodes the binary into a structured Erlang term.
    Equivalent of decode(JSON, []) -&gt; Term.</p>
</div></div>
<div class="function">
<h3 id="decode/1-1">decode(Binary::binary(), Opts::[opt()] | #opts{encoding=encoding(), plain_string=plain_format(), atom_strings=boolean(), atom_keys=boolean(), existing_atom_keys=boolean(), bom=boolean(), return_type=iolist | binary, orig_call=any()}) -&gt; json()</h3>


<div class="description">

<p>
    Decodes the binary into a structured Erlang.
    Decode will give an exception if the binary is not well formed JSON.
    Options are:
      bom -&gt; the binary to decode has a UTF byte order mark
      {plain_string, Format} -&gt; what format the strings are encoded in
      {atom_keys, Bool} -&gt; if true all object keys are converted to atoms,
                           default is false.
      {existing_atom_keys, Bool} -&gt; if true all object keys are converted
                           to atoms, decoding fails if the atom does not
                           already exist, default is false.
      For both atom_keys and existing_atom_keys the string has to Unicode
      characters up to 0xFF.</p>
</div></div></div>

<authors>

<aname>Jan Henry Nystrom</aname>
<email>JanHenryNystrom@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
