<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper_types (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper_types</h1>
<h2 class="modsummary">Type manipulation functions and predefined types.</h2>
<div class="description">
<p>Type manipulation functions and predefined types.</p>
  
   <em><marker id="Basic_types">Basic types</marker></em><p>
   This module defines all the basic types of the PropEr type system as
   functions. See the <a href="#index" class="seealso">function index</a> for an overview.</p>
  
   <p>Types can be combined in tuples or lists to produce other types. Exact
   values (such as exact numbers, atoms, binaries and strings) can be combined
   with types inside such structures, like in this example of the type of a
   tagged tuple: <code>{'result', integer()}</code>.</p>
  
   <p>When including the PropEr header file, all
   <a href="#index" class="seealso">API functions</a> of this module are automatically
   imported, unless <code>PROPER_NO_IMPORTS</code> is defined.</p>
  
   <em><marker id="Customized_types">Customized types</marker></em><p>   
The following operators can be applied to basic types in order to produce   
new ones:</p>
  
   <taglist>
   <dt><code>?LET(&lt;Xs&gt;, &lt;Xs_type&gt;, &lt;In&gt;)</code></dt>
   <item><p>To produce an instance of this type, all appearances of the variables
     in <code>&lt;Xs&gt;</code> are replaced inside <code>&lt;In&gt;</code> by their corresponding values in a
     randomly generated instance of <code>&lt;Xs_type&gt;</code>. It's OK for the <code>&lt;In&gt;</code> part to
     evaluate to a type - in that case, an instance of the inner type is
     generated recursively.</p></item>
   <dt><code>?SUCHTHAT(&lt;X&gt;, &lt;Type&gt;, &lt;Condition&gt;)</code></dt>
   <item><p>This produces a specialization of <code>&lt;Type&gt;</code>, which only includes those
     members of <code>&lt;Type&gt;</code> that satisfy the constraint <code>&lt;Condition&gt;</code> - that is,
     those members for which the function <code>fun(&lt;X&gt;) -&gt; &lt;Condition&gt; end</code> returns
     <code>true</code>. If the constraint is very strict - that is, only a small
     percentage of instances of <code>&lt;Type&gt;</code> pass the test - it will take a lot of
     tries for the instance generation subsystem to randomly produce a valid
     instance. This will result in slower testing, and testing may even be
     stopped short, in case the <code>constraint_tries</code> limit is reached (see the
     "Options" section in the documentation of the <a href="proper.html" class="seealso">proper</a> module). If
     this is the case, it would be more appropriate to generate valid instances
     of the specialized type using the <code>?LET</code> macro. Also make sure that even
     small instances can satisfy the constraint, since PropEr will only try
     small instances at the start of testing. If this is not possible, you can
     instruct PropEr to start at a larger size, by supplying a suitable value
     for the <code>start_size</code> option (see the "Options" section in the
     documentation of the <a href="proper.html" class="seealso">proper</a> module).</p></item>
   <dt><code>?SUCHTHATMAYBE(&lt;X&gt;, &lt;Type&gt;, &lt;Condition&gt;)</code></dt>
   <item><p>Equivalent to the <code>?SUCHTHAT</code> macro, but the constraint <code>&lt;Condition&gt;</code>
     is considered non-strict: if the <code>constraint_tries</code> limit is reached, the
     generator will just return an instance of <code>&lt;Type&gt;</code> instead of failing,
     even if that instance doesn't satisfy the constraint.</p></item>
   <dt><code>?SHRINK(&lt;Generator&gt;, &lt;List_of_alt_gens&gt;)</code></dt>
   <item><p>This creates a type whose instances are generated by evaluating the
     statement block <code>&lt;Generator&gt;</code> (this may evaluate to a type, which will
     then be generated recursively). If an instance of such a type is to be
     shrunk, the generators in <code>&lt;List_of_alt_gens&gt;</code> are first run to produce
     hopefully simpler instances of the type. Thus, the generators in the
     second argument should be simpler than the default. The simplest ones
     should be at the front of the list, since those are the generators
     preferred by the shrinking subsystem. Like the main <code>&lt;Generator&gt;</code>, the
     alternatives may also evaluate to a type, which is generated recursively.
     </p></item>
   <dt><code>?LETSHRINK(&lt;List_of_variables&gt;, &lt;List_of_types&gt;, &lt;Generator&gt;)</code></dt>
   <item><p>This is created by combining a <code>?LET</code> and a <code>?SHRINK</code> macro. Instances
     are generated by applying a randomly generated list of values inside
     <code>&lt;Generator&gt;</code> (just like a <code>?LET</code>, with the added constraint that the
     variables and types must be provided in a list - alternatively,
     <code>&lt;List_of_types&gt;</code> may be a list or vector type). When shrinking instances
     of such a type, the sub-instances that were combined to produce it are
     first tried in place of the failing instance.</p></item>
   <dt><code>?LAZY(&lt;Generator&gt;)</code></dt>
   <item><p>This construct returns a type whose only purpose is to delay the
     evaluation of <code>&lt;Generator&gt;</code> (<code>&lt;Generator&gt;</code> can return a type, which will
     be generated recursively). Using this, you can simulate the lazy
     generation of instances:
     </p><pre class="sh_erlang">         stream() -&gt; ?LAZY(frequency([ {1,[]}, {3,[0|stream()]} ])).</pre><p>
     The above type produces lists of zeroes with an average length of 3. Note
     that, had we not enclosed the generator with a <code>?LAZY</code> macro, the
     evaluation would continue indefinitely, due to the eager evaluation of
     the Erlang language.</p></item>
   <dt><code>non_empty(&lt;List_or_binary_type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#non_empty/1" class="seealso">non_empty/1</a>.</p></item>
   <dt><code>noshrink(&lt;Type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#noshrink/1" class="seealso">noshrink/1</a>.</p></item>
   <dt><code>default(&lt;Default_value&gt;, &lt;Type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#default/2" class="seealso">default/2</a>.</p></item>
   <dt><code>with_parameter(&lt;Parameter&gt;, &lt;Value&gt;, &lt;Type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#with_parameter/3" class="seealso">with_parameter/3</a>.</p></item>
   <dt><code>with_parameters(&lt;Param_value_pairs&gt;, &lt;Type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#with_parameters/2" class="seealso">with_parameters/2</a>.</p></item>
   </taglist>
  
   <em><marker id="Size_manipulation">Size manipulation</marker></em><p>
   The following operators are related to the <code>size</code> parameter, which controls
   the maximum size of produced instances. The actual size of a produced
   instance is chosen randomly, but can never exceed the value of the <code>size</code>
   parameter at the moment of generation. A more accurate definition is the
   following: the maximum instance of <code>size S</code> can never be smaller than the
   maximum instance of <code>size S-1</code>. The actual size of an instance is measured
   differently for each type: the actual size of a list is its length, while
   the actual size of a tree may be the number of its internal nodes. Some
   types, e.g. unions, have no notion of size, thus their generation is not
   influenced by the value of <code>size</code>. The <code>size</code> parameter starts at 1 and   
grows automatically during testing.</p>
  
   <taglist>
   <dt><code>?SIZED(&lt;S&gt;, &lt;Generator&gt;)</code></dt>
   <item><p>Creates a new type, whose instances are produced by replacing all
     appearances of the <code>&lt;S&gt;</code> parameter inside the statement block
     <code>&lt;Generator&gt;</code> with the value of the <code>size</code> parameter. It's OK for the
     <code>&lt;Generator&gt;</code> to return a type - in that case, an instance of the inner
     type is generated recursively.</p></item>
   <dt><code>resize(&lt;New_size&gt;, &lt;Type&gt;)</code></dt>
   <item><p>See the documentation for <a href="#resize/2" class="seealso">resize/2</a>.</p></item>
   </taglist></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-extint">extint() = integer() | inf</h3></div>
    <div class="type"><h3 id="type-extnum">extnum() = number() | inf</h3></div>
    <div class="type"><h3 id="type-frequency">frequency() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-length">length() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-raw_type">raw_type() = <a href="#type-type" class="seealso">type()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<a href="#type-raw_type" class="seealso">raw_type()</a>]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-loose_tuple" class="seealso">loose_tuple</a>(<a href="#type-raw_type" class="seealso">raw_type()</a>)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| term()</h3></div>
    <div class="type"><h3 id="type-size">size() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-type">type()</h3></div>
    <div class="type"><h3 id="type-value">value() = term()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="integer/1">integer(Low::extint(), High::extint()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All integers between <code>Low</code> and <code>High</code>, bounds included.
  <code>Low</code> and <code>High</code> must be Erlang expressions that evaluate to integers, with
  <code>Low =&lt; High</code>. Additionally, <code>Low</code> and <code>High</code> may have the value <code>inf</code>, in
  which case they represent minus infinity and plus infinity respectively.
  Instances shrink towards 0 if <code>Low =&lt; 0 =&lt; High</code>, or towards the bound with
  the smallest absolute value otherwise.</p>
</div></div>
<div class="function">
<h3 id="float/1">float(Low::extnum(), High::extnum()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All floats between <code>Low</code> and <code>High</code>, bounds included.
  <code>Low</code> and <code>High</code> must be Erlang expressions that evaluate to floats, with
  <code>Low =&lt; High</code>. Additionally, <code>Low</code> and <code>High</code> may have the value <code>inf</code>, in
  which case they represent minus infinity and plus infinity respectively.
  Instances shrink towards 0.0 if <code>Low =&lt; 0.0 =&lt; High</code>, or towards the bound
  with the smallest absolute value otherwise.</p>
</div></div>
<div class="function">
<h3 id="atom/0">atom() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All atoms. All atoms used internally by PropEr start with a '<code>$</code>', so
  such atoms will never be produced as instances of this type. You should also
  refrain from using such atoms in your code, to avoid a potential clash.
  Instances shrink towards the empty atom, ''.</p>
</div></div>
<div class="function">
<h3 id="binary/0">binary() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All binaries. Instances shrink towards the empty binary, <code>&lt;&lt;&gt;&gt;</code>.</p>
</div></div>
<div class="function">
<h3 id="binary/1">binary(Len::length()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All binaries with a byte size of <code>Len</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.
  Instances shrink towards binaries of zeroes.</p>
</div></div>
<div class="function">
<h3 id="bitstring/0">bitstring() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All bitstrings. Instances shrink towards the empty bitstring, <code>&lt;&lt;&gt;&gt;</code>.</p>
</div></div>
<div class="function">
<h3 id="bitstring/1">bitstring(Len::length()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All bitstrings with a bit size of <code>Len</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.
  Instances shrink towards bitstrings of zeroes</p>
</div></div>
<div class="function">
<h3 id="list/1">list(ElemType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All lists containing elements of type <code>ElemType</code>.
  Instances shrink towards the empty list, <code>[]</code>.</p>
</div></div>
<div class="function">
<h3 id="shrink_list/1">shrink_list(List::[term()]) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A type that generates exactly the list <code>List</code>. Instances shrink towards
  shorter sublists of the original list.</p>
</div></div>
<div class="function">
<h3 id="vector/1">vector(Len::length(), ElemType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All lists of length <code>Len</code> containing elements of type <code>ElemType</code>.
  <code>Len</code> must be an Erlang expression that evaluates to a non-negative integer.</p>
</div></div>
<div class="function">
<h3 id="union/1">union(ListOfTypes::[raw_type(), ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>The union of all types in <code>ListOfTypes</code>. <code>ListOfTypes</code> can't be empty.
  The random instance generator is equally likely to choose any one of the
  types in <code>ListOfTypes</code>. The shrinking subsystem will always try to shrink an
  instance of a type union to an instance of the first type in <code>ListOfTypes</code>,
  thus you should write the simplest case first.</p>
</div></div>
<div class="function">
<h3 id="weighted_union/1">weighted_union(ListOfTypes::[{frequency(), raw_type()}, ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A specialization of <a href="#union/1" class="seealso">union/1</a>, where each type in <code>ListOfTypes</code> is
  assigned a frequency. Frequencies must be Erlang expressions that evaluate to
  positive integers. Types with larger frequencies are more likely to be chosen
  by the random instance generator. The shrinking subsystem will ignore the
  frequencies and try to shrink towards the first type in the list.</p>
</div></div>
<div class="function">
<h3 id="tuple/1">tuple(ListOfTypes::[raw_type()]) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All tuples whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>. Also written simply as a tuple of types.</p>
</div></div>
<div class="function">
<h3 id="loose_tuple/1">loose_tuple(ElemType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Tuples whose elements are all of type <code>ElemType</code>.
  Instances shrink towards the 0-size tuple, <code>{}</code>.</p>
</div></div>
<div class="function">
<h3 id="exactly/1">exactly(E::term()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Singleton type consisting only of <code>E</code>. <code>E</code> must be an evaluated term.
  Also written simply as <code>E</code>.</p>
</div></div>
<div class="function">
<h3 id="fixed_list/1">fixed_list(ListOfTypes::maybe_improper_list(raw_type(), raw_type() | [])) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All lists whose i-th element is an instance of the type at index i of
  <code>ListOfTypes</code>. Also written simply as a list of types.</p>
</div></div>
<div class="function">
<h3 id="function/1">function(ArgTypes::[raw_type()] | arity(), RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All pure functions that map instances of <code>ArgTypes</code> to instances of
  <code>RetType</code>. The syntax <code>function(Arity, RetType)</code> is also acceptable.</p>
</div></div>
<div class="function">
<h3 id="any/0">any() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All Erlang terms (that PropEr can produce). For reasons of efficiency,
  functions are never produced as instances of this type.<br />
  CAUTION: Instances of this type are expensive to produce, shrink and instance-
  check, both in terms of processing time and consumed memory. Only use this
  type if you are certain that you need it.</p>
</div></div>
<div class="function">
<h3 id="integer/0">integer() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(inf, inf)</a>.</p>
</div></div>
<div class="function">
<h3 id="non_neg_integer/0">non_neg_integer() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(0, inf)</a>.</p>
</div></div>
<div class="function">
<h3 id="pos_integer/0">pos_integer() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(1, inf)</a>.</p>
</div></div>
<div class="function">
<h3 id="neg_integer/0">neg_integer() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(inf, -1)</a>.</p>
</div></div>
<div class="function">
<h3 id="range/1">range(Low::extint(), High::extint()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(Low, High)</a>.</p>
</div></div>
<div class="function">
<h3 id="float/0">float() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#float/2" class="seealso">float(inf, inf)</a>.</p>
</div></div>
<div class="function">
<h3 id="non_neg_float/0">non_neg_float() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#float/2" class="seealso">float(0.0, inf)</a>.</p>
</div></div>
<div class="function">
<h3 id="number/0">number() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#union/1" class="seealso">union([integer(), float()])</a>.</p>
</div></div>
<div class="function">
<h3 id="boolean/0">boolean() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>The atoms <code>true</code> and <code>false</code>. Instances shrink towards <code>false</code>.</p>
</div></div>
<div class="function">
<h3 id="byte/0">byte() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(0, 255)</a>.</p>
</div></div>
<div class="function">
<h3 id="char/0">char() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(0, 1114111)</a>.</p>
</div></div>
<div class="function">
<h3 id="list/0">list() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#list/1" class="seealso">list(any())</a>.</p>
</div></div>
<div class="function">
<h3 id="tuple/0">tuple() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#loose_tuple/1" class="seealso">loose_tuple(any())</a>.</p>
</div></div>
<div class="function">
<h3 id="string/0">string() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#list/1" class="seealso">list(char())</a>.</p>
</div></div>
<div class="function">
<h3 id="wunion/1">wunion(FreqChoices::[{frequency(), raw_type()}, ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#weighted_union/1" class="seealso">weighted_union(FreqChoices)</a>.</p>
</div></div>
<div class="function">
<h3 id="term/0">term() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#any/0" class="seealso">any()</a>.</p>
</div></div>
<div class="function">
<h3 id="timeout/0">timeout() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#union/1" class="seealso">union([non_neg_integer() | infinity])</a>.</p>
</div></div>
<div class="function">
<h3 id="arity/0">arity() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(0, 255)</a>.</p>
</div></div>
<div class="function">
<h3 id="int/0">int() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Small integers (bound by the current value of the <code>size</code> parameter).
  Instances shrink towards <code>0</code>.</p>
</div></div>
<div class="function">
<h3 id="nat/0">nat() -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Small non-negative integers (bound by the current value of the <code>size</code>
  parameter). Instances shrink towards <code>0</code>.</p>
</div></div>
<div class="function">
<h3 id="largeint/0">largeint() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/0" class="seealso">integer()</a>.</p>
</div></div>
<div class="function">
<h3 id="real/0">real() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#float/0" class="seealso">float()</a>.</p>
</div></div>
<div class="function">
<h3 id="bool/0">bool() -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#boolean/0" class="seealso">boolean()</a>.</p>
</div></div>
<div class="function">
<h3 id="choose/1">choose(Low::extint(), High::extint()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#integer/2" class="seealso">integer(Low, High)</a>.</p>
</div></div>
<div class="function">
<h3 id="elements/1">elements(Choices::[raw_type(), ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#union/1" class="seealso">union(Choices)</a>.</p>
</div></div>
<div class="function">
<h3 id="oneof/1">oneof(Choices::[raw_type(), ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#union/1" class="seealso">union(Choices)</a>.</p>
</div></div>
<div class="function">
<h3 id="frequency/1">frequency(FreqChoices::[{frequency(), raw_type()}, ...]) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#weighted_union/1" class="seealso">weighted_union(Choices)</a>.</p>
</div></div>
<div class="function">
<h3 id="return/1">return(E::term()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#exactly/1" class="seealso">exactly(E)</a>.</p>
</div></div>
<div class="function">
<h3 id="default/1">default(Default::raw_type(), Type::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Adds a default value, <code>Default</code>, to <code>Type</code>.
  The default serves as a primary shrinking target for instances, while it
  is also chosen by the random instance generation subsystem half the time.</p>
</div></div>
<div class="function">
<h3 id="orderedlist/1">orderedlist(ElemType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>All sorted lists containing elements of type <code>ElemType</code>.
  Instances shrink towards the empty list, <code>[]</code>.</p>
</div></div>
<div class="function">
<h3 id="function0/1">function0(RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#function/2" class="seealso">function(0, RetType)</a>.</p>
</div></div>
<div class="function">
<h3 id="function1/1">function1(RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#function/2" class="seealso">function(1, RetType)</a>.</p>
</div></div>
<div class="function">
<h3 id="function2/1">function2(RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#function/2" class="seealso">function(2, RetType)</a>.</p>
</div></div>
<div class="function">
<h3 id="function3/1">function3(RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#function/2" class="seealso">function(3, RetType)</a>.</p>
</div></div>
<div class="function">
<h3 id="function4/1">function4(RetType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">
<p>Equivalent to <a href="#function/2" class="seealso">function(4, RetType)</a>.</p>
</div></div>
<div class="function">
<h3 id="weighted_default/1">weighted_default(Default::{frequency(), raw_type()}, Type::{frequency(), raw_type()}) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A specialization of <a href="#default/2" class="seealso">default/2</a>, where <code>Default</code> and <code>Type</code> are
  assigned weights to be considered by the random instance generator. The
  shrinking subsystem will ignore the weights and try to shrink using the
  default value.</p>
</div></div>
<div class="function">
<h3 id="resize/1">resize(NewSize::size(), Type::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Overrides the <code>size</code> parameter used when generating instances of
  <code>Type</code> with <code>NewSize</code>. Has no effect on size-less types, such as unions.
  Also, this will not affect the generation of any internal types contained in
  <code>Type</code>, such as the elements of a list - those will still be generated
  using the test-wide value of <code>size</code>. One use of this function is to modify
  types to produce instances that grow faster or slower, like so:
  </p><pre class="sh_erlang">     ?SIZED(Size, resize(Size * 2, list(integer()))</pre><p>
  The above specifies a list type that grows twice as fast as normal lists.</p>
</div></div>
<div class="function">
<h3 id="non_empty/1">non_empty(ListType::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>This is a predefined constraint that can be applied to random-length
  list and binary types (e.g. <a href="#list/0" class="seealso">list/0</a>, <a href="#string/0" class="seealso">string/0</a>,
  <a href="#binary/0" class="seealso">binary/0</a>) to ensure that the produced values are never empty.</p>
</div></div>
<div class="function">
<h3 id="noshrink/1">noshrink(Type::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Creates a new type which is equivalent to <code>Type</code>, but whose instances
  are never shrunk by the shrinking subsystem.</p>
</div></div>
<div class="function">
<h3 id="with_parameter/1">with_parameter(Parameter::atom(), Value::value(), Type::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Associates the atom key <code>Parameter</code> with the value <code>Value</code> while
  generating instances of <code>Type</code>.</p>
</div></div>
<div class="function">
<h3 id="with_parameters/1">with_parameters(PVlist::[{atom(), value()}], Type::raw_type()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Similar to <a href="#with_parameter/3" class="seealso">with_parameter/3</a>, but accepts a list of
  <code>{Parameter, Value}</code> pairs.</p>
</div></div>
<div class="function">
<h3 id="parameter/1">parameter(Parameter::atom(), Default::value()) -&gt; value()</h3>


<div class="description">

<p>Returns the value associated with <code>Parameter</code>, or <code>Default</code> in case
  <code>Parameter</code> is not associated with any value.</p>
</div></div>
<div class="function">
<h3 id="parameter/1-1">parameter(Parameter::atom()) -&gt; value()</h3>


<div class="description">
<p>Equivalent to <a href="#parameter/2" class="seealso">parameter(Parameter, undefined)</a>.</p>
</div></div></div>

<authors>

<aname>Manolis Papadakis</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
