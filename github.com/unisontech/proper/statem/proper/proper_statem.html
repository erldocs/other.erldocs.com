<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper_statem (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper_statem</h1>
<h2 class="modsummary">This module contains functions for testing stateful systems whose   
side-effects are specified via an abstract state machine.</h2>
<div class="description">
<p>This module contains functions for testing stateful systems whose   
side-effects are specified via an abstract state machine. Given a callback   
module implementing the state machine, PropEr can generate random   
symbolic command sequences subject to the constraints of the specification.   
These command sequences model the operations in the system under test (SUT).   
As a next step, symbolic command sequences are evaluated in order to check   
that the system behaves as expected. Upon failure, the shrinking mechanism   
attempts to find a minimal command sequence provoking the same error.</p>
  
   <p>When including the <code>"proper/include/proper.hrl"</code> header file,
   all <a href="#index" class="seealso">API functions </a> of proper_statem are automatically
   imported, unless <code>PROPER_NO_IMPORTS</code> is defined.</p>
  
   <em><marker id="Command_representation">Command representation</marker></em><p>
   The testcases generated for stateful systems are lists of symbolic API
   calls. Symbolic representation makes failing testcases easier to shrink
   and also easier to read and understand.
   Since the results of the symbolic calls are not known at generation time,
   we use symbolic variables (<code>symb_var()</code>) to refer to them.
   A command (<code>command()</code>) is a symbolic term, used to bind a symbolic   
variable to the result of a symbolic call. For example:</p>
  
   <pre class="sh_erlang">      [{set, {var,1}, {call,erlang,put,[a,42]}},
       {set, {var,2}, {call,erlang,erase,[a]}},
       {set, {var,3}, {call,erlang,put,[b,{var,2}]}}]</pre>
  
   <p>is a command sequence that could be used to test the process dictionary.
   Initially, the pair <code>{a,42}</code> is stored in the process dictionary. Then, the
   key <code>a</code> is deleted. Finally, a new pair <code>{b,{var,2}}</code> is stored. <code>{var,2}</code>
   is a symbolic variable bound to the result of the <code>erlang:erase/1</code> call.
   The expected result is that <code>{b,42}</code> will be finally stored in the process   
dictionary.</p>
  
   <em><marker id="Testcase_state">Testcase state</marker></em>
   In order to be able to test impure code, we need  a way to track its
   internal state (at least the useful part of it). To this end,
   we use an abstract state machine (asm) as a  model of the internal state of
   the SUT. When referring to <i>testcase state</i>, we mean the state of the
   asm. Testcase state can be either symbolic or dynamic:
   <list>
   <item><p>During command generation, we use symbolic variables to bind the
   results of symbolic calls. Therefore, the state of the asm might
   (and usually does) contain symbolic variables and/or symbolic calls, which
   are necessary to operate on symbolic variables. Thus, we refer to it as
   symbolic state. For example, assuming that the internal state of the
   process dictionary is modelled as a proplist, the testcase state after
   generating the previous command sequence will be <code>[{b,{var,2}}]</code>.</p></item>
   <item><p>During command execution, symbolic calls are evaluated and symbolic
   variables are replaced by their corresponding real values. Now we refer to
   the state as dynamic state. After running the previous command sequence,
   the testcase state will be <code>[{b,42}]</code>.</p></item>
   </list>
  
   <em><marker id="Callback_functions">Callback functions</marker></em>
   The following functions must be exported from the callback module
   implementing the abstract state machine:
   <list>
   <item><p> <code>initial_state() ::</code> <code>symbolic_state()</code>
     </p><p>Specifies the symbolic initial state of the state machine. This state
     will be evaluated at command execution time to produce the actual initial
     state. The function is not only called at command generation time, but
     also in order to initialize the state every time the command sequence is
     run (i.e. during normal execution, while shrinking and when checking a
     counterexample). For this reason, it should be deterministic.</p></item>
   <item><p> <code>command(S::</code><code>symbolic_state()</code><code>) ::</code> <code>proper_types:type()</code>
     </p><p>Generates a symbolic call to be included in the command sequence,
     given the current state <code>S</code> of the abstract state machine. However,
     before the call is actually included, a precondition is checked.</p></item>
   <item><p> <code>precondition(S::</code><code>symbolic_state()</code><code>,
                      Call::</code><code>symb_call()</code><code>) :: boolean()</code>
     </p><p>Specifies the precondition that should hold so that <code>Call</code> can be
     included in the command sequence, given the current state <code>S</code> of the
     abstract state machine. In case precondition doesn't hold, a new call is
     chosen using the <code>command/1</code> generator. If preconditions are very strict,
     it will take a lot of tries for PropEr to randomly choose a valid command.
     Testing will be stopped in case the 'constraint_tries' limit is reached
     (see the 'Options' section).</p></item>
   <item><p> <code>postcondition(S::</code><code>dynamic_state()</code><code>,
                       Call::</code><code>symbolic_call()</code><code>,
                       Res::term()) :: boolean()</code>
     </p><p>Specifies the postcondition that should hold about the result <code>Res</code> of
     performing <code>Call</code>, given the dynamic state <code>S</code> of the abstract state
     machine prior to command execution. This function is called during
     runtime, this is why the state is dynamic.</p></item>
   <item><p> <code>next_state(S::</code><code>symbolic_state()</code><code>|</code><code>dynamic_state()</code><code>,
                    Res::term(),
                    Call::</code><code>symbolic_call()</code><code>) ::</code>
          <code>symbolic_state()</code>
     </p><p>Specifies the next state of the abstract state machine, given the
     current state <code>S</code>, the symbolic <code>Call</code> chosen and its result <code>Res</code>. This
     function is called both at command generation and command execution time
     in order to update the testcase state, therefore the state <code>S</code> and the
     result <code>Res</code> can be either symbolic or dynamic.</p></item>
   </list>
  
   <em><marker id="Property_for_testing_stateful_systems">Property for testing stateful systems</marker></em><p>   
This is an example of a property to test the process dictionary:</p>
  
   <pre class="sh_erlang">      prop_pdict() -&gt;
         ?FORALL(Cmds, commands(?MODULE),
          begin
           {H,S,Res} = run_commands(?MODULE, Cmds),
           cleanup(),
           ?WHENFAIL(io:format("History: ~w\nState: ~w\nRes: ~w\n",
  	                        [H,S,Res]),
  		      aggregate(command_names(Cmds), Res =:= ok))
          end).</pre>
  
   <em><marker id="Parallel_testing">Parallel testing</marker></em><p>
   After ensuring that a system's behaviour can be described via an abstract
   state machine when commands are executed sequentially, it is possible to
   move to parallel testing. The same state machine can be used to generate
   command sequences that will be executed concurrently to test for race
   conditions. A parallel testcase (<code>parallel_test_case()</code>) consists of   
a sequential part and a list of concurrent tasks. The sequential part is   
a command list that is run first to put the system in a random state. The   
concurrent tasks are also command lists and they are executed in parallel,   
each of them in a separate process. After running a parallel testcase,   
PropEr uses the state machine specification to check if the results   
observed could have been produced by a possible serialization of the   
concurrent tasks. If no such serialization is possible, then an atomicity   
violation is detected. Properties for parallel testing are very similar to   
those used for sequential testing.</p>
  
   <pre class="sh_erlang">      prop_parallel_testing() -&gt;
         ?FORALL(Testcase, parallel_commands(?MODULE),
          begin
           {Seq,Par,Res} = run_parallel_commands(?MODULE, Testcase),
           cleanup(),
           ?WHENFAIL(io:format("Sequential: ~w\nParallel: ~w\nRes: ~w\n",
  	                        [Seq,Par,Res]),
  		      Res =:= ok)
          end).</pre></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-combination">combination() = [{integer() >= 1, <a href="#type-indices" class="seealso">indices()</a>}]</h3></div>
    <div class="type"><h3 id="type-command">command() = {set, <a href="#type-symb_var" class="seealso">symb_var()</a>, <a href="#type-symb_call" class="seealso">symb_call()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {init, <a href="#type-symbolic_state" class="seealso">symbolic_state()</a>}</h3></div>
    <div class="type"><h3 id="type-command_history">command_history() = [{<a href="#type-command" class="seealso">command()</a>, term()}]</h3></div>
    <div class="type"><h3 id="type-command_list">command_list() = [<a href="#type-command" class="seealso">command()</a>]</h3></div>
    <div class="type"><h3 id="type-dynamic_state">dynamic_state() = term()</h3></div>
    <div class="type"><h3 id="type-history">history() = [{<a href="#type-dynamic_state" class="seealso">dynamic_state()</a>, term()}]</h3></div>
    <div class="type"><h3 id="type-indices">indices() = [integer() &gt;= 1]</h3></div>
    <div class="type"><h3 id="type-lookup">lookup() = <a href="orddict.html#type-orddict" class="seealso">orddict:orddict()</a></h3></div>
    <div class="type"><h3 id="type-mod_name">mod_name() = atom()</h3></div>
    <div class="type"><h3 id="type-parallel_test_case">parallel_test_case() = {<a href="#type-command_list" class="seealso">command_list()</a>, [<a href="#type-command_list" class="seealso">command_list()</a>]}</h3></div>
    <div class="type"><h3 id="type-statem_result">statem_result() = ok<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| initialization_error<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {precondition,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean() | <a href="proper.html#type-exception" class="seealso">proper:exception()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {postcondition,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean() | <a href="proper.html#type-exception" class="seealso">proper:exception()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="proper.html#type-exception" class="seealso">proper:exception()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| no_possible_interleaving</h3></div>
    <div class="type"><h3 id="type-symb_call">symb_call() = {call, <a href="#type-mod_name" class="seealso">mod_name()</a>, <a href="#type-fun_name" class="seealso">fun_name()</a>, [term()]}</h3></div>
    <div class="type"><h3 id="type-symb_var">symb_var() = {var, integer() &gt;= 1}</h3></div>
    <div class="type"><h3 id="type-symbolic_state">symbolic_state() = term()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="commands/1">commands(Mod::mod_name()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A special PropEr type which generates random command sequences,
  according to an absract state machine specification. The function takes as
  input the name of a callback module, which contains the state machine
  specification. The initial state is computed by <code>Mod:initial_state/0</code>.</p>
</div></div>
<div class="function">
<h3 id="commands/1-1">commands(Mod::mod_name(), InitialState::symbolic_state()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Similar to <a href="#commands/1" class="seealso">commands/1</a>, but generated command sequences always
  start at a given state. In this case, the first command is always
  <code>{init,InitialState}</code> and is used to correctly initialize the state
  every time the command sequence is run (i.e. during normal execution,
  while shrinking and when checking a counterexample). In this case,
  <code>Mod:initial_state/0</code> is never called.</p>
</div></div>
<div class="function">
<h3 id="more_commands/1">more_commands(N::pos_integer(), Type::type() (see module proper_types)) -&gt; type() (see module proper_types)</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="parallel_commands/1">parallel_commands(Mod::mod_name()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>A special PropEr type which generates parallel testcases,
  according to an absract state machine specification. The function takes as
  input the name of a callback module, which contains the state machine
  specification. The initial state is computed by <code>Mod:initial_state/0</code>.</p>
</div></div>
<div class="function">
<h3 id="parallel_commands/1-1">parallel_commands(Mod::mod_name(), InitialState::symbolic_state()) -&gt; type() (see module proper_types)</h3>


<div class="description">

<p>Similar to <a href="#parallel_commands/1" class="seealso">parallel_commands/1</a>, but generated command sequences
  always start at a given state.</p>
</div></div>
<div class="function">
<h3 id="fix_parallel/1">fix_parallel(MaxIndex::pos_integer(), Len::non_neg_integer(), Comb::combination() | done, LookUp::lookup(), Mod::mod_name(), State::symbolic_state(), SymbEnv::[symb_var()], W::pos_integer()) -&gt; [command_list()]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="run_commands/1">run_commands(Mod::mod_name(), Cmds::command_list()) -&gt; {history(), dynamic_state(), statem_result()}</h3>


<div class="description">

<p>Evaluates a given symbolic command sequence <code>Cmds</code> according to the
   state machine specified in <code>Mod</code>. The result is a triple of the form<br />
   <code>{History, DynamicState, Result}</code>, where:
  </p><list>
  <item><p><code>History</code> contains the execution history of all commands that were
    executed without raising an exception. It contains tuples of the form
    {<code>dynamic_state()</code>, <code>term()</code>}, specifying the state prior to
    command execution and the actual result of the command.</p></item>
  <item><p><code>DynamicState</code> contains the state of the abstract state machine at
    the moment when execution stopped.</p></item>
  <item><p><code>Result</code> specifies the outcome of command execution.</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="run_commands/1-1">run_commands(Mod::mod_name(), Cmds::command_list(), Env::var_values() (see module proper_symb)) -&gt; {history(), dynamic_state(), statem_result()}</h3>


<div class="description">

<p> Similar to <a href="#run_commands/2" class="seealso">run_commands/2</a>, but also accepts an environment,
  used for symbolic variable evaluation during command execution. The
  environment consists of <code>{Key::atom(), Value::term()}</code> pairs. Keys may be
  used in symbolic variables (i.e. <code>{var,Key}</code>) whithin the command sequence
  <code>Cmds</code>. These symbolic variables will be replaced by their corresponding
  <code>Value</code> during command execution.</p>
</div></div>
<div class="function">
<h3 id="run/1">run(Mod::mod_name(), Cmds::command_list(), Env::var_values() (see module proper_symb)) -&gt; {{history(), dynamic_state(), statem_result()}, var_values() (see module proper_symb)}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="run_parallel_commands/1">run_parallel_commands(Mod::mod_name(), Testcase::parallel_test_case()) -&gt; {history(), [command_history()], statem_result()}</h3>


<div class="description">

<p>Runs a given parallel testcase according to the state machine
  specified in <code>Mod</code>. The result is a triple of the form<br />
  <code>{Sequential_history, Parallel_history, Result}</code>, where:
  </p><list>
  <item><p><code>Sequential_history</code> contains the execution history of the
    sequential prefix.</p></item>
  <item><p><code>Parallel_history</code> contains the execution history of each of the
    concurrent tasks.</p></item>
  <item><p><code>Result</code> specifies the outcome of the attemp to serialize command
    execution, based on the results observed. It can be one of the following:
    </p><list><item><p> <code>ok</code> </p></item><item><p> <code>no_possible_interleaving</code> </p></item></list><p> </p></item>
  </list>
</div></div>
<div class="function">
<h3 id="run_parallel_commands/1-1">run_parallel_commands(Mod::mod_name(), Testcase::parallel_test_case(), Env::var_values() (see module proper_symb)) -&gt; {history(), [command_history()], statem_result()}</h3>


<div class="description">

<p>Similar to <a href="#run_parallel_commands/2" class="seealso">run_parallel_commands/2</a>, but also accepts an
  environment used for symbolic variable evaluation, exactly as described in
  <a href="#run_commands/3" class="seealso">run_commands/3</a>.</p>
</div></div>
<div class="function">
<h3 id="command_names/1">command_names(Cmds::command_list()) -&gt; [mfa()]</h3>


<div class="description">

<p>Extracts the names of the commands from a given command sequence, in
  the form of MFAs. It is useful in combination with functions such as
  <a href="proper.html#aggregate/2" class="seealso">proper:aggregate/2</a> in order to collect statistics about command
  execution.</p>
</div></div>
<div class="function">
<h3 id="state_after/1">state_after(Mod::mod_name(), Cmds::command_list()) -&gt; symbolic_state()</h3>


<div class="description">

<p>Returns the symbolic state after running a given command sequence,
  according to the state machine specification found in <code>Mod</code>. The commands
  are not actually executed.</p>
</div></div>
<div class="function">
<h3 id="zip/2">zip(X::[A], Y::[B]) -&gt; [{A, B}]</h3>


<div class="description">

<p>Behaves like <code>lists:zip/2</code>, but the input lists do no not necessarily
  have equal length. Zipping stops when the shortest list stops. This is
  useful for zipping a command sequence with its (failing) execution history.</p>
</div></div></div>

<authors>

<aname>Eirini Arvaniti</aname>
<email>eirinibob@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
