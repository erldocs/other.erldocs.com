<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>exprecs (parse_trans) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>exprecs</h1>
<h2 class="modsummary">Parse transform for generating record access functions.</h2>
<div class="description">
<p>Parse transform for generating record access functions.
  </p><p>This parse transform can be used to reduce compile-time
  dependencies in large systems.</p>
  <p>In the old days, before records, Erlang programmers often wrote
  access functions for tuple data. This was tedious and error-prone.
  The record syntax made this easier, but since records were implemented
  fully in the pre-processor, a nasty compile-time dependency was
  introduced.</p>
  <p>This module automates the generation of access functions for
  records. While this method cannot fully replace the utility of
  pattern matching, it does allow a fair bit of functionality on
  records without the need for compile-time dependencies.</p>
  <p>Whenever record definitions need to be exported from a module,
  inserting a compiler attribute,
  <code>export_records([RecName|...])</code> causes this transform
  to lay out access functions for the exported records:</p>
 
  <p>As an example, consider the following module:
  </p><pre class="sh_erlang">
  -module(test_exprecs).
  -export([f/0]).
 
  -compile({parse_transform, exprecs}).
 
  -record(r, {a = 0 :: integer(),
              b = 0 :: integer(),
              c = 0 :: integer()}).
 
  -record(s,{a}).
 
  -export_records([r,s]).
 
  f() -&gt;
      {new,'#new-r'([])}.
  </pre>
 
  <pre class="sh_erlang">
  -module(test_exprecs).
  -compile({pt_pp_src,true}).
  -export([f/0]).
  -record(r,{a = 0 :: integer(),b = 0 :: integer(),c = 0 :: integer()}).
  -record(s,{a}).
  -export_records([r,s]).
  -export(['#exported_records-'/0,
           '#new-'/1,
           '#info-'/1,
           '#info-'/2,
           '#pos-'/2,
           '#is_record-'/1,
           '#is_record-'/2,
           '#get-'/2,
           '#set-'/2,
           '#fromlist-'/2,
           '#new-r'/0,
           '#new-r'/1,
           '#get-r'/2,
           '#set-r'/2,
           '#pos-r'/1,
           '#fromlist-r'/1,
           '#fromlist-r'/2,
           '#info-r'/1,
           '#new-s'/0,
           '#new-s'/1,
           '#get-s'/2,
           '#set-s'/2,
           '#pos-s'/1,
           '#fromlist-s'/1,
           '#fromlist-s'/2,
           '#info-s'/1]).
 
  -type '#prop-r'() :: {a, integer()} | {b, integer()} | {c, integer()}.
  -type '#attr-r'() :: a | b | c.
  -type '#prop-s'() :: {a, any()}.
  -type '#attr-s'() :: a.
 
  -spec '#exported_records-'() -&gt; [r | s].
  '#exported_records-'() -&gt;
      [r,s].
 
  -spec '#new-'(r) -&gt; #r{};
               (s) -&gt; #s{}.
  '#new-'(r) -&gt;
      '#new-r'();
  '#new-'(s) -&gt;
      '#new-s'().
 
  -spec '#info-'(r) -&gt; [a | b | c];
                (s) -&gt; [a].
  '#info-'(RecName) -&gt;
      '#info-'(RecName, fields).
 
  -spec '#info-'(r, size) -&gt; 4;
                (r, fields) -&gt; [a | b | c];
                (s, size) -&gt; 2;
                (s, fields) -&gt; [a].
  '#info-'(r, Info) -&gt;
      '#info-r'(Info);
  '#info-'(s, Info) -&gt;
      '#info-s'(Info).
 
  -spec '#pos-'(r, a) -&gt; 1;
               (r, b) -&gt; 2;
               (r, c) -&gt; 3;
               (s, a) -&gt; 1.
  '#pos-'(r, Attr) -&gt;
      '#pos-r'(Attr);
  '#pos-'(s, Attr) -&gt;
      '#pos-s'(Attr).
 
  -spec '#is_record-'(any()) -&gt; boolean().
 
  '#is_record-'(X) -&gt;
      if
          is_record(X, r) -&gt;
              true;
          is_record(X, s) -&gt;
              true;
          true -&gt;
              false
      end.
 
  -spec '#is_record-'(any(), any()) -&gt; boolean().
 
  '#is_record-'(s, Rec) when tuple_size(Rec) == 2, element(1, Rec) == s -&gt;
      true;
  '#is_record-'(r, Rec) when tuple_size(Rec) == 4, element(1, Rec) == r -&gt;
      true;
  '#is_record-'(_, _) -&gt;
      false.
 
  -spec '#get-'(a, #r{}) -&gt; integer();
               (b, #r{}) -&gt; integer();
               (c, #r{}) -&gt; integer();
               (a, #s{}) -&gt; any();
               (['#attr-r'()], #r{}) -&gt; [integer()];
               (['#attr-s'()], #s{}) -&gt; [any()].
  '#get-'(Attrs, Rec) when is_record(Rec, r) -&gt;
      '#get-r'(Attrs, Rec);
  '#get-'(Attrs, Rec) when is_record(Rec, s) -&gt;
      '#get-s'(Attrs, Rec).
 
  -spec '#set-'(['#prop-r'()], #r{}) -&gt; #r{};
               (['#prop-s'()], #s{}) -&gt; #s{}.
  '#set-'(Vals, Rec) when is_record(Rec, r) -&gt;
      '#set-r'(Vals, Rec);
  '#set-'(Vals, Rec) when is_record(Rec, s) -&gt;
      '#set-s'(Vals, Rec).
 
  -spec '#fromlist-'(['#prop-r'()], #r{}) -&gt; #r{};
                    (['#prop-s'()], #s{}) -&gt; #s{}.
  '#fromlist-'(Vals, Rec) when is_record(Rec, r) -&gt;
      '#fromlist-r'(Vals, Rec);
  '#fromlist-'(Vals, Rec) when is_record(Rec, s) -&gt;
      '#fromlist-s'(Vals, Rec).
 
  -spec '#new-r'() -&gt; #r{}.
  '#new-r'() -&gt;
      #r{}.
 
  -spec '#new-r'(['#prop-r'()]) -&gt; #r{}.
  '#new-r'(Vals) -&gt;
      '#set-r'(Vals, #r{}).
 
  -spec '#get-r'(a, #r{}) -&gt; integer();
                (b, #r{}) -&gt; integer();
                (c, #r{}) -&gt; integer();
                (['#attr-r'()], #r{}) -&gt; [integer()].
  '#get-r'(Attrs, R) when is_list(Attrs) -&gt;
      [
       '#get-r'(A, R) ||
           A &lt;- Attrs
      ];
  '#get-r'(a, R) -&gt;
      R#r.a;
  '#get-r'(b, R) -&gt;
      R#r.b;
  '#get-r'(c, R) -&gt;
      R#r.c;
  '#get-r'(Attr, R) -&gt;
      error(bad_record_op, ['#get-r',Attr,R]).
 
  -spec '#set-r'(['#prop-r'()], #r{}) -&gt; #r{}.
  '#set-r'(Vals, Rec) -&gt;
      F = fun([], R, _F1) -&gt;
                 R;
             ([{a,V}|T], R, F1) when is_list(T) -&gt;
                 F1(T, R#r{a = V}, F1);
             ([{b,V}|T], R, F1) when is_list(T) -&gt;
                 F1(T, R#r{b = V}, F1);
             ([{c,V}|T], R, F1) when is_list(T) -&gt;
                 F1(T, R#r{c = V}, F1);
             (Vs, R, _) -&gt;
                 error(bad_record_op, ['#set-r',Vs,R])
          end,
      F(Vals, Rec, F).
 
  -spec '#fromlist-r'(['#prop-r'()]) -&gt; #r{}.
  '#fromlist-r'(Vals) when is_list(Vals) -&gt;
      '#fromlist-r'(Vals, '#new-r'()).
 
  -spec '#fromlist-r'(['#prop-r'()], #r{}) -&gt; #r{}.
  '#fromlist-r'(Vals, Rec) -&gt;
      AttrNames = [{a,2},{b,3},{c,4}],
      F = fun([], R, _F1) -&gt;
                 R;
             ([{H,Pos}|T], R, F1) when is_list(T) -&gt;
                 case lists:keyfind(H, 1, Vals) of
                     false -&gt;
                         F1(T, R, F1);
                     {_,Val} -&gt;
                         F1(T, setelement(Pos, R, Val), F1)
                 end
          end,
      F(AttrNames, Rec, F).
 
  -spec '#pos-r'('#attr-r'() | atom()) -&gt; integer().
  '#pos-r'(a) -&gt;
      2;
  '#pos-r'(b) -&gt;
      3;
  '#pos-r'(c) -&gt;
      4;
  '#pos-r'(A) when is_atom(A) -&gt;
      0.
 
  -spec '#info-r'(fields) -&gt; [a | b | c];
                 (size) -&gt; 3.
  '#info-r'(fields) -&gt;
      record_info(fields, r);
  '#info-r'(size) -&gt;
      record_info(size, r).
 
  -spec '#new-s'() -&gt; #s{}.
  '#new-s'() -&gt;
      #s{}.
 
  -spec '#new-s'(['#prop-s'()]) -&gt; #s{}.
  '#new-s'(Vals) -&gt;
      '#set-s'(Vals, #s{}).
 
  -spec '#get-s'(a, #s{}) -&gt; any();
                (['#attr-s'()], #s{}) -&gt; [any()].
  '#get-s'(Attrs, R) when is_list(Attrs) -&gt;
      [
       '#get-s'(A, R) ||
           A &lt;- Attrs
      ];
  '#get-s'(a, R) -&gt;
      R#s.a;
  '#get-s'(Attr, R) -&gt;
      error(bad_record_op, ['#get-s',Attr,R]).
 
  -spec '#set-s'(['#prop-s'()], #s{}) -&gt; #s{}.
  '#set-s'(Vals, Rec) -&gt;
      F = fun([], R, _F1) -&gt;
                 R;
             ([{a,V}|T], R, F1) when is_list(T) -&gt;
                 F1(T, R#s{a = V}, F1);
             (Vs, R, _) -&gt;
                 error(bad_record_op, ['#set-s',Vs,R])
          end,
      F(Vals, Rec, F).
 
  -spec '#fromlist-s'(['#prop-s'()]) -&gt; #s{}.
  '#fromlist-s'(Vals) when is_list(Vals) -&gt;
      '#fromlist-s'(Vals, '#new-s'()).
 
  -spec '#fromlist-s'(['#prop-s'()], #s{}) -&gt; #s{}.
  '#fromlist-s'(Vals, Rec) -&gt;
      AttrNames = [{a,2}],
      F = fun([], R, _F1) -&gt;
                 R;
             ([{H,Pos}|T], R, F1) when is_list(T) -&gt;
                 case lists:keyfind(H, 1, Vals) of
                     false -&gt;
                         F1(T, R, F1);
                     {_,Val} -&gt;
                         F1(T, setelement(Pos, R, Val), F1)
                 end
          end,
      F(AttrNames, Rec, F).
 
  -spec '#pos-s'('#attr-s'() | atom()) -&gt; integer().
  '#pos-s'(a) -&gt;
      2;
  '#pos-s'(A) when is_atom(A) -&gt;
      0.
 
  -spec '#info-s'(fields) -&gt; [a];
                 (size) -&gt; 1.
  '#info-s'(fields) -&gt;
      record_info(fields, s);
  '#info-s'(size) -&gt;
      record_info(size, s).
 
  f() -&gt;
      {new,'#new-r'([])}.
 
  </pre>
 
  <p>It is possible to modify the naming rules of exprecs, through the use  
of the following attributes (example reflecting the current rules):</p>
 
  <pre class="sh_erlang">
  -exprecs_prefix(["#", operation, "-"]).
  -exprecs_fname([prefix, record]).
  -exprecs_vfname([fname, "__", version]).
  </pre>
 
  <p>The lists must contain strings or any of the following control atoms:
  </p><list>
  <item><p>in <code>exprecs_prefix</code>: <code>operation</code></p></item>
  <item><p>in <code>exprecs_fname</code>: <code>operation</code>, <code>record</code>, <code>prefix</code></p></item>
  <item><p>in <code>exprecs_vfname</code>: <code>operation</code>, <code>record</code>, <code>prefix</code>, <code>fname</code>, <code>version</code>
  </p></item>
  </list>
 
  <p>Exprecs will substitute the control atoms with the string values of the  
corresponding items. The result will then be flattened and converted to an  
atom (a valid function or type name).</p>
 
  <p><code>operation</code> is one of:
  </p><list>
  <item><p><code>new</code></p></item>
  <item><p><code>get</code></p></item>
  <item><p><code>set</code></p></item>
  <item><p><code>fromlist</code></p></item>
  <item><p><code>info</code></p></item>
  <item><p><code>pos</code></p></item>
  <item><p><code>is_record</code></p></item>
  <item><p><code>convert</code></p></item>
  <item><p><code>prop</code></p></item>
  <item><p><code>attr</code></p></item>
  </list><p>
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-form">form() = any()</h3></div>
    <div class="type"><h3 id="type-forms">forms() = [<a href="#type-form" class="seealso">form()</a>]</h3></div>
    <div class="type"><h3 id="type-options">options() = [{atom(), any()}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="parse_transform/1">parse_transform(Forms::forms(), Options::options()) -&gt; forms()</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>: Ulf Wiger</aname>
<email>ulf.wiger@ericsson.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
