<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>recfun (translib) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>recfun</h1>
<h2 class="modsummary">Parse transformer that makes possible to easily write recursive  
anonymous function.</h2>
<div class="description">
<p>Parse transformer that makes possible to easily write recursive  
anonymous function.</p>
 
  <p>Performs parse transformation that modifies the semantic of Erlang to
  simplify the writing of recursive anonymous functions. To deal with this goal
  and make the parsing easier, This module also implements the <a href="gen_trans.html" class="seealso">gen_trans</a> behaviour.</p>
 
  <p>To perform this kind of transformation, we reserved the function name
  <code>callee</code> that refers to the anonymous function itself. this keyword plays the
  role of a special function name with, obviously, the same number of arguments
  that the anonymous function referred to. Furthermore, to deal with anonymous
  functions nested in other ones, we hijacked the notation of a Mnesia record
  access inside a query to recursively call parent functions. So, the notation
  <code>(parent.)+callee</code> refers to parent anonymous functions.</p>
 
  <p><em><marker id="Examples">Examples</marker></em></p>
 
  <list>
    <item><p> A simple example: the factorial function. This recursive
    anonymous function:
      <div class="example">
  <pre class="sh_erlang">  Fact = fun(0) -&gt; 1;
            (N) -&gt; N * callee(N-1)
         end,
  Fact(5). %% return 5! = 120</pre>
      </div>
 
  </p><p>is transformed by the module <code>recfun</code> in</p>
 
      <p><div class="example">
  <pre class="sh_erlang">  Fact = (fun(Callee) -&gt;
                 fun(0) -&gt; 1;
                    (N) -&gt; N * (Callee(Callee))(N-1)
                 end
          end)(fun(Callee) -&gt;
                       fun(0) -&gt; 1;
                          (N) -&gt; N * (Callee(Callee))(N-1)
                       end
               end),
  Fact(5). %% return 5! = 120</pre>
      </div>
    </p></item>
    <item><p> A trickier one: This recursive anonymous function:
      <div class="example">
  <pre class="sh_erlang">  Fact = fun(N) -&gt;
               G = fun(0) -&gt; 1;
                      (M) -&gt; M * parent.callee(M-1)
                   end,
               G(N)
         end,
  Fact(5). %% return 5! = 120</pre>
      </div>
 
  </p><p>is transformed by the module <code>recfun</code> in</p>
 
      <p><div class="example">
  <pre class="sh_erlang">  Fact = (fun(Callee) -&gt;
                  fun(N) -&gt;
                          G = fun(0) -&gt; 1;
                                 (M) -&gt; M * (Callee(Callee))(M-1)
                              end,
                          G(N)
                  end
          end)(fun(Callee) -&gt;
                       fun(N) -&gt;
                               G = fun(0) -&gt; 1;
                                      (M) -&gt; M * (Callee(Callee))(M-1)
                                   end,
                               G(N)
                       end
               end),
  Fact(5). %% return 5! = 120</pre>
      </div>
    </p></item>
  </list>
 
  <p><br />
  <em><marker id="EXPORTS">EXPORTS</marker></em>
 <marker id="parse_transform-2"> </marker>
 </p><pre class="sh_erlang"> parse_transform(Forms, Options) -&gt; NewForms | {error, Errors, []}</pre><p>
  <div class="REFBODY">
    Types:
    <div class="REFTYPES">
      <pre class="sh_erlang">      Forms, NewForms = [erlang_form()]
      Options = [compiler_options()]
      Errors = [{Filename, [ErrorInfo]}]
         FileName = atom() | string()
         ErrorInfo = see separate description below.</pre>
    </div>
 
    <p>Implements the actual transformation at compile time. This function is
    called by the compiler to do the source code transformation if and when the
    option <code>{parse_transform, recfun}</code> is passed to the compiler. This function
    starts a new <url href="gen_trans.xml"><code>gen_trans</code></url> by calling <url href="gen_trans.xml#start-3"><code>gen_trans:start/3</code></url> with
    <code>recfun</code> as callback module.</p>
 
    <p>If the abstract code format is successfully parsed, the function returns
    <code>NewForms</code>. if it fails the function returns <code>{error, Errors, []}</code>.</p>
 
    <p>See <a href="http://www.erlang.org/doc/man/compile.html" target="_top">compile(3)</a>.</p>
 
  </div></p>
 
 <p><marker id="format_error-1"> </marker>
 </p><pre class="sh_erlang"> format_error(ErrCode) -&gt; ErrMessage</pre><p>
  <div class="REFBODY">
    Types:
    <div class="REFTYPES">
      <pre class="sh_erlang">      Errcode = term()
      ErrMessage = string()</pre>
    </div>
 
    <p>Takes an error code returned by one of the other functions in the module
    and creates a textual description of the error. <code>ErrCode</code> can be either of
    the following terms. The <code>format_error/1</code> function returns a descriptive    
string which describes the error.</p>
 
    <list>
       <item><code>reserved_callee_usage</code>. Function <code>callee(...)</code>: reserved syntax.</item>
       <item><code>recfun_badrec</code>. Bad recursive call.</item>
       <item><code>{recfun_badarity, A0, A1}</code>. Interpreted function with arity <code>A0</code> called with <code>A1</code> arguments</item>
       <item>Other <code>ErrCode</code>. Unknown error: <code>ErrCode</code>.</item>
    </list>
 
  </div></p>
 
 
  <p><br />
  <em><marker id="Error_Information">Error Information</marker></em></p>
 
  <p>The <code>ErrorInfo</code> mentioned above is the standard <code>ErrorInfo</code> structure which
  is returned from <code>recfun</code> module. It has the following format:</p>
 
  <p><div class="example">
 <pre class="sh_erlang">    {ErrorLine, recfun, ErrorDescriptor}</pre>
  </div></p>
 
  <p>A string which describes the error is obtained with the following call:</p>
 
  <p><div class="example">
 <pre class="sh_erlang">    apply(recfun, format_error, ErrorDescriptor)</pre>
  </div>
 </p></div>


<authors>

<aname>Christopher Faulet</aname>
<email>christopher.faulet@capflam.org</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
