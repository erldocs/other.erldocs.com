<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_dt_gcounter (riak_dt) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_dt_gcounter</h1>
<h2 class="modsummary">  
A G-Counter CRDT.</h2>
<div class="description">
<p>  
A G-Counter CRDT. A G-Counter is a Grow-only counter. Modeled as a list of  
two-tuples. Each entry in the list is an {actor, count} pair. The value of the counter  
is the sum of all entries in the list. An actor may only update its own entry. An entry  
can only be incremented. Borrows liberally from argv0 and Justin Sheehy's vclock module  
in implementation.</p>
 
  <p>See <a href="riak_kv_pncounter.html" class="seealso">riak_kv_pncounter</a> for a counter that can be decremented
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-gcounter">gcounter()</h3></div>
    <div class="type"><h3 id="type-gcounter_op">gcounter_op() = increment | {increment, integer() &gt;= 1}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/0">new() -&gt; gcounter()</h3>


<div class="description">

<p>Create a new, empty <code>gcounter()</code></p>
</div></div>
<div class="function">
<h3 id="new/1">new(Id::actor() (see module riak_dt), Count::pos_integer()) -&gt; gcounter()</h3>


<div class="description">

<p>Create a <code>gcounter()</code> with an initial update</p>
</div></div>
<div class="function">
<h3 id="value/1">value(GCnt::gcounter()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>The single total value of a <code>gcounter()</code>.</p>
</div></div>
<div class="function">
<h3 id="value/1-1">value(X1::any(), GCnt::gcounter()) -&gt; non_neg_integer()</h3>


<div class="description">

<p><code>value/2</code> is just <code>value/1</code> for a <code>gcounter()</code></p>
</div></div>
<div class="function">
<h3 id="update/1">update(X1::gcounter_op(), Actor::actor() (see module riak_dt), GCnt::gcounter()) -&gt; {ok, gcounter()}</h3>


<div class="description">

<p><code>increment</code> the entry in <code>GCnt</code> for <code>Actor</code> by 1 or <code>{increment, Amt}</code>.
  returns an updated <code>gcounter()</code> or error if <code>Amt</code> is not a <code>pos_integer()</code></p>
</div></div>
<div class="function">
<h3 id="update/1-1">update(Op::gcounter_op(), Actor::actor() (see module riak_dt), GCnt::gcounter(), Ctx::context() (see module riak_dt)) -&gt; {ok, gcounter()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="parent_clock/1">parent_clock(Clock::vclock() (see module riak_dt_vclock), GCnt::gcounter()) -&gt; gcounter()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/1">merge(GCnt1::gcounter(), GCnt2::gcounter()) -&gt; gcounter()</h3>


<div class="description">

<p>Merge two <code>gcounter()</code>s to a single <code>gcounter()</code>. This is the Least Upper Bound
  function described in the literature.</p>
</div></div>
<div class="function">
<h3 id="equal/1">equal(VA::gcounter(), VB::gcounter()) -&gt; boolean()</h3>


<div class="description">

<p>Are two <code>gcounter()</code>s structurally equal? This is not <code>value/1</code> equality.
  Two counters might represent the total <code>42</code>, and not be <code>equal/2</code>. Equality here is
  that both counters contain the same actors and those actors have the same count.</p>
</div></div>
<div class="function">
<h3 id="stats/1">stats(GCnt::gcounter()) -&gt; [{atom(), number()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="stat/1">stat(X1::atom(), GCnt::gcounter()) -&gt; number() | undefined</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="to_binary/1">to_binary(GCnt::gcounter()) -&gt; binary()</h3>


<div class="description">

<p>Encode an effecient binary representation of a <code>gcounter()</code></p>
</div></div>
<div class="function">
<h3 id="to_binary/1-1">to_binary(Vers::pos_integer(), C::gcounter()) -&gt; {ok, binary()} | {error, unsupported_version, Vers::pos_integer()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="from_binary/1">from_binary(B::binary()) -&gt; {ok, gcounter()} | {error, invalid_binary} | {error, unsupported_version, Vers::pos_integer()}</h3>


<div class="description">

<p>Decode binary G-Counter</p>
</div></div>
<div class="function">
<h3 id="to_version/1">to_version(Version::pos_integer(), C::gcounter()) -&gt; gcounter()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_operation/1">is_operation(Operation::term()) -&gt; boolean()</h3>


<div class="description">

<p>The following operation verifies
       that Operation is supported by this particular CRDT.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
