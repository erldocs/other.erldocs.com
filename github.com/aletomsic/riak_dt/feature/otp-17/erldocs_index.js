var index = [['app','riak_dt','riak_dt','[application]'],['mod','riak_dt','riak_dt_disable_flag','   an ON/OFF (boolean) CRDT, which converges towa'],['mod','riak_dt','riak_dt_emcntr','A PN-Counter CRDT.'],['mod','riak_dt','riak_dt_enable_flag','   an ON/OFF (boolean) CRDT, which converges towa'],['mod','riak_dt','riak_dt_gcounter','  A G-Counter CRDT.'],['mod','riak_dt','riak_dt_gset','a Grow Only Set.'],['mod','riak_dt','riak_dt_lwwreg','  An LWW Register CRDT.'],['mod','riak_dt','riak_dt_od_flag',[]],['mod','riak_dt','riak_dt_oe_flag',[]],['mod','riak_dt','riak_dt_orset',[]],['mod','riak_dt','riak_dt_pncounter','  A PN-Counter CRDT.'],['mod','riak_dt','riak_dt_vclock','A simple Erlang implementation of vector clocks as'],['fun','riak_dt','riak_dt_disable_flag:equal/1',[]],['fun','riak_dt','riak_dt_disable_flag:from_binary/1',[]],['fun','riak_dt','riak_dt_disable_flag:merge/1',[]],['fun','riak_dt','riak_dt_disable_flag:new/0',[]],['fun','riak_dt','riak_dt_disable_flag:parent_clock/1',[]],['fun','riak_dt','riak_dt_disable_flag:stat/1',[]],['fun','riak_dt','riak_dt_disable_flag:stats/1',[]],['fun','riak_dt','riak_dt_disable_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_disable_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_disable_flag:to_version/1',[]],['fun','riak_dt','riak_dt_disable_flag:update/1',[]],['fun','riak_dt','riak_dt_disable_flag:update/1',[]],['fun','riak_dt','riak_dt_disable_flag:value/1',[]],['fun','riak_dt','riak_dt_disable_flag:value/1',[]],['fun','riak_dt','riak_dt_emcntr:equal/1','equality of two counters internal structure, not t'],['fun','riak_dt','riak_dt_emcntr:from_binary/1','Decode a binary encoded riak_dt_emcntr.'],['fun','riak_dt','riak_dt_emcntr:merge/1','takes two emcntr()s and merges them into a single'],['fun','riak_dt','riak_dt_emcntr:new/0',[]],['fun','riak_dt','riak_dt_emcntr:parent_clock/1','embedded CRDTs most share a causal context with th'],['fun','riak_dt','riak_dt_emcntr:stat/1','generate stat for requested stat type at first arg'],['fun','riak_dt','riak_dt_emcntr:stats/1','generate stats for this counter.'],['fun','riak_dt','riak_dt_emcntr:to_binary/1',[]],['fun','riak_dt','riak_dt_emcntr:to_binary/1','produce a compact binary representation of the cou'],['fun','riak_dt','riak_dt_emcntr:to_version/1',[]],['fun','riak_dt','riak_dt_emcntr:update/1','update with a context.'],['fun','riak_dt','riak_dt_emcntr:update/1','increment/decrement the counter.'],['fun','riak_dt','riak_dt_emcntr:value/1','query value, not implemented.'],['fun','riak_dt','riak_dt_emcntr:value/1','the current integer value of the counter.'],['fun','riak_dt','riak_dt_enable_flag:equal/1',[]],['fun','riak_dt','riak_dt_enable_flag:from_binary/1',[]],['fun','riak_dt','riak_dt_enable_flag:merge/1',[]],['fun','riak_dt','riak_dt_enable_flag:new/0',[]],['fun','riak_dt','riak_dt_enable_flag:parent_clock/1',[]],['fun','riak_dt','riak_dt_enable_flag:stat/1',[]],['fun','riak_dt','riak_dt_enable_flag:stats/1',[]],['fun','riak_dt','riak_dt_enable_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_enable_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_enable_flag:to_version/1',[]],['fun','riak_dt','riak_dt_enable_flag:update/1',[]],['fun','riak_dt','riak_dt_enable_flag:update/1',[]],['fun','riak_dt','riak_dt_enable_flag:value/1',[]],['fun','riak_dt','riak_dt_enable_flag:value/1',[]],['fun','riak_dt','riak_dt_gcounter:equal/1','Are two gcounter()s structurally equal? This is no'],['fun','riak_dt','riak_dt_gcounter:from_binary/1','Decode binary G-Counter.'],['fun','riak_dt','riak_dt_gcounter:merge/1','Merge two gcounter()s to a single gcounter().'],['fun','riak_dt','riak_dt_gcounter:new/0','Create a new, empty gcounter()'],['fun','riak_dt','riak_dt_gcounter:new/1','Create a gcounter() with an initial update.'],['fun','riak_dt','riak_dt_gcounter:parent_clock/1',[]],['fun','riak_dt','riak_dt_gcounter:stat/1',[]],['fun','riak_dt','riak_dt_gcounter:stats/1',[]],['fun','riak_dt','riak_dt_gcounter:to_binary/1',[]],['fun','riak_dt','riak_dt_gcounter:to_binary/1','Encode an effecient binary representation of a gco'],['fun','riak_dt','riak_dt_gcounter:to_version/1',[]],['fun','riak_dt','riak_dt_gcounter:update/1',[]],['fun','riak_dt','riak_dt_gcounter:update/1','increment the entry in GCnt for Actor by 1 or {inc'],['fun','riak_dt','riak_dt_gcounter:value/1','value/2 is just value/1 for a gcounter()'],['fun','riak_dt','riak_dt_gcounter:value/1','The single total value of a gcounter().'],['fun','riak_dt','riak_dt_gset:equal/1',[]],['fun','riak_dt','riak_dt_gset:from_binary/1',[]],['fun','riak_dt','riak_dt_gset:merge/1',[]],['fun','riak_dt','riak_dt_gset:new/0',[]],['fun','riak_dt','riak_dt_gset:parent_clock/1',[]],['fun','riak_dt','riak_dt_gset:stat/1',[]],['fun','riak_dt','riak_dt_gset:stats/1',[]],['fun','riak_dt','riak_dt_gset:to_binary/1',[]],['fun','riak_dt','riak_dt_gset:to_binary/1',[]],['fun','riak_dt','riak_dt_gset:to_version/1',[]],['fun','riak_dt','riak_dt_gset:update/1',[]],['fun','riak_dt','riak_dt_gset:update/1',[]],['fun','riak_dt','riak_dt_gset:value/1','note: not implemented yet, same as value/1'],['fun','riak_dt','riak_dt_gset:value/1',[]],['fun','riak_dt','riak_dt_lwwreg:equal/1','Are two lwwreg()s structurally equal? This is not '],['fun','riak_dt','riak_dt_lwwreg:from_binary/1','Decode binary lwwreg()'],['fun','riak_dt','riak_dt_lwwreg:merge/1','Merge two lwwreg()s to a single lwwreg().'],['fun','riak_dt','riak_dt_lwwreg:new/0','Create a new, empty lwwreg()'],['fun','riak_dt','riak_dt_lwwreg:parent_clock/1',[]],['fun','riak_dt','riak_dt_lwwreg:stat/1',[]],['fun','riak_dt','riak_dt_lwwreg:stats/1',[]],['fun','riak_dt','riak_dt_lwwreg:to_binary/1',[]],['fun','riak_dt','riak_dt_lwwreg:to_binary/1','Encode an effecient binary representation of an lw'],['fun','riak_dt','riak_dt_lwwreg:to_version/1',[]],['fun','riak_dt','riak_dt_lwwreg:update/1','Assign a Value to the lwwreg()  associating the u'],['fun','riak_dt','riak_dt_lwwreg:update/4',[]],['fun','riak_dt','riak_dt_lwwreg:value/1','query for this lwwreg().'],['fun','riak_dt','riak_dt_lwwreg:value/1','The single total value of a gcounter().'],['fun','riak_dt','riak_dt_od_flag:equal/1',[]],['fun','riak_dt','riak_dt_od_flag:from_binary/1',[]],['fun','riak_dt','riak_dt_od_flag:merge/1',[]],['fun','riak_dt','riak_dt_od_flag:new/0',[]],['fun','riak_dt','riak_dt_od_flag:parent_clock/1','sets the clock in the flag to that Clock.'],['fun','riak_dt','riak_dt_od_flag:precondition_context/1','the precondition_context is an opaque piece of sta'],['fun','riak_dt','riak_dt_od_flag:stat/1',[]],['fun','riak_dt','riak_dt_od_flag:stats/1',[]],['fun','riak_dt','riak_dt_od_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_od_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_od_flag:to_version/1',[]],['fun','riak_dt','riak_dt_od_flag:update/1','update/4 is similar to update/3 except that it tak'],['fun','riak_dt','riak_dt_od_flag:update/1',[]],['fun','riak_dt','riak_dt_od_flag:value/1',[]],['fun','riak_dt','riak_dt_od_flag:value/1',[]],['fun','riak_dt','riak_dt_oe_flag:equal/1',[]],['fun','riak_dt','riak_dt_oe_flag:from_binary/1',[]],['fun','riak_dt','riak_dt_oe_flag:merge/1',[]],['fun','riak_dt','riak_dt_oe_flag:new/0',[]],['fun','riak_dt','riak_dt_oe_flag:parent_clock/1',[]],['fun','riak_dt','riak_dt_oe_flag:stat/1',[]],['fun','riak_dt','riak_dt_oe_flag:stats/1',[]],['fun','riak_dt','riak_dt_oe_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_oe_flag:to_binary/1',[]],['fun','riak_dt','riak_dt_oe_flag:to_version/1',[]],['fun','riak_dt','riak_dt_oe_flag:update/1',[]],['fun','riak_dt','riak_dt_oe_flag:update/1',[]],['fun','riak_dt','riak_dt_oe_flag:value/1',[]],['fun','riak_dt','riak_dt_oe_flag:value/1',[]],['fun','riak_dt','riak_dt_orset:equal/1',[]],['fun','riak_dt','riak_dt_orset:from_binary/1',[]],['fun','riak_dt','riak_dt_orset:merge/1',[]],['fun','riak_dt','riak_dt_orset:new/0',[]],['fun','riak_dt','riak_dt_orset:parent_clock/1',[]],['fun','riak_dt','riak_dt_orset:precondition_context/1','the precondition context is a fragment of the CRDT'],['fun','riak_dt','riak_dt_orset:stat/1',[]],['fun','riak_dt','riak_dt_orset:stats/1',[]],['fun','riak_dt','riak_dt_orset:to_binary/1',[]],['fun','riak_dt','riak_dt_orset:to_binary/1',[]],['fun','riak_dt','riak_dt_orset:to_version/1',[]],['fun','riak_dt','riak_dt_orset:update/1',[]],['fun','riak_dt','riak_dt_orset:update/1',[]],['fun','riak_dt','riak_dt_orset:value/1',[]],['fun','riak_dt','riak_dt_orset:value/1',[]],['fun','riak_dt','riak_dt_pncounter:change_versions/1',[]],['fun','riak_dt','riak_dt_pncounter:current_version/1',[]],['fun','riak_dt','riak_dt_pncounter:equal/1','Are two pncounter()s structurally equal? This is n'],['fun','riak_dt','riak_dt_pncounter:from_binary/1',[]],['fun','riak_dt','riak_dt_pncounter:merge/1','Merge two pncounter()s to a single pncounter().'],['fun','riak_dt','riak_dt_pncounter:new/0','Create a new, empty pncounter()'],['fun','riak_dt','riak_dt_pncounter:new/1','Create a pncounter() with an initial Value for Act'],['fun','riak_dt','riak_dt_pncounter:parent_clock/1','no-op.'],['fun','riak_dt','riak_dt_pncounter:stat/1',[]],['fun','riak_dt','riak_dt_pncounter:stats/1',[]],['fun','riak_dt','riak_dt_pncounter:to_binary/1',[]],['fun','riak_dt','riak_dt_pncounter:to_binary/1','Encode an effecient binary representation of pncou'],['fun','riak_dt','riak_dt_pncounter:to_version/1',[]],['fun','riak_dt','riak_dt_pncounter:update/1','Update a pncounter().'],['fun','riak_dt','riak_dt_pncounter:update/4',[]],['fun','riak_dt','riak_dt_pncounter:value/1','query the parts of a pncounter()  valid queries a'],['fun','riak_dt','riak_dt_pncounter:value/1','The single, total value of a pncounter()'],['fun','riak_dt','riak_dt_vclock:all_nodes/1','Return the list of all nodes that have ever increm'],['fun','riak_dt','riak_dt_vclock:descends/1','Return true if Va is a direct descendant of Vb, el'],['fun','riak_dt','riak_dt_vclock:dominates/1',[]],['fun','riak_dt','riak_dt_vclock:equal/1','Compares two VClocks for equality.'],['fun','riak_dt','riak_dt_vclock:fresh/0','Create a brand new vclock.'],['fun','riak_dt','riak_dt_vclock:from_binary/1','takes the output of to_binary/1 and returns a vclo'],['fun','riak_dt','riak_dt_vclock:get_counter/1','Get the counter value in VClock set from Node.'],['fun','riak_dt','riak_dt_vclock:glb/1','take two vclocks and return a vclock that summeriz'],['fun','riak_dt','riak_dt_vclock:increment/1','Increment VClock at Node.'],['fun','riak_dt','riak_dt_vclock:merge/1','Combine all VClocks in the input list into their l'],['fun','riak_dt','riak_dt_vclock:subtract_dots/1','subtract the VClock from the DotList.'],['fun','riak_dt','riak_dt_vclock:to_binary/1','an effecient format for disk / wire.']];