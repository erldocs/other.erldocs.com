<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>iris (iris-erl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>iris</h1>
<h2 class="modsummary">Module responsible for initiating communication within the Iris network.</h2>
<div class="description">
<p>Module responsible for initiating communication within the Iris network.</p>
 
       <p>If this module is used for connecting to the network, all inbound events
       will arrive as low level process messages to the connecting process.
       Unless you have special needs (i.e. wrapping the messages yourself) the
       <a href="iris_server.html" class="seealso">iris_server</a> behavior would probably be the better choice.</p>
 
       <p>The relationship between the Iris messaging API and the inbound process       
level message format is as follows:</p>
 
       <pre class="sh_erlang">       iris module             received process message
       --------------          ------------------------------------------------
       iris:broadcast   ---&gt;   {broadcast, Message :: binary()}
       iris:request     ---&gt;   {request, From :: sender(), Request :: binary()}
       iris:publish     ---&gt;   {publish, Topic :: [byte()], Event :: binary()}
       iris:tunnel      ---&gt;   {tunnel, Tunnel :: tunnel()}
       &lt;remote drop&gt;    ---&gt;   {drop, Reason :: atom()}</pre>
 
       <p>Opposed to the connection setup and teardown functions, the messaging       
methods are used by both low and high level APIs. For details on these       
see the individual method docs.</p>
 
       <p>Since the tunnel is an ordered and throttled communication primitive,
       reading from and writing to must be done explicitly, similar to passive
       gen_tcp.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-connection">connection() = {connection, pid()}</h3></div>
    <div class="type"><h3 id="type-sender">sender() = term()</h3></div>
    <div class="type"><h3 id="type-tunnel">tunnel() = {tunnel, pid()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="connect/3">connect(Port, App, Handler) -&gt; {ok, Connection} | {error, Reason}</h3>

<ul class="type">
<li><code>Port = pos_integer()</code></li><li><code>App = string()</code></li><li><code>Handler = pid()</code></li><li><code>Connection = connection()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Connects to the iris message relay running locally, registering with the
       specified app name, and registering the specified handler to receive all
       iris events.
 </p>
</div></div>
<div class="function">
<h3 id="broadcast/3">broadcast(X1::Connection, App, Message) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>App = string()</code></li><li><code>Message = binary()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Broadcasts a message to all applications of type app. No guarantees are       
made that all recipients receive the message (best effort).</p>
 
       <p>The call blocks until the message is sent to the relay node.
 </p>
</div></div>
<div class="function">
<h3 id="request/4">request(X1::Connection, App, Request, Timeout) -&gt; {ok, Reply} | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>App = string()</code></li><li><code>Request = binary()</code></li><li><code>Timeout = pos_integer()</code></li><li><code>Reply = binary()</code></li><li><code>Reason = timeout | atom()</code></li></ul>
<div class="description">

<p>Executes a synchronous request to app, load balanced between all the       
active ones, returning the received reply.</p>
 
       <p>The call blocks until either a reply arrives or the request times out.
 </p>
</div></div>
<div class="function">
<h3 id="reply/2">reply(Sender, Reply) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Sender = sender()</code></li><li><code>Reply = binary()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Remote pair of the request function. Should be used to send back a reply       
to the request origin.</p>
 
       <p>The call blocks until the message is sent to the relay node.</p>
 
       <p>Sender must be the Sender argument from the request message.
 </p>
</div></div>
<div class="function">
<h3 id="subscribe/2">subscribe(X1::Connection, Topic) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>Topic = string()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Subscribes to a topic, receiving events as process messages.</p>
 
       <p>The call blocks until the message is sent to the relay node.
 </p>
</div></div>
<div class="function">
<h3 id="publish/3">publish(X1::Connection, Topic, Event) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>Topic = string()</code></li><li><code>Event = binary()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Publishes an event to all applications subscribed to the topic. No       
guarantees are made that all subscribers receive the message (best       
effort).</p>
 
       <p>The call blocks until the message is sent to the relay node.
 </p>
</div></div>
<div class="function">
<h3 id="unsubscribe/2">unsubscribe(X1::Connection, Topic) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>Topic = string()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Unsubscribes from a previously subscribed topic.</p>
 
       <p>The call blocks until the message is sent to the relay node.
 </p>
</div></div>
<div class="function">
<h3 id="tunnel/3">tunnel(X1::Connection, App, Timeout) -&gt; {ok, Tunnel} | {error, Reason}</h3>

<ul class="type">
<li><code>Connection = connection()</code></li><li><code>App = string()</code></li><li><code>Timeout = pos_integer()</code></li><li><code>Tunnel = tunnel()</code></li><li><code>Reason = timeout | atom()</code></li></ul>
<div class="description">

<p>Opens a direct tunnel to an instance of app, allowing pairwise-exclusive       
and order-guaranteed message passing between them.</p>
 
       <p>The call blocks until the either the newly created tunnel is set up, or
       a timeout occurs.
 </p>
</div></div>
<div class="function">
<h3 id="send/3">send(X1::Tunnel, Message, Timeout) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Tunnel = tunnel()</code></li><li><code>Message = binary()</code></li><li><code>Timeout = timeout()</code></li><li><code>Reason = timeout | atom()</code></li></ul>
<div class="description">

<p>Sends a message over the tunnel to the remote pair, blocking until the       
local relay node receives the message.</p>
 
       <p>Infinite timeouts are supported.
 </p>
</div></div>
<div class="function">
<h3 id="recv/2">recv(X1::Tunnel, Timeout) -&gt; {ok, Message} | {error, Reason}</h3>

<ul class="type">
<li><code>Tunnel = tunnel()</code></li><li><code>Timeout = timeout()</code></li><li><code>Message = binary()</code></li><li><code>Reason = timeout | atom()</code></li></ul>
<div class="description">

<p>Retrieves a message from the tunnel, blocking until one is available.</p>
 
       <p>Infinite timeouts are supported.
 </p>
</div></div>
<div class="function">
<h3 id="close/1">close(X1::Entity) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Entity = connection() | tunnel()</code></li><li><code>Reason = atom()</code></li></ul>
<div class="description">

<p>Gracefully terminates an Iris entity.</p>
 
       <list>
         <item><p>If <code>Entity</code> is a connection, all subscriptions are removed and all
             open tunnels are closed, after which the relay link is severed.</p></item>
         <item><p>If <code>Entity</code> is a tunnel, all pending operations are notified and
             the tunnel closed.</p></item>
       </list>
 
       <p>The call blocks until the operation finishes or fails.
 </p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
