<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>parse_trans_codegen (parse_trans) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>parse_trans_codegen</h1>
<h2 class="modsummary">Parse transform for code generation pseduo functions.</h2>
<div class="description">
<p>Parse transform for code generation pseduo functions</p>
  
   <p>...</p>
  </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="parse_transform/2">parse_transform(Forms, Options) -&gt; NewForms</h3>


<div class="description">

<p>
  Searches for calls to pseudo functions in the module <code>codegen</code>,  
and converts the corresponding erlang code to a data structure  
representing the abstract form of that code.</p>
 
  <p>The purpose of these functions is to let the programmer write  
the actual code that is to be generated, rather than manually  
writing abstract forms, which is more error prone and cannot be  
checked by the compiler until the generated module is compiled.</p>
 
  <p>Supported functions:</p>
 
  <p><em>gen_function/2</em></p>
 
  <p>Usage: <code>codegen:gen_function(Name, Fun)</code></p>
 
  <p>Substitutes the abstract code for a function with name <code>Name</code>
  and the same behaviour as <code>Fntun</code>.</p>
 
  <p><code>Fun</code> can either be a anonymous <code>fun</code>, which is then converted to
  a named function. It can also be an <code>implicit fun</code>, e.g.
  <code>fun is_member/2</code>. In this case, the referenced function is fetched
  and converted to an abstract form representation. It is also renamed
  so that the generated function has the name <code>Name</code>.</p>
 
  <p><em>gen_functions/1</em></p>
 
  <p>Takes a list of <code>{Name, Fun}</code> tuples and produces a list of abstract
  data objects, just as if one had written
  <code>[codegen:gen_function(N1,F1),codegen:gen_function(N2,F2),...]</code>.</p>
 
  <p><em>exprs/1</em></p>
 
  <p>Usage: <code>codegen:exprs(Fun)</code></p>
 
  <p><code>Fun</code> is either an anonymous function, or an implicit fun with only one  
function clause. This "function" takes the body of the fun and produces  
a data type representing the abstract form of the list of expressions in  
the body. The arguments of the function clause are ignored, but can be  
used to ensure that all necessary variables are known to the compiler.</p>
 
  <p><em>Variable substitution</em></p>
 
  <p>It is possible to do some limited expansion (importing a value
  bound at compile-time), using the construct <code>{'$var', V}</code>, where
  <code>V</code> is a bound variable in the scope of the call to <code>gen_function/2</code>.</p>
 
  <p>Example:
  </p><pre class="sh_erlang">
  gen(Name, X) -&gt;
     codegen:gen_function(Name, fun(L) -&gt; lists:member({'$var',X}, L) end).
  </pre>
 
  <p>After transformation, calling <code>gen(contains_17, 17)</code> will yield the
  abstract form corresponding to:
  </p><pre class="sh_erlang">
  contains_17(L) -&gt;
     lists:member(17, L).
  </pre>
 
  <p><em>Form substitution</em></p>
 
  <p>It is possible to inject abstract forms, using the construct
  <code>{'$form', F}</code>, where <code>F</code> is bound to a parsed form in
  the scope of the call to <code>gen_function/2</code>.</p>
 
  <p>Example:
  </p><pre class="sh_erlang">
  gen(Name, F) -&gt;
     codegen:gen_function(Name, fun(X) -&gt; X =:= {'$form',F} end).
  </pre>
 
  <p>After transformation, calling <code>gen(is_foo, {atom,0,foo})</code> will yield the
  abstract form corresponding to:
  </p><pre class="sh_erlang">
  is_foo(X) -&gt;
     X =:= foo.
  </pre>
</div></div></div>

<authors>

<aname>: Ulf Wiger</aname>
<email>ulf.wiger@erlang-solutions.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
