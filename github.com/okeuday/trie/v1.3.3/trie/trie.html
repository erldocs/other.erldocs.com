<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>trie (trie) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>trie</h1>
<h2 class="modsummary">
   A trie data structure implementation.   
The trie (i.e., from "retrieval") data structure was invented by   
Edward Fredkin (it is a form of radix sort).  The implementation stores   
string suffixes as a list because it is a PATRICIA trie   
(PATRICIA - Practical Algorithm to Retrieve Information    
Coded in Alphanumeric, D.R.Morrison (1968)).
  
   This Erlang trie implementation uses string (list of integers) keys and
   is able to get performance close to the process dictionary when doing key
   lookups (find or fetch, see http://okeuday.livejournal.com/16941.html).</h2>
<div class="description">
<p>
   <em><marker id="A_trie_data_structure_implementation.">A trie data structure implementation.</marker></em></p><p>   
The trie (i.e., from "retrieval") data structure was invented by   
Edward Fredkin (it is a form of radix sort).  The implementation stores   
string suffixes as a list because it is a PATRICIA trie   
(PATRICIA - Practical Algorithm to Retrieve Information    
Coded in Alphanumeric, D.R.Morrison (1968)).</p>
  
   This Erlang trie implementation uses string (list of integers) keys and
   is able to get performance close to the process dictionary when doing key
   lookups (find or fetch, see <url href="http://okeuday.livejournal.com/16941.html">http://okeuday.livejournal.com/16941.html</url>).
   Utilizing this trie, it is possible to avoid generating dynamic atoms
   in various contexts.  Also, an added benefit to using this trie is that
   the traversals preserve alphabetical ordering.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-trie">trie() = [] | <a href="#type-trie_return" class="seealso">trie_return()</a></h3></div>
    <div class="type"><h3 id="type-trie_return">trie_return() = {integer(), integer(), tuple()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="append/1">append(Key::string(), Value::any(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="append_list/1">append_list(Key::string(), ValueList::list(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="erase/1">erase(Key::string(), Node::trie()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="erase_similar/1">erase_similar(Similar::string(), Node::trie()) -&gt; [string()]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fetch/1">fetch(T::string(), Node::trie_return()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fetch_keys/1">fetch_keys(Node::trie()) -&gt; [string()]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fetch_keys_similar/1">fetch_keys_similar(Similar::string(), Node::trie()) -&gt; [string()]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="filter/1">filter(F::(string(), any()) -&gt; boolean(), Node::trie()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="find/1">find(T::string(), Node::trie()) -&gt; {ok, any()} | error</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="find_prefix/1">find_prefix(T::string(), X2::trie()) -&gt; {ok, any()} | prefix | error</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="find_prefix_longest/1">find_prefix_longest(Match::string(), Node::trie()) -&gt; {ok, string(), any()} | error</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fold/1">fold(F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="foldl/1">foldl(F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="foldr/1">foldr(F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fold_similar/1">fold_similar(Similar::string(), F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="foldl_similar/1">foldl_similar(Similar::string(), F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="foldr_similar/1">foldr_similar(Similar::string(), F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="foreach/1">foreach(F::(string(), any()) -&gt; any(), Node::trie()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="from_list/1">from_list(L::list()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_key/1">is_key(T::string(), Node::trie()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="map/1">map(F::(string(), any()) -&gt; any(), Node::trie()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="merge/1">merge(F::(string(), any(), any()) -&gt; any(), Node1::trie(), Node2::trie()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="new/0">new() -&gt; []</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="new/1">new(L::list()) -&gt; trie()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="prefix/1">prefix(Key::string(), Value::any(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="size/1">size(Node::trie()) -&gt; non_neg_integer()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="store/1">store(Key::string(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="store/1-1">store(Key::string(), NewValue::any(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="to_list/1">to_list(Node::trie()) -&gt; [{string(), any()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="to_list_similar/1">to_list_similar(Similar::string(), Node::trie()) -&gt; [{string(), any()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update/1">update(T::string(), F::(any()) -&gt; any(), Node::trie_return()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update/1-1">update(Key::string(), F::(any()) -&gt; any(), Initial::any(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update_counter/1">update_counter(Key::string(), Increment::number(), Node::trie()) -&gt; trie_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="find_match/1">find_match(Match::string(), Node::trie()) -&gt; {ok, any(), any()} | error</h3>


<div class="description">

<p>
  <em><marker id="Find_a_match_with_patterns_held_within_a_trie.">Find a match with patterns held within a trie.</marker></em>
  All patterns held within the trie use a wildcard character "*" to represent
  a regex of ".+".  "**" within the trie will result in undefined behavior
  (the pattern is malformed).  The function will search for the most specific
  match possible, given the input string and the trie contents.  The input
  string must not contain wildcard characters, otherwise badarg is thrown.
  If you instead want to supply a pattern string to match the contents of
  the trie, see fold_match/4.</p>
</div></div>
<div class="function">
<h3 id="find_similar/1">find_similar(Similar::string(), Node::trie()) -&gt; {ok, string(), any()} | error</h3>


<div class="description">

<p>
  <em><marker id="Find_the_first_key/value_pair_in_a_trie_where_the_key_shares_a_common_prefix.">Find the first key/value pair in a trie where the key shares a common prefix.</marker></em>
  The first match is found based on alphabetical order.</p>
</div></div>
<div class="function">
<h3 id="fold_match/1">fold_match(Match::string(), F::(string(), any(), any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">

<p>
  <em><marker id="Fold_a_function_over_the_keys_within_a_trie_that_matches_a_pattern.">Fold a function over the keys within a trie that matches a pattern.</marker></em>
  Traverses in alphabetical order.  Uses "*" as a wildcard character
  within the pattern (it acts like a ".+" regex, and "**" is forbidden).
  The trie keys must not contain wildcard characters, otherwise badarg
  is thrown. If you want to match a specific string without wildcards
  on trie values that contain wildcard characters, see find_match/2.</p>
</div></div>
<div class="function">
<h3 id="is_pattern/1">is_pattern(Pattern::string()) -&gt; true | false</h3>


<div class="description">

<p>
  <em><marker id="Test_to_determine_if_a_string_is_a_pattern.">Test to determine if a string is a pattern.</marker></em>
  "*" is the wildcard character (equivalent to the ".+" regex) and
  "**" is forbidden.</p>
</div></div>
<div class="function">
<h3 id="is_prefix/1">is_prefix(T::string(), X2::trie()) -&gt; true | false</h3>


<div class="description">

<p>
  <em><marker id="Determine_if_the_prefix_provided_has_existed_within_a_trie.">Determine if the prefix provided has existed within a trie.</marker></em>
  The function returns true if the string supplied is a prefix
  for a key that has previously been stored within the trie.
  If no values with the prefix matching key(s) were removed from the trie,
  then the prefix currently exists within the trie.</p>
</div></div>
<div class="function">
<h3 id="is_prefixed/1">is_prefixed(T::string(), X2::trie()) -&gt; true | false</h3>


<div class="description">

<p>
  <em><marker id="Determine_if_the_provided_string_has_a_prefix_within_a_trie.">Determine if the provided string has a prefix within a trie.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="is_prefixed/1-1">is_prefixed(Key::string(), Exclude::string(), Node::trie()) -&gt; true | false</h3>


<div class="description">

<p>
  <em><marker id="Determine_if_the_provided_string_has_an_acceptable_prefix_within_a_trie.">Determine if the provided string has an acceptable prefix within a trie.</marker></em>
  The prefix within the trie must match at least 1 character that is not
  within the excluded list of characters.</p>
</div></div>
<div class="function">
<h3 id="iter/1">iter(F::(string(), any(), () -&gt; any()) -&gt; any(), Node::trie()) -&gt; ok</h3>


<div class="description">

<p>
  <em><marker id="Iterate_over_a_trie.">Iterate over a trie.</marker></em>
  Traverses in alphabetical order.</p>
</div></div>
<div class="function">
<h3 id="itera/1">itera(F::(string(), any(), any(), (any()) -&gt; any()) -&gt; any(), A::any(), Node::trie()) -&gt; any()</h3>


<div class="description">

<p>
  <em><marker id="Iterate_over_a_trie_with_an_accumulator.">Iterate over a trie with an accumulator.</marker></em>
  Traverses in alphabetical order.</p>
</div></div>
<div class="function">
<h3 id="pattern_parse/1">pattern_parse(Pattern::string(), L::string()) -&gt; [string()] | error</h3>


<div class="description">

<p>
  <em><marker id="Parse_a_string_based_on_the_supplied_wildcard_pattern.">Parse a string based on the supplied wildcard pattern.</marker></em>
  "*" is the wildcard character (equivalent to the ".+" regex) and
  "**" is forbidden.</p>
</div></div>
<div class="function">
<h3 id="pattern_parse/1-1">pattern_parse(Pattern::string(), L::string(), Option::default | with_suffix) -&gt; [string()] | {[string()], string()} | error</h3>


<div class="description">

<p>
  <em><marker id="Parse_a_string_based_on_the_supplied_wildcard_pattern.">Parse a string based on the supplied wildcard pattern.</marker></em>
  "*" is the wildcard character (equivalent to the ".+" regex) and
  "**" is forbidden.
  This function assumes there is a direct match with the characters following
  the wildcard characters, so "*/" will parse "//" but not "///".  That means
  it currently depends on the pattern delimiters being unique
  (not part of what is consumed by the wildcard).  So, it is possible to have
  a find_match/2 argument that doesn't parse with the pattern it matches
  (since it is matching the most exact pattern while not making any
   decisions based on the delimiters following wildcard characters, i.e.,
   it backtracks through the string to match when the current path through
   the pattern doesn't match).  This function's current implementation
  is simple to keep the pattern parse efficient, without the need to
  consume extra memory.</p>
</div></div></div>

<authors>

<aname>Michael Truog</aname>
<email>mjtruog [at] gmail (dot) com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
