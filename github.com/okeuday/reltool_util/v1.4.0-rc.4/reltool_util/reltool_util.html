<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>reltool_util (reltool_util) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>reltool_util</h1>
<h2 class="modsummary">
   reltool Utility Functions
   All the functions here are probably considered unorthodox, but
   are useful for runtime usage of applications and releases.</h2>
<div class="description">
<p>
   <em><marker id="reltool_Utility_Functions">reltool Utility Functions</marker></em>
   All the functions here are probably considered unorthodox, but
   are useful for runtime usage of applications and releases.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="application_env/1">application_env(Application::atom()) -&gt; {ok, [{atom(), any()}]} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Get_the_application's_env_settings.">Get the application's env settings.</marker></em>
  Only get the env settings from the application's .app file.</p>
</div></div>
<div class="function">
<h3 id="application_start/1">application_start(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_all_the_dependent_applications_manually.">Start all the dependent applications manually.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_start/1-1">application_start(Application::atom(), Env::[{atom(), any()}]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_all_the_dependent_applications_manually_with_a_specific_configuration.">Start all the dependent applications manually with a specific configuration.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_start/1-2">application_start(Application::atom(), Env::[{atom(), any()}], Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_all_the_dependent_applications_manually_with_a_specific_configuration_and_timeout.">Start all the dependent applications manually with a specific configuration and timeout.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="applications_start/1">applications_start(Applications::[atom() | {atom(), list()}]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_all_the_dependent_applications_manually.">Start all the dependent applications manually.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="applications_start/1-1">applications_start(Applications::[atom() | {atom(), list()}], Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_all_the_dependent_applications_manually.">Start all the dependent applications manually.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_stop/1">application_stop(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_an_application_and_its_dependencies.">Stop an application and its dependencies.</marker></em>
  Only stop dependencies that are not required for other applications.</p>
</div></div>
<div class="function">
<h3 id="application_stop/1-1">application_stop(Application::atom(), Ignore::[atom()]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_an_application_and_its_dependencies_with_a_list_of_applications_to_ignore.">Stop an application and its dependencies with a list of applications to ignore.</marker></em>
  Only stop dependencies that are not required for other applications.</p>
</div></div>
<div class="function">
<h3 id="application_remove/1">application_remove(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_and_purge_the_modules_of_an_application_and_all_of_its_dependencies.">Stop and purge the modules of an application and all of its dependencies.</marker></em>
  Only application dependencies that are not required for other
  applications are removed.</p>
</div></div>
<div class="function">
<h3 id="application_remove/1-1">application_remove(Application::atom(), Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_and_purge_the_modules_of_an_application_and_all_of_its_dependencies_with_a_timeout.">Stop and purge the modules of an application and all of its dependencies with a timeout.</marker></em>
  Only application dependencies that are not required for other
  applications are removed.</p>
</div></div>
<div class="function">
<h3 id="application_remove/1-2">application_remove(Application::atom(), Timeout::pos_integer() | infinity, Ignore::[atom()]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_and_purge_the_modules_of_an_application_and_all_of_its_dependencies_with_a_timeout_and_a_list_of_applications_to_ignore.">Stop and purge the modules of an application and all of its dependencies with a timeout and a list of applications to ignore.</marker></em>
  Only application dependencies that are not required for other
  applications are removed.</p>
</div></div>
<div class="function">
<h3 id="application_purged/1">application_purged(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Purge_a_loaded_application's_modules_and_unload_the_application.">Purge a loaded application's modules and unload the application.</marker></em>
  The application is stopped if it is running, but its dependencies are
  ignored.</p>
</div></div>
<div class="function">
<h3 id="application_purged/1-1">application_purged(Application::atom(), Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Purge_a_loaded_application's_modules_and_unload_the_application_with_a_specific_timeout.">Purge a loaded application's modules and unload the application with a specific timeout.</marker></em>
  The application is stopped if it is running, but its dependencies are
  ignored.</p>
</div></div>
<div class="function">
<h3 id="application_running/1">application_running(Application::atom()) -&gt; {ok, {atom(), string()}} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Check_if_an_application_is_currently_running.">Check if an application is currently running.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_running/1-1">application_running(Application::atom(), Timeout::pos_integer() | infinity) -&gt; {ok, {atom(), string()}} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Check_if_an_application_is_currently_running_with_a_timeout.">Check if an application is currently running with a timeout.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_loaded/1">application_loaded(Application::atom()) -&gt; {ok, {atom(), string()}} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Check_if_an_application_is_currently_loaded.">Check if an application is currently loaded.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_modules/1">application_modules(Application::atom()) -&gt; {ok, [atom()]} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Retrieve_a_list_of_application_modules.">Retrieve a list of application modules.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="application_modules/1-1">application_modules(Application::atom(), Options::[{atom(), any()}]) -&gt; {ok, [atom()]} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Retrieve_a_list_of_application_modules_with_filter_options.">Retrieve a list of application modules with filter options.</marker></em>
  Options can contain {behavior, ModuleName} to list all the modules
  that use a specific behaviour (the information will not be present if
  the beam file was stripped).</p>
</div></div>
<div class="function">
<h3 id="ensure_application_loaded/1">ensure_application_loaded(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_an_application_is_loaded.">Make sure an application is loaded.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="ensure_application_started/1">ensure_application_started(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_an_application_is_started.">Make sure an application is started.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="ensure_application_stopped/1">ensure_application_stopped(Application::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_an_application_is_stopped.">Make sure an application is stopped.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="module_loaded/1">module_loaded(Module::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_a_module_is_loaded.">Make sure a module is loaded.</marker></em>
  If the module is not loaded, attempt to load it.</p>
</div></div>
<div class="function">
<h3 id="is_module_loaded/1">is_module_loaded(Module::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Wait_to_check_if_a_module_is_loaded.">Wait to check if a module is loaded.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="is_module_loaded/1-1">is_module_loaded(Module::atom(), Timeout::non_neg_integer()) -&gt; {ok, non_neg_integer()} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Wait_to_check_if_a_module_is_loaded.">Wait to check if a module is loaded.</marker></em>
  Return a new timeout value with the elapsed time subtracted.</p>
</div></div>
<div class="function">
<h3 id="module_purged/1">module_purged(Module::atom()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_a_module_is_purged.">Make sure a module is purged.</marker></em>
  If the module is not loaded, ignore it.</p>
</div></div>
<div class="function">
<h3 id="module_purged/1-1">module_purged(Module::atom(), Timeout::non_neg_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Make_sure_a_module_is_purged_with_a_timeout.">Make sure a module is purged with a timeout.</marker></em>
  If the module is not loaded, ignore it.</p>
</div></div>
<div class="function">
<h3 id="module_exports/1">module_exports(Module::atom()) -&gt; [{atom(), pos_integer()}]</h3>


<div class="description">

<p>
  <em><marker id="List_the_exported_functions_of_a_module.">List the exported functions of a module.</marker></em>
</p>
</div></div>
<div class="function">
<h3 id="script_start/1">script_start(FilePath::string()) -&gt; {ok, [atom()]} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_everything_specified_within_a_script_file.">Start everything specified within a script file.</marker></em>
  A script file is the input used when creating a boot file, which is the
  file used when first starting the Erlang VM.  This function checks
  all applications to determine if they are already running with the
  expected versions.  All modules are checked to make sure they have
  been loaded, if they are expected to have been loaded. Normally,
  the script is only used in the binary boot file format and only a single
  boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The script file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="script_remove/1">script_remove(FilePath::string()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_script_file.">Stop everything specified within a script file.</marker></em>
  A script file is the input used when creating a boot file, which is the
  file used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  the script is only used in the binary boot file format and only a single
  boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The script file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="script_remove/1-1">script_remove(FilePath::string(), Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_script_file_with_a_timeout.">Stop everything specified within a script file with a timeout.</marker></em>
  A script file is the input used when creating a boot file, which is the
  file used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  the script is only used in the binary boot file format and only a single
  boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The script file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="script_remove/1-2">script_remove(FilePath::string(), Timeout::pos_integer() | infinity, Ignore::[atom()]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_script_file_with_a_timeout_and_a_list_of_applications_to_ignore.">Stop everything specified within a script file with a timeout and a list of applications to ignore.</marker></em>
  A script file is the input used when creating a boot file, which is the
  file used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  the script is only used in the binary boot file format and only a single
  boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The script file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="boot_start/1">boot_start(FilePath::string()) -&gt; {ok, [atom()]} | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Start_everything_specified_within_a_boot_file.">Start everything specified within a boot file.</marker></em>
  A boot file is used when first starting the Erlang VM.  This function checks
  all applications to determine if they are already running with the
  expected versions.  All modules are checked to make sure they have
  been loaded, if they are expected to have been loaded. Normally,
  only a single boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The boot file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="boot_remove/1">boot_remove(FilePath::string()) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_boot_file.">Stop everything specified within a boot file.</marker></em>
  A boot file is used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  only a single boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The boot file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="boot_remove/1-1">boot_remove(FilePath::string(), Timeout::pos_integer() | infinity) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_boot_file_with_a_timeout.">Stop everything specified within a boot file with a timeout.</marker></em>
  A boot file is used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  only a single boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The boot file is expected to be within a release directory created
  by reltool.</p>
</div></div>
<div class="function">
<h3 id="boot_remove/1-2">boot_remove(FilePath::string(), Timeout::pos_integer() | infinity, Ignore::[atom()]) -&gt; ok | {error, any()}</h3>


<div class="description">

<p>
  <em><marker id="Stop_everything_specified_within_a_boot_file_with_a_timeout_and_a_list_of_applications_to_ignore.">Stop everything specified within a boot file with a timeout and a list of applications to ignore.</marker></em>
  A boot file is used when first starting the Erlang VM.  This function checks
  all applications to determine applications which can be safely removed
  (assuming the application dependencies are correct).  The applications
  will then be stopped and their modules will be purged.  Normally,
  only a single boot file is used during the lifetime of the Erlang VM
  (so it is unclear if using this function is bad or just unorthodox).
  The boot file is expected to be within a release directory created
  by reltool.</p>
</div></div></div>

<authors>

<aname>Michael Truog</aname>
<email>mjtruog [at] gmail (dot) com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
