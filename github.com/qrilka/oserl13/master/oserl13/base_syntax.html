<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>base_syntax (oserl13) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>base_syntax</h1>
<h2 class="modsummary">SMPP Base Syntax Library.</h2>
<div class="description">
<p>SMPP Base Syntax Library.</p>
  
   <p>Functions for the SMPP base syntax manipulation.</p>
  
   <p>As a guideline, some comments include references to the specific section
   numbers on [SMPP 5.0].</p>
  
  
   <em>Changes 0.1 -&gt; 0.2</em>
  
   <p>[18 Feb 2004]</p>
  
   <list>
     <item><p>Trailing <code>NULL_CHARACTER</code> is transparetly handled by
       <a href="#encode/2" class="seealso">base_syntax:encode/2</a> and
       <a href="#decode/2" class="seealso">base_syntax:decode/2</a> functions.
     </p></item>
     <item><p>
     <url href="http://oserl.sourceforge.net/common_lib/binary.html#take_until-3">
     take_until/3</url> moved to module <url href="binary.html">binary.erl</url> of
     the <url href="http://oserl.sourceforge.net/common_lib/index.html">
     common_lib</url>.
     </p></item>
     <item><p>
     <url href="http://oserl.sourceforge.net/common_lib/my_string.html#is_dec-1">
     is_dec/1</url> and
     <url href="http://oserl.sourceforge.net/common_lib/my_string.html#is_hex-1">
     is_hex/1</url> moved to module <url href="my_string.html">my_string.erl</url>
     of the <url href="http://oserl.sourceforge.net/common_lib/index.html">
     common_lib</url>.
     </p></item>
     <item><p><code>format</code> field in strings is now a Fun. Much more powerful and
       elegant than before.<br />
       <br />
        <a href="#decode/2" class="seealso">decode/2</a> and <a href="#encode/2" class="seealso">encode/2</a>
       changed (simplified :-) accordingly.
     </p></item>
   </list>
  
  
   <em>References</em>
   <taglist>
     <dt>[SMPP 5.0]</dt><item><p>Short Message Peer-to-Peer Protocol
       Specification. Version 5.0. SMS Forum.
     </p></item>
   </taglist>
  </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="decode/2">decode(Binary, Constant::Type) -&gt; {ok, Value, Rest} | {error, Reason}</h3>

<ul class="type">
<li><code>Binary = bin()</code></li><li><code>Type = {constant, Constant} | {integer, Size, Min, Max} | {c_octet_string, Fixed, Size, Format} | {octet_string, Fixed, Size, Format} | {list, Type, Size} | {composite, Name, Tuple} | {union, Types}</code></li><li><code>Constant = bin()</code></li><li><code>Size = int()</code></li><li><code>Min = int()</code></li><li><code>Max = int()</code></li><li><code>Fixed = bool()</code></li><li><code>Name = atom()</code></li><li><code>Tuple = term()</code></li><li><code>Types = [Type]</code></li><li><code>Value = term()</code></li><li><code>Rest = bin()</code></li><li><code>Reason = {type_mismatch, Type, Details}</code></li><li><code>Details = Data | Reason</code></li><li><code>Data = bin() | int() | string()</code></li></ul>
<div class="description">

<p>Decodes a Value from the head of a Binary using a Type specifier.  As
  the Value is decoded a type checking operation is performed, if successful
  the term <code>{ok, Value, Rest}</code> is returned (where Rest is the
  remainder of the unused binary), otherwise <code>{error, {type_mismatch,
  Type, Details}}</code> is returned.</p>
 
  <p>where</p>
 
  <list>
    <item><p><code>Format = fun(Str) -&gt; bool()</code></p></item>
    <item><p><code>Str = string()</code></p></item>
  </list>
 
  <p>Every type is decoded according to [SMPP 5.0].</p>
 
  <list>
    <item><a href="#decode-constant" class="seealso">constant</a></item>
    <item><a href="#decode-integer" class="seealso">integer</a></item>
    <item><a href="#decode-c_octet_string" class="seealso">c_octet_string</a></item>
    <item><a href="#decode-octet_string" class="seealso">octet_string</a></item>
    <item><a href="#decode-list" class="seealso">list</a></item>
    <item><a href="#decode-composite" class="seealso">composite</a></item>
    <item><a href="#decode-union" class="seealso">union</a></item>
  </list>
 
 
  <p><em><marker id="decode-constant">constant</marker></em></p>
 
  <p>Binaries, strings and integers are valid constants.</p>
 
  <p>If the binary representation of the Constant is at the head of Binary,
  the Constant is returned as Value.  Otherwise an error is reported.</p>
 
 
  <p><em><marker id="decode-integer">integer</marker></em></p>
 
  <p>Checks if Value is a valid Size octets integer.  Must be an integer
  between 0 and <code>math:pow(256, Size) - 1</code>.</p>
 
  <p>An integer of Size octets is taken from the head of the Binary, if not
  enough bytes an error is reported.</p>
 
 
  <p><em><marker id="decode-c_octet_string">c_octet_string</marker></em></p>
 
  <p>Checks if Value is a valid C-Octet String.  A C-Octet String must be
  NULL_CHARACTER ($\0) terminated.</p>
 
  <p>When a fixed size is given and the Size-th octet on the Binary is the
  NULL_CHARACTER, a <code>Size - 1</code> long binary is taken an translated into
  string using the binary_to_list BIF.</p>
 
  <p>On variable length strings, every octet until the NULL_CHARACTER is taken
  using the function <code>binary:take_until/3</code> (common_lib).  The result is
  translated to a list with the BIF binary_to_list.  Notice that the resulting
  <code>Value</code> is always smaller than <code>Size</code> characters long.</p>
 
  <p>Important (Since version 0.2).  The base syntax
  takes care of trailing NULL_CHARACTERs for you so, <i>even you have to count
  this character when setting the <code>Size</code> field</i>, <em>do not</em> add a
  trailing NULL_CHARACTER in your c_octet_string values, base_syntax:decode/2
  handles NULLs on its own.</p>
 
  <p>As a rule of thumb.  Set the <code>Size</code> of your c_octet_string
  accordingly to SMPP specs.  Do not expect decoded c_octet_string values to
  have a trailing NULL_CHARACTER.  This character is automatically removed at
  decode time.</p>
 
 
  <p><em><marker id="decode-octet_string">octet_string</marker></em></p>
 
  <p>When a fixed size is given the Value must be exactly 0 or Size
  characters long.  For variable lengths any range between 0 and Size
  octets is considered to be correct.</p>
 
  <p>Fixed size Octet Strings are decoded pretty much like a C-Octet String,
  but no terminating NULL_CHARACTER is required.</p>
 
  <p>It's not easy to guess where a variable Octet String ends, in fact this
  data-type makes sense only if encapsulated inside a TLV.  In order to let a
  TLV recursively decode an inner variable Octet String the following rule
  applies; if size(Binary) less than Size, the hole Binary is translated to a
  list (string), otherwise the first Size octets of the Binary are taken.</p>
 
 
  <p><em><marker id="decode-list">list</marker></em></p>
 
  <p>Every Value in the list must conform the given Type.</p>
 
  <p>To decode a list, a (Size / 256) + 1 octets integer indicating the
  total number (Num) of values is extracted from the head of the Binary, then
  a list with Num elements is decoded using the base Type of the list.
  This list of Values is returned, Num is discarded.</p>
 
 
  <p><em><marker id="decode-composite">composite</marker></em></p>
 
  <p>In a composite every field is checked against the corresponding field
  in the tuple with the types.</p>
 
  <p>Every field in the composite is decoded, one at a time, using the
  corresponding field in the type descriptor.  On anonymous composites
  (<code>Name = undefined</code>) the returning Value is a tuple built from
  the individual fields, named composites tuples are translated to a record of
  type Name.</p>
 
 
  <p><em><marker id="decode-union">union</marker></em></p>
 
  <p>The Value must conform at least one of the given types.</p>
 
  <p>An union value is decoded using the first type descriptor conformed
  by the value.</p>
 
<p><em>See also:</em> <a href="#decode_iter/3" class="seealso">decode_iter/3</a>, <a href="#decode_list/2" class="seealso">decode_list/2</a>, <a href="#decode_try/2" class="seealso">decode_try/2</a>, <a href="#encode/2" class="seealso">encode/2</a>, <a href="binary.html#take_until/3" class="seealso">binary:take_until/3</a>.</p>
</div></div>
<div class="function">
<h3 id="encode/2">encode(Value, Constant::Type) -&gt; {ok, Binary} | {error, Reason}</h3>

<ul class="type">
<li><code>Value = term()</code></li><li><code>Type = {constant, Constant} | {integer, Size, Min, Max} | {c_octet_string, Fixed, Size, Format} | {octet_string, Fixed, Size, Format} | {list, Type, Size} | {composite, Name, Tuple} | {union, Types}</code></li><li><code>Constant = bin()</code></li><li><code>Size = int()</code></li><li><code>Min = int()</code></li><li><code>Max = int()</code></li><li><code>Fixed = bool()</code></li><li><code>Name = atom()</code></li><li><code>Tuple = term()</code></li><li><code>Types = [Type]</code></li><li><code>Binary = bin()</code></li><li><code>Reason = {type_mismatch, Type, Details}</code></li><li><code>Details = Data | Reason</code></li><li><code>Data = bin() | int() | string()</code></li></ul>
<div class="description">

<p>Encodes a Value using a Type specifier.  Before encoding the value
  a type checking operation is done, if unsuccessful the term
  <code>{error, {type_mismatch, Type, Details}}</code> is returned.</p>
 
  <p>where</p>
 
  <list>
    <item><p><code>Format = fun(Str) -&gt; bool()</code></p></item>
    <item><p><code>Str = string()</code></p></item>
  </list>
 
  <p>Every type is encoded according to [SMPP 5.0].</p>
 
  <list>
    <item><a href="#encode-constant" class="seealso">constant</a></item>
    <item><a href="#encode-integer" class="seealso">integer</a></item>
    <item><a href="#encode-c_octet_string" class="seealso">c_octet_string</a></item>
    <item><a href="#encode-octet_string" class="seealso">octet_string</a></item>
    <item><a href="#encode-list" class="seealso">list</a></item>
    <item><a href="#encode-composite" class="seealso">composite</a></item>
    <item><a href="#encode-union" class="seealso">union</a></item>
  </list>
 
 
  <p><em><marker id="encode-constant">constant</marker></em></p>
 
  <p>Value must be identical to given constant.  Binaries, strings and
  integers are valid constants.</p>
 
  <p>The Value is directly encoded into a binary.</p>
 
 
  <p><em><marker id="encode-integer">integer</marker></em></p>
 
  <p>Checks if Value is a valid Size octets integer.  Must be an integer
  between 0 and <code>math:pow(256, Size) - 1</code>.</p>
 
  <p>The integer is translated into binary using Size octets.</p>
 
 
  <p><em><marker id="encode-c_octet_string">c_octet_string</marker></em></p>
 
  <p>Checks if Value is a valid C-Octet String: Just a string with Size - 1
  characters.  Notice that C-Octet Strings (erlang) Values should not include
  the terminating NULL_CHARACTER ($\0), it is automatically included by the
  encode function.</p>
 
  <p>When a fixed size is given, the <code>Value</code> (having no terminating
  NULL_CHARACTER) must be exactly 0 or Size - 1 characters long.  For variable
  lengths any range between 0 and Size - 1 octets is considered to be correct.
  </p>
 
  <p>The string is translated into binary using the BIF <code>list_to_binary
  </code>, thus one octet per character.</p>
 
  <p>Important (Since version 0.2).  The base syntax
  takes care of trailing NULL_CHARACTERs for you so, <i>even you have to count
  this character when setting the <code>Size</code> field</i>, <em>do not</em> add a
  trailing NULL_CHARACTER in your c_octet_string values, base_syntax:encode/2
  handles NULLs on its own.</p>
 
  <p>As a rule of thumb.  Set the <code>Size</code> of your c_octet_string
  accordingly to SMPP specs.  Do not add the trailing NULL_CHARACTER to the
  values of the c_octet_string parameters.  The NULL_CHARACTER is
  automatically included at encode time.</p>
 
 
  <p><em><marker id="encode-octet_string">octet_string</marker></em></p>
 
  <p>When a fixed size is given the Value must be exactly 0 or Size
  characters long.  For variable lengths any range between 0 and Size
  octets is considered to be correct.</p>
 
  <p>An string is translated into binary using the BIF <code>list_to_binary
  </code>, thus one octet per character.</p>
 
 
  <p><em><marker id="encode-list">list</marker></em></p>
 
  <p>Every Value in the list must conform the given Type.</p>
 
  <p>To encode a list, a (Size / 256) + 1 octets integer indicating the
  total number of values is prepended to the list of encoded values.  Every
  element on the list is encoded (and appended) according to the given type.
  </p>
 
 
  <p><em><marker id="encode-composite">composite</marker></em></p>
 
  <p>In a composite every field is checked against the corresponding field
  in the tuple with the types.</p>
 
  <p>Every field in the composite is encoded using the corresponding field
  in the type descriptor.  The global result is obtained concatenating every
  encoded field in the same order of appearance in the composite.  On named
  composites the identifier of the record is discarded (not encoded).</p>
 
 
  <p><em><marker id="encode-union">union</marker></em></p>
 
  <p>The Value must conform at least one of the given types.</p>
 
  <p>An union value is encoded using the first type descriptor conformed
  by the value.</p>
 
<p><em>See also:</em> <a href="#decode/2" class="seealso">decode/2</a>, <a href="#encode_iter/2" class="seealso">encode_iter/2</a>, <a href="#encode_list/2" class="seealso">encode_list/2</a>, <a href="#encode_try/2" class="seealso">encode_try/2</a>.</p>
</div></div>
<div class="function">
<h3 id="fit/2">fit(Integer::Type, NewSize::Size) -&gt; NewType</h3>

<ul class="type">
<li><code>Type = {constant, Constant} | {integer, Size, Min, Max} | {c_octet_string, Fixed, Size, Format} | {octet_string, Fixed, Size, Format} | {list, Type, Size} | {composite, Name, Tuple} | {union, Types}</code></li><li><code>Constant = bin()</code></li><li><code>Size = int()</code></li><li><code>Min = int()</code></li><li><code>Max = int()</code></li><li><code>Fixed = bool()</code></li><li><code>Name = atom()</code></li><li><code>Tuple = term()</code></li><li><code>Types = [Type]</code></li><li><code>NewType = Type</code></li></ul>
<div class="description">

<p>Fits a type specifier to a given Size.</p>
 
  <p>where</p>
 
  <list>
    <item><p><code>Format = fun(Str) -&gt; bool()</code></p></item>
    <item><p><code>Str = string()</code></p></item>
  </list>
 
  <list>
    <item><p>constants, composites and union specifiers are left unchanged.
    </p></item>
    <item><p>On strings (c_octet_string and octet_string), besides the size field,
      the length is set to fixed (<code>fixed = true</code>).
    </p></item>
    <item><p>The min and max fields are not changed on integers, the size is
      changed with no further checking.
    </p></item>
    <item><p>If the new Size is greater than the one permitted by the Type, the
      Type is returned unchanged.
    </p></item>
  </list>
 
  <p>This function was mainly conceived to adapt the type specification to a
  TLV parameter definition.</p>
</div></div></div>

<authors>

<aname>Enrique Marcote Peña</aname>
<email>mpquique_at_users.sourceforge.net</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
