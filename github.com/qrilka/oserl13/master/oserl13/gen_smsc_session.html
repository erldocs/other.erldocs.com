<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gen_smsc_session (oserl13) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gen_smsc_session</h1>
<h2 class="modsummary">Generic SMSC SMPP Session.</h2>
<div class="description">
<p>Generic SMSC SMPP Session.</p>
  
   <p>A generic SMSC SMPP session modeled as a FSM.  It also implements the
   <url href="gen_connection.html">gen_connection</url> behaviour.</p>
  
   <p>Every SMPP session works over a single TCP/IP connection.  If the
   underlying connection exits, the session is also terminated.</p>
  
   <p>Session failures due to connection errors must be handled by the
   callback SMSC.</p>
  
  
   <em>State transitions table</em>
  
   <p>To a better understanding of this behaviour, should notice that the
   state name on a SMSC session references that state of the ESME session on
   the other peer.  Thus:</p>
  
   <taglist>
     <dt>bound_rx: </dt><item><p>A SMSC session has this state whenever there's a
       receiver ESME on the other peer.
     </p></item>
     <dt>bound_tx: </dt><item><p>If there is a transmitter ESME on the other peer.
     </p></item>
     <dt>bound_trx: </dt><item><p>Bound to a transceiver.
     </p></item>
   </taglist>
  
   <p>Possible states for the SMSC SMPP session are shown in the first row.
   Events are those in the first column.  This table shows the next state
   given an event and the current state.</p>
  
   <p>Operations issued by the other peer (ESME) are treated asynchronously
   by the SMSC session, thus represented by async events.</p>
  
  
   <em>response_timer</em>
  
   <p>One <quote>instance</quote> of this timer is started for each request.
   On expiration, the request is considered unsuccessful.</p>
  
   <p>The timer associated to a request is stopped when the corresponding
   response arrives.</p>
  
  
   <em>Callback Function Index</em>
  
   <p>A module implementing this behaviour must export these functions.
   Leaving a callback undefined crashes the entire session (when that
   particular function is called).</p>
  
   
     
       <a href="#handle_bind/3" class="seealso">handle_bind/3</a>
       Forwards <i>bind_receiver</i>, <i>bind_transmitter</i> and
         <i>bind_transceiver</i> operations (from the peer ESME) to the
         callback SMSC.
       
     <br />
     
       <a href="#handle_operation/3" class="seealso">handle_operation/3</a>
       
       Forwards <i>broadcast_sm</i>, <i>cancel_broadcast_sm</i>,
         <i>cancel_sm</i>, <i>query_broadcast_sm</i>, <i>query_sm</i>,
         <i>replace_sm</i>, <i>submit_multi</i>, <i>submit_sm</i> and
         <i>data_sm</i> operations (from the peer ESME) to the callback
         SMSC.
       
     <br />
     
       <a href="#handle_unbind/3" class="seealso">handle_unbind/3</a>
       This callback forwards an unbind request (issued by a peer ESME)
         to the SMSC.
       
     <br />
   
  
  
   <em>Callback Function Details</em>
  
   <em><marker id="handle_bind-3">handle_bind/3</marker></em>
  
   <code>handle_bind(SMSC, Session, {CmdName, Pdu}) -&gt; Result</code>
   <list>
     <item><p><code>SMSC = pid()</code></p></item>
     <item><p><code>Session = pid()</code></p></item>
     <item><p><code>CmdName = bind_receiver |
                       bind_transmitter |
                       bind_transceiver</code></p></item>
     <item><p><code>Pdu = pdu()</code></p></item>
     <item><p><code>Result = {ok, ParamList} | {error, Error, ParamList}</code></p></item>
     <item><p><code>ParamList = [{ParamName, ParamValue}]</code></p></item>
     <item><p><code>ParamName = atom()</code></p></item>
     <item><p><code>ParamValue = term()</code></p></item>
   </list>
  
   <p>Forwards <i>bind_receiver</i>, <i>bind_transmitter</i> and
   <i>bind_transceiver</i> operations (from the peer ESME) to the
   callback SMSC.</p>
  
   <p>The <code>ParamList</code> included in the response is used to construct
   the bind response PDU.  If a command_status other than ESME_ROK is to
   be returned by the ESME in the response PDU, the callback should return the
   term <code>{error, Error, ParamList}</code>, where <code>Error</code> is the
   desired command_status error code.</p>
  
   <p><code>SMSC</code> is the SMSC's process id, <code>Session</code> is the
   session id.</p>
  
  
   <em><marker id="handle_operation-3">handle_operation/3</marker></em>
  
   <code>handle_operation(SMSC, Session, {CmdName, Pdu}) -&gt; Result</code>
   <list>
     <item><p><code>SMSC = pid()</code></p></item>
     <item><p><code>Session = pid()</code></p></item>
     <item><p><code>CmdName = broadcast_sm |
                       cancel_broadcast_sm |
                       cancel_sm |
                       query_broadcast_sm |
                       query_sm |
                       replace_sm |
                       submit_multi |
                       submit_sm |
                       data_sm</code></p></item>
     <item><p><code>Pdu = pdu()</code></p></item>
     <item><p><code>Result = {ok, ParamList} | {error, Error, ParamList}</code></p></item>
     <item><p><code>ParamList = [{ParamName, ParamValue}]</code></p></item>
     <item><p><code>ParamName = atom()</code></p></item>
     <item><p><code>ParamValue = term()</code></p></item>
   </list>
  
   <p>Forwards <i>broadcast_sm</i>, <i>cancel_broadcast_sm</i>,
   <i>cancel_sm</i>, <i>query_broadcast_sm</i>, <i>query_sm</i>,
   <i>replace_sm</i>, <i>submit_multi</i>, <i>submit_sm</i> and
   <i>data_sm</i> operations (from the peer ESME) to the callback SMSC.</p>
  
   <p>The <code>ParamList</code> included in the response is used to construct
   the response PDU.  If a command_status other than ESME_ROK is to
   be returned by the ESME in the response PDU, the callback should return the
   term <code>{error, Error, ParamList}</code>, where <code>Error</code> is the
   desired command_status error code.</p>
  
   <p><code>SMSC</code> is the SMSC's process id, <code>Session</code> is the
   session id.</p>
  
  
   <em><marker id="handle_unbind-3">handle_unbind/3</marker></em>
  
   <code>handle_unbind(SMSC, Session, Pdu) -&gt; ok | {error, Error}</code>
   <list>
     <item><p><code>SMSC = pid()</code></p></item>
     <item><p><code>Session = pid()</code></p></item>
     <item><p><code>Pdu = pdu()</code></p></item>
     <item><p><code>Error = int()</code></p></item>
   </list>
  
   <p>This callback forwards an unbind request (issued by a peer ESME) to the
   SMSC.</p>
  
   <p>If <code>ok</code> returned an unbind_resp with a ESME_ROK
   command_status is sent to the MC and the session moves into the unbound
   state.  When <code>{error, Error}</code> is returned by the ESME, the
   response PDU sent by the session to the MC will have an <code>Error</code>
   command_status and the session will remain on it's current bound state
   (bound_rx, bound_tx or bound_trx).</p>
  
   <p><code>SMSC</code> is the SMSC's process id, <code>Session</code> is the
   session id.</p>
  
   <em>Changes 1.1 -&gt; 1.2</em>
  
   <p>[30 Jul 2005 Anders Nygren]</p>
  
   <list>
     <item><p>Wrap #state.sequence_number to 1 when it reaches 16#7FFFFFFF.</p></item>
     <item><p>Do not reset timers when a PDU is dropped because the peer is
         congested.</p></item>
     <item><p>handle_peer_bind/3, add remote peer IP address in handle_bind callback.
     </p></item>
   </list>
  
   <p>[19 Sep 2006 Enrique Marcote]</p>
  
   <list>
     <item><p>Add <code>SmscRef</code> to
       <url href="gen_smsc_session.html#start-4">start/4</url>,
       <url href="gen_smsc_session.html#start-5">start/5</url>,
       <url href="gen_smsc_session.html#start_link-4">start_link/4</url> and
       <url href="gen_smsc_session.html#start_link-5">start_link/5</url> functions.
     </p></item>
   </list>
  
  </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="behaviour_info/1">behaviour_info(Other::Category) -&gt; Info</h3>

<ul class="type">
<li><code>Category = callbacks | term()</code></li><li><code>Info = CallbacksInfo | term()</code></li><li><code>CallbacksInfo = [{FunctionName, Arity}]</code></li><li><code>FunctionName = atom()</code></li><li><code>Arity = int()</code></li></ul>
<div class="description">

<p>Gives information about the behaviour.</p>
</div></div>
<div class="function">
<h3 id="start/4">start(SmscRef, Mod, Socket, Timers) -&gt; Result</h3>

<ul class="type">
<li><code>SmscRef = pid() | atom()</code></li><li><code>Mod = atom()</code></li><li><code>Socket = socket()</code></li><li><code>Timers = timers()</code></li><li><code>Result = {ok, Pid} | ignore | {error, Error}</code></li><li><code>Pid = pid()</code></li><li><code>Error = {already_started, Pid} | term()</code></li></ul>
<div class="description">

<p>Starts the server setting <code>SmscRef</code> as the session SMSC (owner).</p>
 
  <p><code>Timers</code> is a <code>timers</code> record.  Use the macro
  ?DEFAULT_TIMERS to set the default values.</p>
 
  <p>Refer to <em>oserl.hrl</em> for more details on the <code>timers</code> record
  definition.</p>
 
  <p>The gen_smsc_session is not registered.</p>
 
<p><em>See also:</em> <a href="#start_link/3" class="seealso">start_link/3</a>, <a href="gen_fsm.html#start/3" class="seealso">gen_fsm:start/3</a>.</p>
</div></div>
<div class="function">
<h3 id="start/5">start(Name, SmscRef, Mod, Socket, Timers) -&gt; Result</h3>

<ul class="type">
<li><code>Name = {local, Atom} | {global, Atom}</code></li><li><code>Atom = atom()</code></li><li><code>SmscRef = pid() | atom()</code></li><li><code>Mod = atom()</code></li><li><code>Socket = pid()</code></li><li><code>Timers = timers()</code></li><li><code>Result = {ok, Pid} | ignore | {error, Error}</code></li><li><code>Pid = pid()</code></li><li><code>Error = {already_started, Pid} | term()</code></li></ul>
<div class="description">

<p>Starts the server setting <code>SmscRef</code> as the session SMSC (owner).</p>
 
  <p><code>Timers</code> is a <code>timers</code> record.  Use the macro
  ?DEFAULT_TIMERS to set the default values.</p>
 
  <p>Refer to <em>oserl.hrl</em> for more details on the <code>timers</code> record
  definition.</p>
 
  <p>If <code>Name = {local, TheName}</code>, the gen_smsc_session is registered
  locally as <code>TheName</code>.  If <code>Name = {global, TheName}</code>, the
  gen_smsc_session is registered globally as <code>TheName</code>.</p>
 
<p><em>See also:</em> <a href="#start_link/4" class="seealso">start_link/4</a>, <a href="gen_fsm.html#start/4" class="seealso">gen_fsm:start/4</a>.</p>
</div></div>
<div class="function">
<h3 id="start_link/4">start_link(SmscRef, Mod, Socket, Timers) -&gt; Result</h3>

<ul class="type">
<li><code>SmscRef = pid() | atom()</code></li><li><code>Mod = atom()</code></li><li><code>Socket = socket()</code></li><li><code>Timers = timers()</code></li><li><code>Result = {ok, Pid} | ignore | {error, Error}</code></li><li><code>Pid = pid()</code></li><li><code>Error = {already_started, Pid} | term()</code></li></ul>
<div class="description">

<p>Starts the server setting <code>SmscRef</code> as the session SMSC (owner).</p>
 
  <p><code>Timers</code> is a <code>timers</code> record.  Use the macro
  ?DEFAULT_TIMERS to set the default values.</p>
 
  <p>Refer to <em>oserl.hrl</em> for more details on the <code>timers</code> record
  definition.</p>
 
  <p>The gen_smsc_session is not registered.</p>
 
<p><em>See also:</em> <a href="#start/3" class="seealso">start/3</a>, <a href="gen_fsm.html#start_link/3" class="seealso">gen_fsm:start_link/3</a>.</p>
</div></div>
<div class="function">
<h3 id="start_link/5">start_link(Name, SmscRef, Mod, Socket, Timers) -&gt; Result</h3>

<ul class="type">
<li><code>Name = {local, Atom} | {global, Atom}</code></li><li><code>Atom = atom()</code></li><li><code>SmscRef = pid() | atom()</code></li><li><code>Mod = atom()</code></li><li><code>Socket = pid()</code></li><li><code>Timers = timers()</code></li><li><code>Result = {ok, Pid} | ignore | {error, Error}</code></li><li><code>Pid = pid()</code></li><li><code>Error = {already_started, Pid} | term()</code></li></ul>
<div class="description">

<p>Starts the server setting <code>SmscRef</code> as the session SMSC (owner).</p>
 
  <p><code>Timers</code> is a <code>timers</code> record.  Use the macro
  ?DEFAULT_TIMERS to set the default values.</p>
 
  <p>Refer to <em>oserl.hrl</em> for more details on the <code>timers</code> record
  definition.</p>
 
  <p>If <code>Name = {local, TheName}</code>, the gen_smsc_session is registered
  locally as <code>TheName</code>.  If <code>Name = {global, TheName}</code>, the
  gen_smsc_session is registered globally as <code>TheName</code>.</p>
 
<p><em>See also:</em> <a href="#start/4" class="seealso">start/4</a>, <a href="gen_fsm.html#start_link/4" class="seealso">gen_fsm:start_link/4</a>.</p>
</div></div>
<div class="function">
<h3 id="alert_notification/2">alert_notification(FsmRef, ParamList) -&gt; Result</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li><li><code>ParamList = [{ParamName, ParamValue}]</code></li><li><code>ParamName = atom()</code></li><li><code>ParamValue = term()</code></li><li><code>Result = {ok, PduResp} | {error, Error}</code></li><li><code>PduResp = pdu()</code></li><li><code>Error = int()</code></li></ul>
<div class="description">

<p>Issues an <i>alert_notification</i> operation on the session identified
  by <code>FsmRef</code>.</p>
</div></div>
<div class="function">
<h3 id="outbind/2">outbind(FsmRef, ParamList) -&gt; Result</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li><li><code>ParamList = [{ParamName, ParamValue}]</code></li><li><code>ParamName = atom()</code></li><li><code>ParamValue = term()</code></li><li><code>Result = {ok, PduResp} | {error, Error}</code></li><li><code>PduResp = pdu()</code></li><li><code>Error = int()</code></li></ul>
<div class="description">

<p>Issues an <i>outbind</i> operation on the session identified by
  <code>FsmRef</code>.</p>
</div></div>
<div class="function">
<h3 id="data_sm/2">data_sm(FsmRef, ParamList) -&gt; Result</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li><li><code>ParamList = [{ParamName, ParamValue}]</code></li><li><code>ParamName = atom()</code></li><li><code>ParamValue = term()</code></li><li><code>Result = {ok, PduResp} | {error, Error}</code></li><li><code>PduResp = pdu()</code></li><li><code>Error = int()</code></li></ul>
<div class="description">

<p>Issues a <i>data_sm</i> operation on the session identified by
  <code>FsmRef</code>.</p>
</div></div>
<div class="function">
<h3 id="deliver_sm/2">deliver_sm(FsmRef, ParamList) -&gt; Result</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li><li><code>ParamList = [{ParamName, ParamValue}]</code></li><li><code>ParamName = atom()</code></li><li><code>ParamValue = term()</code></li><li><code>Result = {ok, PduResp} | {error, Error}</code></li><li><code>PduResp = pdu()</code></li><li><code>Error = int()</code></li></ul>
<div class="description">

<p>Issues a <i>deliver_sm</i> operation on the session identified by
  <code>FsmRef</code>.</p>
</div></div>
<div class="function">
<h3 id="unbind/1">unbind(FsmRef) -&gt; Result</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li><li><code>Result = {ok, PduResp} | {error, Error}</code></li><li><code>PduResp = pdu()</code></li><li><code>Error = int()</code></li></ul>
<div class="description">

<p>Issues an <i>unbind</i> operation on the session identified by
  <code>FsmRef</code>.</p>
</div></div>
<div class="function">
<h3 id="stop/1">stop(FsmRef) -&gt; ok</h3>

<ul class="type">
<li><code>FsmRef = Name | {Name, Node} | {global, Name} | pid()</code></li></ul>
<div class="description">

<p>Stops the fsm.  This function does *NOT* issue an unbind operation.
  The unbind must have been previously sent using the unbind/1 function.
 </p>
<p><em>See also:</em> <a href="gen_fsm.html#send_all_state_event/2" class="seealso">gen_fsm:send_all_state_event/2</a>.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(X1::Args) -&gt; Result</h3>

<ul class="type">
<li><code>Args = term()</code></li><li><code>Result = {ok, StateName, StateData} | {ok, StateName, StateData, Timeout} | ignore | {stop, StopReason}</code></li><li><code>StateName = atom()</code></li><li><code>StateData = term()</code></li><li><code>Timeout = int()</code></li><li><code>StopReason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - init/1</url> callback implementation. Initializes the the fsm.</p>
</div></div>
<div class="function">
<h3 id="open/2">open(R::Event, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name open.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="outbound/2">outbound(R::Event, S) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name outbound.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="bound_rx/2">bound_rx(R::Event, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name bound_rx.  Bound against a receiver ESME.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="bound_tx/2">bound_tx(R::Event, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name bound_tx.  Bound against a transmitter ESME.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="bound_trx/2">bound_trx(R::Event, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name bound_trx.  Bound against a transceiver ESME.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="unbound/2">unbound(R::Event, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = timeout | term()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/2</url> callback implementation.  Handles async events  
for the state name unbound.</p>
 
  <p>PDUs comming from the other peer (ESME) are received asynchronously.</p>
</div></div>
<div class="function">
<h3 id="open/3">open(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name open.</p>
</div></div>
<div class="function">
<h3 id="outbound/3">outbound(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name outbound.</p>
</div></div>
<div class="function">
<h3 id="bound_rx/3">bound_rx(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name bound_rx.  Bound against a receiver ESME.</p>
</div></div>
<div class="function">
<h3 id="bound_tx/3">bound_tx(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name bound_tx.  Bound against a transmitter ESME.</p>
</div></div>
<div class="function">
<h3 id="bound_trx/3">bound_trx(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name bound_trx.  Bound against a transceiver ESME.</p>
</div></div>
<div class="function">
<h3 id="unbound/3">unbound(Event, From, S::StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - StateName/3</url> callback implementation.  Handles events for
  the state name unbound.</p>
</div></div>
<div class="function">
<h3 id="handle_event/3">handle_event(R::Event, StateName, StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = die | term()</code></li><li><code>StateName = atom()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - handle_event/3</url> callback implementation.  Handles
  events received by <code>gen_fsm:send_all_state_event/2</code>.</p>
</div></div>
<div class="function">
<h3 id="handle_sync_event/4">handle_sync_event(Event, From, StateName, StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Event = term()</code></li><li><code>From = {pid(), Tag}</code></li><li><code>StateName = atom()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {reply, Reply, NextStateName, NextStateData} | {reply, Reply, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData} | {stop, Reason, Reply, NewStateData}</code></li><li><code>Reply = term()</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - handle_sync_event/4</url> callback implementation.  Handles
  events received via <code>gen_fsm:sync_send_all_state_event/2,3</code>.</p>
</div></div>
<div class="function">
<h3 id="handle_info/3">handle_info(Info, StateName, StateData) -&gt; Result</h3>

<ul class="type">
<li><code>Info = term()</code></li><li><code>StateName = atom()</code></li><li><code>StateData = term()</code></li><li><code>Result = {next_state, NextStateName, NextStateData} | {next_state, NextStateName, NextStateData, Timeout} | {stop, Reason, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NextStateData = term()</code></li><li><code>Timeout = int() | infinity</code></li><li><code>Reason = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - handle_info/3</url> callback implementation.  Call on reception
  of any other messages than a synchronous or asynchronous event.</p>
</div></div>
<div class="function">
<h3 id="terminate/3">terminate(R::Reason, N::StateName, S::StateData) -&gt; true</h3>

<ul class="type">
<li><code>Reason = normal | shutdown | term()</code></li><li><code>StateName = atom()</code></li><li><code>StateData = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - terminate/3</url> callback implementation.  Shutdown the fsm.</p>
 
  <p>Return value is ignored by the server.</p>
</div></div>
<div class="function">
<h3 id="code_change/4">code_change(OldVsn, StateName, StateData, Extra) -&gt; Result</h3>

<ul class="type">
<li><code>OldVsn = undefined | term()</code></li><li><code>StateName = term()</code></li><li><code>StateData = term()</code></li><li><code>Extra = term()</code></li><li><code>Result = {ok, NextStateName, NewStateData}</code></li><li><code>NextStateName = atom()</code></li><li><code>NewStateData = term()</code></li></ul>
<div class="description">

<p><url href="http://www.erlang.org/doc/r9c/lib/stdlib-1.12/doc/html/gen_fsm.html">gen_fsm - code_change/4</url> callback implementation.  Convert process
  state when code is changed</p>
</div></div></div>

<authors>

<aname>Enrique Marcote Peï¿½a</aname>
<email>mpquique_at_users.sourceforge.net</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
