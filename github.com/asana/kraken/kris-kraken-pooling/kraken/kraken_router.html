<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>kraken_router (kraken) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>kraken_router</h1>
<h2 class="modsummary">Routes topic invalidation messages to the appropriate clients.</h2>
<div class="description">
<p>Routes topic invalidation messages to the appropriate clients.  
Uses multiple kraken_router_shard processes to manage the topic space and get  
more concurrency between cores.</p>
 
  <p>At the moment, the kraken_router itself is a bottleneck since any router
  operation must first requests the list of Router shards from the kraken_router
  process. In practice, this doesn't seem to affect performance however we could
  request that information once when we launch the kraken TCP server and pass it
  through to the various kraken_router functions if necessary.</p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/3">start_link(Sup, NumRouters, ProxyToNode) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_queue_link/1">start_queue_link(Name) -&gt; {ok, QPid::pid()}</h3>


<div class="description">

<p>Creates a new kraken_queue, links it to the calling process, and
  registers it with the router so that the router will know when it exits
  and can clean up the appropriate routing information.
 </p>
</div></div>
<div class="function">
<h3 id="register/1">register(QPid) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(QPid::pid(), Topics::[string()]) -&gt; ok</h3>


<div class="description">

<p>Subscribes QPid to a list of topics so that they will receive messages
  whenever another client publishes to the topic. This is a synchronous call.
  Subscribers will not receive their own messages.
 </p>
</div></div>
<div class="function">
<h3 id="unsubscribe/1">unsubscribe(QPid::pid(), Topics::[string()]) -&gt; ok</h3>


<div class="description">

<p>Unsubscribes QPid from a list of the topics they were previously  
subscribed to. If there is a topic in the list that the caller was not  
previously subscribed to it will be ignored.</p>
 
  <p>TODO#Performance:
  This should probably become an asynchronous call to improve client
  performance. We could have a dedicated publisher process, or just spawn
  a new process for each publish operation. Note that if we make this
  async we must still ensure that unsubscribes and subscribes from the same
  client happen in order!
 </p>
</div></div>
<div class="function">
<h3 id="publish/1">publish(PublisherQPid::pid(), Topics::[string()], Message::string()) -&gt; ok</h3>


<div class="description">

<p>Publishes a messages to all subscribers of Topics except the publisher
  themself. This is a asynchronous call because the publisher should not need
  to wait for it to complete before it can move on to other processing.
 </p>
</div></div>
<div class="function">
<h3 id="queue_pids/0">queue_pids() -&gt; [Pid::pid()]</h3>


<div class="description">

<p>Returns the list of queue pids.
 </p>
</div></div>
<div class="function">
<h3 id="topics/1">topics(QPid::pid()) -&gt; {ok, [Topics::string()]}</h3>


<div class="description">

<p>Lists the topics that QPid is subscribed to.
 </p>
</div></div>
<div class="function">
<h3 id="topic_status/0">topic_status() -&gt; [Topics::{string(), integer()}]</h3>


<div class="description">

<p>Lists all topics, with the count of subscribers
 </p>
</div></div>
<div class="function">
<h3 id="status/0">status() -&gt; ok</h3>


<div class="description">

<p>Prints the status of each queue currently referenced by the router.
 </p>
</div></div>
<div class="function">
<h3 id="init/1">init(X1) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_call/3">handle_call(X1, From, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_cast/2">handle_cast(Cast, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_info/2">handle_info(Info, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="terminate/2">terminate(Reason, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="code_change/3">code_change(OldVsn, State, Extra) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
