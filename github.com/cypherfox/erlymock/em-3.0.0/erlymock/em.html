<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>em (erlymock) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>em</h1>
<h2 class="modsummary">   
The module name 'em' stands for 'Erly Mock'.</h2>
<div class="description">
<p>   
The module name 'em' stands for 'Erly Mock'.</p>
  
   <p>This mocking library works similar to Easymock.</p>
  
   <p>After a mock process is started by <code>new/0</code> it can be
   programmed to expect function calls and to react to them in two
   ways: </p><list><item><p>by returning a value</p></item><item><p>by executing an arbitrary
   function</p></item></list><p>
   This is done with <code>strict/4, strict/5, stub/4, stub/5</code>.
   </p>
  
   <p>Before the code under test is executed, the mock must be told
   that the programming phase is over by <code>replay/1</code>.</p>
  
   <p>In the next phase the code under test is run, and might or
   might not call the functions mocked.
   The mock process checks that all functions programmed with
   <code>strict/4, strict/5</code>are called in the
   correct order, with the expected arguments and reacts in the way
   defined during the programming phase. If a mocked function is called
   although another function was expected, or if an expected function
   was called with different arguments, the mock process dies and
   prints a comprehensive error message before failing the test.</p>
  
   <p>At the end of a unit test <code>verify/1</code> is called to
   check for missing invocations at the end of the programming phase
   and to remove all modules, that were dynamically created and loaded
   during the programming phase.</p>
  
   <p>NOTE: This library works by purging the modules mocked and replacing   
them with dynamically created and compiled code, so be careful what   
you mock, i.e. it brings chaos to mock modules from kernel. This also   
implies, that tests that mock the same modules must be run sequentially.</p>
  
   Apart from that, it is very advisable to <em>only mock owned modules</em>
   anyway.
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-answer">answer() = {function, fun(([any()]) -> any())}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {return, any()}</h3></div>
    <div class="type"><h3 id="type-args">args() = [fun((any()) -&gt; true | false) | term()]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/0">new() -&gt; pid()</h3>


<div class="description">

<p>
  Spawns a linked mock process and returns it's pid. This is usually the first
  thing to do in each unit test. The resulting pid is used in the other
  functions below. NOTE: only a single mock proccess is required for a single
  unit test case. One mock process can mock an arbitrary number of different
  modules.
  When the mock process dies, all uploaded modules are purged from the code
  server, and all cover compiled modules are restored.
  When the process that started the mock exits, the mock automatically cleans
  up and exits.
  After new() the mock is in 'programming' state.</p>
</div></div>
<div class="function">
<h3 id="strict/1">strict(M::pid(), Mod::atom(), Fun::atom(), Args::args()) -&gt; ok</h3>


<div class="description">

<p>
  Adds an expectation during the programming phase for a specific functiion
  invokation.
  </p><p>All expectations defined by 'strict' define an order in which the
  application must call the mocked functions, hence the name 'strict' as oposed
  to 'stub' (see below).</p>
  <p>The parameters are:
  </p><list>
  <item><p><code>M</code> the mock pid, returned by <code>new/0</code></p></item>
  <item><p><code>Mod</code> the module of the function to mock</p></item>
  <item><p><code>Fun</code> the name of the function to mock</p></item>
  <item><p><code>Args</code> a list of expected arguments.
  Each list element is either a value that will be matched to the actual value
  of the parameter at that position, or a predicate function which will be
  applied to the actual argument.</p></item>
  </list>
  <p>
  The return value, that the application will get when calling the mocked
  function is simply the atom <code>ok</code>. This differentiates this
  function from <code>strict/5</code>, which allows the definition of a
  custom response function or a custom return value.
  </p>
  NOTE: This function may only be called between <code>new/0</code> and
  <code>replay/1</code> - that is during the programming phase.
</div></div>
<div class="function">
<h3 id="strict/1-1">strict(M::pid(), Mod::atom(), Fun::atom(), Args::args(), Answer::answer()) -&gt; ok</h3>


<div class="description">

<p>
  This function behaves like <code>strict/4</code>
  and additionally accepts a return value or an answer function. That parameter
  <code>Answer</code> may be:
  </p><list>
  <item><p><code>{return, SomeValue}</code> This causes the mocked function invocation to
  return the specified value.</p></item>
  <item><p><code>{function, fun(([Arg1, ... , ArgN]) -&gt; SomeValue)}</code> This defines
  a function to be called when the mocked invokation happens.
  That function is applied to all captured actual arguments.  For convenience these
  are passed as a list, so the user can simply write <code>fun(_) -&gt; ...</code>
  when the actual values are not needed.
  The function will be executed by the process that calls the mocked function, not
  by the mock process. Hence the function may access <code>self()</code> and may
  throw an exception, which will then correctly appear in the process under test,
  allowing unit testing of exception handling.
  Otherwise the value returned by the function is passed through as the value
  returned from the invocation.
  </p></item>
  </list>
<p><em>See also:</em> <a href="#strict/4" class="seealso"><code>strict/4</code></a>.</p>
</div></div>
<div class="function">
<h3 id="stub/1">stub(M::pid(), Mod::atom(), Fun::atom(), Args::args()) -&gt; ok</h3>


<div class="description">

<p>
  Defines a what happens when a function is called whithout recording any
  expectations. The invocations defined by this function may happen in any order
  any number of times. The way, the invocation is defined is analog to</p>
<p><em>See also:</em> <a href="#strict/4" class="seealso"><code>strict/4</code></a>.</p>
</div></div>
<div class="function">
<h3 id="stub/1-1">stub(M::pid(), Mod::atom(), Fun::atom(), Args::args(), Answer::answer()) -&gt; ok</h3>


<div class="description">

<p>
  This is similar <code>stub/4</code> except that it, like
  <code>strict/5</code> allows the definition of a return value
  or an answer function.</p>
<p><em>See also:</em> <a href="#strict/5" class="seealso"><code>strict/5</code></a>, <a href="#stub/4" class="seealso"><code>stub/4</code></a>.</p>
</div></div>
<div class="function">
<h3 id="replay/1">replay(M) -&gt; term()
</h3>


<div class="description">

<p>
  Finishes the programming phase and switches to the replay phase where the
  actual code under test may run and invoke the functions mocked. This may
  be called only once, and only in the programming phase. This also loads
  (or replaces) the modules of the functions mocked.
  In the replay phase the code under test may call all mocked functions.
  If the application calls a mocked function with invalid arguments, or
  if the application calls a function not expected on a mocked module, the mock
  process dies and - if used in a typical edoc test suite - fails the test.</p>
</div></div>
<div class="function">
<h3 id="verify/1">verify(M) -&gt; term()
</h3>


<div class="description">

<p>
  Finishes the replay phase. If the code under test did not cause all expected
  invokations defined by <code>strict/4</code> or <code>strict/5</code>, the
  call will fail with <code>badmatch</code> with a comprehensive error message.
  Otherwise the mock process exits normally, returning <code>ok</code>.</p>
</div></div>
<div class="function">
<h3 id="any/0">any() -&gt; (any()) -&gt; true</h3>


<div class="description">

<p>
  Utility function that can be used as a match function in an argument list
  to match any value.</p>
</div></div></div>

<authors>

<aname>Sven Heyll</aname>
<email>sven.heyll@lindenbaum.eu</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
