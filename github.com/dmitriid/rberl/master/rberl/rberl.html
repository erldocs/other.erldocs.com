<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>rberl (rberl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>rberl</h1>
<h2 class="modsummary">Parse Java Resource Bundles in Erlang.</h2>
<div class="description">
<p>Parse Java Resource Bundles in Erlang</p>
 
  <p>This module deals with parsing Java properties files,
  see <url href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html">http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html</url>,  
especially the load function</p>
 
  <p>This module makes part of rberl, a library that provides functionality
  similar to Java's resource bundles (see tutorial for java resource bundles at
  <url href="http://java.sun.com/docs/books/tutorial/i18n/resbundle/index.html">http://java.sun.com/docs/books/tutorial/i18n/resbundle/index.html</url>)</p>
 
  <p>This code is available as Open Source Software under the MIT license.</p>
 
  <p>Updates at http://github.com/dmitriid/rberl/</p>
 
 
  <p><em>HERE BE LIONS.</em></p><p> Documentation for properties files. Quoted almost word for word from the javadocs</p>
 
  <p>The spec for .properties files is weird, to say the least.</p>
 
  <p><em>Incoming data</em></p>
 
  <p>The stream is assumed to be using the ISO 8859-1 character encoding; that is each byte is one Latin1 character.
  Characters not in Latin1, and certain special characters, can be represented in keys and elements using escape sequences
  similar to those used for character and string literals (see
  <url href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#100850">3.3</url> and
  <url href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#101089">3.10.6</url> of the Java Language Specification).
  The differences from the character escape sequences used for characters and strings are:
  </p><list>
    <item><p>Octal escapes are not recognized.</p></item>
    <item><p>The character sequence \b does not represent a backspace character (see next for treatment of backslashes).</p></item>
    <item><p>The method does not treat a backslash character, \, before a non-valid escape character as an error;
        the backslash is silently dropped. For example, in a Java string the sequence "\z" would cause a compile time error.
        In contrast, this method silently drops the backslash. Therefore, this method treats the two character sequence "\b"
        as equivalent to the single character 'b'.</p></item>
    <item><p>Escapes are not necessary for single and double quotes; however, by the rule above, single and double quote characters
        preceded by a backslash still yield single and double quote characters, respectively.</p></item>
  </list>
 
  <p><em>Unlike it's Java counterpart, the module doesn't yet throw any exceptions if a malformed Unicode escape appears in the
          input, other than possible exceptions by the unicode module. It doesn't attempt to recover from any such errors either</em></p>
 
  <p><em>Lines</em></p>
 
  <p>This module processes input in terms of lines. A natural line of input is terminated  
either by a set of line terminator characters (\n or \r or \r\n) or by the end of the file.  
A natural line may be either a blank line, a comment line, or hold some part of a key-element pair.</p>
 
  <p>The logical line holding all the data for a key-element pair may be spread out across several  
adjacent natural lines by escaping the line terminator sequence with a backslash character, \.</p>
 
  <p>Note that a comment line cannot be extended in this manner; every natural line that is a comment  
must have its own comment indicator, as described below. If a logical line is continued  
over several natural lines, the continuation lines receive further processing, also described below.  
Lines are read from the input stream until end of file is reached.</p>
 
  <p><em>Blank lines and comments</em></p>
 
  <p>A natural line that contains only white space characters is considered blank and is ignored.  
A comment line has an ASCII '#' or '!' as its first non-white space character; comment lines  
are also ignored and do not encode key-element information. In addition to line terminators,  
this module considers the characters space (' ', '\u0020'), tab ('\t', '\u0009'), and form feed ('\f', '\u000C') to be white space.</p>
 
  <p><em>Values spanning several lines</em></p>
 
  <p>If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence,  
the line terminator sequence, and any white space at the start the following line have no affect on the key or element values.  
The remainder of the discussion of key and element parsing will assume all the characters constituting the key and element  
appear on a single natural line after line continuation characters have been removed.  
Note that it is not sufficient to only examine the character preceding a line terminator sequence to see  
if the line terminator is escaped; there must be an odd number of contiguous backslashes for the line terminator  
to be escaped. Since the input is processed from left to right, a non-zero even number of 2n contiguous backslashes  
before a line terminator (or elsewhere) encodes n backslashes after escape processing.</p>
 
  <p><em>Key-value pairs</em></p>
 
  <p>The key contains all of the characters in the line starting with the first non-white space character
  and up to, but not including, the first unescaped '=', ':', or white space character other than
  a line terminator. All of these key termination characters may be included in the key by
  escaping them with a preceding backslash character; for example,
  </p><pre class="sh_erlang">
    \:\=
  </pre>
 
  <p>would be the two-character key ":=". Line terminator characters can be included using \r and \n  
escape sequences. Any white space after the key is skipped; if the first non-white space character  
after the key is '=' or ':', then it is ignored and any white space characters after it are also skipped.  
All remaining characters on the line become part of the associated element string;  
if there are no remaining characters, the element is the empty string "".  
Once the raw character sequences constituting the key and element are identified, escape processing  
is performed as described above.</p>
 
  <p>As an example, each of the following three lines specifies the key "Truth" and the associated element value "Beauty":
  </p><pre class="sh_erlang">
    Truth = Beauty
           Truth:Beauty
    Truth                  :Beauty
  </pre>
 
  <p>As another example, the following three lines specify a single property:
  </p><pre class="sh_erlang">
    fruits                           apple, banana, pear, \
                                     cantaloupe, watermelon, \
                                     kiwi, mango
  </pre><p>
  The key is "fruits" and the associated element is:
  </p><pre class="sh_erlang">
    "apple, banana, pear, cantaloupe, watermelon, kiwi, mango"
  </pre><p>  
Note that a space appears before each \ so that a space will appear after each comma in the final result;  
the \, line terminator, and leading white space on the continuation line are merely discarded and are not  
replaced by one or more other characters.</p>
 
 <p>As a third example, the line:
  </p><pre class="sh_erlang">
    cheeses
  </pre>
 
  <p>specifies that the key is "cheeses" and the associated element is the empty string "".</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-key_value_list">key_value_list() = [key_value_pair()]</h3></div>
    <div class="type"><h3 id="type-key_value_pair">key_value_pair() = {Key::string(), Value::string()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="process_file/1">process_file(FileName::string()) -&gt; key_value_list()</h3>


<div class="description">

<p>Process the specified file. Only one file at a time</p>
</div></div></div>
<div class="section"><h4>See also</h4><p><a href="rberl_server.html" class="seealso">rberl_server</a></p></div>
<authors>

<aname>Dmitrii Dimandt</aname>
<email>dmitrii@dmitriid.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
