<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sregulator (sbroker) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sregulator</h1>
<h2 class="modsummary">
  This module provides a load regulation service.</h2>
<div class="description">
<p>
  This module provides a load regulation service. A process joins the queue
  waiting to begin work. The level of concurrency is controlled by the sojourn
  time of another queue, such as a queue for an <code>sbroker</code>. Usually this  
means that the level of concurrency is decreased when a queue is slow (i.e.  
workers in excess) and increased when a queue is fast (i.e. workers in  
demand).</p>
 
  <p>When the number of active workers is below the minimum concurrency limit,
  workers are dequeued until the minimum level is reached. When the number of
  active workers is at (or above) the maximum, workers are never dequeued. When
  the number of workers is greater than or equal to the minimum and less than
  the maximum, a worker can be dequeued based on the sojourn time of a queue in
  an <code>sbroker</code>, or similar process.</p>
 
  <p>Before commencing work a worker calls <code>sregulator:ask/1</code>. If the regulator
  returns a <code>go</code> tuple, i.e. <code>{go, Ref, RegulatorPid, Relative, SojournTime}</code>,
  the worker may continue. <code>Ref</code>, the lock reference, and <code>RegulatorPid</code>, the
  pid of the regulator, are used for future communication with the regulator.
  <code>RelativeTime</code> is <code>undefined</code> if the regulator grants the lock due to the
  level of concurrency going below the minimum limit. Otherwise <code>RelativeTime</code>
  is the time (in <code>native</code> time units) spent waiting for the regulator's valve
  to dequeue the request after discounting time spent waiting for the regulator
  to handle requests. <code>SojournTime</code> is the time spent in both the regulator's
  message queue and internal queue, in <code>native</code> time units.</p>
 
  <p>The regulator may also return a <code>drop</code> tuple, i.e. <code>{drop, SojournTime}</code>.  
This means that work can not begin as a lock was not acquired.</p>
 
  <p>The worker uses <code>update/4</code> to report and update the result of a successful
  enqueuing attempt against a sbroker (or another sregulator). For example:
  </p><pre class="sh_erlang">  {go, Ref, Regulator, _, _} = sregulator:ask(Regulator),
  {go, _, _, RelativeTime, _} = sbroker:ask(Broker),
  {continue, Ref, _, _} = sregulator:update(Regulator, Ref, RelativeTime, 500).</pre><p>
  Or <code>drop/2</code> in the case of a failure:
  </p><pre class="sh_erlang">  {go, Ref, Regulator, _, _} = sregulator:ask(Regulator),
  {drop, _} = sbroker:ask(Broker),
  case sregulator:drop(Regulator, Ref) of
      {dropped, _} -&gt; dropped;
      {retry, _} -&gt; retry
   end.</pre><p>
  If <code>drop/2</code> returns <code>{dropped, SojournTime}</code> the work lock is lost and the
  process should stop working. However if it returns <code>{retry, SojournTime}</code> the
  process should continue because dropping it would bring the number of active
  workers below the concurrency limit. The regulator will always favour active
  workers over queued workers, so a drop request can return a <code>retry</code> tuple  
even when workers are queued waiting for a lock.</p>
 
  <p>The lock reference can be released using <code>done(Regulator, Ref)</code> or will be  
automatically released when a worker exits.</p>
 
  <p>A regulator requires a callback module. The callback modules implements one
  callback, <code>init/1</code>, with single argument <code>Args</code>. <code>init/1</code> should return
  <code>{ok, {QueueSpec, ValveSpec, Interval})</code> or <code>ignore</code>. <code>QueueSpec</code> is the
  queue specification for the queue and <code>Valve</code> is the valve specification for
  the queue. <code>Interval</code> is the interval in milliseconds that the queue is
  polled. This ensures that the active queue management strategy is applied
  even if no processes are enqueued/dequeued. In the case of <code>ignore</code> the
  regulator is not started and <code>start_link</code> returns <code>ignore</code>.</p>
 
  <p>A queue specification takes the following form:
  <code>{Module, Args, Out, Size, Drop}</code>. <code>Module</code> is the <code>squeue</code> callback module
  and <code>Args</code> are its arguments. The queue is created using
  <code>squeue:new(Time, Module, Args)</code>, where <code>Time</code> is the current time in
  <code>native</code> time units. <code>Out</code> defines the method of dequeuing, it is either the
  atom <code>out</code> (dequeue items from the head, i.e. FIFO), or the atom <code>out_r</code>
  (dequeue items from the tail, i.e. LIFO). <code>Size</code> is the maximum size of the
  queue, it is either a <code>non_neg_integer()</code> or <code>infinity</code>. <code>Drop</code> defines the
  strategy to take when the maximum size, <code>Size</code>, of the queue is exceeded. It
  is either the atom <code>drop</code> (drop from the head of the queue, i.e. head drop)
  or <code>drop_r</code> (drop from the tail of the queue, i.e. tail drop).</p>
 
  <p>A valve specification takes the following form:
  <code>{Module, Args, Min, Max}</code>. <code>Module</code> is the <code>svalve</code> callback module and
  <code>Args</code> are its arguments. The valve is created using
  <code>svalve:new(Time, Module, Args)</code>, where <code>Time</code> is the current time in
  <code>native</code> time units. <code>Min</code> is the minimum desired level of concurrency, a
  <code>non_neg_integer()</code>. <code>Max</code> is the maximum desired level of concurrency and is
  a <code>non_neg_integer()</code> or <code>infinity</code>. The maximum must be greater than or  
equal to the minimum.</p>
 
  <p>For example:</p>
 
  <pre class="sh_erlang">  -module(sregulator_example).
 
  -behaviour(sregulator).
 
  -export([start_link/0]).
  -export([ask/0]).
  -export([done/1]).
  -export([update/2]).
  -export([init/1]).
 
  start_link() -&gt;
      sregulator:start_link({local, ?MODULE}, ?MODULE, []).
 
  ask() -&gt;
      sregulator:ask(?MODULE).
 
  done(Ref) -&gt;
      sregulator:done(?MODULE, Ref).
 
  update(Ref, RelativeTime) -&gt;
      sregulator:update(?MODULE, Ref, RelativeTime, 500).
 
  drop(Ref) -&gt;
      sregulator:drop(?MODULE, Ref).
 
  init([]) -&gt;
      Timeout = sbroker_time:milli_seconds_to_native(5000),
      Target = sbroker_time:milli_seconds_to_native(5),
      ValveInternal = sbroker_time:milli_second_to_native(100),
      QueueSpec = {squeue_timeout, Timeout, out_r, infinity, drop},
      ValveSpec = {svalve_codel_r, {Target, ValveInternal}, 8, 64},
      RegInterval = 200,
      {ok, {QueueSpec, ValveSpec, RegInterval}}.</pre></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-name">name() = {local, atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-queue_spec">queue_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out | out_r,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop | drop_r}</h3></div>
    <div class="type"><h3 id="type-regulator">regulator() = pid()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| atom()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {atom(), node()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-start_return">start_return() = {ok, pid()} | {error, any()}</h3></div>
    <div class="type"><h3 id="type-valve_spec">valve_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ask/1">ask(Regulator) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = non_neg_integer() | undefined</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to gain a work lock with the regulator. Returns
  <code>{go, Ref, Pid, RelativeTime, SojournTime}</code> on successfully gaining a lock or
  <code>{drop, SojournTime}</code>.</p>
 
  <p><code>Ref</code> is the lock reference, which is a <code>reference()</code>. <code>Pid</code> is the <code>pid()</code>
  of the regulator. <code>RelativeTime</code> is the time (in <code>native</code> time units) spent
  waiting for the svalve signal to dequeue the request after discounting time
  spent waiting for the regulator to handle requests. If the regulator dequeues
  the request due to going below the minimum concurrency limit the
  <code>RelativeTime</code> is <code>undefined</code>. <code>SojournTime</code> is the time spent in the message
  queue and the internal queue, in <code>native</code> time units.</p>
 
  <p><code>RelativeTime</code> represents the <code>SojournTime</code> without some of the overhead of  
the regulator. The value measures the level of queue congestion in the  
without being effected by the load of the regulator.</p>
 
  <p>If <code>RelativeTime</code> is an integer, the request was enqueued in the internal
  queue awaiting a signal request to dequeue it sent approximately
  <code>RelativeTime</code> after this request was sent. Therefore <code>SojournTime</code> minus
  <code>RelativeTime</code> is the latency, or overhead, of the regulator in <code>native</code> time
  units.</p>
</div></div>
<div class="function">
<h3 id="nb_ask/1">nb_ask(Regulator) -&gt; Go | Retry</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Go = {go, Ref, Pid, undefined, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Retry = {retry, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to gain a work lock with the regulator but does not enqueue the
  request if a lock is not immediately available. Returns
  <code>{go, Ref, Pid, undefined, SojournTime}</code> on a successfully gaining a lock or
  <code>{retry, SojournTime}</code>.</p>
 
  <p><code>Ref</code> is the lock reference, which is a <code>reference()</code>. <code>Pid</code> is the <code>pid()</code>
  of the regulator. <code>undefined</code> reflects the fact that request is successful
  because the regulator is below its minimum concurrency limit. <code>SojournTime</code>
  is the time spent in the message queue of the regulator, in <code>native</code> time
  units.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/1">async_ask(Regulator) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = reference()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Monitors the regulator and sends an asynchronous request to gain a work
  lock. Returns <code>{await, Tag, Process}</code>.</p>
 
  <p><code>Tag</code> is a monitor <code>reference()</code> that uniquely identifies the reply
  containing the result of the request. <code>Process</code>, is the pid (<code>pid()</code>) of the
  monitored regulator. To cancel the request call <code>cancel(Process, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, RelativeTime, SojournTime}</code>
  or <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  regulator and no guarantee is made of the order of replies. A process making
  multiple requests can reuse the monitor reference for subsequent requests to
  the same regulator process (<code>Process</code>) using <code>async_ask/2</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/2">async_ask(Regulator, Tag) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = any()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Sends an asynchronous request to gain a work lock with the regulator.
  Returns <code>{await, Tag, Process}</code>.</p>
 
  <p><code>Tag</code> is a <code>any()</code> that identifies the reply containing the result of the
  request. <code>Process</code>, is the pid (<code>pid()</code>) of the regulator. To cancel all
  requests identified by <code>Tag</code> on regulator <code>Process</code> call
  <code>cancel(Process, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, RelativeTime, SojournTime}</code>
  or <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  regulator and no guarantee is made of the order of replies. If the regulator
  exits or is on a disconnected node there is no guarantee of a reply and so
  the caller should take appropriate steps to handle this scenario.
 </p>
<p><em>See also:</em> <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="await/2">await(Tag, Timeout) -&gt; Go | Drop | Continue | NotFound</h3>

<ul class="type">
<li><code>Tag = any()</code></li><li><code>Timeout = timeout()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = non_neg_integer() | undefined</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li><li><code>Continue = {continue, Ref, Pid, SojournTime}</code></li><li><code>NotFound = {not_found, SojournTime}</code></li></ul>
<div class="description">

<p>Await the response to an asynchronous request identified by <code>Tag</code>.</p>
 
  <p>Exits if a response is not received after <code>Timeout</code> milliseconds.</p>
 
  <p>Exits if a <code>DOWN</code> message is received with the reference <code>Tag</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#async_ask_r/2" class="seealso">async_ask_r/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cancel/3">cancel(Regulator, Tag, Timeout) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = any()</code></li><li><code>Timeout = timeout()</code></li></ul>
<div class="description">

<p>Cancels an asynchronous request. Returns the number of cancelled
  requests or <code>false</code> if no requests exist. In the later case a caller may wish
  to check its message queue for an existing reply.
 </p>
<p><em>See also:</em> <a href="#async_ask/1" class="seealso">async_ask/1</a>, <a href="#async_ask/2" class="seealso">async_ask/2</a>.</p>
</div></div>
<div class="function">
<h3 id="done/3">done(Regulator, Ref, Timeout) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>Timeout = timeout()</code></li></ul>
<div class="description">

<p>Release lock, <code>Ref</code>, on regulator <code>Regulator</code>. Returns <code>ok</code> on success
  and <code>{error, not_found}</code> if the lock reference does not exist on the
  regulator.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="update/4">update(Regulator, Ref, RelativeTime, Timeout) -&gt; Continue | NotFound</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>RelativeTime = integer()</code></li><li><code>Timeout = timeout()</code></li><li><code>Continue = {continue, Ref, Pid, SojournTime}</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>NotFound = {not_found, SojournTime}</code></li></ul>
<div class="description">

<p>Update the regulator, <code>Regulator</code>, with a relative sojourn time,
  <code>RelativeTime</code>, in <code>native</code> time units. <code>Ref</code> is the lock reference and
  <code>Timeout</code> is the time to wait in milliseconds for a reply. Returns
  <code>{continue, Ref, Pid, SojournTime}</code> if the lock reference, <code>Ref</code>, exists on
  the regulator. <code>Pid</code> is the pid of the regulator and <code>SojournTime</code> is the
  time spent waiting for the regulator to handle the request. If the lock
  reference, <code>Ref</code>, does not exist returns <code>{not_found, SojournTime}</code>.</p>
 
  <p>The relative sojourn time, <code>RelativeTime</code>, is used as the sojourn time in a
  a <code>svalve:sojourn/4</code> or <code>svalve:sojourn_r/4</code> call on the valve in the
  regulator.</p>
</div></div>
<div class="function">
<h3 id="async_update/3">async_update(Regulator, Ref, RelativeTime) -&gt; {await, Ref2, Pid}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>RelativeTime = integer()</code></li><li><code>Ref2 = reference()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Asynchronously update the regulator, <code>Regulator</code>, with a relative
  sojourn time, <code>RelativeTime</code>, in <code>native</code> time units. Returns
  <code>{await, Tag, Pid}</code>, where <code>Tag</code> is a monitor reference of the regulator
  and <code>Pid</code> is the pid of the regulator. A reply is sent by the regulator
  idenitified by the <code>Tag</code>.</p>
 
  <p>The reply if of the form <code>{Tag, {continue, Ref, Pid, SojournTime}}</code> or
  <code>{Tag, {not_found, SojournTime}}</code>. <code>SojournTime</code> is the time between sending  
the update request and the regulator sending a reply.</p>
 
  <p>This function is intended to allow back pressure while not blocking the
  worker. An update request is assumed to occur at the moment a dequeue event
  occurs. If the regulator is overloaded and has not replied to a previous
  asynchronous update request a worker should skip updating the regulator
  rather than delay sending the update.</p>
</div></div>
<div class="function">
<h3 id="async_update/4">async_update(Regulator, Ref, RelativeTime, Tag) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>RelativeTime = integer()</code></li><li><code>Tag = any()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Asynchronous update the regulator, <code>Regulator</code>, with a relative sojourn
  time, <code>RelativeTime</code>, in <code>native</code> time units. Returns <code>{await, Tag, Pid}</code>,
  where <code>Pid</code> is the pid of the regulator.</p>
 
  <p>The reply if of the form <code>{Tag, {continue, Ref, Pid, SojournTime}}</code> or
  <code>{Tag, {not_found, SojournTime}}</code>. <code>SojournTime</code> is the time between sending  
the update request and the regulator sending a reply.</p>
 
  <p>This function behaves the same as <code>async_update/3</code> except the regulator is
  not monitored and the supplied tag, <code>Tag</code>, is used in the reply. If the
  regulator exits there is no guarantee of a reply.</p>
</div></div>
<div class="function">
<h3 id="drop/2">drop(Regulator, Ref) -&gt; Response</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>Response = {dropped | retry | not_found, SojournTime}</code></li><li><code>SojournTime = non_neg_integer()</code></li></ul>
<div class="description">

<p>Signal a drop. Returns <code>ok</code> if the lock is released, <code>{error, retry}</code> if
  the lock is maintained and <code>{error, not_found}</code> if the lock does not exist on  
the regulator.</p>
 
  <p>This function can be used to signal to the regulator that an event has
  occured that should shrink the level of concurrency. For example a connection
  process that fails to connect to a remote server may call <code>drop/2</code> so that
  the concurrency level decreases when the remote server is unavailable.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="ensure_dropped/3">ensure_dropped(Regulator, Ref, Timeout) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>Timeout = timeout()</code></li></ul>
<div class="description">

<p>Signal a drop and release the lock. Returns <code>ok</code> if the lock is
  released and <code>{error, not_found}</code> if the lock does not exist on the  
regulator.</p>
 
  <p>Unlike <code>drop/2</code> the lock is always released if it exists.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>, <a href="#drop/2" class="seealso">drop/2</a>.</p>
</div></div>
<div class="function">
<h3 id="change_config/2">change_config(Regulator, Timeout) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Change the configuration of the regulator. Returns <code>ok</code> on success and
  <code>{error, Reason}</code> on failure, where <code>Reason</code>, is the reason for failure.</p>
 
  <p>Regulator calls the <code>init/1</code> callback to get the new configuration. If
  <code>init/1</code> returns <code>ignore</code> the config does not change.
 </p>
<p><em>See also:</em> <a href="#start_link/2" class="seealso">start_link/2</a>.</p>
</div></div>
<div class="function">
<h3 id="len/2">len(Regulator, Timeout) -&gt; Length</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Length = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the length of the queue in the regulator, <code>Regulator</code>.</p>
</div></div>
<div class="function">
<h3 id="size/2">size(Regulator, Timeout) -&gt; Size</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Size = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the number of active process using the regulator, <code>Regulator</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/2">start_link(Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a regulator with callback module <code>Module</code> and argument <code>Args</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/3">start_link(Name, Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Name = name()</code></li><li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a regulator with name <code>Name</code>, callback module <code>Module</code> and
  argument <code>Args</code>.
 </p>
<p><em>See also:</em> <a href="#start_link/2" class="seealso">start_link/2</a>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
