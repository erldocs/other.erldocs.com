<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sthrottle (sbroker) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sthrottle</h1>
<h2 class="modsummary">
  This modules provides a concurrency limiting service.</h2>
<div class="description">
<p>
  This modules provides a concurrency limiting service. A process joins a queue
  and remains there until the number of active processes goes below the limit.
  The queue can be actively managed using an <code>squeue</code> callback module, and  
passively managed using head or tail drop. Processes that die while in the  
queue are automatically removed and active processes that die are replaced by  
processes in the queue. The concurrency limit can be altered using the built  
in algorithm and/or a custom (manual) feedback loop.</p>
 
  <p>To join the queue a process calls <code>ask/1</code>, which will block until the process
  can start the task. Once the task is completed <code>done/2</code> releases the lock.</p>
 
  <p>To increase the concurrency limit (up to the maximum) call <code>positive/1</code>, and
  to decrease (up to the minimum) call <code>negative/1</code>.</p>
 
  <p>To use the built in feedback loop call <code>signal/3</code> on the result of another
  queue attempt (e.g. <code>sbroker:ask/1</code>). This will reduce the concurrency limit
  when processes are dropped. It will also increase the concurrency limit when
  two queue attempts in a row are successful with a sojourn time of 0.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-name">name() = {local, atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-queue_spec">queue_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out | out_r,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop | drop_r}</h3></div>
    <div class="type"><h3 id="type-throttle">throttle() = pid()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| atom()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {atom(), node()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ask/1">ask(Throttle) -&gt; {go, Ref, Pid, SojournTime} | {drop, SojournTime}</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li></ul>
<div class="description">

<p>Tries to gain access to a work lock. Returns
  <code>{go, Ref, Pid, SojournTime}</code> on success or <code>{drop SojournTime}</code> on failure.</p>
 
  <p><code>Ref</code> is the lock reference, which is a <code>reference()</code>. <code>Pid</code> is the <code>pid()</code>
  of the throttle. <code>SojournTime</code> is the time spent in the queue in  
milliseconds.</p>
 
  <p>A process should stop the task if <code>Pid</code> exits as the lock is lost. Usually
  this can achieved by using a <code>rest_for_one</code> or <code>one_for_all</code> supervisor that  
will shutdown the worker if the throttle exits. If this is not in place a  
monitor, or link (warning: the throttle does not trap exits), can be used.</p>
 
  <p>The <code>Pid</code> should be used as the <code>Throttle</code> in future calls that use the lock,
  such as <code>done/2</code> and <code>signal/3</code>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/1">async_ask(Throttle) -&gt; ARef</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li><li><code>ARef = reference()</code></li></ul>
<div class="description">

<p>Sends an asynchronous request to gain access to a work lock. Returns a
  <code>reference()</code>, <code>ARef</code>, which can be used to identify the reply containing the
  result of the request, or to cancel the request using <code>cancel/1</code>.</p>
 
  <p>The reply is of the form <code>{ARef, {go, Ref, Pid, SojournTime}</code> or
  <code>{ARef, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  throttle and no guarantee is made of the order of replies. If the throttle
  exits or is on a disconnected node there is no guarantee of
  a reply and so the caller should take appriopriate steps to handle this
  scenario.
 </p>
<p><em>See also:</em> <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cancel/2">cancel(Throttle, ARef) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li><li><code>ARef = reference()</code></li></ul>
<div class="description">

<p>Cancels an asynchronous request. Returns <code>ok</code> on success and
  <code>{error, not_found}</code> if the request does not exist. In the later case a
  caller may wish to check its message queue for an existing reply.
 </p>
<p><em>See also:</em> <a href="#async_ask/1" class="seealso">async_ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="done/2">done(Throttle, Ref) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li><li><code>Ref = reference()</code></li></ul>
<div class="description">

<p>Releases the lock represented by <code>Ref</code>. Returns <code>ok</code> on success and
  <code>{error, not_found}</code> if the request does not exist.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="positive/1">positive(Throttle) -&gt; ok</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li></ul>
<div class="description">

<p>Applies positive feedback to the throttle. Increases the concurrency
  limit by 1, up to the maximum.</p>
</div></div>
<div class="function">
<h3 id="negative/1">negative(Throttle) -&gt; ok</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li></ul>
<div class="description">

<p>Applies negative feedback to the throttle. Decreases the concurrency
  limit by 1, up to the minimum.</p>
</div></div>
<div class="function">
<h3 id="signal/3">signal(Throttle, Ref, Response) -&gt; Response</h3>

<ul class="type">
<li><code>Throttle = throttle()</code></li><li><code>Ref = reference()</code></li><li><code>Response = {go, Ref2, Pid, SojournTime}</code></li><li><code>Ref2 = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li></ul>
<div class="description">

<p>Send a signal to the throttle based on a queue attempt response. Returns
  the response if the response is a <code>go</code> tuple. Returns a new response, which
  might be the same, if the response is a <code>drop</code> tuple:</p>
 
  <p><code>{done, SojournTime}</code> means the concurrency lock is lost and <code>SojournTime</code> is  
the sojourn time from the initial response.</p>
 
  <p><code>{not_found, SojournTime}</code> means the concurrency lock did not exist on the
  throttle and <code>SojournTime</code> is the sojourn time from the initial response.</p>
 
  <p>This function is designed to control the concurrency limit of a throttle
  process based on a queue attempt on a different queue (such as the result
  of <code>sbroker:ask/1</code>), not on queue attempts on the throttle itself.</p>
</div></div>
<div class="function">
<h3 id="erase/1">erlang:erase(Ref) -&gt; ok</h3>

<ul class="type">
<li><code>Ref = reference()</code></li></ul>
<div class="description">

<p>Removes process dictionary entries relating to the lock <code>Ref</code>.</p>
 
  <p><code>signal/3</code> may use the process dictionary to store state. This is cleaned up
  by <code>signal/3</code> when it returns <code>{done, SojournTime}</code> and by <code>done/2</code>. However  
if the throttle exits and owner of the lock does not then this  
function should be called to prevent a leak.</p>
 
  <p>This function can also be used to forget any data used by <code>signal/3</code> while
  the lock is still active. Future calls to <code>signal/3</code> on the same lock will
  still work and may re-add an entry to the process dictionary.</p>
</div></div>
<div class="function">
<h3 id="start_link/0">start_link() -&gt; {ok, Pid} | {error, Reason}</h3>

<ul class="type">
<li><code>Pid = pid()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Starts a throttle with default limits and queues. The default
  queue uses <code>squeue_timeout</code> with a timeout of <code>5000</code>, which means that items
  are dropped if they spend longer than 5000ms in the queue. The queue has a
  size of <code>infinity</code> and uses <code>out</code> to dequeue items. The tick interval is
  <code>200</code>, so the active queue management timeout strategy is applied at least
  every 200ms. The minimum (and initial) concurrency limit is <code>0</code> and the
  maximum is <code>infinity</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/1">start_link(Name) -&gt; {ok, Pid} | {error, Reason}</h3>

<ul class="type">
<li><code>Name = name()</code></li><li><code>Pid = pid()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Starts a registered throttle with default limits and queue.</p>
<p><em>See also:</em> <a href="#start_link/1" class="seealso">start_link/1</a>.</p>
</div></div>
<div class="function">
<h3 id="start_link/4">start_link(Min, Max, AskingSpec, Interval) -&gt; {ok, Pid} | {error, Reason}</h3>

<ul class="type">
<li><code>Min = non_neg_integer()</code></li><li><code>Max = non_neg_integer() | infinity</code></li><li><code>AskingSpec = queue_spec()</code></li><li><code>Interval = pos_integer()</code></li><li><code>Pid = pid()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Starts a throttle with custom limits and queue.</p>
 
  <p>The first argument, <code>Min</code> is the minimum, (and initial), concurrency limit
  and is a <code>non_neg_integer()</code>. The second argument, <code>Max</code>, is the maximum
  concurrency limit, is a <code>non_neg_integer()</code> or <code>infinity</code> and must be greater
  than or equal to <code>Min</code>.</p>
 
  <p>The third argument, <code>QueueSpec</code>, is the queue specification for the queue.
  Processes that call <code>ask/1</code> (or <code>async_ask/1</code>) join this queue until they
  gain a lock or are dropped. The fourth argument, <code>Interval</code>, is the interval  
in milliseconds that the queue is polled. This ensures that the active queue  
management strategy is applied even if no processes are enqueued/dequeued.</p>
 
  <p>A queue specifcation takes the following form:
  <code>{Module, Args, Out, Size, Drop}</code>. <code>Module</code> is the <code>squeue</code> callback module
  and <code>Args</code> are its arguments. The queue is created using
  <code>squeue:new(Module, Arg)</code>. <code>Out</code> defines the method of dequeuing, it is
  either the atom <code>out</code> (dequeue items from the head, i.e. FIFO), or the
  atom <code>out_r</code> (dequeue items from the tail, i.e. LIFO). <code>Size</code> is the maximum
  size of the queue, it is either a <code>non_neg_integer()</code> or <code>infinity</code>. <code>Drop</code>
  defines the strategy to take when the maximum size, <code>Size</code>, of the queue is
  exceeded. It is either the atom <code>drop</code> (drop from the head of the queue, i.e.
  head drop) or <code>drop_r</code> (drop from the tail of the queue, i.e. tail drop)</p>
</div></div>
<div class="function">
<h3 id="start_link/5">start_link(Name, Min, Max, AskingSpec, Interval) -&gt; {ok, Pid} | {error, Reason}</h3>

<ul class="type">
<li><code>Name = name()</code></li><li><code>Min = non_neg_integer()</code></li><li><code>Max = non_neg_integer() | infinity</code></li><li><code>AskingSpec = queue_spec()</code></li><li><code>Interval = pos_integer()</code></li><li><code>Pid = pid()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Starts a registered throttle with custom queues.</p>
<p><em>See also:</em> <a href="#start_link/3" class="seealso">start_link/3</a>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
