<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sregulator (sbroker) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sregulator</h1>
<h2 class="modsummary">
  This module provides a load regulation service.</h2>
<div class="description">
<p>
  This module provides a load regulation service. A process joins the queue
  waiting to begin work. The level of concurrency is controlled by the sojourn
  time of another queue, such as a queue for an <code>sbroker</code>. Usually this  
means that the level of concurrency is decreased when a queue is slow (i.e.  
workers in excess) and increased when a queue is fast (i.e. workers in  
demand).</p>
 
  <p>When the number of active workers is below the minimum concurrency limit,
  workers are dequeued until the minimum level is reached. When the number of
  active workers is at (or above) the maximum, workers are never dequeued. When
  the number of workers is greater than or equal to the minimum and less than
  the maximum, a worker can be dequeued based on the sojourn time of a queue in
  an <code>sbroker</code>, or similar process.</p>
 
  <p>Before commencing work a worker calls <code>sregulator:ask/1</code>. If the regulator
  returns a <code>go</code> tuple, i.e. <code>{go, Ref, RegulatorPid, SojournTime}</code>, the
  worker may continue. <code>Ref</code>, the lock reference, and <code>RegulatorPid</code>, the pid
  of the regulator, are used for future communication with the regulator.
  <code>SojournTime</code> is the time spent waiting in the internal queue of the
  regulator process. The regulator may also return a <code>drop</code> tuple, i.e.
  <code>{drop, SojournTime}</code>. This means that work can not begin as a lock was not  
acquired.</p>
 
  <p>The worker uses <code>update/3</code> to report and update the result of an enqueuing
  attempt. For example:
  </p><pre class="sh_erlang">  {go, Ref, Regulator, _} = sregulator:ask(Regulator),
  AskResult = sbroker:ask(Broker),
  AskResult2 = sregulator:update(Regulator, Ref, AskResult).</pre><p>
  In the case of a <code>go</code> or <code>retry</code> tuple the result is unchanged. However for a
  <code>drop</code> tuple the regulator will change the result. The regulator may allow
  the worker to continue working with its current lock and change the <code>drop</code>
  tuple to a <code>retry</code> tuple, e.g. <code>{drop, 100}</code> to <code>{retry, 100}</code>. Or it may
  drop the worker, removing the worker's concurrency lock, by changing the
  <code>drop</code> tuple to a <code>dropped</code> tuple, e.g. <code>{drop, 100}</code> to <code>{dropped, 100}</code>.
  If the lock reference does not exist the <code>drop</code> tuple is changed to a
  <code>not_found</code> tuple, e.g. <code>{drop, 100}</code> to <code>{not_found, 100}</code>.</p>
 
  <p><code>update/3</code> may be used in combination with <code>sbroker:ask/1</code>,
  <code>sbroker:ask_r/1</code>, <code>sregulator:ask/1</code>, <code>sbroker:nb_ask/1</code>,
  <code>sbroker:nb_ask_r/1</code>, <code>sregulator:nb_ask/1</code>, <code>sbroker:await/2</code> and
  <code>sregulator:await/2</code>.</p>
 
  <p>The lock reference can be released using <code>done(Regulator, Ref)</code> or will be  
automatically released when a worker exits.</p>
 
  <p>A regulator requires a callback module. The callback modules implements one
  callback, <code>init/1</code>, with single argument <code>Args</code>. <code>init/1</code> should return
  <code>{ok, {QueueSpec, ValveSpec, Interval})</code> or <code>ignore</code>. <code>QueueSpec</code> is the
  queue specification for the queue and <code>Valve</code> is the valve specification for
  the queue. <code>Interval</code> is the interval in milliseconds that the queue is
  polled. This ensures that the active queue management strategy is applied
  even if no processes are enqueued/dequeued. In the case of <code>ignore</code> the
  regulator is not started and <code>start_link</code> returns <code>ignore</code>.</p>
 
  <p>A queue specification takes the following form:
  <code>{Module, Args, Out, Size, Drop}</code>. <code>Module</code> is the <code>squeue</code> callback module
  and <code>Args</code> are its arguments. The queue is created using
  <code>squeue:new(Module, Arg)</code>. <code>Out</code> defines the method of dequeuing, it is
  either the atom <code>out</code> (dequeue items from the head, i.e. FIFO), or the
  atom <code>out_r</code> (dequeue items from the tail, i.e. LIFO). <code>Size</code> is the maximum
  size of the queue, it is either a <code>non_neg_integer()</code> or <code>infinity</code>. <code>Drop</code>
  defines the strategy to take when the maximum size, <code>Size</code>, of the queue is
  exceeded. It is either the atom <code>drop</code> (drop from the head of the queue, i.e.
  head drop) or <code>drop_r</code> (drop from the tail of the queue, i.e. tail drop)</p>
 
  <p>A valve specification takes the following form:
  <code>{Module, Args, Min, Max}</code>. <code>Module</code> is the <code>svalve</code> callback module and
  <code>Args</code> are its arguments. The valve is created using
  <code>svalve:new(Module, Args)</code>. <code>Min</code> is the minimum desired level of
  concurrency, a <code>non_neg_integer()</code>. <code>Max</code> is the maximum desired level of
  concurrency and is a <code>non_neg_integer()</code> or <code>infinity</code>. The maximum must be  
greater than or equal to the minimum.</p>
 
  <p>For example:</p>
 
  <pre class="sh_erlang">  -module(sregulator_example).
 
  -behaviour(sregulator).
 
  -export([start_link/0]).
  -export([ask/0]).
  -export([done/1]).
  -export([update/2]).
  -export([init/1]).
 
  start_link() -&gt;
      sregulator:start_link({local, ?MODULE}, ?MODULE, []).
 
  ask() -&gt;
      sregulator:ask(?MODULE).
 
  done(Ref) -&gt;
      sregulator:done(?MODULE, Ref).
 
  update(Ref, AskResult) -&gt;
      sregulator:update(?MODULE, Ref, AskResult).
 
  init([]) -&gt;
      QueueSpec = {squeue_timeout, 5000, out_r, infinity, drop},
      ValveSpec = {svalve_codel_r, {5, 100}, 8, 64},
      Interval = 200,
      {ok, {QueueSpec, ValveSpec, Interval}}.</pre></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-name">name() = {local, atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-queue_spec">queue_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out | out_r,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop | drop_r}</h3></div>
    <div class="type"><h3 id="type-regulator">regulator() = pid()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| atom()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {atom(), node()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-start_return">start_return() = {ok, pid()} | {error, any()}</h3></div>
    <div class="type"><h3 id="type-valve_spec">valve_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ask/1">ask(Regulator) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Go = {go, Ref, Pid, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to gain a work lock with the regulator. Returns
  <code>{go, Ref, Pid, SojournTime}</code> on a successfully gaining a lock or
  <code>{drop, SojournTime}</code>.</p>
 
  <p><code>Ref</code> is the lock refernece, which is a <code>reference()</code>. <code>Pid</code> is the <code>pid()</code>
  of the regulator. <code>SojournTime</code> is the time spent in the queue in
  milliseconds.</p>
</div></div>
<div class="function">
<h3 id="nb_ask/1">nb_ask(Regulator) -&gt; Go | Retry</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Go = {go, Ref, Pid, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = 0</code></li><li><code>Retry = {retry, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to gain a work lock with the regulator but does not enqueue the
  request if a lock is not immediately available. Returns
  <code>{go, Ref, Pid, 0}</code> on a successfully gaining a lock or <code>{retry, 0}</code>.</p>
 
  <p><code>Ref</code> is the lock reference, which is a <code>reference()</code>. <code>Pid</code> is the <code>pid()</code>
  of the regulator. <code>0</code> reflects the fact that no time was spent in the queue.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/1">async_ask(Regulator) -&gt; {await, Tag, Process}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = reference()</code></li><li><code>Process = pid() | {atom(), node()}</code></li></ul>
<div class="description">

<p>Monitors the regulator and sends an asynchronous request to gain a work
  lock. Returns <code>{await, Tag, Process}</code>.</p>
 
  <p><code>Tag</code> is a monitor <code>reference()</code> that uniquely identifies the reply
  containing the result of the request. <code>Process</code>, is the pid (<code>pid()</code>) or
  process name (<code>{atom(), node()}</code>) of the monitored regulator. To cancel the
  request call <code>cancel(Process, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, SojournTime}</code> or
  <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  regulator and no guarantee is made of the order of replies. A process making
  multiple requests can reuse the monitor reference for subsequent requests to
  the same regulator process (<code>Process</code>) using <code>async_ask/2</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/2">async_ask(Regulator, Tag) -&gt; {await, Tag, Process}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = any()</code></li><li><code>Process = pid() | {atom(), node()}</code></li></ul>
<div class="description">

<p>Sends an asynchronous request to gain a work lock with the regulator.
  Returns <code>{await, Tag, Process}</code>.</p>
 
  <p><code>Tag</code> is a <code>any()</code> that identifies the reply containing the result of the
  request. <code>Process</code>, is the pid (<code>pid()</code>) or process name (<code>{atom(), node()}</code>)
  of the regulator. To cancel all requests identified by <code>Tag</code> on regulator
  <code>Process</code> call <code>cancel(Process, Tag)</code>.</p>
 
  <p><code>Tag</code> is a monitor <code>reference()</code> that uniquely identifies the reply
  containing the result of the request. <code>Process</code>, is the pid (<code>pid()</code>) or
  process name (<code>{atom(), node()}</code>) of the monitored regulator. To cancel the
  request call <code>cancel(Process, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, SojournTime}</code> or
  <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  regulator and no guarantee is made of the order of replies. If the regulator
  exits or is on a disconnected node there is no guarantee of a reply and so
  the caller should take appropriate steps to handle this scenario.
 </p>
<p><em>See also:</em> <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="await/2">await(Tag, Timeout) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Tag = any()</code></li><li><code>Timeout = timeout()</code></li><li><code>Go = {go, Ref, Pid, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Await the response to an asynchronous request identified by <code>Tag</code>.</p>
 
  <p>Exits if a response is not received after <code>Timeout</code> milliseconds.</p>
 
  <p>Exits if a <code>DOWN</code> message is received with the reference <code>Tag</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#async_ask_r/2" class="seealso">async_ask_r/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cancel/2">cancel(Regulator, Tag) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Tag = any()</code></li></ul>
<div class="description">

<p>Cancels an asynchronous request. Returns the number of cancelled
  requests or <code>false</code> if no requests exist. In the later case a caller may wish
  to check its message queue for an existing reply.
 </p>
<p><em>See also:</em> <a href="#async_ask/1" class="seealso">async_ask/1</a>, <a href="#async_ask/2" class="seealso">async_ask/2</a>.</p>
</div></div>
<div class="function">
<h3 id="done/2">done(Regulator, Ref) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li></ul>
<div class="description">

<p>Release lock, <code>Ref</code>, on regulator <code>Regulator</code>. Returns <code>ok</code> on success
  and <code>{error, not_found}</code> if the lock reference does not exist on the
  regulator.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="update/3">update(Regulator, Ref, Response) -&gt; Response</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li><li><code>Response = {go, Ref2, Pid, SojournTime} | {retry, SojournTime}</code></li><li><code>Ref2 = reference()</code></li><li><code>Pid = pid()</code></li><li><code>SojournTime = non_neg_integer()</code></li></ul>
<div class="description">

<p>Report the queue response and update the status of the lock. Returns
  <code>Response</code> if it is of the form <code>{go, Ref, Pid, SojournTime}</code> or
  <code>{retry, SojournTime}</code>. If <code>Response</code> is of the form <code>{drop, SojournTime}</code>
  returns either <code>{dropped, SojournTime}</code> if the lock is lost due to being
  dropped, <code>{retry, SojournTime}</code> if the lock is maintained. or
  <code>{not_found, SojournTime}</code> if the lock does not exist on the regulator.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="drop/2">drop(Regulator, Ref) -&gt; ok | {error, retry | not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li></ul>
<div class="description">

<p>Signal a drop. Returns <code>ok</code> if the lock is released, <code>{error, retry}</code> if
  the lock is maintained and <code>{error, not_found}</code> if the lock does not exist on  
the regulator.</p>
 
  <p>This function can be used to signal to the regulator that an event has
  occured that should shrink the level of concurrency. For example a connection
  process that fails to connect to a remote server may call <code>drop/2</code> so that
  the concurrency level decreases when the remote server is unavailable.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="ensure_dropped/2">ensure_dropped(Regulator, Ref) -&gt; ok | {error, not_found}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Ref = reference()</code></li></ul>
<div class="description">

<p>Signal a drop and release the lock. Returns <code>ok</code> if the lock is
  released and <code>{error, not_found}</code> if the lock does not exist on the  
regulator.</p>
 
  <p>Unlike <code>drop/2</code> the lock is always released if it exists.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>, <a href="#drop/2" class="seealso">drop/2</a>.</p>
</div></div>
<div class="function">
<h3 id="change_config/2">change_config(Regulator, Timeout) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Change the configuration of the regulator. Returns <code>ok</code> on success and
  <code>{error, Reason}</code> on failure, where <code>Reason</code>, is the reason for failure.</p>
 
  <p>Regulator calls the <code>init/1</code> callback to get the new configuration. If
  <code>init/1</code> returns <code>ignore</code> the config does not change.
 </p>
<p><em>See also:</em> <a href="#start_link/2" class="seealso">start_link/2</a>.</p>
</div></div>
<div class="function">
<h3 id="len/2">len(Regulator, Timeout) -&gt; Length</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Length = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the length of the queue in the regulator, <code>Regulator</code>.</p>
</div></div>
<div class="function">
<h3 id="size/2">size(Regulator, Timeout) -&gt; Size</h3>

<ul class="type">
<li><code>Regulator = regulator()</code></li><li><code>Timeout = timeout()</code></li><li><code>Size = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the number of active process using the regulator, <code>Regulator</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/2">start_link(Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a regulator with callback module <code>Module</code> and argument <code>Args</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/3">start_link(Name, Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Name = name()</code></li><li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a regulator with name <code>Name</code>, callback module <code>Module</code> and
  argument <code>Args</code>.
 </p>
<p><em>See also:</em> <a href="#start_link/2" class="seealso">start_link/2</a>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
