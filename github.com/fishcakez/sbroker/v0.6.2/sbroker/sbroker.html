<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sbroker (sbroker) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sbroker</h1>
<h2 class="modsummary">
  This module provides a process match making service.</h2>
<div class="description">
<p>
  This module provides a process match making service. A process joins one of
  two queues and is matcheid with a process in the other queue. The queues can
  be actively managed using an <code>squeue</code> callback module, and passively managed  
using head or tail drop. A different strategy can be used for both queues.  
Processes that die while in a queue are automatically removed to prevent  
matching with a process that is nolonger alive.</p>
 
  <p>There are two functions to join a queue: <code>ask/1</code> and <code>ask_r/1</code>. Processes
  that call <code>ask/1</code> are matched against processes that call <code>ask_r/1</code>. If no  
match is immediately avaliable a process is queued in the relevant queue  
until a match becomes avaliable. If queue management is used processes may be  
dropped without a match.</p>
 
  <p>Processes calling <code>ask/1</code> try to match with/dequeue a process in the <code>ask_r</code>
  queue. If no process exists they are queued in the <code>ask</code> queue and await a
  process to call <code>ask_r/1</code>.</p>
 
  <p>Similarly processes calling <code>ask_r/1</code> try to match with/dequeue a process
  in the <code>ask</code> queue. If no process exists they are queued in the <code>ask_r</code> queue
  and await a process to call <code>ask/1</code>.</p>
 
  <p>A broker requires a callback module. The callback modules implements one
  callback, <code>init/1</code>, with single argument <code>Args</code>. <code>init/1</code> should return
  <code>{ok, {AskQueueSpec, AskRQueueSpec, Interval})</code> or <code>ignore</code>. <code>AskQueuSpec</code> is
  the queue specification for the <code>ask</code> queue and <code>AskRQueueSpec</code> is the queue
  specification for the <code>ask_r</code> queue. <code>Interval</code> is the interval in
  milliseconds that the active queue is polled. This ensures that the active
  queue management strategy is applied even if no processes are
  enqueued/dequeued. In the case of <code>ignore</code> the broker is not started and
  <code>start_link</code> returns <code>ignore</code>.</p>
 
  <p>A queue specifcation takes the following form:
  <code>{Module, Args, Out, Size, Drop}</code>. <code>Module</code> is the <code>squeue</code> callback module
  and <code>Args</code> are its arguments. The queue is created using
  <code>squeue:new(Time, Module, Args)</code>, where <code>Time</code> is chte current time in
  <code>native</code> time units. <code>Out</code> defines the method of dequeuing, it is either the
  atom <code>out</code> (dequeue items from the head, i.e. FIFO), or the atom <code>out_r</code>
  (dequeue items from the tail, i.e. LIFO). <code>Size</code> is the maximum size of the
  queue, it is either a <code>non_neg_integer()</code> or <code>infinity</code>. <code>Drop</code> defines the
  strategy to take when the maximum size, <code>Size</code>, of the queue is exceeded. It
  is either the atom <code>drop</code> (drop from the head of the queue, i.e. head drop)
  or <code>drop_r</code> (drop from the tail of the queue, i.e. tail drop).</p>
 
  <p>For example:</p>
 
  <pre class="sh_erlang">  -module(sbroker_example).
 
  -behaviour(sbroker).
 
  -export([start_link/0]).
  -export([ask/0]).
  -export([ask_r/1]).
  -export([init/1]).
 
  start_link() -&gt;
      sbroker:start_link({local, ?MODULE}, ?MODULE, []).
 
  ask() -&gt;
      sbroker:ask(?MODULE).
 
  ask_r() -&gt;
      sbroker:ask_r(?MODULE).
 
  init([]) -&gt;
      AskQueueSpec = {squeue_codel, {5, 100}, out, 64, drop},
      AskRQueueSpec = {squeue_timeout, 5000, out_r, infinity, drop},
      Interval = 200,
      {ok, {AskQueueSpec, AskRQueueSpec, Interval}}.</pre></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-broker">broker() = pid()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| atom()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {atom(), node()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-name">name() = {local, atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {global, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {via, module(), any()}</h3></div>
    <div class="type"><h3 id="type-queue_spec">queue_spec() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{module(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out | out_r,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer() >= 0 | infinity,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drop | drop_r}</h3></div>
    <div class="type"><h3 id="type-start_return">start_return() = {ok, pid()} | ignore | {error, any()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="ask/1">ask(Broker) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = integer()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to match with a process calling <code>ask_r/1</code> on the same broker.
  Returns <code>{go, Ref, Pid, RelativeTime, SojournTime}</code> on a successful match
  or <code>{drop, SojournTime}</code>.</p>
 
  <p><code>Ref</code> is the transaction reference, which is a <code>reference()</code>. <code>Pid</code> is the
  matched process. <code>RelativeTime</code> is the time (in <code>native</code> time units) spent
  waiting for a match after discounting time spent waiting for the broker to
  handle requests. <code>SojournTime</code> is the time spent in both the broker's message
  queue and internal queue, in <code>native</code> time units.</p>
 
  <p><code>RelativeTime</code> represents the <code>SojournTime</code> without the overhead of the  
broker. The value measures the level of queue congestion without being  
effected by the load of the broker.</p>
 
  <p>If <code>RelativeTime</code> is positive, the request was enqueued in the internal
  queue awaiting a match with another request sent approximately <code>RelativeTime</code>
  after this request was sent. Therefore <code>SojournTime</code> minus <code>RelativeTime</code>
  is the latency, or overhead, of the broker in <code>native</code> time units.</p>
 
  <p>If <code>RelativeTime</code> is negative, the request dequeued a request in the internal
  queue that was sent approximately <code>RelativeTime</code> before this request was
  sent. Therefore <code>SojournTime</code> is the latency, or overhead, of the broker in
  <code>native</code> time units.</p>
 
  <p>If <code>RelativeTime</code> is <code>0</code>, the request was matched with a request sent at
  approximately the same time. Therefore <code>SojournTime</code> is the latency, or
  overhead, of the broker in <code>native</code> time units.</p>
 
  <p>The sojourn time for <code>Pid</code> (in <code>native</code> time units) can be approximated by
  <code>SojournTime</code> minus <code>RelativeTime</code>.</p>
</div></div>
<div class="function">
<h3 id="ask_r/1">ask_r(Broker) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = integer()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to match with a process calling <code>ask/1</code> on the same broker.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="nb_ask/1">nb_ask(Broker) -&gt; Go | Retry</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = 0 | neg_integer()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Retry = {retry, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to match with a process calling <code>ask_r/1</code> on the same broker but
  does not enqueue the request if no immediate match. Returns
  <code>{go, Ref, Pid, RelativeTime, SojournTime}</code> on a successful match or
  <code>{retry, SojournTime}</code>.</p>
 
  <p><code>Ref</code> is the transaction reference, which is a <code>reference()</code>. <code>Pid</code> is the
  matched process. <code>RelativeTime</code> is the time (in <code>native</code> time units) spent
  waiting for a match after discounting time spent waiting for the broker to
  handle requests. <code>SojournTime</code> is the time spent in the broker's message
  queue in <code>native</code> time units.
 </p>
<p><em>See also:</em> <a href="#ask/1" class="seealso">ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="nb_ask_r/1">nb_ask_r(Broker) -&gt; Go | Retry</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = 0 | neg_integer()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Retry = {retry, SojournTime}</code></li></ul>
<div class="description">

<p>Tries to match with a process calling <code>ask/1</code> on the same broker but
  does not enqueue the request if no immediate match.
 </p>
<p><em>See also:</em> <a href="#nb_ask/1" class="seealso">nb_ask/1</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/1">async_ask(Broker) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Tag = reference()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Monitors the broker and sends an asynchronous request to match with a
  process calling <code>ask_r/1</code>. Returns <code>{await, Tag, Pid}</code>.</p>
 
  <p><code>Tag</code> is a monitor <code>reference()</code> that uniquely identifies the reply
  containing the result of the request. <code>Pid</code>, is the pid (<code>pid()</code>) of the
  monitored broker. To cancel the request call <code>cancel(Pid, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, RelativeTime, SojournTime}</code>
  or <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  broker and no guarantee is made of the order of replies. A process making
  multiple requests can reuse the monitor reference for subsequent requests to
  the same broker process (<code>Process</code>) using <code>async_ask/2</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask/2">async_ask(Broker, Tag) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Tag = any()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Sends an asynchronous request to match with a process calling <code>ask_r/1</code>.
  Returns <code>{await, Tag, Pid}</code>.</p>
 
  <p><code>Tag</code> is a <code>any()</code> that identifies the reply containing the result of the
  request. <code>Pid</code>, is the pid (<code>pid()</code>) of the broker. To cancel all requests
  identified by <code>Tag</code> on broker <code>Pid</code> call <code>cancel(Pid, Tag)</code>.</p>
 
  <p>The reply is of the form <code>{Tag, {go, Ref, Pid, RelativeTime, SojournTime}</code> or
  <code>{Tag, {drop, SojournTime}}</code>.</p>
 
  <p>Multiple asynchronous requests can be made from a single process to a
  broker and no guarantee is made of the order of replies. If the broker
  exits or is on a disconnected node there is no guarantee of a reply and so
  the caller should take appropriate steps to handle this scenario.
 </p>
<p><em>See also:</em> <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask_r/1">async_ask_r(Broker) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Tag = reference()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Monitors the broker and sends an asynchronous request to match with a
  process calling <code>ask/1</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/1" class="seealso">async_ask/1</a>, <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="async_ask_r/2">async_ask_r(Broker, Tag) -&gt; {await, Tag, Pid}</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Tag = any()</code></li><li><code>Pid = pid()</code></li></ul>
<div class="description">

<p>Sends an asynchronous request to match with a process calling <code>ask/1</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#cancel/2" class="seealso">cancel/2</a>.</p>
</div></div>
<div class="function">
<h3 id="await/2">await(Tag, Timeout) -&gt; Go | Drop</h3>

<ul class="type">
<li><code>Tag = any()</code></li><li><code>Timeout = timeout()</code></li><li><code>Go = {go, Ref, Pid, RelativeTime, SojournTime}</code></li><li><code>Ref = reference()</code></li><li><code>Pid = pid()</code></li><li><code>RelativeTime = integer()</code></li><li><code>SojournTime = non_neg_integer()</code></li><li><code>Drop = {drop, SojournTime}</code></li></ul>
<div class="description">

<p>Await the response to an asynchronous request identified by <code>Tag</code>.</p>
 
  <p>Exits if a response is not received after <code>Timeout</code> milliseconds.</p>
 
  <p>Exits if a <code>DOWN</code> message is received with the reference <code>Tag</code>.
 </p>
<p><em>See also:</em> <a href="#async_ask/2" class="seealso">async_ask/2</a>, <a href="#async_ask_r/2" class="seealso">async_ask_r/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cancel/3">cancel(Broker, Tag, Timeout) -&gt; Count | false</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Tag = any()</code></li><li><code>Timeout = timeout()</code></li><li><code>Count = pos_integer()</code></li></ul>
<div class="description">

<p>Cancels an asynchronous request. Returns the number of cancelled
  requests or <code>false</code> if no requests exist. In the later case a caller may wish
  to check its message queue for an existing reply.
 </p>
<p><em>See also:</em> <a href="#async_ask/1" class="seealso">async_ask/1</a>, <a href="#async_ask_r/1" class="seealso">async_ask_r/1</a>.</p>
</div></div>
<div class="function">
<h3 id="change_config/2">change_config(Broker, Timeout) -&gt; ok | {error, Reason}</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Timeout = timeout()</code></li><li><code>Reason = any()</code></li></ul>
<div class="description">

<p>Change the configuration of the broker. Returns <code>ok</code> on success and
  <code>{error, Reason}</code> on failure, where <code>Reason</code>, is the reason for failure.</p>
 
  <p>Broker calls the <code>init/1</code> callback to get the new configuration. If <code>init/1</code>
  returns <code>ignore</code> the config does not change.</p>
</div></div>
<div class="function">
<h3 id="len/2">len(Broker, Timeout) -&gt; Length</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Timeout = timeout()</code></li><li><code>Length = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the length of the <code>ask</code> queue in the broker, <code>Broker</code>.</p>
</div></div>
<div class="function">
<h3 id="len_r/2">len_r(Broker, Timeout) -&gt; Length</h3>

<ul class="type">
<li><code>Broker = broker()</code></li><li><code>Timeout = timeout()</code></li><li><code>Length = non_neg_integer()</code></li></ul>
<div class="description">

<p>Get the length of the <code>ask_r</code> queue in the broker, <code>Broker</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/2">start_link(Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a broker with callback module <code>Module</code> and argument <code>Args</code>.</p>
</div></div>
<div class="function">
<h3 id="start_link/3">start_link(Name, Module, Args) -&gt; StartReturn</h3>

<ul class="type">
<li><code>Name = name()</code></li><li><code>Module = module()</code></li><li><code>Args = any()</code></li><li><code>StartReturn = start_return()</code></li></ul>
<div class="description">

<p>Starts a broker with name <code>Name</code>, callback module <code>Module</code> and argument
  <code>Args</code>.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
