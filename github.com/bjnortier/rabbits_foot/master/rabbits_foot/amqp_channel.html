<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>amqp_channel (rabbits_foot) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>amqp_channel</h1>
<h2 class="modsummary">This module encapsulates the client's view of an AMQP
  channel.</h2>
<div class="description">
<p>This module encapsulates the client's view of an AMQP
  channel. Each server side channel is represented by an amqp_channel
  process on the client side. Channel processes are created using the
  <url href="/home/pete/wefwefwef/docs/other/6099319920/repo/master/.xml/rabbits_foot/./amqp_connection.xml">amqp_connection</url> module. Channel processes are supervised
  under amqp_client's supervision tree.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-amqp_method">amqp_method()</h3></div>
    <div class="type"><h3 id="type-amqp_msg">amqp_msg() = #amqp_msg{}</h3></div>
    <div class="type"><h3 id="type-consume">consume() = #'basic.consume'{}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="call/2">call(Channel, Method) -&gt; Result</h3>


<div class="description">

<p>This is equivalent to amqp_channel:call(Channel, Method, none).</p>
</div></div>
<div class="function">
<h3 id="call/3">call(Channel, Method, Content) -&gt; Result</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Method = amqp_method()</code></li><li><code>Content = amqp_msg() | none</code></li><li><code>Result = amqp_method() | ok | blocked | closing</code></li></ul>
<div class="description">

<p>This sends an AMQP method on the channel.
  For content bearing methods, Content has to be an amqp_msg(), whereas
  for non-content bearing methods, it needs to be the atom 'none'.<br />
  In the case of synchronous methods, this function blocks until the
  corresponding reply comes back from the server and returns it.
  In the case of asynchronous methods, the function blocks until the method
  gets sent on the wire and returns the atom 'ok' on success.<br />
  This will return the atom 'blocked' if the server has
  throttled the  client for flow control reasons. This will return the
  atom 'closing' if the channel is in the process of shutting down.<br />
  Note that for asynchronous methods, the synchronicity implied by
  'call' only means that the client has transmitted the method to
  the broker. It does not necessarily imply that the broker has
  accepted responsibility for the message.</p>
</div></div>
<div class="function">
<h3 id="cast/2">cast(Channel, Method) -&gt; ok</h3>


<div class="description">

<p>This is equivalent to amqp_channel:cast(Channel, Method, none).</p>
</div></div>
<div class="function">
<h3 id="cast/3">cast(Channel, Method, Content) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Method = amqp_method()</code></li><li><code>Content = amqp_msg() | none</code></li></ul>
<div class="description">

<p>This function is the same as <a href="#call/3" class="seealso">call/3</a>, except that it returns
  immediately with the atom 'ok', without blocking the caller process.
  This function is not recommended with synchronous methods, since there is no
  way to verify that the server has received the method.</p>
</div></div>
<div class="function">
<h3 id="close/1">close(Channel) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Closes the channel, invokes
  close(Channel, 200, &lt;&lt;"Goodbye"&gt;&gt;).</p>
</div></div>
<div class="function">
<h3 id="close/3">close(Channel, Code, Text) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Code = integer()</code></li><li><code>Text = binary()</code></li></ul>
<div class="description">

<p>Closes the channel, allowing the caller to supply a reply code and
  text.</p>
</div></div>
<div class="function">
<h3 id="subscribe/2">subscribe(Channel, BasicConsume::consume(), Consumer) -&gt; amqp_method()</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Consumer = pid()</code></li></ul>
<div class="description">

<p>Creates a subscription to a queue. This subscribes a consumer pid to
  the queue defined in the #'basic.consume'{} method record. Note that
  both the process invoking this method and the supplied consumer process
  receive an acknowledgement of the subscription. The calling process will
  receive the acknowledgement as the return value of this function, whereas
  the consumer process will receive the notification asynchronously.</p>
</div></div>
<div class="function">
<h3 id="register_return_handler/2">register_return_handler(Channel, ReturnHandler) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>ReturnHandler = pid()</code></li></ul>
<div class="description">

<p>This registers a handler to deal with returned messages. The
  registered process will receive #basic.return{} records.</p>
</div></div>
<div class="function">
<h3 id="register_flow_handler/2">register_flow_handler(Channel, FlowHandler) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>FlowHandler = pid()</code></li></ul>
<div class="description">

<p>This registers a handler to deal with channel flow notifications.
  The registered process will receive #channel.flow{} records.</p>
</div></div>
<div class="function">
<h3 id="register_default_consumer/2">register_default_consumer(Channel, Consumer) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Consumer = pid()</code></li></ul>
<div class="description">

<p>Set the current default consumer.
  Under certain circumstances it is possible for a channel to receive a
  message delivery which does not match any consumer which is currently
  set up via basic.consume. This will occur after the following sequence
  of events:<br />
  <br />
  basic.consume with explicit acks<br />
  %% some deliveries take place but are not acked<br />
  basic.cancel<br />
  basic.recover{requeue = false}<br />
  <br />
  Since requeue is specified to be false in the basic.recover, the spec
  states that the message must be redelivered to "the original recipient"
  - i.e. the same channel / consumer-tag. But the consumer is no longer
  active.<br />
  In these circumstances, you can register a default consumer to handle
  such deliveries. If no default consumer is registered then the channel
  will exit on receiving such a delivery.<br />
  Most people will not need to use this.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
