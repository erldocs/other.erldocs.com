<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cowboy_static (cowboy) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>cowboy_static</h1>
<h2 class="modsummary">Static resource handler.</h2>
<div class="description">
<p>Static resource handler.</p>
 
  <p>This built in HTTP handler provides a simple file serving capability for  
cowboy applications. It should be considered an experimental feature because  
of it's dependency on the experimental REST handler. It's recommended to be  
used for small or temporary environments where it is not preferrable to set  
up a second server just to serve files.</p>
 
  <p>If this handler is used the Erlang node running the cowboy application must
  be configured to use an async thread pool. This is configured by adding the
  <code>+A $POOL_SIZE</code> argument to the <code>erl</code> command used to start the node. See
  <url href="http://erlang.org/pipermail/erlang-bugs/2012-January/002720.html">
  this reply</url> from the OTP team to erlang-bugs</p>
 
  <p><em><marker id="Base_configuration">Base configuration</marker></em></p>
 
  <p>The handler must be configured with a request path prefix to serve files
  under and the path to a directory to read files from. The request path prefix
  is defined in the path pattern of the cowboy dispatch rule for the handler.
  The request path pattern must end with a <code>...</code> token.  
The directory path can be set to either an absolute or relative path in the  
form of a list or binary string representation of a file system path. A list  
of binary path segments, as is used throughout cowboy, is also a valid  
directory path.</p>
 
  <p>The directory path can also be set to a relative path within the <code>priv/</code>
  directory of an application. This is configured by setting the value of the
  directory option to a tuple of the form <code>{priv_dir, Application, Relpath}</code>.</p>
 
  <p><em><marker id="Examples">Examples</marker></em>
  </p><pre class="sh_erlang">  %% Serve files from /var/www/ under http://example.com/static/
  {[&lt;&lt;"static"&gt;&gt;, '...'], cowboy_static,
      [{directory, "/var/www"}]}
 
  %% Serve files from the current working directory under http://example.com/static/
  {[&lt;&lt;"static"&gt;&gt;, '...'], cowboy_static,
      [{directory, &lt;&lt;"./"&gt;&gt;}]}
 
  %% Serve files from cowboy/priv/www under http://example.com/
  {['...'], cowboy_static,
      [{directory, {priv_dir, cowboy, [&lt;&lt;"www"&gt;&gt;]}}]}</pre>
 
  <p><em><marker id="Content_type_configuration">Content type configuration</marker></em></p>
 
  <p>By default the content type of all static resources will be set to
  <code>application/octet-stream</code>. This can be overriden by supplying a list
  of filename extension to mimetypes pairs in the <code>mimetypes</code> option.
  The filename extension should be a binary string including the leading dot.
  The mimetypes must be of a type that the <code>cowboy_rest</code> protocol can  
handle.</p>
 
  <p>The <a href="../https///github.com/spawngrid/mimetypes.html" class="seealso">spawngrid/mimetypes</a>  
application, or an arbitrary function accepting the path to the file being  
served, can also be used to generate the list of content types for a static  
file resource. The function used must accept an additional argument after  
the file path argument.</p>
 
  <p><em><marker id="Example">Example</marker></em>
  </p><pre class="sh_erlang">  %% Use a static list of content types.
  {[&lt;&lt;"static"&gt;&gt;, '...'], cowboy_static,
      [{directory, {priv_dir, cowboy, []}},
       {mimetypes, [
           {&lt;&lt;".css"&gt;&gt;, [&lt;&lt;"text/css"&gt;&gt;]},
           {&lt;&lt;".js"&gt;&gt;, [&lt;&lt;"application/javascript"&gt;&gt;]}]}]}
 
  %% Use the default database in the mimetypes application.
  {[&lt;&lt;"static"&gt;&gt;, '...', cowboy_static,
      [{directory, {priv_dir, cowboy, []}},
       {mimetypes, {fun mimetypes:path_to_mimes/2, default}}]]}</pre>
 
  <p><em><marker id="ETag_Header_Function">ETag Header Function</marker></em></p>
 
  <p>The default behaviour of the static file handler is to not generate ETag  
headers. This is because generating ETag headers based on file metadata  
causes different servers in a cluster to generate different ETag values for  
the same file unless the metadata is also synced. Generating strong ETags  
based on the contents of a file is currently out of scope for this module.</p>
 
  <p>The default behaviour can be overridden to generate an ETag header based on
  a combination of the file path, file size, inode and mtime values. If the
  option value is a non-empty list of attribute names tagged with <code>attributes</code>  
a hex encoded checksum of each attribute specified is included in the value  
of the the ETag header. If the list of attribute names is empty no ETag  
header is generated.</p>
 
  <p>If a strong ETag is required a user defined function for generating the
  header value can be supplied. The function must accept a proplist of the
  file attributes as the first argument and a second argument containing any
  additional data that the function requires. The function must return a term
  of the type <code>{weak | strong, binary()}</code> or <code>undefined</code>.</p>
 
  <p><em><marker id="Examples">Examples</marker></em>
  </p><pre class="sh_erlang">  %% A value of default is equal to not specifying the option.
  {[&lt;&lt;"static"&gt;&gt;, '...', cowboy_static,
      [{directory, {priv_dir, cowboy, []}},
       {etag, default}]]}
 
  %% Use all avaliable ETag function arguments to generate a header value.
  {[&lt;&lt;"static"&gt;&gt;, '...', cowboy_static,
      [{directory, {priv_dir, cowboy, []}},
       {etag, {attributes, [filepath, filesize, inode, mtime]}}]]}
 
  %% Use a user defined function to generate a strong ETag header value.
  {[&lt;&lt;"static"&gt;&gt;, '...', cowboy_static,
      [{directory, {priv_dir, cowboy, []}},
       {etag, {fun generate_strong_etag/2, strong_etag_extra}}]]}
 
  generate_strong_etag(Arguments, strong_etag_extra) -&gt;
      {_, Filepath} = lists:keyfind(filepath, 1, Arguments),
      {_, _Filesize} = lists:keyfind(filesize, 1, Arguments),
      {_, _INode} = lists:keyfind(inode, 1, Arguments),
      {_, _Modified} = lists:keyfind(mtime, 1, Arguments),
      ChecksumCommand = lists:flatten(io_lib:format("sha1sum ~s", [Filepath])),
      [Checksum|_] = string:tokens(os:cmd(ChecksumCommand), " "),
      {strong, iolist_to_binary(Checksum)}.</pre>
 
  <p><em><marker id="File_configuration">File configuration</marker></em></p>
 
  <p>If the file system path being served does not share a common suffix with
  the request path it is possible to override the file path using the <code>file</code>
  option. The value of this option is expected to be a relative path within
  the static file directory specified using the <code>directory</code> option.  
The path must be in the form of a list or binary string representation of a  
file system path. A list of binary path segments, as is used throughout  
cowboy, is also a valid.</p>
 
  <p>When the <code>file</code> option is used the same file will be served for all requests
  matching the cowboy dispatch fule for the handler. It is not necessary to
  end the request path pattern with a <code>...</code> token because the request path  
will not be used to determine which file to serve from the static directory.</p>
 
  <p><em><marker id="Examples">Examples</marker></em></p>
 
  <pre class="sh_erlang">  %% Serve cowboy/priv/www/index.html as http://example.com/
  {[], cowboy_static,
      [{directory, {priv_dir, cowboy, [&lt;&lt;"www"&gt;&gt;]}}
       {file, &lt;&lt;"index.html"&gt;&gt;}]}
 
  %% Serve cowboy/priv/www/page.html under http://example.com/*/page
  {['*', &lt;&lt;"page"&gt;&gt;], cowboy_static,
      [{directory, {priv_dir, cowboy, [&lt;&lt;"www"&gt;&gt;]}}
       {file, &lt;&lt;"page.html"&gt;&gt;}]}.
 
  %% Always serve cowboy/priv/www/other.html under http://example.com/other
  {[&lt;&lt;"other"&gt;&gt;, '...'], cowboy_static,
      [{directory, {priv_dir, cowboy, [&lt;&lt;"www"&gt;&gt;]}}
       {file, "other.html"}]}</pre></div>


<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
