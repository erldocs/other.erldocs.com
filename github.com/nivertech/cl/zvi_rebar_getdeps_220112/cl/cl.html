<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cl (cl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>cl</h1>
<h2 class="modsummary">The erlang api for OpenCL.</h2>
<div class="description">
<p>The erlang api for <url href="http://www.khronos.org/opencl/">OpenCL</url>.</p>
 
  <p>OpenCL (Open Computing Language) is an open royalty-free standard  
for general purpose parallel programming across CPUs, GPUs and  
other processors, giving software developers portable and efficient  
access to the power of these heterogeneous processing platforms.</p>
 
  <p>OpenCL supports a wide range of applications, ranging from embedded  
and consumer software to HPC solutions, through a low-level,  
high-performance, portable abstraction. By creating an efficient,  
close-to-the-metal programming interface, OpenCL will form the  
foundation layer of a parallel computing ecosystem of  
platform-independent tools, middleware and applications.</p>
 
  <p>OpenCL consists of an API for coordinating parallel computation  
across heterogeneous processors; and a cross-platform programming  
language with a well-specified computation environment. The OpenCL  
standard:</p>
 
  <p><item><p> Supports both data- and task-based parallel programming models</p></item>
  <item><p> Utilizes a subset of ISO C99 with extensions for parallelism </p></item>
  <item><p> Defines consistent numerical requirements based on IEEE 754</p></item>
  <item><p> Defines a configuration profile for handheld and embedded devices</p></item>
  <item><p> Efficiently interoperates with OpenGL, OpenGL ES, and other graphics APIs</p></item></p>
 
  <p>The specification is divided into a core specification that any  
OpenCL compliant implementation must support; a handheld/embedded  
profile which relaxes the OpenCL compliance requirements for  
handheld and embedded devices; and a set of optional extensions  
that are likely to move into the core specification in later  
revisions of the OpenCL specification.</p>
 
  <p>The documentation is re-used with the following copyright:</p>
 
  <p>Copyright Â© 2007-2009 The Khronos Group Inc. Permission is hereby
  granted, free of charge, to any person obtaining a copy of this
  software and/or associated documentation files (the "Materials"),
  to deal in the Materials without restriction, including without
  limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Materials, and to
  permit persons to whom the Materials are furnished to do so,
  subject to the condition that this copyright notice and permission
  notice shall be included in all copies or substantial portions of
  the Materials.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-cl_addressing_mode">cl_addressing_mode() = {none | clamp_to_edge | clamp | repeat}</h3></div>
    <div class="type"><h3 id="type-cl_char">cl_char() = integer()</h3></div>
    <div class="type"><h3 id="type-cl_context">cl_context() = {{object, 3, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_context_info">cl_context_info() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{reference_count, <a href="#type-cl_uint" class="seealso">cl_uint()</a>} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{devices, [<a href="#type-cl_device_id" class="seealso">cl_device_id()</a>]} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{properties, [<a href="#type-cl_int" class="seealso">cl_int()</a>]}}</h3></div>
    <div class="type"><h3 id="type-cl_context_info_key">cl_context_info_key() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{reference_count | devices | properties}</h3></div>
    <div class="type"><h3 id="type-cl_device_id">cl_device_id() = {{object, 2, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_device_info">cl_device_info() = {<a href="#type-cl_device_info_key" class="seealso">cl_device_info_key()</a>, term()}</h3></div>
    <div class="type"><h3 id="type-cl_device_info_key">cl_device_info_key() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{type |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vendor_id |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_compute_units |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_work_item_dimensions |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_work_group_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_work_item_sizes |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_char |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_short |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_int |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_long |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_float |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preferred_vector_width_double |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_clock_frequency |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address_bits |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_read_image_args |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_write_image_args |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_mem_alloc_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image2d_max_width |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image2d_max_height |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image3d_max_width |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image3d_max_height |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image3d_max_depth |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_support |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_parameter_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_samplers |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_base_addr_align |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_data_type_align_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single_fp_config |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_mem_cache_type |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_mem_cacheline_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_mem_cache_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global_mem_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_constant_buffer_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_constant_args |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_mem_type |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_mem_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_correction_support |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiling_timer_resolution |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endian_little |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;available |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compiler_available |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execution_capabilities |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue_properties |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vendor |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver_version |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profile |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extensions |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;platform}</h3></div>
    <div class="type"><h3 id="type-cl_device_type">cl_device_type() = {gpu | cpu | accelerator | all | default}</h3></div>
    <div class="type"><h3 id="type-cl_device_types">cl_device_types() = {<a href="#type-cl_device_type" class="seealso">cl_device_type()</a> | [<a href="#type-cl_device_type" class="seealso">cl_device_type()</a>]}</h3></div>
    <div class="type"><h3 id="type-cl_double">cl_double() = float()</h3></div>
    <div class="type"><h3 id="type-cl_error">cl_error() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{device_not_found |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device_not_available |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compiler_not_available |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_object_allocation_failure |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out_of_resources |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out_of_host_memory |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiling_info_not_available |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_copy_overlap |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_format_mismatch |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image_format_not_supported |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;build_program_failure |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map_failure |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_value |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'invalid_device type' |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_platform |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_device |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_context |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_queue_properties |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_command_queue |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_host_ptr |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_mem_object |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_image_format_descriptor |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_image_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_sampler |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_binary |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_build_options |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_program |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_program_executable |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_kernel_name |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_kernel_definition |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_kernel |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_arg_index |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_arg_value |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_arg_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_kernel_args |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_work_dimension |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_work_group_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'invalid_work_item size' |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_global_offset |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_event_wait_list |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_event |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_operation |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_gl_object |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_buffer_size |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid_mip_level |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unknown}</h3></div>
    <div class="type"><h3 id="type-cl_event">cl_event() = {{object, 9, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_filter_mode">cl_filter_mode() = {nearest | linear}</h3></div>
    <div class="type"><h3 id="type-cl_float">cl_float() = float()</h3></div>
    <div class="type"><h3 id="type-cl_half">cl_half() = float()</h3></div>
    <div class="type"><h3 id="type-cl_int">cl_int() = integer()</h3></div>
    <div class="type"><h3 id="type-cl_kernel">cl_kernel() = {{object, 8, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_kernel_arg">cl_kernel_arg() = integer() | float() | binary()</h3></div>
    <div class="type"><h3 id="type-cl_long">cl_long() = integer()</h3></div>
    <div class="type"><h3 id="type-cl_mem">cl_mem() = {{object, 5, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_mem_flag">cl_mem_flag() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{read_write |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write_only |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_only |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_host_ptr |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alloc_host_ptr |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy_host_ptr}</h3></div>
    <div class="type"><h3 id="type-cl_platform_id">cl_platform_id() = {{object, 1, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_platform_info">cl_platform_info() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{profile, string()} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{version, string()} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{name, string()} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vendor, string()} |<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{extensions, string()}}</h3></div>
    <div class="type"><h3 id="type-cl_platform_info_key">cl_platform_info_key() = {profile | name | vendor | extensions}</h3></div>
    <div class="type"><h3 id="type-cl_program">cl_program() = {{object, 7, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_queue">cl_queue() = {{object, 4, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_queue_property">cl_queue_property() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{out_of_order_exec_mode_enable | profiling_enabled}</h3></div>
    <div class="type"><h3 id="type-cl_sampler">cl_sampler() = {{object, 6, integer() &gt;= 0}}</h3></div>
    <div class="type"><h3 id="type-cl_short">cl_short() = integer()</h3></div>
    <div class="type"><h3 id="type-cl_uchar">cl_uchar() = non_neg_integer()</h3></div>
    <div class="type"><h3 id="type-cl_uint">cl_uint() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-cl_ulong">cl_ulong() = non_neg_integer()</h3></div>
    <div class="type"><h3 id="type-cl_ushort">cl_ushort() = non_neg_integer()</h3></div>
    <div class="type"><h3 id="type-start_arg">start_arg() = {{debug, boolean()}}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start/1">start(Args::[start_arg()]) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Start the OpenCL application
 </p>
</div></div>
<div class="function">
<h3 id="start/0">start() -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Start the OpenCL application
 </p>
</div></div>
<div class="function">
<h3 id="stop/0">stop() -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Stop the OpenCL application
 </p>
</div></div>
<div class="function">
<h3 id="noop/0">noop() -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Run a no operation towards the NIF object. This call can be used
  to messure the call overhead to the NIF objeect.
 </p>
</div></div>
<div class="function">
<h3 id="get_platform_ids/0">get_platform_ids() -&gt; {ok, [cl_platform_id()]} | {error, cl_error()}</h3>


<div class="description">

<p>Obtain the list of platforms available.</p>
</div></div>
<div class="function">
<h3 id="platform_info/0">platform_info() -&gt; [cl_platform_info_keys()]</h3>


<div class="description">

<p>Returns a list of the possible platform info keys.</p>
</div></div>
<div class="function">
<h3 id="get_platform_info/1">get_platform_info(Platform::cl_platform_id(), Info::cl_platform_info_key()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Get specific information about the OpenCL platform.
  </p><taglist>
 
  <dt>name</dt>     <item><p>Platform name string.</p></item>
 
  <dt>vendor</dt>   <item><p>Platform vendor string.</p></item>
 
  <dt>profile</dt>
         <item><p> OpenCL profile string. Returns the profile name         
supported by the implementation. The profile name returned         
can be one of the following strings:</p>
 
         <p>FULL_PROFILE - if the implementation supports the OpenCL         
specification (functionality defined as part of the core         
specification and does not require any extensions to be supported).</p>
 
         <p>EMBEDDED_PROFILE - if the implementation supports the OpenCL
         embedded profile. The embedded profile is defined to be a subset for
         each version of OpenCL.</p></item>
 
  <dt>version</dt>
        <item><p>OpenCL version string. Returns the OpenCL version supported by the implementation.</p></item>
 
  <dt>extensions</dt> <item><p>Returns a space-separated list of extension
  names (the extension names themselves do not contain any spaces)
  supported by the platform. Extensions defined here must be
  supported by all devices associated with this platform. </p></item>
 </taglist>
</div></div>
<div class="function">
<h3 id="get_platform_info/1-1">get_platform_info(Platform::cl_platform_id()) -&gt; {ok, [cl_platform_info()]} | {error, cl_error()}</h3>


<div class="description">

<p>Get all information about the OpenCL platform.</p>
<p><em>See also:</em> <a href="#get_platform_info/2" class="seealso">get_platform_info/2</a>.</p>
</div></div>
<div class="function">
<h3 id="get_device_ids/0">get_device_ids() -&gt; {ok, [cl_device_id()]} | {error, cl_error()}</h3>


<div class="description">
<p>Equivalent to <a href="#get_devive_ids/2" class="seealso">get_devive_ids(0, all)</a>.</p>
</div></div>
<div class="function">
<h3 id="get_device_ids/1">get_device_ids(Platform::cl_platform_id(), Type::cl_device_types()) -&gt; {ok, [cl_device_id()]} | {error, cl_error()}</h3>


<div class="description">

<p>Obtain the list of devices available on a platform.
  </p><taglist> <dt>Platform</dt> <item><p>
 
  Refers to the platform ID returned by <code>get_platform_ids</code> or can be
  NULL. If platform is NULL, the behavior is implementation-defined. </p></item>
 
  <dt>Type</dt> <item><p>
 
  A list that identifies the type of OpenCL device. The
  device_type can be used to query specific OpenCL devices or all
  OpenCL devices available. </p></item>
 
  </taglist><p>
 
   </p><p>get_device_ids/2 may return all or a subset of the actual   
physical devices present in the platform and that match   
device_type.</p>
 
  <p>The application can query specific capabilities of the OpenCL
  device(s) returned by get_device_ids/2. This can be used by the
  application to determine which device(s) to use.
 </p>
</div></div>
<div class="function">
<h3 id="device_info/0">device_info() -&gt; [cl_device_info_key()]</h3>


<div class="description">

<p>Return a list of possible device info queries.</p>
<p><em>See also:</em> <a href="#get_device_info/2" class="seealso">get_device_info/2</a>.</p>
</div></div>
<div class="function">
<h3 id="get_device_info/1">get_device_info(DevID::cl_device_id(), Info::cl_device_info_key()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Get information about an OpenCL device.</p>
 
  <taglist> <dt>'type' </dt> <item><p>The OpenCL device type. Currently
  supported values are one of or a combination of: CL_DEVICE_TYPE_CPU,
  CL_DEVICE_TYPE_GPU, CL_DEVICE_TYPE_ACCELERATOR, or
  CL_DEVICE_TYPE_DEFAULT.</p></item>
 
  <dt>'vendor_id'</dt> <item><p>A unique device vendor identifier. An
  example of a unique device identifier could be the PCIe ID.</p> </item>
 
  <dt>'max_compute_units'</dt> <item><p>The number of parallel compute
  cores on the OpenCL device. The minimum value is 1.</p> </item>
 
  <dt>'max_work_item_dimensions'</dt> <item><p>Maximum dimensions that
  specify the global and local work-item IDs used by the data parallel
  execution model. (@see enqueue_nd_range_kernel/5). The
  minimum value is 3.</p></item>
 
  <dt>'max_work_group_size'</dt> <item><p>Maximum number of
  work-items in a work-group executing a kernel using the data parallel
  execution model. (@see enqueue_nd_range_kernel/5). The minimum value
  is 1.</p> </item>
 
  <dt>'max_work_item_sizes'</dt> <item><p>Maximum number of work-items
  that can be specified in each dimension of the work-group to enqueue_nd_range_kernel/5.</p>
  <p>Returns <c class="varname">n</c> entries, where <c class="varname">n</c> is the value returned by the query for
  CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS. The minimum value is (1, 1,
  1).</p></item>
 
  <dt>'preferred_vector_width_TYPE'</dt> <item><p>Preferred native vector
  width size for built-in scalar types that can be put into vectors. The
  vector width is defined as the number of scalar elements that can be
  stored in the vector.</p> <p>If the <code>cl_khr_fp64</code> extension is
  not supported, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE must return
  0.</p></item>
 
  <dt>'max_clock_frequency'</dt> <item><p>Maximum configured clock
  frequency of the device in MHz.</p>
 
  </item> <dt>'address_bits'</dt> <item><p> The default compute device address
  space size specified as an unsigned integer value in bits. Currently
  supported values are 32 or 64 bits. </p></item>
 
  <dt>'max_read_image_args'</dt> <item><p>Max number of simultaneous
  image objects that can be read by a kernel. The minimum value is 128
  if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.</p></item>
 
  <dt>'max_write_image_args'</dt> <item><p>Max number of
  simultaneous image objects that can be written to by a kernel. The
  minimum value is 8 if CL_DEVICE_IMAGE_SUPPORT is CL_TRUE.</p> </item>
 
  <dt>'max_mem_alloc_size'</dt> <item><p>Max size of memory object
  allocation in bytes. The minimum value is max (1/4th of
  CL_DEVICE_GLOBAL_MEM_SIZE, 128*1024*1024)</p></item>
 
  <dt>'image2d_max_width'</dt> <item><p>Max width of 2D image in
  pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is
  CL_TRUE.</p> </item>
 
  <dt>'image2d_max_height'</dt> <item><p>Max height of 2D image in
  pixels. The minimum value is 8192 if CL_DEVICE_IMAGE_SUPPORT is
  CL_TRUE.</p> </item>
 
  <dt>'image3d_max_width'</dt> <item><p>Max width of 3D image in
  pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is
  CL_TRUE.</p> </item>
 
  <dt>'image3d_max_height'</dt> <item><p>Max height of 3D image in
  pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is
  CL_TRUE.</p> </item>
 
  <dt>'image3d_max_depth'</dt> <item><p>Max depth of 3D image in
  pixels. The minimum value is 2048 if CL_DEVICE_IMAGE_SUPPORT is
  CL_TRUE.</p> </item>
 
  <dt>'image_support'</dt> <item><p>Is CL_TRUE if images are supported by
  the OpenCL device and CL_FALSE otherwise.</p> </item>
 
  <dt>'max_parameter_size'</dt> <item><p>Max size in bytes of the
  arguments that can be passed to a kernel. The minimum value is
  256.</p> </item>
 
  <dt>'max_samplers'</dt> <item><p>Maximum number of samplers that can be
  used in a kernel. The minimum value is 16 if CL_DEVICE_IMAGE_SUPPORT
  is CL_TRUE.</p> </item>
 
  <dt>'mem_base_addr_align'</dt> <item><p>Describes the alignment in bits
  of the base address of any allocated memory object.</p> </item>
 
  <dt>'min_data_type_align_size'</dt> <item><p>The smallest alignment in
  bytes which can be used for any data type.</p> </item>
  <dt>'single_fp_config'</dt> <item><p>Describes single precision
  floating-point capability of the device. This is a bit-field that
  describes one or more of the following values:</p> <p>CL_FP_DENORM -
  denorms are supported</p> <p>CL_FP_INF_NAN - INF and quiet NaNs are
  supported</p> <p>CL_FP_ROUND_TO_NEAREST - round to nearest even
  rounding mode supported</p>
  <p>CL_FP_ROUND_TO_ZERO - round to zero rounding mode supported</p>
  <p>CL_FP_ROUND_TO_INF - round to +ve and -ve infinity rounding modes supported</p>
  <p>CL_FP_FMA - IEEE754-2008 fused multiply-add is supported</p>
  <p>The mandated minimum floating-point capability is CL_FP_ROUND_TO_NEAREST | CL_FP_INF_NAN.</p>
  </item>
 
  <dt>'global_mem_cache_type'</dt> <item><p>Return type:
  cl_device_mem_cache_type</p> <p>Type of global memory cache
  supported. Valid values are: CL_NONE, CL_READ_ONLY_CACHE, and
  CL_READ_WRITE_CACHE.</p> </item>
 
  <dt>'global_mem_cacheline_size'</dt> <item><p>Size of global memory cache line in bytes.</p>
  </item>
 
  <dt>'global_mem_cache_size'</dt> <item><p>Size of global memory cache in bytes.</p>
  </item>
 
  <dt>'global_mem_size'</dt> <item><p>Size of global device memory in bytes.</p>
  </item>
 
  <dt>'max_constant_buffer_size'</dt> <item><p>Max size in bytes of a constant buffer allocation. The minimum value is 64 KB.</p></item>
 
   <dt>'max_constant_args'</dt> <item><p>Max number of arguments
  declared with the <code>__constant</code> qualifier in a kernel. The minimum
  value is 8.</p> </item>
 
  <dt>'local_mem_type'</dt> <item><p>Type of local memory
  supported. This can be set to CL_LOCAL implying dedicated local memory
  storage such as SRAM, or CL_GLOBAL.</p> </item>
 
  <dt>'local_mem_size'</dt> <item><p>Size of local memory arena in
  bytes. The minimum value is 16 KB.</p></item>
 
  <dt>'error_correction_support'</dt> <item><p> Is CL_TRUE if the device
  implements error correction for the memories, caches, registers
  etc. in the device. Is CL_FALSE if the device does not implement error
  correction. This can be a requirement for certain clients of
  OpenCL.</p></item>
 
  <dt>'profiling_timer_resolution'</dt> <item><p>Describes the resolution
  of device timer. This is measured in nanoseconds.</p> </item>
 
  <dt>'endian_little'</dt> <item><p> Is CL_TRUE if the OpenCL device is a
  little endian device and CL_FALSE otherwise.  </p></item>
 
  <dt>'available'</dt> <item><p> Is CL_TRUE if the device is available and
  CL_FALSE if the device is not available.  </p></item>
 
  <dt>'compiler_available'</dt> <item><p> Is CL_FALSE if the implementation
  does not have a compiler available to compile the program source. Is
  CL_TRUE if the compiler is available. This can be CL_FALSE for the
  embededed platform profile only.  </p></item>
 
  <dt>'execution_capabilities'</dt> <item><p>Return type:
  cl_device_exec_capabilities</p> <p>Describes the execution
  capabilities of the device. This is a bit-field that describes one or
  more of the following values:</p> <p>CL_EXEC_KERNEL - The OpenCL
  device can execute OpenCL kernels.</p> <p>CL_EXEC_NATIVE_KERNEL - The
  OpenCL device can execute native kernels.</p> <p>The mandated minimum
  capability is CL_EXEC_KERNEL.</p> </item>
 
  <dt>'queue_properties'</dt> <item><p>Describes the command-queue
  properties supported by the device.  This is a bit-field that
  describes one or more of the following values:</p>
  <p>'out_of_order_exec_mode_enable'</p>
  <p>'profiling_enable'</p> <p>These properties are described in
  the table for create_queue/3 .  The mandated minimum capability is
  'profiling_enable'.</p> </item>
 
  <dt>'name'</dt> <item><p>Device name string.</p> </item>
 
  <dt>'vendor'</dt> <item><p>Vendor name string.</p></item>
 
  <dt>'driver_version'</dt> <item><p>OpenCL software driver version string</p> </item>
 
  <dt>'profile'</dt> <item><p>OpenCL profile string. Returns the profile
  name supported by the device (see note). The profile name returned can
  be one of the following strings:</p>
  <p>FULL_PROFILE - if the device supports the OpenCL specification
  (functionality defined as part of the core
  specification and does not require any extensions
  to be supported).</p> <p>EMBEDDED_PROFILE - if
  the device supports the OpenCL embedded
  profile.</p></item>
 
  <dt>'version'</dt> <item><p>OpenCL version string.</p> </item>
 
  <dt>'extensions' </dt> <item><p>Returns a space separated list of extension names (the extension
  names themselves do not contain any spaces). </p></item>
 
  <dt>'platform' </dt> <item><p>The platform associated with this device.</p> </item>
 
  </taglist>
 
  <p><code>NOTE</code>: CL_DEVICE_PROFILE: The platform profile returns the profile that is
  implemented by the OpenCL framework. If the platform profile
  returned is FULL_PROFILE, the OpenCL framework will support devices
  that are FULL_PROFILE and may also support devices that are
  EMBEDDED_PROFILE. The compiler must be available for all devices
  i.e. CL_DEVICE_COMPILER_AVAILABLE is CL_TRUE. If the platform
  profile returned is EMBEDDED_PROFILE, then devices that are only
  EMBEDDED_PROFILE are supported.</p>
</div></div>
<div class="function">
<h3 id="get_device_info/1-1">get_device_info(Device) -&gt; {ok, [cl_device_info()]} | {error, cl_error()}</h3>


<div class="description">

<p>Get all device info.</p>
<p><em>See also:</em> <a href="#get_device_info/2" class="seealso">get_device_info/2</a>.</p>
</div></div>
<div class="function">
<h3 id="create_context/1">create_context(DeviceList::[cl_device_id()]) -&gt; {ok, cl_context()} | {error, cl_error()}</h3>


<div class="description">

<p>Creates an OpenCL context.</p>
 
  <p>An OpenCL context is created with one or more devices. Contexts are  
used by the OpenCL runtime for managing objects such as  
command-queues, memory, program and kernel objects and for  
executing kernels on one or more devices specified in the context.</p>
 
  <p>NOTE: create_context/1 and create_context_from_type/1 perform an
  implicit retain. This is very helpful for 3rd party libraries,
  which typically get a context passed to them by the
  application. However, it is possible that the application may
  delete the context without informing the library. Allowing
  functions to attach to (i.e. retain) and release a context solves
  the problem of a context being used by a library no longer being
  valid.</p>
</div></div>
<div class="function">
<h3 id="create_context_from_type/1">create_context_from_type(Type::cl_device_types()) -&gt; {ok, cl_context()} | {error, cl_error()}</h3>


<div class="description">

<p>Create an OpenCL context from a device type that identifies the specific device(s) to use.</p>
 
  <p>NOTE:  
create_context_from_type/1 may return all or a subset of the  
actual physical devices present in the platform and that match  
device_type.</p>
 
  <p>create_context/1 and create_context_from_type/1 perform an
  implicit retain. This is very helpful for 3rd party libraries,
  which typically get a context passed to them by the
  application. However, it is possible that the application may
  delete the context without informing the library. Allowing
  functions to attach to (i.e. retain) and release a context solves
  the problem of a context being used by a library no longer being
  valid.</p>
</div></div>
<div class="function">
<h3 id="release_context/1">release_context(Context::cl_context()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Decrement the context reference count.</p>
 
  <p>After the context reference count becomes zero and all the objects
  attached to context (such as memory objects, command-queues) are
  released, the context is deleted.</p>
</div></div>
<div class="function">
<h3 id="retain_context/1">retain_context(Context::cl_context()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Increment the context reference count.</p>
<p><em>See also:</em> <a href="create_context.html" class="seealso">create_context</a>.</p>
</div></div>
<div class="function">
<h3 id="context_info/0">context_info() -&gt; [cl_context_info_key()]</h3>


<div class="description">

<p>List context info queries.</p>
</div></div>
<div class="function">
<h3 id="get_context_info/1">get_context_info(Context::cl_context(), Info::cl_context_info_key()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p> Query information about a context.</p>
 
  <taglist> <dt>reference_count</dt> <item><p> Return the context reference
  count. The reference count returned should be considered
  immediately stale. It is unsuitable for general use in
  applications. This feature is provided for identifying memory
  leaks. </p></item>
 
  <dt>devices</dt> <item><p>Return the list of devices in context.</p></item>
 
  <dt>properties</dt> <item><p>Return the context properties.</p></item>
  </taglist>
</div></div>
<div class="function">
<h3 id="get_context_info/1-1">get_context_info(Context::cl_context()) -&gt; {ok, [cl_context_info()]} | {error, cl_error()}</h3>


<div class="description">

<p>Get all context info.</p>
<p><em>See also:</em> <a href="#get_context_info/2" class="seealso">get_context_info/2</a>.</p>
</div></div>
<div class="function">
<h3 id="create_queue/1">create_queue(Context::cl_context(), Device::cl_device_id(), Properties::[cl_queue_property()]) -&gt; {ok, cl_queue()} | {error, cl_error()}</h3>


<div class="description">

<p>Create a command-queue on a specific device.</p>
 
  <taglist>
  <dt>'out_of_order_exec_mode_enable'</dt> <item><p> Determines
  whether the commands queued in the command-queue are executed
  in-order or out-of-order. If set, the commands in the command-queue
  are executed out-of-order. Otherwise, commands are executed
  in-order.</p></item>
 
  <dt>'profiling_enabled'</dt> <item><p> Enable or disable profiling of
  commands in the command-queue. If set, the profiling of commands is
  enabled. Otherwise profiling of commands is disabled. See
  clGetEventProfilingInfo for more information.
  </p></item>
  </taglist>
 
  <p>The OpenCL functions that are submitted to a command-queue are  
enqueued in the order the calls are made but can be configured to  
execute in-order or out-of-order. The properties argument in  
clCreateCommandQueue can be used to specify the execution order.</p>
 
  <p>If the 'out_of_order_exec_mode_enable' property of a  
command-queue is not set, the commands enqueued to a command-queue  
execute in order. For example, if an application calls  
clEnqueueNDRangeKernel to execute kernel A followed by a  
clEnqueueNDRangeKernel to execute kernel B, the application can  
assume that kernel A finishes first and then kernel B is  
executed. If the memory objects output by kernel A are inputs to  
kernel B then kernel B will see the correct data in memory objects  
produced by execution of kernel A. If the  
'out_of_order_exec_mode_enable' property of a commandqueue  
is set, then there is no guarantee that kernel A will finish before  
kernel B starts execution.</p>
 
  <p>Applications can configure the commands enqueued to a command-queue  
to execute out-of-order by setting the  
'out_of_order_exec_mode_enable' property of the  
command-queue. This can be specified when the command-queue is  
created or can be changed dynamically using  
clCreateCommandQueue. In out-of-order execution mode there is no  
guarantee that the enqueued commands will finish execution in the  
order they were queued. As there is no guarantee that kernels will  
be executed in order, i.e. based on when the clEnqueueNDRangeKernel  
calls are made within a command-queue, it is therefore possible  
that an earlier clEnqueueNDRangeKernel call to execute kernel A  
identified by event A may execute and/or finish later than a  
clEnqueueNDRangeKernel call to execute kernel B which was called by  
the application at a later point in time. To guarantee a specific  
order of execution of kernels, a wait on a particular event (in  
this case event A) can be used. The wait for event A can be  
specified in the event_wait_list argument to clEnqueueNDRangeKernel  
for kernel B.</p>
 
  <p>In addition, a wait for events or a barrier command can be enqueued  
to the command-queue. The wait for events command ensures that  
previously enqueued commands identified by the list of events to  
wait for have finished before the next batch of commands is  
executed. The barrier command ensures that all previously enqueued  
commands in a command-queue have finished execution before the next  
batch of commands is executed.</p>
 
  <p>Similarly, commands to read, write, copy or map memory objects that
  are enqueued after clEnqueueNDRangeKernel, clEnqueueTask or
  clEnqueueNativeKernel commands are not guaranteed to wait for
  kernels scheduled for execution to have completed (if the
  'out_of_order_exec_mode_enable' property is set). To ensure
  correct ordering of commands, the event object returned by
  clEnqueueNDRangeKernel, clEnqueueTask or clEnqueueNativeKernel can
  be used to enqueue a wait for event or a barrier command can be
  enqueued that must complete before reads or writes to the memory
  object(s) occur.</p>
</div></div>
<div class="function">
<h3 id="set_queue_property/1">set_queue_property(Queue::cl_queue(), Properties::[cl_queue_property()], Enable::bool()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Function is deprecated and have been removed.</p>
</div></div>
<div class="function">
<h3 id="release_queue/1">release_queue(Queue::cl_queue()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Decrements the command_queue reference count.</p>
 
  <p>After the command_queue reference count becomes zero and all
  commands queued to command_queue have finished (e.g., kernel
  executions, memory object updates, etc.), the command-queue is
  deleted.</p>
</div></div>
<div class="function">
<h3 id="retain_queue/1">retain_queue(Queue::cl_queue()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Increments the command_queue reference count.</p>
 
   <p>create_queue/3 performs an implicit retain. This is very
   helpful for 3rd party libraries, which typically get a
   command-queue passed to them by the application. However, it is
   possible that the application may delete the command-queue without
   informing the library. Allowing functions to attach to
   (i.e. retain) and release a command-queue solves the problem of a
   command-queue being used by a library no longer being valid.</p>
</div></div>
<div class="function">
<h3 id="queue_info/0">queue_info() -&gt; [queue_info_keys()]</h3>


<div class="description">

<p>Returns the list of possible queue info items.</p>
</div></div>
<div class="function">
<h3 id="get_queue_info/2">get_queue_info(Queue, Info) -&gt; {ok, term()}</h3>


<div class="description">

<p>Return the specified queue info</p>
</div></div>
<div class="function">
<h3 id="get_queue_info/1">get_queue_info(Queue) -&gt; [queue_info_keys()]</h3>


<div class="description">

<p>Returns all queue info.</p>
</div></div>
<div class="function">
<h3 id="create_buffer/1">create_buffer(Context::cl_context(), Flags::cl_mem_flags(), Size::non_neg_integer()) -&gt; {ok, cl_mem()} | {error, cl_error()}</h3>


<div class="description">
<p>Equivalent to <a href="#create_buffer/4" class="seealso">create_buffer(Context, Flags, Size, &lt;&lt;&gt;&gt;)</a>.</p>
</div></div>
<div class="function">
<h3 id="create_buffer/1-1">create_buffer(Context::cl_context(), Flags::[cl_mem_flag()], Size::non_neg_integer(), Data::binary()) -&gt; {ok, cl_mem()} | {error, cl_error()}</h3>


<div class="description">

<p> Creates a buffer object.
 </p>
</div></div>
<div class="function">
<h3 id="release_mem_object/1">release_mem_object(Mem::cl_mem()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p> Decrements the memory object reference count.</p>
 
  <p>After the memobj reference count becomes zero and commands queued
  for execution on a command-queue(s) that use memobj have finished,
  the memory object is deleted.</p>
</div></div>
<div class="function">
<h3 id="retain_mem_object/1">retain_mem_object(Mem::cl_mem()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Increments the memory object reference count.</p>
</div></div>
<div class="function">
<h3 id="mem_object_info/0">mem_object_info() -&gt; [cl_mem_info_keys()]</h3>


<div class="description">

<p>Returns a list of the possible mem info keys.</p>
</div></div>
<div class="function">
<h3 id="get_mem_object_info/1">get_mem_object_info(Mem::cl_mem(), InfoType::cl_mem_info_key()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Used to get <code>InfoType</code> information that is common to all memory objects
  (buffer and image objects).</p>
</div></div>
<div class="function">
<h3 id="get_mem_object_info/1-1">get_mem_object_info(Mem::cl_mem()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Used to get all information that is common to all memory objects
  (buffer and image objects).</p>
</div></div>
<div class="function">
<h3 id="image_info/0">image_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_image_info/2">get_image_info(Mem, Info) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_image_info/1">get_image_info(Mem) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="create_sampler/1">create_sampler(Context::cl_context(), Normalized::boolean(), AddressingMode::cl_addressing_mode(), FilterMode::cl_filter_mode()) -&gt; {ok, cl_sampler()} | {error, cl_error()}</h3>


<div class="description">

<p>Creates a sampler object.</p>
 
   <p>A sampler object describes how to sample an image when the image
   is read in the kernel. The built-in functions to read from an
   image in a kernel take a sampler as an argument. The sampler
   arguments to the image read function can be sampler objects
   created using OpenCL functions and passed as argument values to
   the kernel or can be samplers declared inside a kernel. In this
   section we discuss how sampler objects are created using OpenCL
   functions.</p>
</div></div>
<div class="function">
<h3 id="release_sampler/1">release_sampler(Sampler::cl_sampler()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Decrements the sampler reference count.</p>
 
   <p>The sampler object is deleted after the reference count becomes
   zero and commands queued for execution on a command-queue(s) that
   use sampler have finished.</p>
</div></div>
<div class="function">
<h3 id="retain_sampler/1">retain_sampler(Sampler::cl_sampler()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Increments the sampler reference count.</p>
</div></div>
<div class="function">
<h3 id="sampler_info/0">sampler_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_sampler_info/1">get_sampler_info(Sampler::cl_sampler(), InfoType::cl_sampler_info_type()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Returns <code>InfoType</code> information about the sampler object.</p>
</div></div>
<div class="function">
<h3 id="get_sampler_info/1-1">get_sampler_info(Sampler::cl_sampler()) -&gt; {ok, term()} | {error, cl_error()}</h3>


<div class="description">

<p>Returns all information about the sampler object.</p>
<p><em>See also:</em> <a href="#get_sampler_info/2" class="seealso">get_sampler_info/2</a>.</p>
</div></div>
<div class="function">
<h3 id="create_program_with_source/1">create_program_with_source(Context::cl_context(), Source::iodata()) -&gt; {ok, cl_program()} | {error, cl_error()}</h3>


<div class="description">

<p>Creates a program object for a context,  
and loads the source code specified by the text strings in the  
strings array into the program object.</p>
 
   <p>The devices associated with the program object are the devices associated with context.</p>
</div></div>
<div class="function">
<h3 id="create_program_with_binary/1">create_program_with_binary(Context::cl_context(), DeviceList::[cl_device_id()], BinaryList::[binary()]) -&gt; {ok, cl_program()} | {error, cl_error()}</h3>


<div class="description">

<p> Creates a program object for a context, and loads specified binary data into the program object.</p>
 
  <p>OpenCL allows applications to create a program object using the  
program source or binary and build appropriate program  
executables. This allows applications to determine whether they  
want to use the pre-built offline binary or load and compile the  
program source and use the executable compiled/linked online as the  
program executable. This can be very useful as it allows  
applications to load and build program executables online on its  
first instance for appropriate OpenCL devices in the system. These  
executables can now be queried and cached by the  
application. Future instances of the application launching will no  
longer need to compile and build the program executables. The  
cached executables can be read and loaded by the application, which  
can help significantly reduce the application initialization time.</p>
 
   <p>The binaries and device can be generated by calling:
   <code>
     {ok,P} = cl:create_program_with_source(Context,Source),
     ok = cl:build_program(P, DeviceList, Options),
     {ok,DeviceList} = cl:get_program_info(P, devices),
     {ok,BinaryList} = cl:get_program_info(P, binaries).
   </code>
 </p>
</div></div>
<div class="function">
<h3 id="retain_program/1">retain_program(Program::cl_program()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p> Increments the program reference count.</p>
</div></div>
<div class="function">
<h3 id="release_program/1">release_program(Program::cl_program()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Decrements the program reference count.</p>
 
  <p>The program object is deleted after all kernel objects associated
  with program have been deleted and the program reference count
  becomes zero.</p>
</div></div>
<div class="function">
<h3 id="build_program/1">build_program(Program::cl_program(), DeviceList::[cl_device_id()], Options::string()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Builds (compiles and links) a program executable from the  
program source or binary.</p>
 
  <p>OpenCL allows program executables to be built using the source or the binary.</p>
 
  <p>The build options are categorized as pre-processor options, options  
for math intrinsics, options that control optimization and  
miscellaneous options. This specification defines a standard set of  
options that must be supported by an OpenCL compiler when building  
program executables online or offline. These may be extended by a  
set of vendor- or platform-specific options.</p>
 
  <p><em>Preprocessor Options</em></p><p> These options
  control the OpenCL preprocessor which is run on each program source
  before actual compilation. -D options are processed in the order
  they are given in the options argument to
  <code>build_program/3</code>.</p>
 
  <taglist>
  <dt><span>-D name</span></dt><item><p> Predefine <code>name</code> as a macro, with definition 1.</p></item>
  <dt>-D name=definition</dt><item><p> The contents of <code>definition</code>
  are tokenized and processed as if they appeared during translation phase three in a <code>#define</code>
  directive. In particular, the definition will be truncated by
  embedded newline characters.  </p></item>
  <dt>-I dir</dt><item><p>Add the directory <code>dir</code> to the list of directories to be
  searched for header files.</p> </item></taglist><p>
  <br /></p>
 
  <p><em>Math Intrinsics Options</em> These options control compiler
  behavior regarding floating-point arithmetic. These options trade
  off between speed and correctness.
  </p><taglist><dt>-cl-single-precision-constant</dt><item><p> Treat double
  precision floating-point constant as single precision constant.
  </p></item><dt>-cl-denorms-are-zero</dt><item><p> This option controls
  how single precision and double precision denormalized numbers are
  handled. If specified as a build option, the single precision
  denormalized numbers may be flushed to zero and if the optional
  extension for double precision is supported, double precision
  denormalized numbers may also be flushed to zero. This is intended
  to be a performance hint and the OpenCL compiler can choose not to
  flush denorms to zero if the device supports single precision (or
  double precision) denormalized numbers.  </p><p> This option is
  ignored for single precision numbers if the device does not support
  single precision denormalized numbers i.e. CL_FP_DENORM bit is not
  set in CL_DEVICE_SINGLE_FP_CONFIG.  </p><p> </p><p> This option is
  ignored for double precision numbers if the device does not support
  double precision or if it does support double precison but
  CL_FP_DENORM bit is not set in CL_DEVICE_DOUBLE_FP_CONFIG.  </p><p>
 
  This flag only applies for scalar and vector single precision
  floating-point variables and computations on these floating-point
  variables inside a program. It does not apply to reading from or
  writing to image objects.  </p><p> </p></item></taglist><p><br />
  </p>
 
  <p><em>Optimization Options</em> These options control various
  sorts of optimizations. Turning on optimization flags makes the
  compiler attempt to improve the performance and/or code size at the
  expense of compilation time and possibly the ability to debug the
  program.  </p><taglist><dt>-cl-opt-disable</dt><item><p> This option
  disables all optimizations. The default is optimizations are
  enabled.  </p></item><dt>-cl-strict-aliasing</dt><item><p> This option
  allows the compiler to assume the strictest aliasing rules.
  </p></item></taglist><p>
 </p><p> The following options control compiler
  behavior regarding floating-point arithmetic. These options trade
  off between performance and correctness and must be specifically
  enabled. These options are not turned on by default since it can
  result in incorrect output for programs which depend on an exact
  implementation of IEEE 754 rules/specifications for math functions.
  </p><taglist><dt>-cl-mad-enable</dt><item><p> Allow <code>a * b + c</code>
  to be replaced by a <code>mad</code>. The <code>mad</code> computes
  <code>a * b + c</code> with reduced accuracy. For example, some
  OpenCL devices implement <code>mad</code> as truncate
  the result of <code>a * b</code> before adding it to
  <code>c</code>.  </p></item>
  <dt>-cl-no-signed-zeros</dt><item><p> Allow optimizations for floating-point arithmetic that ignore
  the signedness of zero. IEEE 754 arithmetic specifies the behavior
  of distinct <code>+0.0</code> and <code>-0.0</code> values, which
  then prohibits simplification of expressions such as
  <code>x+0.0</code> or <code>0.0*x</code> (even with -clfinite-math
  only). This option implies that the sign of a zero result isn't
  significant.  </p></item>
  <dt>-cl-unsafe-math-optimizations</dt><item><p> Allow optimizations
  for floating-point arithmetic that (a) assume that arguments and
  results are valid, (b) may violate IEEE 754 standard and (c) may
  violate the OpenCL numerical compliance requirements as defined in
  section 7.4 for single-precision floating-point, section 9.3.9 for
  double-precision floating-point, and edge case behavior in section
  7.5. This option includes the -cl-no-signed-zeros and
  -cl-mad-enable options.  </p></item>
 <dt><span class="term">-cl-finite-math-only</span></dt><item><p>
  Allow optimizations for floating-point arithmetic that assume that arguments and results
  are not NaNs or Â±infinity. This option may violate the OpenCL numerical compliance
  requirements defined in in section 7.4 for single-precision floating-point,
  section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5.
  </p></item>
 <dt><span class="term">-cl-fast-relaxed-math</span></dt><item><p>
  Sets the optimization options -cl-finite-math-only and -cl-unsafe-math-optimizations.
  This allows optimizations for floating-point arithmetic that may violate the IEEE 754
  standard and the OpenCL numerical compliance requirements defined in the specification in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point,
  and edge case behavior in section 7.5. This option causes the preprocessor macro
 
  <code>__FAST_RELAXED_MATH__</code> to be defined in the OpenCL program.
  </p></item></taglist><p><br />
  </p><em>Options to Request or Suppress Warnings</em>
  Warnings are diagnostic messages that report constructions which are not inherently erroneous
  but which are risky or suggest there may have been an error. The following languageindependent
  options do not enable specific warnings but control the kinds of diagnostics
  produced by the OpenCL compiler.
  <taglist><dt><span class="term">-w</span></dt><item><p>
  Inhibit all warning messages.
  </p></item><dt><span class="term">-Werror</span></dt><item><p>
  Make all warnings into errors.
  </p></item>
 </taglist>
</div></div>
<div class="function">
<h3 id="async_build_program/3">async_build_program(Program, DeviceList, Options) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="unload_compiler/0">unload_compiler() -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Allows the implementation to release the resources allocated by the OpenCL compiler.</p>
 
  <p>This is a hint from the application and does not guarantee that the
  compiler will not be used in the future or that the compiler will
  actually be unloaded by the implementation. Calls to build_program/3
  after unload_compiler/0 will reload the compiler, if necessary, to
  build the appropriate program executable.</p>
</div></div>
<div class="function">
<h3 id="program_info/0">program_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_program_info/2">get_program_info(Program, Info) -&gt; term()
</h3>


<div class="description">

<p> Returns specific information about the program object.</p>
</div></div>
<div class="function">
<h3 id="get_program_info/1">get_program_info(Program) -&gt; term()
</h3>


<div class="description">

<p> Returns all information about the program object.</p>
</div></div>
<div class="function">
<h3 id="program_build_info/0">program_build_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_program_build_info/3">get_program_build_info(Program, Device, Info) -&gt; term()
</h3>


<div class="description">

<p>Returns specific build information for each device in the program object.</p>
</div></div>
<div class="function">
<h3 id="get_program_build_info/2">get_program_build_info(Program, Device) -&gt; term()
</h3>


<div class="description">

<p>Returns all build information for each device in the program object.</p>
</div></div>
<div class="function">
<h3 id="create_kernel/1">create_kernel(Program::cl_program(), Name::string()) -&gt; {ok, cl_kernel()} | {error, cl_error()}</h3>


<div class="description">

<p> Creates a kernal object.</p>
 
   <p>A kernel is a function declared in a program. A kernel is
   identified by the __kernel qualifier applied to any function in a
   program. A kernel object encapsulates the specific __kernel
   function declared in a program and the argument values to be used
   when executing this __kernel function.</p>
</div></div>
<div class="function">
<h3 id="create_kernels_in_program/1">create_kernels_in_program(Program::cl_program()) -&gt; {ok, [cl_kernel()]} | {error, cl_error()}</h3>


<div class="description">

<p>Creates kernel objects for all kernel functions in a program object.</p>
 
   <p>Creates kernel objects for all kernel functions in program. Kernel
   objects are not created for any __kernel functions in program that
   do not have the same function definition across all devices for
   which a program executable has been successfully built.</p>
</div></div>
<div class="function">
<h3 id="set_kernel_arg/1">set_kernel_arg(Kernel::cl_kernel(), Index::non_neg_integer(), Argument::cl_kernel_arg()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Used to set the argument value for a specific argument of a kernel.</p>
 
  <p>For now set_kernel_arg handles integer and floats
  to set any other type use <code>&lt;&lt;Foo:Bar/native...&gt;&gt;</code>  
use the macros defined in cl.hrl to get it right (except for padding)</p>
 
  <p>A kernel object does not update the reference count for objects  
such as memory, sampler objects specified as argument values by  
set_kernel_arg/3, Users may not rely on a kernel object to retain  
objects specified as argument values to the kernel.</p>
 
  <p>Implementations shall not allow cl_kernel objects to hold reference
  counts to cl_kernel arguments, because no mechanism is provided for
  the user to tell the kernel to release that ownership right. If the
  kernel holds ownership rights on kernel args, that would make it
  impossible for the user to tell with certainty when he may safely
  release user allocated resources associated with OpenCL objects
  such as the cl_mem backing store used with CL_MEM_USE_HOST_PTR.</p>
</div></div>
<div class="function">
<h3 id="set_kernel_arg_size/1">set_kernel_arg_size(Kernel::cl_kernel(), Index::non_neg_integer(), Size::non_neg_integer()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>clErlang special to set kernel arg with size only (local mem etc)
 </p>
</div></div>
<div class="function">
<h3 id="retain_kernel/1">retain_kernel(Context::cl_kernel()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p> Increments the program kernel reference count.</p>
</div></div>
<div class="function">
<h3 id="release_kernel/1">release_kernel(Context::cl_kernel()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p> Decrements the kernel reference count.</p>
</div></div>
<div class="function">
<h3 id="kernel_info/0">kernel_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_kernel_info/2">get_kernel_info(Kernel, Info) -&gt; term()
</h3>


<div class="description">

<p>Returns specific information about the kernel object.</p>
</div></div>
<div class="function">
<h3 id="get_kernel_info/1">get_kernel_info(Kernel) -&gt; term()
</h3>


<div class="description">

<p>Returns all information about the kernel object.</p>
</div></div>
<div class="function">
<h3 id="kernel_workgroup_info/0">kernel_workgroup_info() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_kernel_workgroup_info/3">get_kernel_workgroup_info(Kernel, Device, Info) -&gt; term()
</h3>


<div class="description">

<p>Returns specific information about the kernel object that may
  be specific to a device.</p>
</div></div>
<div class="function">
<h3 id="get_kernel_workgroup_info/2">get_kernel_workgroup_info(Kernel, Device) -&gt; term()
</h3>


<div class="description">

<p>Returns all information about the kernel object that may be
  specific to a device.</p>
</div></div>
<div class="function">
<h3 id="enqueue_task/1">enqueue_task(Queue::cl_queue(), Kernel::cl_kernel(), WaitList::[cl_event()]) -&gt; {ok, cl_event()} | {error, cl_error()}</h3>


<div class="description">

<p>Enqueues a command to execute a kernel on a device.</p>
 
  <p>The kernel is executed using a single work-item.</p>
<p><em>See also:</em> <a href="#enqueue_nd_range_kernel/5" class="seealso">enqueue_nd_range_kernel/5</a>.</p>
</div></div>
<div class="function">
<h3 id="nowait_enqueue_task/1">nowait_enqueue_task(Queue::cl_queue(), Kernel::cl_kernel(), WaitList::[cl_event()]) -&gt; ok | {error, cl_error()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_task/4">enqueue_task(Queue, Kernel, WaitList, WantEvent) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_nd_range_kernel/1">enqueue_nd_range_kernel(Queue::cl_queue(), Kernel::cl_kernel(), Global::[non_neg_integer()], Local::[non_neg_integer()], WaitList::[cl_event()]) -&gt; {ok, cl_event()} | {error, cl_error()}</h3>


<div class="description">

<p>Enqueues a command to execute a kernel on a device.</p>
 
  <p>Work-group instances are executed in parallel across multiple  
compute units or concurrently on the same compute unit.</p>
 
  <p>Each work-item is uniquely identified by a global identifier. The
  global ID, which can be read inside the kernel, is computed using
  the value given by global_work_size and global_work_offset. In
  OpenCL 1.0, the starting global ID is always (0, 0, ... 0). In
  addition, a work-item is also identified within a work-group by a
  unique local ID. The local ID, which can also be read by the
  kernel, is computed using the value given by local_work_size. The
  starting local ID is always (0, 0, ... 0).</p>
</div></div>
<div class="function">
<h3 id="nowait_enqueue_nd_range_kernel/1">nowait_enqueue_nd_range_kernel(Queue::cl_queue(), Kernel::cl_kernel(), Global::[non_neg_integer()], Local::[non_neg_integer()], WaitList::[cl_event()]) -&gt; ok | {error, cl_error()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_nd_range_kernel/6">enqueue_nd_range_kernel(Queue, Kernel, Global, Local, WaitList, WantEvent) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_marker/1">enqueue_marker(Queue::cl_queue()) -&gt; {ok, cl_event()} | {error, cl_error()}</h3>


<div class="description">

<p> Enqueues a marker command.</p>
 
   <p>Enqueues a marker command to command_queue. The marker command
   returns an event which can be used to queue a wait on this marker
   event i.e. wait for all commands queued before the marker command
   to complete.</p>
</div></div>
<div class="function">
<h3 id="enqueue_wait_for_events/1">enqueue_wait_for_events(Queue::cl_queue(), WaitList::[cl_event()]) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Enqueues a wait for a specific event or a list of events  
to complete before any future commands queued in the command-queue are  
executed.</p>
 
  <p>The context associated with events in WaitList and Queue must be the same.</p>
</div></div>
<div class="function">
<h3 id="enqueue_read_buffer/1">enqueue_read_buffer(Queue::cl_queue(), Buffer::cl_mem(), Offset::non_neg_integer(), Size::non_neg_integer(), WaitList::[cl_event()]) -&gt; {ok, cl_event()} | {error, cl_error()}</h3>


<div class="description">

<p>Enqueue commands to read from a buffer object to host memory.</p>
 
  <p>Calling <code>enqueue_read_buffer</code> to read a region of the
  buffer object with the <code>Buffer</code> argument value set to
  <code>host_ptr</code> + <code>offset</code>, where
  <code>host_ptr</code> is a pointer to the memory region specified
  when the buffer object being read is created with
  <code>CL_MEM_USE_HOST_PTR</code>, must meet the following  
requirements in order to avoid undefined behavior:</p>
 
  <list> <item><p>All commands that use this buffer object have finished
  execution before the read command begins execution</p></item>
  <item><p>The buffer object is not mapped</p></item>
  <item><p>The buffer object is not used by any command-queue until the
  read command has finished execution</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="enqueue_write_buffer/1">enqueue_write_buffer(Queue::cl_queue(), Buffer::cl_mem(), Offset::non_neg_integer(), Size::non_neg_integer(), Data::binary(), WaitList::[cl_event()]) -&gt; {ok, cl_event()} | {error, cl_error()}</h3>


<div class="description">

<p>Enqueue commands to write to a buffer object from host memory.</p>
 
  <p>Calling <code>enqueue_write_buffer</code> to update the latest bits
  in a region of the buffer object with the <code>Buffer</code>
  argument value set to <code>host_ptr</code> + <code>offset</code>,
  where <code>host_ptr</code> is a pointer to the memory region
  specified when the buffer object being read is created with
  <code>CL_MEM_USE_HOST_PTR</code>, must meet the following  
requirements in order to avoid undefined behavior:</p>
 
  <list> <item><p>The host memory region given by <code>(host_ptr + offset, cb)</code>
  contains the latest bits when the enqueued write command begins
  execution. </p></item>
  <item><p>The buffer object is not mapped</p></item>
  <item><p>The buffer object is not used by any command-queue until the read
  command has finished execution</p></item> </list>
</div></div>
<div class="function">
<h3 id="nowait_enqueue_write_buffer/1">nowait_enqueue_write_buffer(Queue::cl_queue(), Buffer::cl_mem(), Offset::non_neg_integer(), Size::non_neg_integer(), Data::binary(), WaitList::[cl_event()]) -&gt; ok | {error, cl_error()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_write_buffer/7">enqueue_write_buffer(Queue, Buffer, Offset, Size, Data, WaitList, WantEvent) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_barrier/1">enqueue_barrier(Queue::cl_queue()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>A synchronization point that enqueues a barrier operation.</p>
 
   <p>enqueue_barrier/1 is a synchronization point that ensures that all
   queued commands in command_queue have finished execution before
   the next batch of commands can begin execution.</p>
</div></div>
<div class="function">
<h3 id="enqueue_read_image/7">enqueue_read_image(Queue, Image, Origin, Region, RowPitch, SlicePitch, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_write_image/8">enqueue_write_image(Queue, Image, Origin, Region, RowPitch, SlicePitch, Data, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="nowait_enqueue_write_image/8">nowait_enqueue_write_image(Queue, Image, Origin, Region, RowPitch, SlicePitch, Data, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_write_image/9">enqueue_write_image(Queue, Image, Origin, Region, RowPitch, SlicePitch, Data, WaitList, WantEvent) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_copy_image/6">enqueue_copy_image(QUeue, SrcImage, DstImage, Origin, Region, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_copy_image_to_buffer/7">enqueue_copy_image_to_buffer(Queue, SrcImage, DstBuffer, Origin, Region, DstOffset, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_copy_buffer_to_image/7">enqueue_copy_buffer_to_image(Queue, SrcBuffer, DstImage, SrcOffset, DstOrigin, Region, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_map_buffer/6">enqueue_map_buffer(Queue, Buffer, MapFlags, Offset, Size, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_map_image/6">enqueue_map_image(Queue, Image, MapFlags, Origin, Region, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="enqueue_unmap_mem_object/3">enqueue_unmap_mem_object(Queue, Mem, WaitList) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="flush/1">flush(Queue::cl_queue()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Issues all previously queued OpenCL commands  
in a command-queue to the device associated with the command-queue.</p>
 
  <p>flush only guarantees that all queued commands to command_queue get
  issued to the appropriate device. There is no guarantee that they
  will be complete after clFlush returns.</p>
</div></div>
<div class="function">
<h3 id="async_flush/1">async_flush(Queue) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="finish/1">finish(Queue::cl_queue()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Blocks until all previously queued OpenCL commands  
in a command-queue are issued to the associated device and have  
completed.</p>
 
  <p>finish does not return until all queued commands in command_queue
  have been processed and completed. clFinish is also a
  synchronization point.</p>
</div></div>
<div class="function">
<h3 id="async_finish/1">async_finish(Queue) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="retain_event/1">retain_event(Event::cl_event()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p> Increments the event reference count.
  NOTE: The OpenCL commands that return an event perform an implicit retain.</p>
</div></div>
<div class="function">
<h3 id="release_event/1">release_event(Event::cl_event()) -&gt; ok | {error, cl_error()}</h3>


<div class="description">

<p>Decrements the event reference count.</p>
 
   <p>Decrements the event reference count. The event object is deleted
   once the reference count becomes zero, the specific command
   identified by this event has completed (or terminated) and there
   are no commands in the command-queues of a context that require a
   wait for this event to complete.</p>
</div></div>
<div class="function">
<h3 id="event_info/0">event_info() -&gt; term()
</h3>


<div class="description">

<p>Returns all possible event_info items.</p>
</div></div>
<div class="function">
<h3 id="get_event_info/2">get_event_info(Event, Info) -&gt; term()
</h3>


<div class="description">

<p>Returns specific information about the event object.</p>
</div></div>
<div class="function">
<h3 id="get_event_info/1">get_event_info(Event) -&gt; term()
</h3>


<div class="description">

<p>Returns all specific information about the event object.</p>
</div></div>
<div class="function">
<h3 id="get_supported_image_formats/3">get_supported_image_formats(Context, Flags, ImageType) -&gt; term()
</h3>


<div class="description">

<p>return a list of image formats [{Order,Type}]</p>
</div></div>
<div class="function">
<h3 id="create_image2d/7">create_image2d(Context, MemFlags, ImageFormat, Width, Height, Picth, Data) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="create_image3d/9">create_image3d(Context, MemFlags, ImageFormat, Width, Height, Depth, RowPicth, SlicePitch, Data) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait/1">wait(Event::cl_event) -&gt; {ok, completed} | {ok, Binary} | {error, cl_error()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait_for_event/1">wait_for_event(Event::cl_event) -&gt; {ok, completed} | {ok, Binary} | {error, cl_error()}</h3>


<div class="description">
<p>Equivalent to <a href="#wait/2" class="seealso">wait(Event, infinity)</a>.</p>
</div></div>
<div class="function">
<h3 id="wait/2">wait(Event::cl_event, Timeout::timeout()) -&gt; {ok, completed} | {ok, Binary} | {error, cl_error()} | {error, timeout}</h3>


<div class="description">

<p> Waits for commands identified by event objects to complete.</p>
 
   <p>Waits for commands identified by event objects
   in event_list to complete. A command is considered complete if its
   execution status is CL_COMPLETE or a negative value.</p>
</div></div>
<div class="function">
<h3 id="async_wait_for_event/1">async_wait_for_event(Event::cl_event()) -&gt; {ok, reference()} | {error, cl_error()}</h3>


<div class="description">

<p> Initiate an asynchronous wait operation.</p>
 
   <p>Generate a wait operation that will run non blocking.
   A reference is return that can be used to match the event
   that is sent when the event has completed or resulted in an error.
   The event returned has the form <code>{cl_event, Ref, Result}</code>
   where Ref is the reference that was returned from the call and
   Result may be one of binary() | 'complete' or {error,cl_error()}.
 </p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
