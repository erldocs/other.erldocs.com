var index = [['app','lasp','lasp','[application]'],['app','lasp','lasp','[application]'],['mod','lasp','lasp',[]],['mod','lasp','lasp_app',[]],['mod','lasp','lasp_console',[]],['mod','lasp','lasp_core',[]],['mod','lasp','lasp_distribution_backend',[]],['mod','lasp','lasp_eleveldb_storage_backend',[]],['mod','lasp','lasp_ets_storage_backend',[]],['mod','lasp','lasp_ivar','Single-assignment variable.'],['mod','lasp','lasp_lattice',[]],['mod','lasp','lasp_node_event_handler',[]],['mod','lasp','lasp_peer_service',[]],['mod','lasp','lasp_plumtree_broadcast_distribution_backend',[]],['mod','lasp','lasp_plumtree_peer_service',[]],['mod','lasp','lasp_process',[]],['mod','lasp','lasp_process_sup',[]],['mod','lasp','lasp_ring_event_handler',[]],['mod','lasp','lasp_storage_backend',[]],['mod','lasp','lasp_sup',[]],['fun','lasp','lasp:bind/1','Bind a dataflow variable to a value.'],['fun','lasp','lasp:bind/1','Bind a dataflow variable to the result of a functi'],['fun','lasp','lasp:bind_to/1','Bind a dataflow variable to another dataflow varia'],['fun','lasp','lasp:declare/1','Declare a new dataflow variable of a given type.'],['fun','lasp','lasp:declare/1','Declare a new dataflow variable of a given type.'],['fun','lasp','lasp:filter/1','Filter values from one lattice into another.'],['fun','lasp','lasp:fold/1','Fold values from one lattice into another.'],['fun','lasp','lasp:intersection/1','Compute the intersection of two sets.'],['fun','lasp','lasp:map/1','Map values from one lattice into another.'],['fun','lasp','lasp:product/1','Compute the cartesian product of two sets.'],['fun','lasp','lasp:read/1','Blocking monotonic read operation for a given data'],['fun','lasp','lasp:read_any/1','Blocking monotonic read operation for a list of gi'],['fun','lasp','lasp:thread/1','Spawn a function.'],['fun','lasp','lasp:union/1','Compute the union of two sets.'],['fun','lasp','lasp:update/1','Update a dataflow variable.'],['fun','lasp','lasp:wait_needed/1','Pause execution until value requested with given t'],['fun','lasp','lasp_app:start/2','Start the lasp application.'],['fun','lasp','lasp_app:stop/1','Stop the lasp application.'],['fun','lasp','lasp_console:join/1',[]],['fun','lasp','lasp_core:bind/1','Define a dataflow variable to be bound a value.'],['fun','lasp','lasp_core:bind/1','Define a dataflow variable to be bound a value.'],['fun','lasp','lasp_core:bind_to/1','Define a dataflow variable to be bound to another '],['fun','lasp','lasp_core:bind_to/1','Define a dataflow variable to be bound to another '],['fun','lasp','lasp_core:bind_to/5',[]],['fun','lasp','lasp_core:declare/1','Declare a dataflow variable in a provided by ident'],['fun','lasp','lasp_core:declare/1','Declare a dataflow variable in a provided by ident'],['fun','lasp','lasp_core:declare/1','Declare a dataflow variable, as a given type.'],['fun','lasp','lasp_core:declare/1','Declare a dataflow variable in a provided by ident'],['fun','lasp','lasp_core:filter/1','Filter values from one lattice into another.'],['fun','lasp','lasp_core:filter/1','Filter values from one lattice into another.'],['fun','lasp','lasp_core:fold/1','Fold values from one lattice into another.'],['fun','lasp','lasp_core:fold/1','Fold values from one lattice into another.'],['fun','lasp','lasp_core:intersection/1','Compute the intersection of two sets.'],['fun','lasp','lasp_core:intersection/1','Compute the intersection of two sets.'],['fun','lasp','lasp_core:map/1','Lap values from one lattice into another.'],['fun','lasp','lasp_core:map/1','Map values from one lattice into another.'],['fun','lasp','lasp_core:product/1','Compute the cartesian product of two sets.'],['fun','lasp','lasp_core:product/1','Compute the cartesian product of two sets.'],['fun','lasp','lasp_core:read/1','Perform a read (or monotonic read) for a particula'],['fun','lasp','lasp_core:read/1','Perform a monotonic read read for a particular ide'],['fun','lasp','lasp_core:read/1','Perform a read for a particular identifier.'],['fun','lasp','lasp_core:read_any/1','Perform a monotonic read for a series of given ide'],['fun','lasp','lasp_core:reply_to_all/1','Given a group of processes which are blocking on r'],['fun','lasp','lasp_core:reply_to_all/1','Given a group of processes which are blocking on r'],['fun','lasp','lasp_core:start/1','Initialize the storage backend.'],['fun','lasp','lasp_core:thread/1','Spawn a function.'],['fun','lasp','lasp_core:union/1','Compute the union of two sets.'],['fun','lasp','lasp_core:union/1','Compute the union of two sets.'],['fun','lasp','lasp_core:update/1',[]],['fun','lasp','lasp_core:update/1','Update a dataflow variable given an operation.'],['fun','lasp','lasp_core:wait_needed/1','Callback wait_needed function for lasp_vnode, wher'],['fun','lasp','lasp_core:wait_needed/1','Pause execution until value requested with given t'],['fun','lasp','lasp_core:wait_needed/1','Pause execution until value requested with given t'],['fun','lasp','lasp_core:write/1','Send responses to waiting threads, via messages.'],['fun','lasp','lasp_eleveldb_storage_backend:get/1','Retrieve a record from the backend.'],['fun','lasp','lasp_eleveldb_storage_backend:put/1','Write a record to the backend.'],['fun','lasp','lasp_eleveldb_storage_backend:start/1','Start and link to calling process.'],['fun','lasp','lasp_eleveldb_storage_backend:update/1','In-place update given a mutation function.'],['fun','lasp','lasp_ets_storage_backend:get/1','Retrieve a record from the backend.'],['fun','lasp','lasp_ets_storage_backend:put/1','Write a record to the backend.'],['fun','lasp','lasp_ets_storage_backend:start/1','Start and link to calling process.'],['fun','lasp','lasp_ets_storage_backend:update/1','In-place update given a mutation function.'],['fun','lasp','lasp_ivar:equal/2','Test for equality.'],['fun','lasp','lasp_ivar:merge/1','Single assignment merge; undefined for two bound v'],['fun','lasp','lasp_ivar:new/0','Create a new single-assignment variable.'],['fun','lasp','lasp_ivar:update/3','Set the value of a single-assignment variable.'],['fun','lasp','lasp_lattice:causal_product/3','Compute a cartesian product from causal metadata s'],['fun','lasp','lasp_lattice:causal_remove/2','Given the metadata for a given value, force that t'],['fun','lasp','lasp_lattice:causal_union/3','Compute the union of causal metadata.'],['fun','lasp','lasp_lattice:is_inflation/3','Determine if a change is an inflation or not.'],['fun','lasp','lasp_lattice:is_lattice_inflation/3','Determine if a change for a given type is an infla'],['fun','lasp','lasp_lattice:is_lattice_strict_inflation/3','Determine if a change for a given type is a strict'],['fun','lasp','lasp_lattice:is_strict_inflation/3','Determine if a change is a strict inflation or not'],['fun','lasp','lasp_lattice:threshold_met/3','Determine if a threshold is met.'],['fun','lasp','lasp_node_event_handler:code_change/3',[]],['fun','lasp','lasp_node_event_handler:handle_call/2',[]],['fun','lasp','lasp_node_event_handler:handle_event/2',[]],['fun','lasp','lasp_node_event_handler:handle_info/2',[]],['fun','lasp','lasp_node_event_handler:init/1',[]],['fun','lasp','lasp_node_event_handler:terminate/2',[]],['fun','lasp','lasp_peer_service:join/1','Prepare node to join a cluster.'],['fun','lasp','lasp_peer_service:join/2','Convert nodename to atom.'],['fun','lasp','lasp_peer_service:join/3','Initiate join.'],['fun','lasp','lasp_peer_service:leave/0','Leave the cluster.'],['fun','lasp','lasp_peer_service:peer_service/0','Return the currently active peer service.'],['fun','lasp','lasp_peer_service:stop/0','Stop node.'],['fun','lasp','lasp_peer_service:stop/1','Stop node for a given reason.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:bind/1','Bind a dataflow variable to a value.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:bind_to/1','Bind a dataflow variable to another dataflow varia'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:broadcast_data/1','Returns from the broadcast message the identifier '],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:declare/1','Declare a new dataflow variable of a given type.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:exchange/1',[]],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:filter/1','Filter values from one lattice into another.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:fold/1','Fold values from one lattice into another.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:graft/1','Given a message identifier and a clock, return a g'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:intersection/1','Compute the intersection of two sets.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:is_stale/1','Use the clock on the object to determine if this m'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:map/1','Map values from one lattice into another.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:merge/1',[]],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:product/1','Compute the cartesian product of two sets.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:read/1','Blocking monotonic read operation for a given data'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:read_any/1','Blocking monotonic read operation for a list of gi'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:start_link/0','Same as start_link([]).'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:start_link/1','Start and link to calling process.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:thread/1','Spawn a function.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:union/1','Compute the union of two sets.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:update/1','Update a dataflow variable.'],['fun','lasp','lasp_plumtree_broadcast_distribution_backend:wait_needed/1','Pause execution until value requested with given t'],['fun','lasp','lasp_plumtree_peer_service:join/1','Prepare node to join a cluster.'],['fun','lasp','lasp_plumtree_peer_service:join/2','Convert nodename to atom.'],['fun','lasp','lasp_plumtree_peer_service:join/3','Initiate join.'],['fun','lasp','lasp_plumtree_peer_service:leave/0','Leave the cluster.'],['fun','lasp','lasp_plumtree_peer_service:stop/0','Stop node.'],['fun','lasp','lasp_plumtree_peer_service:stop/1','Stop node for a given reason.'],['fun','lasp','lasp_process:init/1','Initialize state.'],['fun','lasp','lasp_process:process/2','Computation to execute when inputs change.'],['fun','lasp','lasp_process:read/1','Return list of read functions.'],['fun','lasp','lasp_process:start_link/1',[]],['fun','lasp','lasp_process_sup:init/1','supervisor callback.'],['fun','lasp','lasp_process_sup:start_child/1','Start a child.'],['fun','lasp','lasp_process_sup:start_link/0','API for starting the supervisor.'],['fun','lasp','lasp_process_sup:terminate_child/2','Stop a child immediately.'],['fun','lasp','lasp_ring_event_handler:code_change/3',[]],['fun','lasp','lasp_ring_event_handler:handle_call/2',[]],['fun','lasp','lasp_ring_event_handler:handle_event/2',[]],['fun','lasp','lasp_ring_event_handler:handle_info/2',[]],['fun','lasp','lasp_ring_event_handler:init/1',[]],['fun','lasp','lasp_ring_event_handler:terminate/2',[]],['fun','lasp','lasp_sup:init/1',[]],['fun','lasp','lasp_sup:start_link/0',[]]];