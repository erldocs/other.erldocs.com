<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>mtree (swirl) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>mtree</h1>
<h2 class="modsummary">This library module implements merkle tree API functions.</h2>
<div class="description">
<p>This library module implements merkle tree API functions.
  </p><p> API for merkle hash tree </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-bin">bin() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-bin_hash">bin_hash() = {<a href="#type-bin" class="seealso">bin()</a>, <a href="#type-hash" class="seealso">hash()</a>}</h3></div>
    <div class="type"><h3 id="type-hash">hash() = binary()</h3></div>
    <div class="type"><h3 id="type-hash_list">hash_list() = [{<a href="#type-bin" class="seealso">bin()</a>, <a href="#type-hash" class="seealso">hash()</a>}]</h3></div>
    <div class="type"><h3 id="type-mtree">mtree()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/1">new(Tree::mtree()) -&gt; ok</h3>


<div class="description">

<p>Initialize a new merkle hash tree.</p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(Tree::mtree(), Data::binary()) -&gt; true</h3>


<div class="description">

<p>insert/2 adds {Bin, Hash, Data} into the ETS table
  </p><p> Provides interface to insert hashes into the ETS table. </p>
</div></div>
<div class="function">
<h3 id="prune_bin_range/1">prune_bin_range(Tree::mtree(), Bin::bin()) -&gt; true</h3>


<div class="description">

<p>remove/3 removes a given hash from tree and re-calculate the root hash</p>
</div></div>
<div class="function">
<h3 id="build_tree/1">build_tree(Tree::mtree()) -&gt; Root_Bin::bin()</h3>


<div class="description">

<p>Takes input the start and end Bin of the leaf nodes and
  constructs a tree using the leaf nodes stored in the ETS table and stores
  the tree back into the ETS table.</p>
</div></div>
<div class="function">
<h3 id="root_hash/1">root_hash(Tree::mtree()) -&gt; bin_hash() | {error, term()}</h3>


<div class="description">

<p>root_hash/1 get the root hash of the tree. The root of a full binary
  tree that uses bin number scheme will always be of the form 2^N -1 where N
  is the number of leaf nodes in the tree. This function assumes that the
  binary tree is full.</p>
</div></div>
<div class="function">
<h3 id="root_hash1/1">root_hash1(Tree) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_data_range/1">get_data_range(Tree::mtree()) -&gt; {ok, bin(), bin()}</h3>


<div class="description">

<p>get_data_range/1 returns the start and end of the chunk range.</p>
</div></div>
<div class="function">
<h3 id="get_peak_hash/1">get_peak_hash(Tree::mtree()) -&gt; hash_list()</h3>


<div class="description">

<p>get_peak_hash/1 returns the peak hashes of the given tree.
  </p><p> Provides an interface to get the peak hashes that are use by the
  receiver for reliable file size detection and download/live streaming
  unification </p>
</div></div>
<div class="function">
<h3 id="verify_peak_hash/1">verify_peak_hash(Peak_List::hash_list(), Root_Hash::hash()) -&gt; true | false</h3>


<div class="description">

<p>verify_peak_hash/1 takes a peak hash list and verifies its against the
  given root hash hence enabling the peer to guess the size of the DATA</p>
</div></div>
<div class="function">
<h3 id="get_subtree_hash/1">get_subtree_hash(Bin) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_hash_by_index/1">get_hash_by_index(Tree::mtree(), Bin::bin()) -&gt; {ok, hash_list()}</h3>


<div class="description">

<p>get_hash_by_index/2 returns a hash or list of hashes for a given
  Bin which may represent a single chunk or a range of chunks.</p>
</div></div>
<div class="function">
<h3 id="get_uncle_hashes/1">get_uncle_hashes(Tree::mtree(), Bin::bin()) -&gt; hash_list() | {error, term()}</h3>


<div class="description">

<p>get_uncle_hashes/2 returns list of uncle hashes required to verify
  a given chunk.</p>
</div></div>
<div class="function">
<h3 id="get_all_uncle_hashes/1">get_all_uncle_hashes(Tree::mtree(), Bin::bin()) -&gt; hash_list() | {error, term()}</h3>


<div class="description">

<p>get_uncle_hashes/2 returns list of uncle hashes required to verify
  a given chunk.</p>
</div></div>
<div class="function">
<h3 id="verify_uncle_hash/1">verify_uncle_hash(Tree::mtree(), Hash_List::hash_list(), X3::bin_hash()) -&gt; {ok, true} | {error, term()}</h3>


<div class="description">

<p>Given a Hash_List of the type [{Bin1,Hash1}, {Bin2,Hash2}, ...]
  verify_uncle_hash/3 for a given chunk ID and its Hash (i.e. Bin Number),
  inserts the Uncle_Hashes into the tree and returns true if the new Root_Hash
  of the tree after addition of a new chunk is same as the received Root_Hash.
  </p><p> When a peer receives a new chunk it MUST receive Uncle_Hashes required
  to verify to calculate the Root_Hash and check it against the received
  Root_Hash </p>
 
  <p>IMPORTANT NOTE : the verify function assumes optimistic approach i.e. if
  reciever is trying to verify chuck 3 (C3), then the function assumes that it
  has already verified C0, C1, C2.</p>
</div></div>
<div class="function">
<h3 id="verify/1">verify(Tree::mtree(), X2::bin_hash(), X3::bin_hash()) -&gt; {ok, true} | {ok, false} | {error, term()}</h3>


<div class="description">

<p>verify/2 for a given bin bumber and its hash it recalculates the root
  hash And verifies its against the root hash</p>
</div></div>
<div class="function">
<h3 id="get_munro_uncles/1">get_munro_uncles(Tree::mtree(), Bin::[integer()]) -&gt; hash()</h3>


<div class="description">

<p>get_munro_uncles/2 returns the uncle hashes required to check the
  intergrity of the given chunk.</p>
</div></div>
<div class="function">
<h3 id="get_all_munro_uncles/1">get_all_munro_uncles(Tree::mtree(), Bin::[integer()]) -&gt; hash()</h3>


<div class="description">

<p>get_all_munro_uncles/2 returns the all munro hashes required to verify
  the intergrity regardless of previous chunks sent.</p>
</div></div>
<div class="function">
<h3 id="get_latest_munro/1">get_latest_munro(Tree::mtree()) -&gt; bin() | {error, term()}</h3>


<div class="description">

<p>This function is helpful during SECURE TUNE IN in a live stream, this
  funcitons gets the most recent munro root bin.  Since the injector will
  generated chunks that are a fixed power of 2 so the muro root will always
  lie in layer corresponding to the power of 2.</p>
</div></div>
<div class="function">
<h3 id="verify_munro_hash/1">verify_munro_hash(Tree::mtree(), X2::hash(), Munro_Uncle_Hashes::hash_list()) -&gt; {true, mtree()} | {false, mtree()}</h3>


<div class="description">

<p>verify_munro_hash/2 returns true if the calculated Munro_Hash from the
  Uncle_Hashes is equal to the received Munro_Hash.
  </p><p> Uses verify function internally which is provided the new subtree as
  Tree and Munro_Hash as Root_Hash as its arguments.</p>
</div></div>
<div class="function">
<h3 id="peaks_to_size/1">peaks_to_size(Hash_List::hash_list()) -&gt; non_neg_integer()</h3>


<div class="description">

<p>determines the APPROXIMATE size of the given data. Returns the number
  of data chunks spanned by the given peaks which can be multiplied with
  CHUNK_SIZE to get the approx. data size.</p>
</div></div>
<div class="function">
<h3 id="load_tree/1">load_tree(File_Name::string()) -&gt; {ok, atom()} | {error, term()}</h3>


<div class="description">

<p>dump_tree/2 write the merkle hash tree into a file with name as
  File_Name. Returns ok if the operation succeeded.</p>
</div></div>
<div class="function">
<h3 id="dump_tree/1">dump_tree(Tree::mtree()) -&gt; ok</h3>


<div class="description">

<p>load_tree/1 loads merkle hash tree from a file with name as File_Name.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
