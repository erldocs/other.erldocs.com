<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ubf_client (ubf) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>ubf_client</h1>
<h2 class="modsummary">UBF client-side public API.</h2>
<div class="description">
<p>UBF client-side public API.</p>
  
   <p>This module implements most of the commonly-used client-side   
functions required to talk to UBF servers:</p>
  
   <p>- +connect()+ to a UBF server   
- +rpc()+ to make a synchronous call to a connected UBF server   
- +stop()+ a connection   
- +install_handler()+ to add a callback function to handle     
asynchronous notifications from theUBF server to your client     
process.</p>
  
   <p>Note that this library can support UBF(a), EBF, JSF, TBF, PBF, and   
ABF transport.  See the +connect()+ function arguments for   
details.</p>
  
   This module also provides an alternative client-side function for
   calling\'s UBF contract manager and a UBF contract\'s
   implementation without any side-effects: +lpc()+ to make a
   synchronous local procedure call to a contract\'s implementation.
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-host">host() = nonempty_string()</h3></div>
    <div class="type"><h3 id="type-ipport">ipport() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-name">name() = atom()</h3></div>
    <div class="type"><h3 id="type-options">options() = [{atom(), term()}]</h3></div>
    <div class="type"><h3 id="type-plugin">plugin() = module()</h3></div>
    <div class="type"><h3 id="type-plugins">plugins() = [<a href="#type-plugin" class="seealso">plugin()</a>]</h3></div>
    <div class="type"><h3 id="type-server">server() = <a href="#type-name" class="seealso">name()</a> | pid()</h3></div>
    <div class="type"><h3 id="type-service">service() = {'#S', nonempty_string()} | undefined</h3></div>
    <div class="type"><h3 id="type-statename">statename() = atom()</h3></div>
    <div class="type"><h3 id="type-tlogger">tlogger() = module()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="connect/1">connect(Host::host() | plugins(), Port::ipport() | server()) -&gt; {ok, Client::pid(), service()} | {error, term()}</h3>


<div class="description">

<p>Connect to a UBF server at address Host + TCP port Port.</p>
</div></div>
<div class="function">
<h3 id="connect/1-1">connect(Host::host() | plugins(), Port::ipport() | server(), Timeout::timeout()) -&gt; {ok, Client::pid(), service()} | {error, term()}</h3>


<div class="description">

<p>Connect to a UBF server at address Host + TCP port Port.</p>
</div></div>
<div class="function">
<h3 id="connect/1-2">connect(X::host() | plugins(), Y::ipport() | server(), Options::options(), Timeout::timeout()) -&gt; {ok, Client::pid(), service()} | {error, term()}</h3>


<div class="description">

<p>Connect to a UBF server at address Host + TCP port Port, or at  
pid/registered name Server.</p>
 
  <p>When using the alternate form, the first two arguments are:</p>
 
  <p>- Plugins: a +plugin_module_list()+.  
- Server: either a process id +(pid())+ or process registered    
name +(atom())+ for an already-started UBF server.</p>
 
  <p>See the docs for +ubf_server:start_link()+ for a description of the
  +Options+ proplist.</p>
</div></div>
<div class="function">
<h3 id="stop/1">stop(Client::pid()) -&gt; ok</h3>


<div class="description">

<p>Stop a UBF client process.</p>
</div></div>
<div class="function">
<h3 id="rpc/1">rpc(Client::pid(), Call::term()) -&gt; timeout | term() | no_return()</h3>


<div class="description">

<p>Perform a synchronous RPC call.</p>
 
  <p>NOTE: It is not recommended that a UBF client return the bare atom
  +timeout+ in response to any RPC call.</p>
</div></div>
<div class="function">
<h3 id="rpc/1-1">rpc(Client::pid(), Call::term(), Timeout::timeout()) -&gt; timeout | term() | no_return()</h3>


<div class="description">

<p>Perform a synchronous RPC call.</p>
</div></div>
<div class="function">
<h3 id="sendEvent/1">sendEvent(Handler::pid(), Cast::term()) -&gt; ok | no_return()</h3>


<div class="description">

<p>Send an asynchronous UBF message.</p>
</div></div>
<div class="function">
<h3 id="install_default_handler/1">install_default_handler(Client::pid()) -&gt; ack</h3>


<div class="description">

<p>Install a default handler function (callback-style) for  
asynchronous UBF messages.</p>
 
  <p>The default handler function, drop_fun/1, does nothing.</p>
</div></div>
<div class="function">
<h3 id="install_handler/1">install_handler(Client::pid(), Fun::function()) -&gt; ack</h3>


<div class="description">

<p>Install a handler function (callback-style) for asynchronous  
UBF messages.</p>
 
  <p>The handler fun Fun should be a function of arity 1.  When an  
asynchronous UBF message is received, the callback function will be  
called with the UBF message as its single argument.  The Fun is  
called by the ubf client process so the Fun can crash and/or block  
this process.</p>
 
  <p>If your handler fun must maintain its own state, then you must use
  an intermediate anonymous fun to bind the state.  See the usage of
  the +irc_client_gs:send_self/2+ fun as an example.  The
  +send_self()+ fun is actually arity 2, but the extra argument is
  how the author, Joe Armstrong, maintains the extra state required
  to deliver the async UBF message to the process that is executing
  the event loop processing function, +irc_client_gs:loop/6+.</p>
</div></div>
<div class="function">
<h3 id="lpc/1">lpc(Mod::plugin(), Call::term()) -&gt; term()</h3>


<div class="description">

<p>Perform a synchronous LPC (local procedure) call with the
  state +none+.</p>
</div></div>
<div class="function">
<h3 id="lpc/1-1">lpc(Mod::plugin(), Call::term(), State::statename()) -&gt; term()</h3>


<div class="description">

<p>Perform a synchronous LPC (local procedure) call with the
  specified state.</p>
</div></div>
<div class="function">
<h3 id="lpc/1-2">lpc(Mod::plugin(), Call::term(), State::statename(), TLogMod::tlogger()) -&gt; term()</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
