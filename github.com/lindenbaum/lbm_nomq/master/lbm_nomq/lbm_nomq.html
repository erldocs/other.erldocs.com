<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>lbm_nomq (lbm_nomq) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>lbm_nomq</h1>
<h2 class="modsummary">   
A simple, distributed, message distribution framework with message queue   
semantics (publish/subscribe), that is actually not really a message queue.</h2>
<div class="description">
<p>   
A simple, distributed, message distribution framework with message queue   
semantics (publish/subscribe), that is actually not really a message queue.   
It uses Erlang terms and distributed Erlang.</p>
  
   <p><code>lbm_nomq</code> is based on the principle, that messages are safest when they   
reside in the originator until they have been delivered to/processed by a   
subscriber. This is achieved by a mechanism similar to a blocking queue. The   
originator will be blocked until the message has been received (and   
eventually handled) by exactly one subscriber. Thus, this mechanism is   
well-suited for applications with many concurrent producers that produce a   
moderate amount of messages each.</p>
  
   <p>In a nutshell <code>lbm_nomq</code> allows sending terms over logical, topic-based
   channels to subscribed MFAs. In the case, the subscribed MFAs adheres to
   <code>gen:call/4</code> semantics, message distribution is guaranteed to be reliable.</p>
  
   It is possible to have multiple subscribers for a topic, however, <code>lbm_nomq</code>
   will deliver a message to exactly one of the subscribed MFAs (randomly
   chosen). This is useful to support active/active redundant subscribers
   sharing a common state.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-mfargs">mfargs() = {module(), atom(), [term()]}</h3></div>
    <div class="type"><h3 id="type-push_option">push_option() = no_wait</h3></div>
    <div class="type"><h3 id="type-subscribe_option">subscribe_option() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{monitor, PidOrLocalName :: pid() | atom()}</h3></div>
    <div class="type"><h3 id="type-topic">topic() = any()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="subscribe_server/1">subscribe_server(Topic::topic()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>
  Similar to <a href="#subscribe/2" class="seealso">subscribe/2</a> with <code>MFAs</code> set to
  <code>{gen_server, call, [self()]}</code>. The subscribed <code>gen_server</code> will receive the
  pushed messages in its <code>handle_call/3</code> function.</p>
</div></div>
<div class="function">
<h3 id="subscribe_fsm/1">subscribe_fsm(Topic::topic()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>
  Similar to <a href="#subscribe/2" class="seealso">subscribe/2</a> with <code>MFAs</code> set to
  <code>{gen_fsm, sync_send_event, [self()]}</code>. The subscribed <code>gen_fsm</code> will
  receive the pushed messages in its <code>StateName/3</code> function.</p>
</div></div>
<div class="function">
<h3 id="subscribe/1">subscribe(Topic::topic(), MFAs::mfargs()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>
  Similar to <a href="#subscribe/3" class="seealso">subscribe/3</a> with <code>Options</code> set to <code>[]</code>.</p>
</div></div>
<div class="function">
<h3 id="subscribe/1-1">subscribe(Topic::topic(), X2::mfargs(), Options::[subscribe_option()]) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>
  Subscribes <code>MFAs</code> as listener for a certain topic. Messages will be delivered
  to the process using either <code>erlang:apply(M, F, As ++ [Message, Timeout])</code> or
  <code>erlang:apply(M, F, As ++ [Message])</code> (whatever is available, where the
  timeout version is preferred). If the function adheres to the <code>gen:call/4</code>  
protocol message delivery will be reliable. This means that if the function  
returns without exiting, the message is considered to be consumed  
successfully.</p>
 
  <p>It is possible to have multiple subscribers for a topic. However, a message  
will be pushed to exactly one subscriber. The subscriber for a message will  
be chosen randomly.</p>
 
  <p>It is recommended to have a limited amount of subscribers for a topic, e.g.
  let's say a maximum of 3-5. There's no explicit <code>unsubscribe</code> in <code>lbm_nomq</code>.
  Subscriptions will be discarded automatically, when the applied <code>MFAs</code> raises
  an exception, error or exit. For functions that always succeed <code>lbm_nomq</code>
  offers the possibility to provide an owner process id that is associated with
  the subscription, see the <code>Options</code> section below for more details.</p>
 
  <p>The only option currently supported, is the <code>{monitor, PidOrLocalName}</code>
  option. This should be used when subscribing <code>MFAs</code> that do not adhere the
  <code>gen:call/4</code> protocol, since <code>lbm_nomq</code> can only remove subscriptions when
  a push attempt raises an exception, error or exit. Providing a process id or
  local name associates this process with the given <code>MFAs</code> and will lead to
  unsubscription when the process exits, e.g. to subscribe <code>gen_server:cast/2</code>
  use someting like this:
  <code>lbm_nomq:subscribe(Topic, {gen_server, cast, [Pid]}, [{monitor, Pid}])</code></p>
</div></div>
<div class="function">
<h3 id="subscribers/1">subscribers(Topic::topic()) -&gt; [#lbm_nomq_subscr{m=undefined | module() | '_', f=undefined | atom() | '_', as=undefined | [term()] | '_', mon=undefined | pid()}]</h3>


<div class="description">

<p>
  Return the subscribers currently registered for a certain topic. The returned
  list may contain subscribers that are already dead and will be sorted out
  when pushing the next time.</p>
</div></div>
<div class="function">
<h3 id="push/1">push(Topic::topic(), Message::term()) -&gt; any()</h3>


<div class="description">

<p>
  Similar to <a href="#push/3" class="seealso">push/3</a> with <code>Timeout</code> set to <code>5000</code>.</p>
</div></div>
<div class="function">
<h3 id="push/1-1">push(Topic::topic(), Message::term(), Timeout::timeout()) -&gt; any()</h3>


<div class="description">

<p>
  Similar to <a href="#push/4" class="seealso">push/4</a> with <code>Options</code> set to <code>[]</code>.</p>
</div></div>
<div class="function">
<h3 id="push/1-2">push(Topic::topic(), Message::term(), Timeout::timeout(), Options::[push_option()]) -&gt; any()</h3>


<div class="description">

<p>
  Send a message for a specific topic. This will block the calling process
  until either the message has been successfully consumed by exactly one
  subscriber or the <code>Timeout</code> millis elapsed. If there are no subscribers
  available for <code>Topic</code> the process will wait for new subscribers (until
  <code>Timeout</code> expires).</p>
 
  <p>If a push finally fails, the caller will be exited with
  <code>exit({timeout, {lbm_nomq, push, [Topic, Msg, Timeout, Options]}})</code>. If the  
calling process decides to catch this error and a subscriber is just late  
with the reply, it may arrive at any time later into the caller's message  
queue. The caller must in this case be prepared for this and discard any such  
garbage messages.</p>
 
  <p>The only option currently supported, is the <code>no_wait</code> option. If this flag
  is given, the caller will not wait for subscribers (e.g. only bad or no
  subscribers for <code>Topic</code> could be found) and will be exited immediately with
  <code>exit({no_subscribers, {lbm_nomq, push, [Topic, Msg, Timeout, Options]}})</code>
  instead.</p>
</div></div>
<div class="function">
<h3 id="info/0">info() -&gt; ok</h3>


<div class="description">

<p>
  Print topic and subscriber info to stdout.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
