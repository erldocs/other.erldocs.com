<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>eipmi_session (eipmi) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>eipmi_session</h1>
<h2 class="modsummary">
   A server providing session management for IPMI over lan channels.</h2>
<div class="description">
<p>
   A server providing session management for IPMI over lan channels. The
   session will be established as soon as the server gets started. An
   established session will be closed when the server terminates. The user
   can close the session using <a href="#stop/1" class="seealso">stop/1</a>.</p>
  
   <p>Synchronous requests can be issued over this session at any given time using
   <a href="#rpc/3" class="seealso">rpc/3</a> or <a href="#rpc/4" class="seealso">rpc/4</a>. When the session is not yet established
   requests will be queued and issued as soon as the far end (BMC) is ready.
   Request timeouts can be configured on state machine startup using the
   <code>timeout</code> property of the <code>Options</code> field.</p>
  
   <p>A session may be shared between mutliple processes. While the requests of   
one process will be synchronous and thus ordered, requests from different   
processes will not block each other. However, it should be mentioned that   
a BMC is allowed to discard packets with a sequence number difference of 8.   
Since the session does not (yet) provide any kind of flow control it is the   
responsibility of the rpc-ing processes to care for the total number of   
concurrent RPCs or to live with error/timeout returns.</p>
  
   <p>The server will handle the low level RMCP and IPMI protocol regarding   
encoding and decoding of messages, as well as correct packet   
acknowledgement, sequence number handling and session opening/closing.   
Packet loss is not handled during session setup.</p>
  
   <p>A session will use the modules <a href="eipmi_request.html" class="seealso">eipmi_request</a> and
   <a href="eipmi_response.html" class="seealso">eipmi_response</a> to encode and decode requests/responses. Therefore,   
there's no need to edit the session but extending these modules when   
support for new requests/responses is added.</p>
  
   Currently all incoming packets are considered to be IPMI responses
   and outbound sequence numbers are not tracked/checked.
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-property">property() = <a href="eipmi.html#type-option" class="seealso">eipmi:option()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {auth_type, none | pwd | md5 | md2}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {auth_types, [none | pwd | md5 | md2]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {challenge, binary()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {completion, atom()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {inbound_seq_nr, integer() >= 0}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {login_status, [anonymous | null | non_null]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {outbound_seq_nr, integer() >= 0}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {rq_seq_nr, 0..64}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {session_id, integer() >= 0}</h3></div>
    <div class="type"><h3 id="type-property_name">property_name() = <a href="eipmi.html#type-option_name" class="seealso">eipmi:option_name()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| auth_type<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| auth_types<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| challenge<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| completion<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| inbound_seq_nr<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| login_status<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| outbound_seq_nr<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| rq_seq_nr<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| session_id</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/1">start_link(Session::session() (see module eipmi), IPAddress::ip_address() (see module inet) | hostname() (see module inet), Options::[property()]) -&gt; {ok, pid()} | {error, term()}</h3>


<div class="description">

<p>
  Starts a session server which in turn will occupy a free UDP socket. The
  provided IP address and network port will be used to send requests. This
  means that the target for this session server is static and configured on
  startup. This will also setup a session by sending the necessary IPMI
  protocol messages. All requests received before the session is activated will
  be queued and sent as soon as the session is established.</p>
</div></div>
<div class="function">
<h3 id="rpc/1">rpc(Pid::pid(), Request::request() (see module eipmi), Properties::proplist() (see module proplists)) -&gt; {ok, proplist() (see module proplists)} | {error, term()}</h3>


<div class="description">

<p>
  Basically the same as <a href="#rpc/4" class="seealso">rpc/4</a>, but the number of allowed retransmits
  is taken from the <code>eipmi</code> application configuration. If not configured the
  default number of allowed retransmits is <code>2</code>.</p>
<p><em>See also:</em> <a href="#rpc/4" class="seealso">rpc/4</a>.</p>
</div></div>
<div class="function">
<h3 id="rpc/1-1">rpc(Pid::pid(), Request::request() (see module eipmi), Properties::proplist() (see module proplists), Retransmits::non_neg_integer()) -&gt; {ok, proplist() (see module proplists)} | {error, term()}</h3>


<div class="description">

<p>
  Send a synchronous IPMI RPC over this session. If the session is not yet
  established the request will be queued. The last arguments specifies the
  number of allowed retransmits. Since requests get sent over UDP packet
  delivery may be unreliable and requests could get lost.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
