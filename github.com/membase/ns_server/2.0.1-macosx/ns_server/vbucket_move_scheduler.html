<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>vbucket_move_scheduler (ns_server) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>vbucket_move_scheduler</h1>
<h2 class="modsummary">this module implements state machine that decides which  
vbucket moves can be started when and when necessary view  
compactions can be performed.</h2>
<div class="description">
<p>this module implements state machine that decides which  
vbucket moves can be started when and when necessary view  
compactions can be performed.</p>
 
  <p>Overall idea is we want to move as many vbuckets as possible in  
parallel but there are certain limits that we still need to  
enforce. More below.</p>
 
  <p>Input is old and new vbucket map, from which it computes moves as  
well as 2 parameters that describe concurrency limits.</p>
 
  <p>First limit is number of concurrent tap backfills into/out-of any  
node. The idea is moving vbucket involves reading entire vbucket  
from disk and sending it to destination node where entire vbucket  
needs to be persisted. While this phase of vbucket move occurs  
between this two nodes it's undesirable to do backfill phase  
affecting any of those two nodes concurrently. We support limit  
higher than 1, but in actual product it's 1.</p>
 
  <p>Second limit is how many vbucket we move into/out-of any node  
before pausing moves and forcing views compaction.</p>
 
  <p>Current model of actions required as part of vbucket move are:</p>
 
  <p>a) build complete replica of vbucket on future master (backfill  
phase). For this phase as pointed out above we have first limit  
that affects both old master and future master. Note: we  
consciously ignore the fact that we can also have incoming  
backfills into future replicas in this phase. Those backfills  
currently are currently not affected by or affect any limits.</p>
 
  <p>b) ensure that indexes are built for new vbucket on new master and  
rest of vbucket takeover. That phase notably can happen  
concurrently for many vbuckets on any node for both incoming and  
outgoing vbucket moves. We actually try to pack as many of them as  
possible so that indexer which is currently slowest part of  
rebalance is always busy.</p>
 
  <p>c) (involves multiple vbucket moves at once) do view  
compaction. This phase _cannot_ happen concurrently with any  
vbucket moves. I.e. we want views to be as quiescent as possible  
(i.e. no massive indexing of incoming vbucket moves at least). As  
noted above we try to do several vbucket moves before pausing for  
views compactions. Because compacting after every single vbucket  
move is expensive.</p>
 
  <p>See image below (drawn by Aaron Miller. Many thanks):</p>
 
            <p>VBucket Move Scheduling  
Time</p>
 
    <p>|   /------------\    
|   | Backfill 0 |                       Backfills cannot happen    
|   \------------/                       concurrently.    
|         |             /------------\    
|   +------------+      | Backfill 1 |    
|   | Index File |      \------------/    
|   |     0      |            |    
|   |            |      +------------+   However, indexing _can_ happen    
|   |            |      | Index File |   concurrently with backfills and    
|   |            |      |     1      |   other indexing.    
|   |            |      |            |    
|   +------------+      |            |    
|         |             |            |    
|         |             +------------+    
|         |                   |    
|         \---------+---------/    
|                   |    
|   /--------------------------------\   Compaction for a set of vbucket moves    
|   |  Compact both source and dest. |   cannot happen concurrently with other    
v   \--------------------------------/   vbucket moves.</p>
 
 
  <p>In that image you can see that backfills of 2 vbuckets between same  
pair of nodes cannot happen concurrently, but next phase is  
concurrent, after which there's view compaction on both nodes that  
logically affect both moves (and prevent other concurrent moves)</p>
 
  <p>vbucket moves are picked w.r.t. this 2 constrains and we also have  
heuristics to decide which moves to proceed based on the following  
understanding of goodness:</p>
 
  <p>a) we want to start moving active vbuckets sooner. I.e. prioritize  
moves that change master node and not just replicas. So that  
balance w.r.t. node's load on GETs and SETs is more quickly  
equalized.</p>
 
  <p>b) given that indexer is our bottleneck we want as much as possible
  nodes to do some indexing work all or most of the time</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-action">action() = {move, <a href="#type-move" class="seealso">move()</a>} | {compact, node()}</h3></div>
    <div class="type"><h3 id="type-move">move() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{VBucket :: <a href="#type-vbucket_id" class="seealso">vbucket_id()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChainBefore :: [node() | undefined],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChainAfter :: [node() | undefined]}</h3></div>
    <div class="type"><h3 id="type-vbucket_id">vbucket_id() = integer() &gt;= 0</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="prepare/5">prepare(CurrentMap, TargetMap, BackfillsLimit, MovesBeforeCompaction, InfoLogger) -&gt; term()
</h3>


<div class="description">

<p>prepares state (list of moves etc) based on current and target map</p>
</div></div>
<div class="function">
<h3 id="is_done/1">is_done(State) -&gt; term()
</h3>


<div class="description">

<p>true iff we're done. NOTE: is_done is only valid if
  choose_action returned empty actions list</p>
</div></div>
<div class="function">
<h3 id="choose_action/1">choose_action(State::#state{backfills_limit=undefined | non_neg_integer(), moves_before_compaction=undefined | non_neg_integer(), total_in_flight=non_neg_integer(), moves_left_count_per_node=undefined | dict(), moves_left=undefined | [move()], moves_from_undefineds=undefined | [move()], compaction_countdown_per_node=undefined | dict(), in_flight_backfills_per_node=undefined | dict(), in_flight_per_node=undefined | dict(), in_flight_compactions=undefined | set(), initial_move_counts=undefined | dict(), left_move_counts=undefined | dict()}) -&gt; {[action()], #state{backfills_limit=undefined | non_neg_integer(), moves_before_compaction=undefined | non_neg_integer(), total_in_flight=non_neg_integer(), moves_left_count_per_node=undefined | dict(), moves_left=undefined | [move()], moves_from_undefineds=undefined | [move()], compaction_countdown_per_node=undefined | dict(), in_flight_backfills_per_node=undefined | dict(), in_flight_per_node=undefined | dict(), in_flight_compactions=undefined | set(), initial_move_counts=undefined | dict(), left_move_counts=undefined | dict()}}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="extract_progress/1">extract_progress(State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="note_backfill_done/2">note_backfill_done(State, X2) -&gt; term()
</h3>


<div class="description">

<p>marks backfill phase of previously started move as done. Users
  of this code will call it when backfill is done to update state so
  that next moves can be started.</p>
</div></div>
<div class="function">
<h3 id="note_move_completed/2">note_move_completed(State, X2) -&gt; term()
</h3>


<div class="description">

<p>marks entire move that was previously started done. NOTE: this
  assumes that backfill phase of this move was previously marked as
  done. Users of this code will call it when move is done to update
  state so that next moves and/or compactions can be started.</p>
</div></div>
<div class="function">
<h3 id="note_compaction_done/2">note_compaction_done(State, X2) -&gt; term()
</h3>


<div class="description">

<p>marks previously started compaction as done. Users of this
  code will call it when compaction is done to update state so that
  next moves and/or compactions can be started.</p>
</div></div></div>

<authors>

<aname>Couchbase</aname>
<email>info@couchbase.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
