<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>dns (dns-tools) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>dns</h1>
<h2 class="modsummary">DNS Lookup and utility functions.</h2>
<div class="description">
<p>DNS Lookup and utility functions.</p>
 
  <p>Provides a programmer-friendly API for a number of undocumented OTP  
dns lookup, resolution, caching and configuration functions.</p>
 
  <p>Also provides utility functions for performing lookups while
  bypassing local resolver caching, finding closest parent zones,
  parsing <code>resolv.conf</code> files, simplifying #dns_rec{} answers and more.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-address">address() = ip_address() | {ip_address(), port_no()} | string() | #dns_rr{}</h3></div>
    <div class="type"><h3 id="type-ip_address">ip_address() = {integer(), integer(), integer(), integer()}</h3></div>
    <div class="type"><h3 id="type-port_no">port_no() = integer()</h3></div>
    <div class="type"><h3 id="type-query_option">query_option() = {read_cache, bool()} | {write_cache, bool()} | {timeout, TimeOut::integer()} | {servers, [address()]} | {class, query_class()} | defaults | read_cached</h3></div>
    <div class="type"><h3 id="type-query_options">query_options() = [query_option()]</h3></div>
    <div class="type"><h3 id="type-query_type">query_type() = a | cname | soa | mx | ns | srv | any</h3></div>
    <div class="type"><h3 id="type-resolver">resolver() = {ip_address(), port_no()}</h3></div>
    <div class="type"><h3 id="type-simple_rr">simple_rr() = {Name::string(), query_type(), RRdata::term(), [simple_rr_info()]}</h3></div>
    <div class="type"><h3 id="type-simple_rr_info">simple_rr_info() = {ttl, TimeToLive::integer()} | {class, query_class()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="lookup/1">lookup(Name::string(), Type::query_type()) -&gt; #dns_res{}</h3>


<div class="description">

<p>Query for a DNS record of Type for Name. Uses reasonable default
  options for class (<code>in</code>) timeouts (5s), caching (no caching) and
  nameservers (<code>inet_db</code> defaults).</p>
</div></div>
<div class="function">
<h3 id="lookup/1-1">lookup(Name::string(), Type::query_type(), Options::query_options()) -&gt; #dns_res{}</h3>


<div class="description">

<p>Query for a DNS record of Type for Name. Takes a variety of
  query options.</p>
</div></div>
<div class="function">
<h3 id="lookup/1-2">lookup(Name::string(), Type::query_type(), Servers::NameServers, Timeout::integer()) -&gt; #dns_res{}</h3>

<ul class="type">
<li><code>NameServers = [resolver()]</code></li></ul>
<div class="description">

<p>Query the given Nameservers for a DNS record of Type (class <code>in</code>) for
  Name. Takes a Timeout in milliseconds. Doesn't read or write the
  <code>inet_db</code> RR cache.</p>
</div></div>
<div class="function">
<h3 id="lookup/1-3">lookup(Name::string(), Class::query_class(), Type::query_type(), Servers::[resolver()], Timeout::integer()) -&gt; #dns_res{}</h3>


<div class="description">

<p>Query the given Nameservers for a DNS record of Class, Type for
  Name. Takes a Timeout in milliseconds. Doesn't read or write the
  <code>inet_db</code> RR cache.</p>
</div></div>
<div class="function">
<h3 id="lookup/1-4">lookup(Name::string(), Class::class(), Type::query_type(), Servers::[address()], Timeout::integer(), ReadCache::bool(), WriteCache::bool()) -&gt; #dns_res{}</h3>


<div class="description">

<p>Query the given Nameservers for a DNS record of Class, Type for
  Name. Takes a Timeout in milliseconds. Returns results from the
  <code>inet_db</code> RR cache if available and ReadCache is <code>true</code>. Writes
  successful query answers to the cache if WriteCache is <code>true</code>.</p>
</div></div>
<div class="function">
<h3 id="simplify/1">simplify(E::Result) -&gt; {error, Reason::term()} | [simple_rr()]</h3>

<ul class="type">
<li><code>Result = {ok, #dns_rec{}} | {error, Reason::term()}</code></li></ul>
<div class="description">

<p>Simplify the records returned from lookup to fixed-format
  tuples instead of records.</p>
</div></div>
<div class="function">
<h3 id="lookup_cache/1">lookup_cache(Class::query_class(), Name::string(), Type::query_type()) -&gt; {ok, #dns_rec{}} | {error, Reason::term()}</h3>


<div class="description">

<p>Query <code>inet_db</code> RR cache. Converts the <code>inet_db</code> <code>#hostent{}</code> respone
   into a fake <code>#dns_rec{}</code>.</p>
</div></div>
<div class="function">
<h3 id="cache_lookup/1">cache_lookup(Dns_rec::#dns_rec{}) -&gt; ok</h3>


<div class="description">

<p>Store dns answer resource records in inet_db cache</p>
</div></div>
<div class="function">
<h3 id="resolvers/0">resolvers() -&gt; [resolver()]</h3>


<div class="description">

<p>Returns a list of name servers that can be used as recursive
  resolvers. Resolvers taken from the <code>inet_db</code> <code>namserver</code> setting.</p>
</div></div>
<div class="function">
<h3 id="find_soa/1">find_soa(Name::string()) -&gt; {ok, {SoaName::string(), #dns_rr{}}} | {error, Reason::term()}</h3>


<div class="description">

<p>Recursively climb the ancestry of a domain name to find the
  most specific SOA. (Closest domain delegation/authority)
  Given <code>foo.bar.baz.com</code> would try <code>foo.bar.baz.com</code> then <code>bar.baz.com</code>
  then <code>baz.com</code> and so on.</p>
</div></div>
<div class="function">
<h3 id="domain_exists/1">domain_exists(DomainName::string()) -&gt; bool()</h3>


<div class="description">

<p>Returns <code>true</code> if a name exists and has an SOA record.</p>
</div></div>
<div class="function">
<h3 id="parse_resolv/1">parse_resolv(FileName::string()) -&gt; [ip_address()]</h3>


<div class="description">

<p>Returns a list of nameservers from a POSIX style <code>resolv.conf</code> file.</p>
</div></div>
<div class="function">
<h3 id="nameservers/1">nameservers(Domain::string()) -&gt; [resolver()]</h3>


<div class="description">
<p>Equivalent to <a href="#nameservers/2" class="seealso">nameservers(Domain, [read_cached])</a>.</p>
</div></div>
<div class="function">
<h3 id="nameservers/1-1">nameservers(Domain::string(), Options::query_options()) -&gt; [resolver()]</h3>


<div class="description">

<p>Retrieve the names and addresses of the authoritative
  nameservers for Domain. Will perform one NS lookup if the
  resolving nameserver returns the address records for the queried
  records, otherwise will perform 1 + N lookups (N = number of NS
  records for Domain). Takes a list of query option that will be used
  for NS lookups.</p>
</div></div>
<div class="function">
<h3 id="nameserver_address/1">nameserver_address(IP::address()) -&gt; resolver() | error</h3>


<div class="description">

<p>
  Convert a variety of nameserver address specifications into a
  host-port tuple for use with <code>gen_udp</code> and <code>inet_res</code>.</p>
</div></div>
<div class="function">
<h3 id="direct_lookup/1">direct_lookup(Name::string(), Type::query_type(), Domain::string()) -&gt; #dns_res{}</h3>


<div class="description">

<p>Lookup the given Name/Type against the authoritative NSs for
  Domain. This will bypass nxdomain caching and should result in
  quicker recognition of changed/added records.
  This is mainly intended for checking if people have setup a set of
  DNS records correctly (say for a white-label hosting service).</p>
</div></div></div>

<authors>

<aname>Geoff Cant</aname>
<email>geoff.cant@process-one.net</email>
<aname>Geoff Cant</aname>
<email>nem@erlang.geek.nz</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
