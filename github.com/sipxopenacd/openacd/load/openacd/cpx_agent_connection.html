<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>cpx_agent_connection (openacd) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>cpx_agent_connection</h1>
<h2 class="modsummary">?? at the beginning of thier documentation conform to the form  
above with one caveat:  The first argument is always the internal state  
of the connection, and is obviously not sent with the json requests.</h2>
<div class="description">
<p>?? at the beginning of thier documentation conform to the form  
above with one caveat:  The first argument is always the internal state  
of the connection, and is obviously not sent with the json requests.  
Thus, a properly documented project will be useful to agent connection  
and agent client developers.</p>
 
  <p>Request_id is an opaque type sent by the client; it is sent back with  
the reply to enable asynchronous requests.</p>
 
  <p>A json response will have 3 major forms.</p>
 
  <p>A very simple success:
  </p><pre class="sh_erlang"> {
   "request_id": any(),
  	"success":  true
  }</pre><p>
  A success with a result:
  </p><pre class="sh_erlang"> {
   "request_id": any(),
  	"success":  true,
  	"result":   any()
  }</pre><p>
  A failure:
  </p><pre class="sh_erlang"> {
   "request_id":  any(),
  	"success":  false,
  	"message":  string(),
  	"errcode":  string()
  }</pre>
 
  <p><em><marker id="Events">Events</marker></em></p>
 
  <p>A server event is a json object with at least a "command" property.  If  
the command references a specific agent channel, it will also have a  
"channel_id" property.  All other properties are specific to the server  
events.</p>
 
  <p><em><marker id="Erlang_API">Erlang API</marker></em></p>
 
  <p>There are two sides to the erlang API, the connection facing side (such  
as a web or tcp connection), and the api handler side, such as this  
module or plugins handing agent requests.</p>
 
  <p><em><marker id="Agent_Connections">Agent Connections</marker></em></p>
 
  <p>After the login procedure, init/1 should be called, passing in the agent
  record (prefereably after the connection is set).  If a reply of
  <code>{ok, state()}</code> is returned, stash the state.  It will be used in the  
encode_cast, and handle_json functions.</p>
 
  <p>Both encode_cast and handle_json have the same return types.
  </p><taglist>
  <dt><code>{ok, json(), state()}</code></dt><item><p>If json() is undefined, no json is
  to be sent.  Otherwise the json should be encoded using
  ejrpc2_json:encode/1 and sent over the wire.</p></item>
  <dt><code>{exit, json(), state()}</code></dt><item><p>the connection should commit
  hari-kari.  If json() is undefined, that's all that needs to happen,
  otherwise json should be sent, then death.</p></item>
  </taglist>
 
  <p><em><marker id="Api_Handlers">Api Handlers</marker></em></p>
 
  <p>Modules intended to handle json calls can do so in two ways.  The first
  is to register a hook to <a href="cpx_hooks.html" class="seealso">agent_api_call</a>.  This hook
  is triggered if the module and function with the appropriate arity is
  not found using the method described below.  The valid return values are
  the same as for the static functions.  The hook is triggered with the
  arguments:
  </p><list>
  <item><p><code>Connection :: state()</code>: internal state of connection</p></item>
  <item><p><code>Module :: atom()</code>: Module that was in the json</p></item>
  <item><p><code>Function :: atom()</code>: Function that was in the json</p></item>
  <item><p><code>Args :: [any()]</code>: Arguments list in the json</p></item>
  </list>
 
  <p>The alternative is more efficient, preventing a call to cpx_hooks,
  though there is no custom information passed to the module.  The module
  has an attribute <code>agent_api_functions</code>, which is a list of tuples of
  type <code>{FunctionAtom, Arity}</code>.  The arity must be one more than the  
number of arguments sent with the json request; this is because the  
state of the agent connection is sent as the first argument.</p>
 
  <p>An api handler function (either kind) should return one of the following:
  </p><taglist>
  <dt><code>ok</code></dt><item><p>A simple success json is returned</p></item>
  <dt><code>{ok, json()}</code></dt><item><p>A json success is sent with the given json
  set as the result</p></item>
  <dt><code>{error, bin_string(), bin_string()}}</code></dt><item><p>An error is
  returned</p></item>
  <dt> <code>exit</code></dt><item><p>The connection should exit, likely taking the agent
  fsm with it.  A simple success is returned.</p></item>
  <dt><code>{exit, json()}</code></dt><item><p>The connection should exit, likely taking
  the agent with it.  A success is returned, with the json as the result.
  </p></item>
  </taglist>
 
  <p>Plugins that want to send server events to agents should send one of the
  two arbitrary command messages.
  </p><list>
  <item><p><code>{arbitrary_command, Command, Props}</code></p></item>
  <item><p><code>{arbitrary_command, ChannelPidOrId, Command, Props}</code></p></item>
  </list>
 
  <p>In both cases, <code>Command</code> should be either an atom or binary string.  
Props can be either a json object struct, or a property list that can  
be put into a json object struct.</p>
 
  <p><code>ChannelPidOrId</code> is the channel id either in its pid form, string form,  
or binary string form.  In any form, if the channel does not exist, the  
message is ignored.</p>
 
  <p>When the event is sent, the command property and channelid (if given)  
properties are automatically pre-pended onto the json struct.  The  
result is sent to the connection for encoding and being sent over the  
wire:</p>
 
  <pre class="sh_erlang">{"command": string(),
  "channelid": string(),
  "field1": any(),
  "field2": any(),...
  "fieldN": any()
  }</pre><p>
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-agent_id">agent_id() = undefined | string()</h3></div>
    <div class="type"><h3 id="type-json">json() = {struct, [{binary(), <a href="#type-json" class="seealso">json()</a>}]}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| binary()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| integer()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| float()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<a href="#type-json" class="seealso">json()</a>]</h3></div>
    <div class="type"><h3 id="type-release_bias">release_bias() = -1 | 0 | 1</h3></div>
    <div class="type"><h3 id="type-release_code">release_code() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<a href="#type-release_id" class="seealso">release_id()</a>, <a href="#type-release_label" class="seealso">release_label()</a>, <a href="#type-release_bias" class="seealso">release_bias()</a>}</h3></div>
    <div class="type"><h3 id="type-release_id">release_id() = string()</h3></div>
    <div class="type"><h3 id="type-release_label">release_label() = default | string()</h3></div>
    <div class="type"><h3 id="type-security_level">security_level() = agent | supervisor | admin</h3></div>
    <div class="type"><h3 id="type-state">state() = <a href="cpx_conn_state.html#type-state" class="seealso">cpx_conn_state:state()</a></h3></div>
    <div class="type"><h3 id="type-ts">ts() = integer() &gt;= 1</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="login/1">login(Username::string(), Password::string()) -&gt; {ok, #agent{login=string(), id=undefined | agent_id(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=ts(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, state()} | {error, deny} | {error, duplicate}</h3>


<div class="description">

<p>Attempt a log-in and initialize the state if successful</p>
</div></div>
<div class="function">
<h3 id="start/1">start(Login::string()) -&gt; {ok, #agent{login=string(), id=undefined | agent_id(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=ts(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}, state()} | {error, noagent}</h3>


<div class="description">

<p>Start a given agent by login</p>
</div></div>
<div class="function">
<h3 id="init/1">init(Agent::#agent{login=string(), id=undefined | agent_id(), skills=[atom(), ...], connection=undefined | pid(), profile=string() | error, securitylevel=security_level(), source=undefined | pid(), release_data=release_code() | undefined, available_channels=any(), all_channels=any(), used_channels=any(), endpoints=any(), ring_channel=none | any(), last_change=ts(), start_opts=[any()], log_pid=undefined | pid(), security_level=agent | supervisor | admin}) -&gt; {ok, state()}</h3>


<div class="description">

<p>After the connection has been started, this should be called to
  seed the state.</p>
</div></div>
<div class="function">
<h3 id="encode_cast/1">encode_cast(State::state(), Cast::any()) -&gt; {error, any(), state()} | {ok, json(), state()} | {error, unhandled}</h3>


<div class="description">

<p>When the connection gets a cast it cannot handle, this should be
  called.  It will either return an error, or json to pump out to the
  client.</p>
</div></div>
<div class="function">
<h3 id="handle_json/2">handle_json(State, Bin) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handle_json/3">handle_json(State, Bin, Mods) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
