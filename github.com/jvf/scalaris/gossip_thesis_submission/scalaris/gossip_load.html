<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gossip_load (scalaris) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gossip_load</h1>
<h2 class="modsummary">Gossip based aggregation of load information.</h2>
<div class="description">
<p>Gossip based aggregation of load information.
       This module implements the symmetric push-sum protocol. The algorithm is
       used to compute aggregates of the load information, which is measured as
       the count of items currently in a node's key range. <br />
       The aggregation of load information is used in Scalaris for two purposes:
       First, for passive load balancing. When a node  joins, the gossiped load
       information is used to decide where to place the new node. The node will
       be placed so that the standard deviation of the load is reduced the most.
       Second, the gossiping is used for system monitoring. The local estimates
       of the gossiping can be viewed for example in the Web Interface of every
       Scalaris node. <br />
       Different metrics are computed on the load information:
       </p><list>
           <item><p> average load, the arithmetic mean of all nodes load information </p></item>
           <item><p> the maximum load </p></item>
           <item><p> the minimum load </p></item>
           <item><p> standard deviation of the average load </p></item>
           <item><p> leader based size, based on counting </p></item>
           <item><p> key range bases size, calculated as address space of keys / average key range per node </p></item>
           <item><p> histogram of load per key range (load measured as number of items per node) </p></item>
       </list><p>
       The module is initialised during the startup of the gossiping framework,
       continuously aggregating load information in the background. Additionally,
       is it possible to start instances of the module for the purpose of computing
       different sizes histograms, request_histogram/1.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-avg">avg() = {Value :: float(), Weight :: float()}</h3></div>
    <div class="type"><h3 id="type-avg_kr">avg_kr() = {number(), float()}</h3></div>
    <div class="type"><h3 id="type-bucket">bucket() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Interval :: <a href="intervals.html#type-interval" class="seealso">intervals:interval()</a>, Avg :: <a href="#type-avg" class="seealso">avg()</a> | unknown}</h3></div>
    <div class="type"><h3 id="type-histogram">histogram() = [<a href="#type-bucket" class="seealso">bucket()</a>]</h3></div>
    <div class="type"><h3 id="type-instance">instance() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Module :: gossip_load, Id :: atom() | <a href="uid.html#type-global_uid" class="seealso">uid:global_uid()</a>}</h3></div>
    <div class="type"><h3 id="type-load_data">load_data() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{load_data,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avg :: <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avg2 :: <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SizeInv :: <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AvgKr :: <a href="#type-avg_kr" class="seealso">avg_kr()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Histogram :: <a href="#type-histogram" class="seealso">histogram()</a>}</h3></div>
    <div class="type"><h3 id="type-load_info">load_info()</h3></div>
    <div class="type"><h3 id="type-state">state() = <a href="ets.html#type-tab" class="seealso">ets:tab()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="trigger_interval/0">trigger_interval() -&gt; pos_integer()</h3>


<div class="description">

<p>The time interval in ms after which a new cycle is trigger by the behaviour
       module.</p>
</div></div>
<div class="function">
<h3 id="fanout/0">fanout() -&gt; pos_integer()</h3>


<div class="description">

<p>The fanout (number of peers contacted per cycle).</p>
</div></div>
<div class="function">
<h3 id="min_cycles_per_round/0">min_cycles_per_round() -&gt; non_neg_integer()</h3>


<div class="description">

<p>The minimum number of cycles per round.
       Only full cycles (i.e. received replies) are counted (ignored triggers
       do not count as cycle).
       Only relevant for leader, all other nodes enter rounds when told to do so.</p>
</div></div>
<div class="function">
<h3 id="max_cycles_per_round/0">max_cycles_per_round() -&gt; pos_integer()</h3>


<div class="description">

<p>The maximum number of cycles per round.
       Only full cycles (i.e. received replies) are counted (ignored triggers
       do not count as cycle).
       Only relevant for leader, all other nodes enter rounds when told to do so.</p>
</div></div>
<div class="function">
<h3 id="check_config/0">check_config() -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="request_histogram/1">request_histogram(Size::pos_integer(), SourceId::mypid() (see module comm)) -&gt; ok</h3>


<div class="description">

<p>Request a histogram with Size number of Buckets. <br />
       The resulting histogram will be sent to SourceId, when all values have
       properly converged.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(Instance::instance()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Initiate the gossip_load module. <br />
       Called by the gossip module upon startup. <br />
       Instance makes the module aware of its own instance id, which is saved
       in the state of the module.</p>
</div></div>
<div class="function">
<h3 id="init/1-1">init(Instance::instance(), NoOfBuckets::non_neg_integer()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Initiate the gossip_load module. <br />
       Used by gossip:start_gossip_task().
       NoOfBuckets defines the size of the histogram calculated.</p>
</div></div>
<div class="function">
<h3 id="init/1-2">init(Instance::instance(), NoOfBuckets::non_neg_integer(), Requestor::mypid() (see module comm) | none) -&gt; {ok, state()}</h3>


<div class="description">

<p>Initiate the gossip_load module. <br />
       Used for request_histogram/1 (called by the gossip module). <br />
       the calculated histogram will be sent to the requestor.</p>
</div></div>
<div class="function">
<h3 id="select_node/1">select_node(State::state()) -&gt; {boolean(), state()}</h3>


<div class="description">

<p>Returns false, i.e. peer selection is done by gossip module.
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="select_data/1">select_data(State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Select and prepare the load information to be sent to the peer. <br />
       Called by the gossip module at the beginning of every cycle. <br />
       The selected exchange data is sent back to the gossip module as a message
       of the form {selected_data, Instance, ExchangeData}.
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="select_reply_data/1">select_reply_data(PData::load_data(), Ref::pos_integer(), RoundStatus::round_status() (see module gossip_beh), Round::non_neg_integer(), State::state()) -&gt; {discard_msg | ok | retry | send_back, state()}</h3>


<div class="description">

<p>Process the data from the requestor and select reply data. <br />
       Called by the behaviour module upon a p2p_exch message. <br />
       PData: exchange data from the p2p_exch request <br />
       Ref: used by the gossip module to identify the request <br />
       RoundStatus / Round: round information used for special handling of
           messages from previous rounds <br />
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="integrate_data/1">integrate_data(QData::load_data(), RoundStatus::round_status() (see module gossip_beh), Round::non_neg_integer(), State::state()) -&gt; {discard_msg | ok | retry | send_back, state()}</h3>


<div class="description">

<p>Integrate the reply data. <br />
       Called by the behaviour module upon a p2p_exch message. <br />
       QData: the reply data from the peer <br />
       RoundStatus / Round: round information used for special handling of
           messages from previous rounds <br />
       State: the state of the gossip_load module <br />
       Upon finishing the processing of the data, a message of the form
       {integrated_§data, Instance, RoundStatus} is to be sent to the gossip module.</p>
</div></div>
<div class="function">
<h3 id="handle_msg/2">handle_msg(Message::{get_state_response, DHTNodeState::state() (see module dht_node_state)}, State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Handle get_state_response messages from the dht_node. <br />
       The received load information is stored and the status is set to init,
       allowing the start of a new gossip round.
       State: the state of the gossip_load module <br /></p>
</div></div>
<div class="function">
<h3 id="round_has_converged/1">round_has_converged(State::state()) -&gt; {boolean(), state()}</h3>


<div class="description">

<p>Checks if the current round has converged yer <br />
       Returns true if the round has converged, false otherwise.</p>
</div></div>
<div class="function">
<h3 id="notify_change/2">notify_change(Keyword::new_round, NewRound::non_neg_integer(), State::state()) -&gt; {ok, state()}</h3>


<div class="description">

<p>Notifies the gossip_load module about changes. <br />
       Changes can be one of the following:
       </p><list>
           <item> new_round <br />
                Notifies the the callback module about the beginning of round </item>
           <item> leader <br />
                Notifies the the callback module about a change in the key range
                of the node. The MsgTag indicates whether the node is a leader
                or not, the NewRange is the new key range of the node. </item>
           <item> exch_failure <br />
                Notifies the the callback module about a failed message delivery,
                including the exchange data and round from the original message. </item>
       </list>
</div></div>
<div class="function">
<h3 id="get_values_best/1">get_values_best(State::state()) -&gt; {load_info(), state()}</h3>


<div class="description">

<p>Returns the best aggregation result. <br />
       Called by the gossip module upon {get_values_best} messages.
       Returns either the aggregation restult from the current or previous round,
       depending on convergence_count_best_values. <br />
       State: the state of the gossip_load module.</p>
</div></div>
<div class="function">
<h3 id="get_values_all/1">get_values_all(State::state()) -&gt; {{PreviousInfo::load_info(), CurrentInfo::load_info(), BestInfo::load_info()}, NewState::state()}</h3>


<div class="description">

<p>Returns all aggregation results. <br />
       Called by the gossip module upon {get_values_all} messages.
       Returns the aggregation restult from a) the previous, b) the current
       and c) the best round (current or previous).
       State: the state of the gossip_load module.</p>
</div></div>
<div class="function">
<h3 id="web_debug_info/1">web_debug_info(State::state()) -&gt; {KeyValueList::[{Key::any(), Value::any()}, ...], NewState::state()}</h3>


<div class="description">

<p>Returns a key-value list of debug infos for the Web Interface. <br />
       Called by the gossip module upon {web_debug_info} messages.
       State: the state of the gossip_load module.</p>
</div></div>
<div class="function">
<h3 id="shutdown/1">shutdown(State::state()) -&gt; {ok, state_deleted}</h3>


<div class="description">

<p>Shutd down the gossip_load module. <br />
       Called by the gossip module upon stop_gossip_task(CBModule).
       Deletes both the current and the previous state.</p>
</div></div>
<div class="function">
<h3 id="load_info_get/2">load_info_get(Key::avgLoad, LoadInfoRecord::load_info()) -&gt; unknown | float()</h3>


<div class="description">

<p>Gets the value to the given key from the given load_info record.</p>
</div></div>
<div class="function">
<h3 id="tester_create_state/10">tester_create_state(ConvCount, Leader, LoadData, Merged, Range, Round, Status, NoOfBuckets, Request, Instance) -&gt; state()</h3>

<ul class="type">
<li><code>ConvCount = non_neg_integer()</code></li><li><code>Leader = boolean()</code></li><li><code>LoadData = load_data()</code></li><li><code>Merged = non_neg_integer()</code></li><li><code>Range = non_empty_interval() (see module intervals)</code></li><li><code>Round = non_neg_integer()</code></li><li><code>Status = init | uninit</code></li><li><code>NoOfBuckets = 1..50</code></li><li><code>Request = boolean()</code></li><li><code>Instance = instance()</code></li></ul>
<div class="description">

<p>Creates a random state() table within the given type specifications.
       Used as value_creator in tester.erl (property testing).</p>
</div></div>
<div class="function">
<h3 id="is_state/1">is_state(State::tab() (see module ets)) -&gt; boolean()</h3>


<div class="description">

<p>Checks if a given ets table is a valid state.
       Used as type_checker in tester.erl (property testing).</p>
</div></div>
<div class="function">
<h3 id="tester_create_histogram/1">tester_create_histogram(ListOfAvgs::[avg() | unknown]) -&gt; histogram()</h3>


<div class="description">

<p>Creates a histogram() within the specifications of this modules, i.e.
       in particular that all histograms need to have the same keys
       (keyrange/no_of_buckets).</p>
</div></div>
<div class="function">
<h3 id="is_histogram/1">is_histogram(Histogram::[{interval() (see module intervals), avg()}]) -&gt; boolean()</h3>


<div class="description">

<p>Checks if a given list is a valid histogram.
       Used as type_checker in tester.erl (property testing).</p>
</div></div></div>

<authors>

<aname>Jens V. Fischer</aname>
<email>jensvfischer@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
