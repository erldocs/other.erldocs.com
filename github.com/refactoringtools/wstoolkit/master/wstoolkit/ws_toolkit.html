<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>ws_toolkit (wstoolkit) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>ws_toolkit</h1>
<h2 class="modsummary"/>
<div class="description">
</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-url">url() = string()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="write_eqc_statem/1">write_eqc_statem(WsdlFile::filename() (see module file) | none, XsdFile::filename() (see module file), HrlFile::filename() (see module file) | none, SUT::filename() (see module file), Style::{grouping, tuple} | {grouping, non_tuple} | {non_grouping, tuple} | {non_grouping, non_tuple}, OutFile::filename() (see module file)) -&gt; ok | {error, Error::term()}</h3>


<div class="description">

<p>Generate the initial <code>eqc_statem</code> test module. This function
      takes the WSDL specification of the web service, the XSD schema,
      the .hrl file containing the type definitions, or <code>none</code> if no
      .hrl file is needed, and the name of the connector module as input,
      and writes the <code>eqc_statem</code> module generated to <code>OutFile</code>.
      This function assumes that the WSDL file follows wsdl2.0 standard.</p>
</div></div>
<div class="function">
<h3 id="write_eqc_statem/1-1">write_eqc_statem(WsdlFile::filename() (see module file) | none, XsdFile::filename() (see module file), SUT::filename() (see module file), Style::{grouping, tuple} | {grouping, non_tuple} | {non_grouping, tuple} | {non_grouping, non_tuple}, OutFile::filename() (see module file)) -&gt; ok | {error, Error::term()}</h3>


<div class="description">

<p>Generate the initial <code>eqc_statem</code> test module without using a <code>.hrl</code> file.</p>
</div></div>
<div class="function">
<h3 id="write_sut_api/1">write_sut_api(HrlFile::filename() (see module file) | none, WsdlFile::filename() (see module file), XsdFile::filename() (see module file), BaseURL::url(), OutFile::filename() (see module file)) -&gt; ok | {error, Error::term()}</h3>


<div class="description">

<p>Generate the WS connector module. The WS connector module
      defines a collection of connector functions that are used by
      QuickCheck to invoke web service operations. There is a connector
      function defined for each web service operation.
      This function takes the the .hrl file containing type definitions,
      the WSDL specification, the XSD schema, and the base url for the
      web service as input, and writes the connector module generated to
      <code>OutFile</code>.
      Note: Some utility functions are added to the module generated, but
      in some cases not all the utility functions are used by the connector
      functions. This should be improved.</p>
</div></div>
<div class="function">
<h3 id="write_sut_api/1-1">write_sut_api(WsdlFile::filename() (see module file), XsdFile::filename() (see module file), BaseURL::url(), OutFile::filename() (see module file)) -&gt; ok | {error, Error::term()}</h3>


<div class="description">

<p>Generate the WS connector module without using a <code>.hrl</code> file.</p>
</div></div>
<div class="function">
<h3 id="write_hrl_file/1">write_hrl_file(XsdFile::filename() (see module file), OutFile::filename() (see module file)) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Generate type definitions. This function takes an .xsd file as input,
      generates the Erlang representation of types, and write the results to
      <code>OutFile</code>. The <code>erlsom</code> library is used to parse .xsd files, however
      <code>erlsom</code> has certain limitations, for instance in Erlsom, all restrictions
      on simple types are ignored, and those types are treated as 'string'. As
      a result, some of the types generated might not be as accurate as needed.</p>
</div></div>
<div class="function">
<h3 id="gen_diff/1">gen_diff(X1::{OldWsdl::filename() (see module file), Oldxsd::filename() (see module file)}, X2::{NewWsdl::filename() (see module file), NewXsd::filename() (see module file)}) -&gt; {ok, [term()], [term()]}</h3>


<div class="description">

<p>This funtions tries to infer the API changes between two versions
      of the web service specification. It takes the WSDL and XSD specification
      of both versions, and reports what has been changed from the first
      version to the second version.So far, the changes this tool is able to
      report include: the adding/removing of WS APIs, renaming of APIs,
      adding/removing of API parameters, renaming of API parameters, as
      well as parameter type changes.</p>
</div></div>
<div class="function">
<h3 id="gen_refac_script/1">gen_refac_script(X1::{OldWsdl::filename() (see module file), Oldxsd::filename() (see module file)}, X2::{NewWsdl::filename() (see module file), NewXsd::filename() (see module file)}, OutFile::filename() (see module file)) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Infer the API changes between two versions of the web service
      specification, and generate a refactoring script that can be
      applied to the existing <code>eqc_statem</code> test model. The current
      implementation ignores type changes.</p>
</div></div></div>

<authors>

<aname>Huiqing Li</aname>
<email>H.Li@kent.ac.uk</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
