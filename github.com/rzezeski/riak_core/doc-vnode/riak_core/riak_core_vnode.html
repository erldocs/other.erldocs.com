<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_core_vnode (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_core_vnode</h1>
<h2 class="modsummary">Riak Virtual Node behaviour.</h2>
<div class="description">
<p>Riak Virtual Node behaviour.</p>
 
  <p><em><marker id="Callbacks">Callbacks</marker></em></p>
 
  <p><em><marker id="Module:init([Index])_->_Result">Module:init([Index]) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  Index = int() &gt;= 0
  Result = {ok, State}
  State = term()</pre>
 
  <p>This function is called by the vnode process to build the initial  
state.</p>
 
  <p>Index is the partition index assigned to this vnode.  The init
  function must return <code>{ok, State}</code> where <code>State</code> is the internal  
state of the vnode.</p>
 
 
  <p><em><marker id="Module:handle_command(Request,_Sender,_State)_->_Result">Module:handle_command(Request, Sender, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  Request = vnode_req()
  Sender = sender()
  State = NewState = term()
  Result -&gt; {reply, Reply, NewState}
            | {noreply, NewState}
            | {stop, Reason, NewState}</pre>
 
  <p>TODO Talk about return types and defined Reply and Reason types.</p>
 
  <p>This function is called by <code>riak_core_vnode</code> when it's been sent a
  command to execute.  A command can be issued several ways:
  <code>riak_core_vnode:send_command/2</code>,
  <code>riak_core_vnode:send_command_after/2</code> or even rely on the fact
  that a vnode is a <code>gen_fsm</code> underneath and send via
  <code>gen_fsm:send_event/2</code>.</p>
 
  <p><code>Request</code> can be any term (typically a record) and represents an  
action to be performed.</p>
 
  <p><code>Sender</code> is a representation of where the request originated from  
and can be used to send a reply.</p>
 
  <p><code>State</code> is the internal state of the vnode.</p>
 
 
  <p><em><marker id="Module:handoff_starting(TargetNode,_State)_->_Result">Module:handoff_starting(TargetNode, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  TargetNode =
  Result = {true, NewState} | {false, NewState}
  State = NewState = term()</pre>
 
  <p>This function is called when if it is determined that this  
particular vnode is not located on the proper physical node.  E.g.,  
when a new node is added to the cluster and the vnodes must be  
redistributed.</p>
 
  <p>As input it gets the <code>TargetNode</code> which is the node that the vnode  
should be located on and state is the internal vnode state.</p>
 
  <p>This function should return <code>{true, NewState}</code> to indicate that
  handoff should indeed occur or <code>{false, NewState}</code> to indicate that  
handoff should be deferred for now.</p>
 
 
  <p><em><marker id="Module:handoff_cancelled(State)_->_Result">Module:handoff_cancelled(State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  State = NewState = term()
  Result = {ok, NewState}</pre>
 
  <p>This function is called if it's determined that the max allowed  
number of concurrent handoffs has already been reached.</p>
 
  <p>This function should return <code>{ok, NewState}</code> to indicate a  
successful cancel.</p>
 
 
  <p><em><marker id="Module:handle_handoff_command(Request,_Sender,_State)_->_Result">Module:handle_handoff_command(Request, Sender, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  Request = vnode_req()
  Sender = sender()
  State = NewState = term()
  Result = {reply, Reply, NewState}
         | {noreply, NewState}
         | {forward, NewState}
         | {drop, NewState}
         | {stop, Reason, NewState}</pre>
 
  <p>TODO Document.</p>
 
 
  <p><em><marker id="Module:handle_handoff_data(BinObj,_State)_->_Result">Module:handle_handoff_data(BinObj, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  BinObj = binary()
  State = NewState = term()
  Result = {reply, ok, NewState}
         | {reply, {error, Error}, NewState}</pre>
 
  <p>This function is called when the vnode is given handoff data.  The
  BinOjb is a binary and is the result of calling
  <code>encode_handoff_item/2</code>.</p>
 
  <p>This function should return <code>{reply, ok, NewState}</code> if the handoff
  was successful otherwise it should return <code>{reply, {error, Error},
  NewState}</code> in the case of an error.</p>
 
 
  <p><em><marker id="Module:encode_handoff_item(K,_V)_->_Result">Module:encode_handoff_item(K, V) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  K = {Bucket, Key}
  Bucket = riak_object:bucket()
  Key = riak_object:key()
  V = term()
  Result -&gt; binary()</pre>
 
  <p>This function is called by riak_core's handoff mechanism in order  
to encode the data before it crosses the wire.</p>
 
  <p>N.B. This function works in conjunction with
  <code>handle_handoff_data/2</code> and should encode the data in such a way
  that <code>handle_handoff_data/2</code> can pull it apart.</p>
 
 
  <p><em><marker id="Module:handoff_finished(TargetNode,_State)_->_Result">Module:handoff_finished(TargetNode, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  TargetNode = node()
  State = NewState = term()
  Result = {ok, NewState}</pre>
 
  <p>This function is called when the vnode is finished handing-off it's
  data to the <code>TargetNode</code>.</p>
 
  <p>This function should return <code>{ok, NewState}</code> to indicate it has  
successfully finished.</p>
 
 
  <p><em><marker id="Module:is_empty(State)_->_Result">Module:is_empty(State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  State = NewState = term()
  Result = {true, NewState} | {false, NewState}</pre>
 
  <p>When handoff is initiated the first thing the vnode does is  
determine if there is anything to actually hand off.</p>
 
  <p>This function should return <code>{true, NewState}</code> if there is nothing
  to hand off or <code>{false, NewState}</code> otherwise.</p>
 
 
  <p><em><marker id="Module:terminate(Reason,_State)_->_Result">Module:terminate(Reason, State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  Reason = normal | shutdown | {shutdown, term()} | term()
  State = Result = term()</pre>
 
  <p>This function is called when the vnode is about to terminate.  The
  <code>Reason</code> will depend on why it's being terminated, you can find out  
more by reading the gen_fsm doc.</p>
 
  <p>The return value of this function is ignored.</p>
 
 
  <p><em><marker id="Module:delete(State)_->_Result">Module:delete(State) -&gt; Result</marker></em></p>
 
  <pre class="sh_erlang">  State = NewState = term()
  Result = {ok, NewState}</pre>
 
  <p>When handoff determines there is no more data to be transfered from
  this node via <code>is_empty/1</code> it calls this function to delete the  
vnode.  This allows the vnode to clean up after itself.</p>
 
  <p>This function should return <code>{ok, NewState}</code> to indicate a
  successful delete.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-sender">sender() = {<a href="#type-sender_type" class="seealso">sender_type()</a>, reference(), pid()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {server, undefined, undefined}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {fsm, undefined, pid()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ignore</h3></div>
    <div class="type"><h3 id="type-sender_type">sender_type() = fsm | server | raw</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="start_link/2">start_link(Mod, Index) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="start_link/3">start_link(Mod, Index, InitialInactivityTimeout) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="send_command/2">send_command(Pid, Request) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="send_command_after/1">send_command_after(Time::integer(), Request::term()) -&gt; reference()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_mod_index/1">get_mod_index(VNode) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="reply/1">reply(X1::sender(), Reply::term()) -&gt; true</h3>


<div class="description">

<p>Send a reply to a vnode request.  If
       the Ref is undefined just send the reply
       for compatibility with pre-0.12 requestors.
       If Ref is defined, send it along with the
       reply.
 </p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
