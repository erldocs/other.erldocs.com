<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper</h1>
<h2 class="modsummary">This is the main PropEr module.</h2>
<div class="description">
<p>This is the main PropEr module.</p>
  
   <em><marker id="How_to_write_properties">How to write properties</marker></em><p>
   The simplest properties that PropEr can test consist of a single boolean
   expression (or a statement block that returns a boolean), which is expected
   to evaluate to <code>true</code>. Thus, the test <code>true</code> always succeeds, while the test
   <code>false</code> always fails (the failure of a property may also be signified by   
throwing an exception, error or exit. More complex (and useful) properties   
can be written by wrapping such a boolean expression with one or more of the   
following wrappers:</p>
  
   <taglist>
   <dt><code>?FORALL(&lt;Xs&gt;, &lt;Xs_type&gt;, &lt;Prop&gt;)</code></dt>
   <item><p>The <code>&lt;Xs&gt;</code> field can either be a single variable, a tuple of variables
     or a list of variables. The <code>&lt;Xs_type&gt;</code> field must then be a single type,
     a tuple of types of the same length as the tuple of variables or a list
     of types of the same length as the list of variables, respectively.
     Tuples and lists can be combined in any way, as long as <code>&lt;Xs&gt;</code> and
     <code>&lt;Xs_type&gt;</code> are compatible. Both PropEr-provided types, as listed in the
     <a href="proper_types.html" class="seealso">proper_types</a> module, and types declared in Erlang's built-in
     typesystem (we will refer to such types in as <em>native types</em>) may
     be used in the <code>&lt;Xs_type&gt;</code> field. The use of native types in <code>?FORALL</code>s is
     subject to some limitations, as described in the documentation for the
     <a href="proper_typeserver.html" class="seealso">proper_typeserver</a> module. All the variables inside <code>&lt;Xs&gt;</code> can
     (and should) be present as free variables inside the wrapped property
     <code>&lt;Prop&gt;</code>. When a <code>?FORALL</code> wrapper is encountered, a random instance of
     <code>&lt;Xs_type&gt;</code> is produced and each variable in <code>&lt;Xs&gt;</code> is replaced inside
     <code>&lt;Prop&gt;</code> by its corresponding instance.</p></item>
   <dt><code>?IMPLIES(&lt;Precondition&gt;, &lt;Prop&gt;)</code></dt>
   <item><p>This wrapper only makes sense when in the scope of at least one
     <code>?FORALL</code>. The <code>&lt;Precondition&gt;</code> field must be a boolean expression or a
     statement block that returns a boolean. If the precondition evaluates to
     <code>false</code> for the variable instances produced in the enclosing <code>?FORALL</code>
     wrappers, the test case is rejected (it doesn't count as a failing test
     case), and PropEr starts over with a new random test case. Also, in
     verbose mode, an <code>x</code> is printed on screen.</p></item>
   <dt><code>?WHENFAIL(&lt;Action&gt;, &lt;Prop&gt;)</code></dt>
   <item><p>The <code>&lt;Action&gt;</code> field should contain an expression or statement block
     that produces some side-effect (e.g. prints something to the screen).
     In case this test fails, <code>&lt;Action&gt;</code> will be executed. Note that the output
     of such actions is not affected by the verbosity setting of the main
     application.</p></item>
   <dt><code>?TRAPEXIT(&lt;Prop&gt;)</code></dt>
   <item><p>If the code inside <code>&lt;Prop&gt;</code> spawns and links to a process that dies
     abnormally, PropEr will catch the exit signal and treat it as a test
     failure, instead of crashing. <code>?TRAPEXIT</code> cannot contain any more
     wrappers.</p></item>
   <dt><code>?TIMEOUT(&lt;Time_limit&gt;, &lt;Prop&gt;)</code></dt>
   <item><p>Signifies that <code>&lt;Prop&gt;</code> should be considered failing if it takes more
     than <code>&lt;Time_limit&gt;</code> milliseconds to return. The purpose of this wrapper is
     to test code that may hang if something goes wrong. <code>?TIMEOUT</code> cannot
     contain any more wrappers.</p></item>
   <dt><code>conjunction(&lt;SubProps&gt;)</code></dt>
   <item><p>See the documentation for <a href="#conjunction/1" class="seealso">conjunction/1</a>.</p></item>
   <dt><code>equals(&lt;A&gt;, &lt;B&gt;)</code></dt>
   <item><p>See the documentation for <a href="#equals/2" class="seealso">equals/2</a>.</p></item>
   </taglist>
  
   <p>There are also multiple wrappers that can be used to collect statistics on   
the distribution of test data:</p>
  
   <list>
   <item><p><a href="#collect/2" class="seealso">collect/2</a></p></item>
   <item><p><a href="#collect/3" class="seealso">collect/3</a></p></item>
   <item><p><a href="#aggregate/2" class="seealso">aggregate/2</a></p></item>
   <item><p><a href="#aggregate/3" class="seealso">aggregate/3</a></p></item>
   <item><p><a href="#classify/3" class="seealso">classify/3</a></p></item>
   <item><p><a href="#measure/3" class="seealso">measure/3</a></p></item>
   </list>
  
   <p><span id="external-wrappers"/>   
A property may also be wrapped with one or more of the following outer-level   
wrappers, which control the behaviour of the testing subsystem. If an   
outer-level wrapper appears more than once in a property, the innermost   
instance takes precedence.</p>
  
   <list>
   <item><p><a href="#numtests/2" class="seealso">numtests/2</a></p></item>
   <item><p><a href="#fails/2" class="seealso">fails/2</a></p></item>
   <item><p><a href="#on_output/2" class="seealso">on_output/2</a></p></item>
   </list>
  
   <p>For some actual usage examples, see the code in the examples directory, or   
check out PropEr's site. The testing modules in the tests directory may also   
be of interest.</p>
  
   <em><marker id="Program_behaviour">Program behaviour</marker></em><p>
   When running in verbose mode (this is the default), each sucessful test
   prints a '.' on screen. If a test fails, a '!' is printed, along with the
   failing test case (the instances of the types in every <code>?FORALL</code>) and the
   cause of the failure, if it was not simply the falsification of the
   property.
   Then, unless the test was expected to fail, PropEr attempts to produce a
   minimal test case that fails the property in the same way. This process is
   called <em>shrinking</em>. During shrinking, a '.' is printed for each   
successful simplification of the failing test case. When PropEr reaches its   
shrinking limit or realizes that the instance cannot be shrunk further while   
still failing the test, it prints the minimal failing test case and failure   
reason and exits.</p>
  
   <p>The return value of PropEr can be one of the following:</p>
  
   <list>
   <item><p><code>true</code>: The property held for all valid produced inputs.</p></item>
   <item><p><code>false</code>: The property failed for some input.</p></item>
   <item><p><code>{error, &lt;Type_of_error&gt;}</code>: An error occured; see the <a href="#Errors" class="seealso">Errors</a>
     section for more information.</p></item>
   </list>
  
   <p>To test all properties exported from a module (a property is a 0-arity
   function whose name begins with <code>prop_</code>), you can use <a href="#module/1" class="seealso">module/1</a> or
   <a href="#module/2" class="seealso">module/2</a>. This returns a list of all failing properties, represented
   by MFAs. Testing progress is also printed on screen (unless quiet mode is
   active). The provided options are passed on to each property, except for
   <code>long_result</code>, which controls the return value format of the <code>module</code>   
function itself.</p>
  
   <em><marker id="Counterexamples">Counterexamples</marker></em><p>
   A counterexample for a property is represented as a list of terms; each such
   term corresponds to the type in a <code>?FORALL</code>. The instances are provided in
   the same order as the <code>?FORALL</code> wrappers in the property, i.e. the instance
   at the head of the list corresponds to the outermost <code>?FORALL</code> etc.   
Instances generated inside a failing sub-property of a conjunction are   
marked with the sub-property's tag.</p>
  
   <p>The last (simplest) counterexample produced by PropEr during a (failing) run
   can be retrieved after testing has finished, by running
   <a href="#counterexample/0" class="seealso">counterexample/0</a>. When testing a whole module, run
   <a href="#counterexamples/0" class="seealso">counterexamples/0</a> to get a counterexample for each failing property,
   as a list of <code>{mfa(),</code><code>counterexample()</code><code>}</code> tuples. To enable this
   functionality, some information has to remain in the process dictionary
   even after PropEr has returned. If, for some reason, you want to completely
   clean up the process dictionary of PropEr-produced entries, run
   <a href="#clean_garbage/0" class="seealso">clean_garbage/0</a>.</p>
  
   <p>Counterexamples can also be retrieved by running PropEr in long-result mode,
   where counterexamples are returned as part of the return value.
   Specifically, when testing a single property under long-result mode
   (activated by supplying the option <code>long_result</code>, or by calling
   <a href="#counterexample/1" class="seealso">counterexample/1</a> or <a href="#counterexample/2" class="seealso">counterexample/2</a> instead of
   <a href="#quickcheck/1" class="seealso">quickcheck/1</a> and <a href="#quickcheck/2" class="seealso">quickcheck/2</a> respectively), PropEr will
   return a counterexample in case of failure (instead of simply returning
   <code>false</code>). When testing a whole module under long-result mode (activated by
   supplying the option <code>long_result</code> to <a href="#module/2" class="seealso">module/2</a>), PropEr will return
   a list of <code>{mfa(),</code><code>counterexample()</code><code>}</code> tuples, one for each failing   
property.</p>
  
   <p>You can re-check a specific counterexample against the property that it
   previously falsified by running <a href="#check/2" class="seealso">check/2</a> or <a href="#check/3" class="seealso">check/3</a>. This   
will return one of the following (both in short- and long-result mode):</p>
  
   <list>
   <item><p><code>true</code>: The property now holds for this test case.</p></item>
   <item><p><code>false</code>: The test case still fails (although not necessarily for the
     same reason as before).</p></item>
   <item><p><code>{error, &lt;Type_of_error&gt;}</code>: An error occured - see the <a href="#Errors" class="seealso">Errors</a>
     section for more information.</p></item>
   </list>
  
   <p>Proper will not attempt to shrink the input in case it still fails the   
property. Unless silent mode is active, PropEr will also print a message on   
screen, describing the result of the re-checking. Note that PropEr can do   
very little to verify that the counterexample actually corresponds to the   
property that it is tested against.</p>
  
   <em><marker id="Options">Options</marker></em><p>
   Options can be provided as an extra argument to most testing functions (such
   as <a href="#quickcheck/1" class="seealso">quickcheck/1</a>). A single option can be written stand-alone, or
   multiple options can be provided in a list. When two settings conflict, the
   one that comes first in the list takes precedence. Settings given inside
   external wrappers to a property (see the <a href="#How_to_write_properties" class="seealso">How to write properties</a>   
section) override any conflicting settings provided as options.</p>
  
   <p>The available options are:</p>
  
   <taglist>
   <dt><code>quiet</code></dt>
   <item><p>Enables quiet mode - no output is printed on screen while PropEr is
     running.</p></item>
   <dt><code>verbose</code></dt>
   <item><p>Enables verbose mode - this is the default mode of operation.</p></item>
   <dt><code>{to_file, &lt;IO_device&gt;}</code></dt>
   <item><p>Redirects all of PropEr's output to <code>&lt;IO_device&gt;</code>, which should be an
     IO device associated with a file opened for writing.</p></item>
   <dt><code>{on_output, &lt;Output_function&gt;}</code></dt>
   <item><p>PropEr will use the supplied function for all output printing. This
     function should accept two arguments in the style of <code>io:format/2</code>.<br />
     CAUTION: The above output control options are incompatible with each
     other.</p></item>
   <dt><code>long_result</code></dt>
   <item><p>Enables long-result mode (see the <a href="#Counterexamples" class="seealso">Counterexamples</a> section
     for details).</p></item>
   <dt><code>{numtests, &lt;Positive_number&gt;}</code> or simply <code>&lt;Positive_number&gt;</code></dt>
   <item><p>This is equivalent to the <a href="#numtests/1" class="seealso">numtests/1</a> property wrapper. Any
     <a href="#numtests/1" class="seealso">numtests/1</a> wrappers in the actual property will overwrite this
     setting.</p></item>
   <dt><code>{start_size, &lt;Size&gt;}</code></dt>
   <item><p>Specifies the initial value of the <code>size</code> parameter (default is 1), see
     the documentation of the <a href="proper_types.html" class="seealso">proper_types</a> module for details.</p></item>
   <dt><code>{max_size, &lt;Size&gt;}</code></dt>
   <item><p>Specifies the maximum value of the <code>size</code> parameter (default is 42), see
     the documentation of the <a href="proper_types.html" class="seealso">proper_types</a> module for details.</p></item>
   <dt><code>{max_shrinks, &lt;Non_negative_number&gt;}</code></dt>
   <item><p>Specifies the maximum number of times a failing test case should be
     shrunk before returning. Note that the shrinking may stop before so many
     shrinks are achieved if the shrinking subsystem deduces that it cannot
     shrink the failing test case further. Default is 500.</p></item>
   <dt><code>noshrink</code></dt>
   <item><p>Instructs PropEr to not attempt to shrink any failing test cases.</p></item>
   <dt><code>{constraint_tries, &lt;Positive_number&gt;}</code></dt>
   <item><p>Specifies the maximum number of tries before the generator subsystem
     gives up on producing an instance that satisfies a <code>?SUCHTHAT</code>
     constraint. Default is 50.</p></item>
   <dt><code>fails</code></dt>
   <item><p>This is equivalent to the <a href="#fails/1" class="seealso">fails/1</a> property wrapper.</p></item>
   <dt><code>{spec_timeout, infinity | &lt;Non_negative_number&gt;}</code></dt>
   <item><p>When testing a spec, PropEr will consider an input to be failing if the
     function under test takes more than the specified amount of milliseconds
     to return for that input.</p></item>
   <dt><code>any_to_integer</code></dt>
   <item><p>All generated instances of the type <a href="proper_types.html#any/0" class="seealso">proper_types:any/0</a> will be
     integers. This is provided as a means to speed up the testing of specs,
     where <code>any()</code> is a commonly used type (see the <a href="#Spec_testing" class="seealso">Spec testing</a>
     section for details).</p></item>
   </taglist>
  
   <em><marker id="Spec_testing">Spec testing</marker></em><p>
   You can test the accuracy of an exported function's spec by running
   <a href="#check_spec/1" class="seealso">check_spec/1</a> or <a href="#check_spec/2" class="seealso">check_spec/2</a>.   
Under this mode of operation, PropEr will call the provided function with   
increasingly complex valid inputs (according to its spec) and test that no   
unexpected value is returned. If an input is found that violates the spec,   
it will be saved as a counterexample and PropEr will attempt to shrink it.</p>
  
   <p>You can test all exported functions of a module against their spec by
   running <a href="#check_specs/1" class="seealso">check_specs/1</a> or <a href="#check_specs/2" class="seealso">check_specs/2</a>.</p>
  
   <p>The use of <code>check_spec</code> is subject to the following usage rules:</p>
  
   <list>
   <item><p>Currently, PropEr can't test functions whose range contains a type
     that exhibits a certain kind of self-reference: it is (directly or
     indirectly) self-recursive and at least one recursion path contains only
     unions and type references. E.g. these types are acceptable:
         </p><pre class="sh_erlang">             -type a(T) :: T | {'bar',a(T)}.
             -type b() :: 42 | [c()].
             -type c() :: {'baz',b()}.</pre><p>
     while these are not:
         </p><pre class="sh_erlang">             -type a() :: 'foo' | b().
             -type b() :: c() | [integer()].
             -type c() :: 'bar' | a().
             -type d(T) :: T | d({'baz',T}).</pre><p> </p></item>
   <item><p>Throwing any exception or raising an <code>error:badarg</code> is considered
     normal behaviour. Currently, users cannot fine-tune this setting.</p></item>
   <item><p>Only the first clause of the function's spec is considered.</p></item>
   <item><p>The only spec constraints we accept are is_subtype' constraints whose
     first argument is a simple, non-'_' variable. It is not checked whether or
     not these variables actually appear in the spec. The second argument of an
     <code>is_subtype</code> constraint cannot contain any non-'_' variables. Multiple
     constraints for the same variable are not supported.</p></item>
   </list>
  
   <em><marker id="Errors">Errors</marker></em><p>   
The following errors may be encountered during testing. The term provided   
for each error is the error type returned by proper:quickcheck in case such   
an error occurs. Normaly, a message is also printed on screen describing   
the error.</p>
  
   <taglist>
   <dt><code>arity_limit</code></dt>
   <item><p>The random instance generation subsystem has failed to produce
     a function of the desired arity. Please recompile PropEr with a suitable
     value for <code>?MAX_ARITY</code> (defined in <code>proper_internal.hrl</code>). This error
     should only be encountered during normal operation.</p></item>
   <dt><code>cant_generate</code></dt>
   <item><p>The random instance generation subsystem has failed to
     produce an instance that satisfies some <code>?SUCHTHAT</code> constraint. You
     should either increase the <code>constraint_tries</code> limit, loosen the failing
     constraint, or make it non-strict. This error should only be encountered
     during normal operation.</p></item>
   <dt><code>cant_satisfy</code></dt>
   <item><p>All the tests were rejected because no produced test case
     would pass all <code>?IMPLIES</code> checks. You should loosen the failing <code>?IMPLIES</code>
     constraint(s). This error should only be encountered during normal
     operation.</p></item>
   <dt><code>non_boolean_result</code></dt>
   <item><p>The property code returned a non-boolean result. Please
     fix your property.</p></item>
   <dt><code>rejected</code></dt>
   <item><p>Only encountered during re-checking, the counterexample does not
     match the property, since the counterexample doesn't pass an <code>?IMPLIES</code>
     check.</p></item>
   <dt><code>too_many_instances</code></dt>
   <item><p>Only encountered during re-checking, the counterexample
     does not match the property, since the counterexample contains more
     instances than there are <code>?FORALL</code>s in the property.</p></item>
   <dt><code>type_mismatch</code></dt>
   <item><p>The variables' and types' structures inside a <code>?FORALL</code> don't
     match. Please check your properties.</p></item>
   <dt><code>{typeserver, &lt;SubError&gt;}</code></dt>
   <item><p>The typeserver encountered an error. The <code>&lt;SubError&gt;</code> field contains
     specific information regarding the error.</p></item>
   <dt><code>{unexpected, &lt;Result&gt;}</code></dt>
   <item><p>A test returned an unexpected result during normal operation. If you
     ever get this error, it means that you have found a bug in PropEr
     - please send an error report to the maintainers and remember to include
     both the failing test case and the output of the program, if possible.
     </p></item>
   <dt><code>{unrecognized_option, &lt;Option&gt;}</code></dt>
   <item><p><code>&lt;Option&gt;</code> is not an option that PropEr understands.</p></item>
   </taglist></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-clean_input">clean_input() = <a href="proper_gen.html#type-instance" class="seealso">proper_gen:instance()</a> | <a href="#type-sub_counterexamples" class="seealso">sub_counterexamples()</a></h3></div>
    <div class="type"><h3 id="type-counterexample">counterexample() = [<a href="#type-clean_input" class="seealso">clean_input()</a>]</h3></div>
    <div class="type"><h3 id="type-error">error() = {error, <a href="#type-error_reason" class="seealso">error_reason()</a>}</h3></div>
    <div class="type"><h3 id="type-error_reason">error_reason() = arity_limit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| cant_generate<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| cant_satisfy<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| non_boolean_result<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| rejected<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| too_many_instances<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| type_mismatch<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| wrong_type<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {typeserver, term()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {unexpected, any()}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {unrecognized_option, term()}</h3></div>
    <div class="type"><h3 id="type-exc_kind">exc_kind() = throw | error | exit</h3></div>
    <div class="type"><h3 id="type-exc_reason">exc_reason() = term()</h3></div>
    <div class="type"><h3 id="type-exception">exception() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{exception, <a href="#type-exc_kind" class="seealso">exc_kind()</a>, <a href="#type-exc_reason" class="seealso">exc_reason()</a>, <a href="#type-stacktrace" class="seealso">stacktrace()</a>}</h3></div>
    <div class="type"><h3 id="type-long_module_result">long_module_result() = [{mfa(), <a href="#type-counterexample" class="seealso">counterexample()</a>}] | <a href="#type-error" class="seealso">error()</a></h3></div>
    <div class="type"><h3 id="type-long_result">long_result() = true | <a href="#type-counterexample" class="seealso">counterexample()</a> | <a href="#type-error" class="seealso">error()</a></h3></div>
    <div class="type"><h3 id="type-mod_name">mod_name() = atom()</h3></div>
    <div class="type"><h3 id="type-module_result">module_result() = <a href="#type-long_module_result" class="seealso">long_module_result()</a> | <a href="#type-short_module_result" class="seealso">short_module_result()</a></h3></div>
    <div class="type"><h3 id="type-outer_test">outer_test() = <a href="#type-test" class="seealso">test()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-numtests_clause" class="seealso">numtests_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-fails_clause" class="seealso">fails_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-on_output_clause" class="seealso">on_output_clause()</a></h3></div>
    <div class="type"><h3 id="type-output_fun">output_fun() = fun((string(), [term()]) -&gt; ok)</h3></div>
    <div class="type"><h3 id="type-result">result() = <a href="#type-long_result" class="seealso">long_result()</a> | <a href="#type-short_result" class="seealso">short_result()</a></h3></div>
    <div class="type"><h3 id="type-sample">sample() = [term()]</h3></div>
    <div class="type"><h3 id="type-short_module_result">short_module_result() = [mfa()] | <a href="#type-error" class="seealso">error()</a></h3></div>
    <div class="type"><h3 id="type-short_result">short_result() = boolean() | <a href="#type-error" class="seealso">error()</a></h3></div>
    <div class="type"><h3 id="type-size">size() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-stacktrace">stacktrace() = [{atom(), atom(), arity() | [term()]}]</h3></div>
    <div class="type"><h3 id="type-stats_printer">stats_printer() = fun((<a href="#type-sample" class="seealso">sample()</a>) -> ok)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| fun((<a href="#type-sample" class="seealso">sample()</a>, <a href="#type-output_fun" class="seealso">output_fun()</a>) -> ok)</h3></div>
    <div class="type"><h3 id="type-sub_counterexamples">sub_counterexamples() = [{<a href="#type-tag" class="seealso">tag()</a>, <a href="#type-counterexample" class="seealso">counterexample()</a>}]</h3></div>
    <div class="type"><h3 id="type-tag">tag() = atom()</h3></div>
    <div class="type"><h3 id="type-test">test() = boolean()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-forall_clause" class="seealso">forall_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-conjunction_clause" class="seealso">conjunction_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-implies_clause" class="seealso">implies_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-sample_clause" class="seealso">sample_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-whenfail_clause" class="seealso">whenfail_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-trapexit_clause" class="seealso">trapexit_clause()</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a href="#type-timeout_clause" class="seealso">timeout_clause()</a></h3></div>
    <div class="type"><h3 id="type-title">title() = atom() | string()</h3></div>
    <div class="type"><h3 id="type-user_opt">user_opt() = quiet<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| verbose<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {to_file, <a href="file.html#type-io_device" class="seealso">file:io_device()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {on_output, <a href="#type-output_fun" class="seealso">output_fun()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| long_result<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {numtests, integer() >= 1}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| integer() >= 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {start_size, <a href="#type-size" class="seealso">size()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {max_size, <a href="#type-size" class="seealso">size()</a>}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {max_shrinks, integer() >= 0}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| noshrink<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {constraint_tries, integer() >= 1}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| fails<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| any_to_integer<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {spec_timeout, timeout()}</h3></div>
    <div class="type"><h3 id="type-user_opts">user_opts() = [<a href="#type-user_opt" class="seealso">user_opt()</a>] | <a href="#type-user_opt" class="seealso">user_opt()</a></h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="counterexample/0">counterexample() -&gt; counterexample() | undefined</h3>


<div class="description">

<p>Retrieves the last (simplest) counterexample produced by PropEr during
  the most recent testing run.</p>
</div></div>
<div class="function">
<h3 id="counterexamples/0">counterexamples() -&gt; [{mfa(), counterexample()}] | undefined</h3>


<div class="description">

<p>Returns a counterexample for each failing property of the most recent
  module testing run.</p>
</div></div>
<div class="function">
<h3 id="clean_garbage/0">clean_garbage() -&gt; ok</h3>


<div class="description">

<p>Cleans up the process dictionary of all PropEr-produced entries.</p>
</div></div>
<div class="function">
<h3 id="quickcheck/1">quickcheck(OuterTest::outer_test()) -&gt; result()</h3>


<div class="description">

<p>Runs PropEr on the property <code>OuterTest</code>.</p>
</div></div>
<div class="function">
<h3 id="quickcheck/1-1">quickcheck(OuterTest::outer_test(), UserOpts::user_opts()) -&gt; result()</h3>


<div class="description">

<p>Same as <a href="#quickcheck/1" class="seealso">quickcheck/1</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="counterexample/1">counterexample(OuterTest::outer_test()) -&gt; long_result()</h3>


<div class="description">
<p>Equivalent to <a href="#quickcheck/2" class="seealso">quickcheck(OuterTest, [long_result])</a>.</p>
</div></div>
<div class="function">
<h3 id="counterexample/1-1">counterexample(OuterTest::outer_test(), UserOpts::user_opts()) -&gt; long_result()</h3>


<div class="description">

<p>Same as <a href="#counterexample/1" class="seealso">counterexample/1</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="check_spec/1">check_spec(MFA::mfa()) -&gt; result()</h3>


<div class="description">

<p>Tests the accuracy of an exported function's spec.</p>
</div></div>
<div class="function">
<h3 id="check_spec/1-1">check_spec(MFA::mfa(), UserOpts::user_opts()) -&gt; result()</h3>


<div class="description">

<p>Same as <a href="#check_spec/1" class="seealso">check_spec/1</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="check/1">check(OuterTest::outer_test(), CExm::counterexample()) -&gt; short_result()</h3>


<div class="description">

<p>Re-checks a specific counterexample <code>CExm</code> against the property
  <code>OuterTest</code> that it previously falsified.</p>
</div></div>
<div class="function">
<h3 id="check/1-1">check(OuterTest::outer_test(), CExm::counterexample(), UserOpts::user_opts()) -&gt; short_result()</h3>


<div class="description">

<p>Same as <a href="#check/2" class="seealso">check/2</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="module/1">module(Mod::mod_name()) -&gt; module_result()</h3>


<div class="description">

<p>Tests all properties (i.e., all 0-arity functions whose name begins with
  <code>prop_</code>)exported from module <code>Mod</code>.</p>
</div></div>
<div class="function">
<h3 id="module/1-1">module(Mod::mod_name(), UserOpts::user_opts()) -&gt; module_result()</h3>


<div class="description">

<p>Same as <a href="#module/1" class="seealso">module/1</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="check_specs/1">check_specs(Mod::mod_name()) -&gt; module_result()</h3>


<div class="description">

<p>Tests all exported, <code>-spec</code>ed functions of a module <code>Mod</code> against their
  spec.</p>
</div></div>
<div class="function">
<h3 id="check_specs/1-1">check_specs(Mod::mod_name(), UserOpts::user_opts()) -&gt; module_result()</h3>


<div class="description">

<p>Same as <a href="#check_specs/1" class="seealso">check_specs/1</a>, but also accepts a list of options.</p>
</div></div>
<div class="function">
<h3 id="numtests/1">numtests(N::pos_integer(), Test::outer_test()) -&gt; outer_test()</h3>


<div class="description">

<p>Specifies the number <code>N</code> of tests to run when testing the property
  <code>Test</code>. Default is 100.</p>
</div></div>
<div class="function">
<h3 id="fails/1">fails(Test::outer_test()) -&gt; outer_test()</h3>


<div class="description">

<p>Specifies that we expect the property <code>Test</code> to fail for some input. The
  property will be considered failing if it passes all the tests.</p>
</div></div>
<div class="function">
<h3 id="on_output/1">on_output(Print::output_fun(), Test::outer_test()) -&gt; outer_test()</h3>


<div class="description">

<p>Specifies an output function <code>Print</code> to be used by PropEr for all output
  printing during the testing of property <code>Test</code>. This wrapper is equivalent to
  the <code>on_output</code> option.</p>
</div></div>
<div class="function">
<h3 id="conjunction/1">conjunction(SubProps::[{tag(), test()}]) -&gt; test()</h3>


<div class="description">

<p>Returns a property that is true only if all of the sub-properties
  <code>SubProps</code> are true. Each sub-property should be tagged with a distinct atom.
  If this property fails, each failing sub-property will be reported and saved
  inside the counterexample along with its tag.</p>
</div></div>
<div class="function">
<h3 id="collect/1">collect(Category::term(), Test::test()) -&gt; test()</h3>


<div class="description">

<p>Specifies that test cases produced by this property should be
  categorized under the term <code>Category</code>. This field can be an expression or
  statement block that evaluates to any term. All produced categories are
  printed at the end of testing (in case no test fails) along with the
  percentage of test cases belonging to each category. Multiple <code>collect</code>
  wrappers are allowed in a single property, in which case the percentages for
  each <code>collect</code> wrapper are printed separately.</p>
</div></div>
<div class="function">
<h3 id="collect/1-1">collect(Printer::stats_printer(), Category::term(), Test::test()) -&gt; test()</h3>


<div class="description">

<p>Same as <a href="#collect/2" class="seealso">collect/2</a>, but also accepts a fun <code>Printer</code> to be used
  as the stats printer.</p>
</div></div>
<div class="function">
<h3 id="aggregate/1">aggregate(Sample::sample(), Test::test()) -&gt; test()</h3>


<div class="description">

<p>Same as <a href="#collect/2" class="seealso">collect/2</a>, but accepts a list of categories under which
  to classify the produced test case.</p>
</div></div>
<div class="function">
<h3 id="aggregate/1-1">aggregate(Printer::stats_printer(), Sample::sample(), Test::test()) -&gt; test()</h3>


<div class="description">

<p>Same as <a href="#collect/3" class="seealso">collect/3</a>, but accepts a list of categories under which
  to classify the produced test case.</p>
</div></div>
<div class="function">
<h3 id="classify/1">classify(Count::boolean(), TermOrSample::term() | sample(), Test::test()) -&gt; test()</h3>


<div class="description">

<p>Same as <a href="#collect/2" class="seealso">collect/2</a>, but can accept both a single category and a
  list of categories. <code>Count</code> is a boolean flag: when <code>false</code>, the particular
  test case will not be counted.</p>
</div></div>
<div class="function">
<h3 id="measure/1">measure(Title::title(), Sample::number() | [number()], Test::test()) -&gt; test()</h3>


<div class="description">

<p>A function that collects numeric statistics on the produced instances.
  The number (or numbers) provided are collected and some statistics over the
  collected sample are printed at the end of testing (in case no test fails),
  prepended with <code>Title</code>, which should be an atom or string.</p>
</div></div>
<div class="function">
<h3 id="equals/1">equals(A::term(), B::term()) -&gt; test()</h3>


<div class="description">

<p>A custom property that evaluates to <code>true</code> only if <code>A =:= B</code>, else
  evaluates to <code>false</code> and prints "<code>A =/= B</code>" on the screen.</p>
</div></div>
<div class="function">
<h3 id="with_title/1">with_title(Title::title()) -&gt; stats_printer()</h3>


<div class="description">

<p>A predefined function that accepts an atom or string and returns a
  stats printing function which is equivalent to the default one, but prints
  the given title <code>Title</code> above the statistics.</p>
</div></div></div>

<authors>

<aname>Manolis Papadakis</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
