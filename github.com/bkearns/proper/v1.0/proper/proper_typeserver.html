<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>proper_typeserver (proper) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>proper_typeserver</h1>
<h2 class="modsummary">Erlang type system - PropEr type system integration module.</h2>
<div class="description">
<p>Erlang type system - PropEr type system integration module.</p>
  
   <p>PropEr can parse types expressed in Erlang's type language and convert them
   to its own type format. Such expressions can be used instead of regular type
   constructors in the second argument of <code>?FORALL</code>s. No extra notation is
   required; PropEr will detect which calls correspond to native types by
   applying a parse transform during compilation. This parse transform is
   automatically applied to any module that includes the <code>proper.hrl</code> header
   file. You can disable this feature by compiling your modules with
   <code>-DPROPER_NO_TRANS</code>. Note that this will currently also disable the   
automatic exporting of properties.</p>
  
   The use of native types in properties is subject to the following usage
   rules:
   <list>
   <item><p>Native types cannot be used outside of <code>?FORALL</code>s.</p></item>
   <item><p>Inside <code>?FORALL</code>s, native types can be combined with other native
     types, and even with PropEr types, inside tuples and lists (the constructs
     <code>[...]</code>, <code>{...}</code> and <code>++</code> are all allowed).</p></item>
   <item><p>All other constructs of Erlang's built-in type system (e.g. <code>|</code> for
     union, <code>_</code> as an alias of <code>any()</code>, <code>&lt;&lt;_:_&gt;&gt;</code> binary type syntax and
     <code>fun((...) -&gt; ...)</code> function type syntax) are not allowed in <code>?FORALL</code>s,
     because they are rejected by the Erlang parser.</p></item>
   <item><p>Anything other than a tuple constructor, list constructor, <code>++</code>
     application, local or remote call will automatically be considered a
     PropEr type constructor and not be processed further by the parse
     transform.</p></item>
   <item><p>Parametric native types are fully supported; of course, they can only
     appear instantiated in a <code>?FORALL</code>. The arguments of parametric native
     types are always interpreted as native types.</p></item>
   <item><p>Parametric PropEr types, on the other hand, can take any kind of
     argument. You can even mix native and PropEr types in the arguments of a
     PropEr type. For example, assuming that the following declarations are
     present:
     </p><pre class="sh_erlang">         my_proper_type() -&gt; ?LET(...).
         -type my_native_type() :: ... .</pre><p>
     Then the following expressions are all legal:
     </p><pre class="sh_erlang">         vector(2, my_native_type())
         function(0, my_native_type())
         union([my_proper_type(), my_native_type()])</pre><p> </p></item>
   <item><p>Some type constructors can take native types as arguments (but only
     inside <code>?FORALL</code>s):
     </p><list>
     <item><p><code>?SUCHTHAT</code>, <code>?SUCHTHATMAYBE</code>, <code>non_empty</code>, <code>noshrink</code>: these work
       with native types too</p></item>
     <item><p><code>?LAZY</code>, <code>?SHRINK</code>, <code>resize</code>, <code>?SIZED</code>: these don't work with native
       types</p></item>
     <item><p><code>?LET</code>, <code>?LETSHRINK</code>: only the top-level base type can be a native
       type</p></item>
     </list></item>
   <item><p>Native type declarations in the <code>?FORALL</code>s of a module can reference any
     custom type declared in a <code>-type</code> or <code>-opaque</code> attribute of the same
     module, as long as no module identifier is used.</p></item>
   <item><p>Typed records cannot be referenced inside <code>?FORALL</code>s using the
     <code>#rec_name{}</code> syntax. To use a typed record in a <code>?FORALL</code>, enclose the
     record in a custom type like so:
     </p><pre class="sh_erlang">         -type rec_name() :: #rec_name{}.</pre><p>
     and use the custom type instead.</p></item>
   <item><p><code>?FORALL</code>s may contain references to self-recursive or mutually
     recursive native types, so long as each type in the hierarchy has a clear
     base case.
     Currently, PropEr requires that the toplevel of any recursive type
     declaration is either a (maybe empty) list or a union containing at least
     one choice that doesn't reference the type directly (it may, however,
     reference any of the types that are mutually recursive with it). This
     means, for example, that some valid recursive type declarations, such as
     this one:
     </p><pre class="sh_erlang">         ?FORALL(..., a(), ...)</pre><p>
     where:
     </p><pre class="sh_erlang">         -type a() :: {'a','none' | a()}.</pre><p>
     are not accepted by PropEr. However, such types can be rewritten in a way
     that allows PropEr to parse them:
     </p><pre class="sh_erlang">         ?FORALL(..., a(), ...)</pre><p>
     where:
     </p><pre class="sh_erlang">         -type a() :: {'a','none'} | {'a',a()}.</pre><p>
     This also means that recursive record declarations are not allowed:
     </p><pre class="sh_erlang">         ?FORALL(..., rec(), ...)</pre><p>
     where:
     </p><pre class="sh_erlang">         -type rec() :: #rec{}.
         -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).</pre><p>
     A little rewritting can usually remedy this problem as well:
     </p><pre class="sh_erlang">         ?FORALL(..., rec(), ...)</pre><p>
     where:
     </p><pre class="sh_erlang">         -type rec() :: #rec{b :: 'nil'} | #rec{b :: rec()}.
         -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).</pre><p>
     </p></item>
   <item><p>Remote types may be referenced in a <code>?FORALL</code>, so long as they are
     exported from the remote module. Currently, PropEr requires that any
     remote modules whose types are directly referenced from within properties
     are present in the code path at compile time, either compiled with
     <code>debug_info</code> enabled or in source form. If PropEr cannot find a remote
     module at all, finds only a compiled object file with no debug
     information or fails to compile the source file, all calls to that module
     will automatically be considered calls to PropEr type constructors.</p></item>
   <item><p>For native types to be translated correctly, both the module that
     contains the <code>?FORALL</code> declaration as well as any module that contains
     the declaration of a type referenced (directly or indirectly) from inside
     a <code>?FORALL</code> must be present in the code path at runtime, either compiled
     with <code>debug_info</code> enabled or in source form.</p></item>
   <item><p>Local types with the same name as an auto-imported BIF are not accepted
     by PropEr, unless the BIF in question has been declared in a
     <code>no_auto_import</code> option.</p></item>
   <item><p>When an expression can be interpreted both as a PropEr type and as a
     native type, the former takes precedence. This means that a function
     <code>foo()</code> will shadow a type <code>foo()</code> if they are both present in the module.
     The same rule applies to remote functions and types as well.</p></item>
   <item><p>The above may cause some confusion when list syntax is used:
     </p><list>
     <item><p>The expression <code>[integer()]</code> can be interpreted both ways, so the
       PropEr way applies. Therefore, instances of this type will always be
       lists of length 1, not arbitrary integer lists, as would be expected
       when interpreting the expression as a native type.</p></item>
     <item><p>Assuming that a custom type foo/1 has been declared, the expression
       <code>foo([integer()])</code> can only be interpreted as a native type declaration,
       which means that the generic type of integer lists will be passed to
       <code>foo/1</code>.</p></item>
     </list></item>
   <item><p>Currently, PropEr does not detect the following mistakes:
     </p><list>
     <item><p>inline record-field specializations that reference non-existent
       fields</p></item>
     <item><p>type parameters that are not present in the RHS of a <code>-type</code>
       declaration</p></item>
     <item><p>using <code>_</code> as a type variable in the LHS of a <code>-type</code> declaration</p></item>
     <item><p>using the same variable in more than one position in the LHS of a
       <code>-type</code> declaration</p></item>
     </list><p>
   </p></item>
   </list>
  
   <p>You can use <a href="#index" class="seealso">these</a> functions to try out the type   
translation subsystem.</p>
  
   CAUTION: These functions should never be used inside properties. They are
   meant for demonstration purposes only.</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-fin_type">fin_type() = <a href="proper_types.html#type-type" class="seealso">proper_types:type()</a></h3></div>
    <div class="type"><h3 id="type-imm_type">imm_type() = {<a href="#type-mod_name" class="seealso">mod_name()</a>, string()}</h3></div>
    <div class="type"><h3 id="type-mod_exp_funs">mod_exp_funs() = set()</h3></div>
    <div class="type"><h3 id="type-mod_exp_types">mod_exp_types() = set()</h3></div>
    <div class="type"><h3 id="type-mod_name">mod_name() = atom()</h3></div>
    <div class="type"><h3 id="type-rich_result">rich_result(T) = {ok, T} | {error, term()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="demo_translate_type/1">demo_translate_type(Mod::mod_name(), TypeExpr::string()) -&gt; rich_result(fin_type())</h3>


<div class="description">

<p>Translates the native type expression <code>TypeExpr</code> (which should be
  provided inside a string) into a PropEr type, which can then be passed to any
  of the demo functions defined in the <a href="proper_gen.html" class="seealso">proper_gen</a> module. PropEr acts
  as if it found this type expression inside the code of module <code>Mod</code>.</p>
</div></div>
<div class="function">
<h3 id="demo_is_instance/1">demo_is_instance(Term::term(), Mod::mod_name(), TypeExpr::string()) -&gt; boolean() | {error, term()}</h3>


<div class="description">

<p>Checks if <code>Term</code> is a valid instance of native type <code>TypeExpr</code> (which
  should be provided inside a string). PropEr acts as if it found this type
  expression inside the code of module <code>Mod</code>.</p>
</div></div></div>

<authors>

<aname>Manolis Papadakis</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
