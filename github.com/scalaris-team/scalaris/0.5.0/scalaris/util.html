<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>util (scalaris) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>util</h1>
<h2 class="modsummary">   Utility Functions.</h2>
<div class="description">
<p>   Utility Functions.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-accumulatorFun">accumulatorFun/0</h3></div>
    <div class="type"><h3 id="type-args">args() = [term()]</h3></div>
    <div class="type"><h3 id="type-erlang_timestamp">erlang_timestamp() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{integer() >= 0, integer() >= 0, integer() >= 0}</h3></div>
    <div class="type"><h3 id="type-repeat_params">repeat_params() = parallel<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| collect<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {accumulate, <a href="#type-accumulatorFun" class="seealso">accumulatorFun</a>(any(), R), R}</h3></div>
    <div class="type"><h3 id="type-time">time() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MegaSecs :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Secs :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MicroSecs :: integer() >= 0}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="sup_worker_desc/1">sup_worker_desc(Name::atom() | string(), Module::module(), Function::atom()) -&gt; {Name::atom() | string(), {Module::module(), Function::atom(), Options::[]}, permanent, brutal_kill, worker, []}</h3>


<div class="description">

<p>Creates a worker description for a supervisor.</p>
</div></div>
<div class="function">
<h3 id="sup_worker_desc/1-1">sup_worker_desc(Name::atom() | string(), Module::module(), Function::atom(), Options::list()) -&gt; {Name::atom() | string(), {Module::module(), Function::atom(), Options::list()}, permanent, brutal_kill, worker, []}</h3>


<div class="description">

<p>Creates a worker description for a supervisor.</p>
</div></div>
<div class="function">
<h3 id="sup_supervisor_desc/1">sup_supervisor_desc(Name::atom() | string(), Module::module(), Function::atom()) -&gt; {Name::atom() | string(), {Module::module(), Function::atom(), Options::[]}, permanent, brutal_kill, supervisor, []}</h3>


<div class="description">

<p>Creates a supervisor description for a supervisor.</p>
</div></div>
<div class="function">
<h3 id="sup_supervisor_desc/1-1">sup_supervisor_desc(Name::atom() | string(), Module::module(), Function::atom(), Options::list()) -&gt; {Name::atom() | string(), {Module::module(), Function::atom(), Options::list()}, permanent, brutal_kill, supervisor, []}</h3>


<div class="description">

<p>Creates a supervisor description for a supervisor.</p>
</div></div>
<div class="function">
<h3 id="supervisor_terminate/1">supervisor_terminate(Supervisor::pid() | atom()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="supervisor_terminate_childs/1">supervisor_terminate_childs(Supervisor::pid() | atom()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait_for/1">wait_for(F::() -&gt; any()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait_for/1-1">wait_for(F::() -&gt; any(), WaitTimeInMs::pos_integer()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait_for_process_to_die/1">wait_for_process_to_die(Name::pid() | atom()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="wait_for_table_to_disappear/1">wait_for_table_to_disappear(Pid::pid(), Table::tid() | atom()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="ets_tables_of/1">ets_tables_of(Pid::pid()) -&gt; list()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="escape_quotes/1">escape_quotes(String::string()) -&gt; string()</h3>


<div class="description">

<p>Escapes quotes in the given string.</p>
</div></div>
<div class="function">
<h3 id="max/1">max(X::any(), B::any()) -&gt; any()</h3>


<div class="description">

<p>Variant of erlang:max/2 also taking ?PLUS_INFINITY_TYPE and
       ?MINUS_INFINITY_TYPE into account, e.g. for comparing keys.</p>
</div></div>
<div class="function">
<h3 id="min/1">min(X::any(), B::any()) -&gt; any()</h3>


<div class="description">

<p>Variant of erlang:min/2 also taking ?PLUS_INFINITY_TYPE and
       ?MINUS_INFINITY_TYPE into account, e.g. for comparing keys.</p>
</div></div>
<div class="function">
<h3 id="pow/1">pow(X::integer(), Y::non_neg_integer()) -&gt; integer()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="log/1">log(X::number(), Base::number()) -&gt; float()</h3>


<div class="description">

<p>Logarithm of X to the base of Base.</p>
</div></div>
<div class="function">
<h3 id="log2/1">log2(X::number()) -&gt; float()</h3>


<div class="description">

<p>Logarithm of X to the base of 2.</p>
</div></div>
<div class="function">
<h3 id="floor/1">floor(X::number()) -&gt; integer()</h3>


<div class="description">

<p>Returns the largest integer not larger than X.</p>
</div></div>
<div class="function">
<h3 id="ceil/1">ceil(X::number()) -&gt; integer()</h3>


<div class="description">

<p>Returns the smallest integer not smaller than X.</p>
</div></div>
<div class="function">
<h3 id="logged_exec/1">logged_exec(Cmd::string() | atom()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_stacktrace/0">get_stacktrace() -&gt; [{Module::atom(), Function::atom(), ArityOrArgs::byte() | [term()]} | {Module::atom(), Function::atom(), ArityOrArgs::byte() | [term()], Sources::[term()]}]</h3>


<div class="description">

<p>Gets the current stack trace. Use this method in order to get a stack
       trace if no exception was thrown.</p>
</div></div>
<div class="function">
<h3 id="get_linetrace/0">get_linetrace() -&gt; term() | undefined</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_linetrace/1">get_linetrace(Pid::pid()) -&gt; term() | undefined</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="dump/0">dump() -&gt; [{Fun::mfa(), FunExecCount::pos_integer()}]</h3>


<div class="description">

<p>Returns a list of all currently executed functions and the number of
       instances for each of them.</p>
</div></div>
<div class="function">
<h3 id="dump2/0">dump2() -&gt; [{PID::pid(), [pos_integer() | mfa() | any()]}]</h3>


<div class="description">

<p>Returns information about all processes' memory usage.</p>
</div></div>
<div class="function">
<h3 id="dump3/0">dump3() -&gt; [{PID::pid(), Mem::non_neg_integer(), MsgQLength::non_neg_integer(), StackSize::non_neg_integer(), HeapSize::non_neg_integer(), Messages::[atom()], Fun::mfa()}]</h3>


<div class="description">

<p>Returns various data about all processes.</p>
</div></div>
<div class="function">
<h3 id="dumpX/1">dumpX(ItemInfo::[ItemInfo::atom(), ...]) -&gt; [tuple(), ...]</h3>


<div class="description">

<p>Returns various data about all processes.</p>
</div></div>
<div class="function">
<h3 id="dumpX/1-1">dumpX(ItemInfo::[ItemInfo::atom(), ...], ValueFun::(atom(), term()) -&gt; term()) -&gt; [tuple(), ...]</h3>


<div class="description">

<p>Returns various data about all processes.</p>
</div></div>
<div class="function">
<h3 id="topDumpX/1">topDumpX(Keys::Keys | Seconds | ValueFun) -&gt; [{pid(), [Reductions | RegName | term(), ...]}, ...]</h3>

<ul class="type">
<li><code>Keys = [ItemInfo::atom()]</code></li><li><code>Seconds = pos_integer()</code></li><li><code>ValueFun = (atom(), term()) -&gt; term()</code></li><li><code>Reductions = non_neg_integer()</code></li><li><code>RegName = atom()</code></li></ul>
<div class="description">

<p>Convenience wrapper to topDumpX/3.</p>
</div></div>
<div class="function">
<h3 id="topDumpX/3">topDumpX(Keys, ValueFun, Seconds) -&gt; [{pid(), [Reductions | RegName | term(), ...]}, ...]</h3>

<ul class="type">
<li><code>Keys = [ItemInfo::atom()]</code></li><li><code>Seconds = pos_integer()</code></li><li><code>ValueFun = (atom(), term()) -&gt; term()</code></li><li><code>Reductions = non_neg_integer()</code></li><li><code>RegName = atom()</code></li></ul>
<div class="description">

<p>Gets the number of reductions for each process within the next Seconds
       and dumps some process data defined by Keys (sorted by the number of
       reductions).</p>
</div></div>
<div class="function">
<h3 id="topDumpXEvery/2">topDumpXEvery(Keys::Keys | Seconds | ValueFun, Subset::pos_integer(), StopAfter::pos_integer()) -&gt; tref() (see module timer)</h3>

<ul class="type">
<li><code>Keys = [ItemInfo::atom()]</code></li><li><code>Seconds = pos_integer()</code></li><li><code>ValueFun = (atom(), term()) -&gt; term()</code></li></ul>
<div class="description">

<p>Convenience wrapper to topDumpXEvery/5.</p>
</div></div>
<div class="function">
<h3 id="topDumpXEvery/4">topDumpXEvery(Keys, ValueFun, Seconds, Subset::pos_integer(), StopAfter::pos_integer()) -&gt; tref() (see module timer)</h3>

<ul class="type">
<li><code>Keys = [ItemInfo::atom()]</code></li><li><code>Seconds = pos_integer()</code></li><li><code>ValueFun = (atom(), term()) -&gt; term()</code></li></ul>
<div class="description">

<p>Calls topDumpX/3 every Seconds and prints the top Subset processes with
       the highest number of reductions. Stops after StopAfter seconds.</p>
</div></div>
<div class="function">
<h3 id="topDumpXEvery_helper/4">topDumpXEvery_helper(Keys, ValueFun, Seconds, Subset::pos_integer()) -&gt; ok</h3>

<ul class="type">
<li><code>Keys = [ItemInfo::atom()]</code></li><li><code>Seconds = pos_integer()</code></li><li><code>ValueFun = (atom(), term()) -&gt; term()</code></li></ul>
<div class="description">

<p>Helper function for topDumpXEvery/5 (export needed for timer:apply_after/4).</p>
</div></div>
<div class="function">
<h3 id="minus_all/2">minus_all(List::[T], Excluded::[T]) -&gt; [T]</h3>


<div class="description">

<p>minus_all(M,N) : { x | x in M and x notin N}</p>
</div></div>
<div class="function">
<h3 id="minus_first/2">minus_first(List::[T], Excluded::[T]) -&gt; [T]</h3>


<div class="description">

<p>Deletes the first occurrence of each element in Excluded from List.
       Similar to lists:foldl(fun lists:delete/2, NewValue1, ToDel) but more
       performant for out case.</p>
</div></div>
<div class="function">
<h3 id="delete_if_exists/2">delete_if_exists(Del::T, List::[T]) -&gt; {Found::boolean(), [T]}</h3>


<div class="description">

<p>Removes Del from List if it is found. Stops on first occurrence.</p>
</div></div>
<div class="function">
<h3 id="get_proc_in_vms/1">get_proc_in_vms(Proc::atom()) -&gt; [mypid() (see module comm)]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="sleep_for_ever/0">sleep_for_ever() -&gt; no_return()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="randomelem/2">randomelem(List::[X, ...]) -&gt; X</h3>


<div class="description">

<p>Returns a random element from the given (non-empty!) list according to
       a uniform distribution.</p>
</div></div>
<div class="function">
<h3 id="pop_randomelem/2">pop_randomelem(List::[X, ...]) -&gt; {NewList::[X], PoppedElement::X}</h3>


<div class="description">

<p>Removes a random element from the (non-empty!) list and returns the
       resulting list and the removed element.</p>
</div></div>
<div class="function">
<h3 id="pop_randomelem/3">pop_randomelem(List::[X, ...], Size::non_neg_integer()) -&gt; {NewList::[X], PoppedElement::X}</h3>


<div class="description">

<p>Removes a random element from the first Size elements of a (non-empty!)
       list and returns the resulting list and the removed element.</p>
</div></div>
<div class="function">
<h3 id="random_subset/1">random_subset(Size::pos_integer(), T::[T]) -&gt; [T]</h3>


<div class="description">

<p>Returns a random subset of Size elements from the given list.</p>
</div></div>
<div class="function">
<h3 id="shuffle/1">shuffle(T::[T]) -&gt; [T]</h3>


<div class="description">

<p>Fisher-Yates shuffling for lists.</p>
</div></div>
<div class="function">
<h3 id="first_matching/2">first_matching(List::[T], Pred::(T) -&gt; boolean()) -&gt; {ok, T} | failed</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="gb_trees_largest_smaller_than/2">gb_trees_largest_smaller_than(Key, X2::gb_tree()) -&gt; {value, Key, Value::any()} | nil</h3>


<div class="description">

<p>Find the largest key in GBTree that is smaller than Key.
       Note: gb_trees offers only linear traversal or lookup of exact keys -
       we implement a more flexible binary search here despite gb_tree being
       defined as opaque.</p>
</div></div>
<div class="function">
<h3 id="gb_trees_foldl/1">gb_trees_foldl(F::(Key::any(), Value::any(), Acc) -&gt; Acc, Acc, GBTree::gb_tree()) -&gt; Acc</h3>


<div class="description">

<p>Foldl over gb_trees.</p>
</div></div>
<div class="function">
<h3 id="tc/1">tc(M::module(), F::atom(), A::list()) -&gt; {integer(), term()}</h3>


<div class="description">

<p>Measures the execution time (in microseconds) for an MFA
       (does not catch exceptions as timer:tc/3 in older Erlang versions).</p>
</div></div>
<div class="function">
<h3 id="tc/1-1">tc(Fun::function(), Args::list()) -&gt; {integer(), term()}</h3>


<div class="description">

<p>Measures the execution time (in microseconds) for Fun(Args)
       (does not catch exceptions as timer:tc/3 in older Erlang versions).</p>
</div></div>
<div class="function">
<h3 id="tc/1-2">tc(Fun::function()) -&gt; {integer(), term()}</h3>


<div class="description">

<p>Measures the execution time (in microseconds) for Fun()
       (does not catch exceptions as timer:tc/3 in older Erlang versions).</p>
</div></div>
<div class="function">
<h3 id="zipfoldl/2">zipfoldl(ZipFun::(X, Y) -&gt; Z, FoldFun::(Z, Acc) -&gt; Acc, L1::[X], L2::[Y], Acc) -&gt; Acc</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="</2">=:&lt;(T, T) -&gt; boolean()</h3>


<div class="description">

<p>Sorts like erlang:'=&lt;'/2 but also defines the order of integers/floats
       representing the same value.</p>
</div></div>
<div class="function">
<h3 id="safe_split/1">safe_split(N::non_neg_integer(), T::[T]) -&gt; {FirstN::[T], Rest::[T]}</h3>


<div class="description">

<p>Splits off N elements from List. If List is not large enough, the whole
       list is returned.</p>
</div></div>
<div class="function">
<h3 id="split_unique/2">split_unique(L1::[X], L2::[X]) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that both lists share and a list of elements unique to L2.
       Returned lists are sorted and contain no duplicates.</p>
</div></div>
<div class="function">
<h3 id="split_unique/4">split_unique(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean()) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that are equal in both lists (according to the ordering
       function Lte) and a list of elements unique to L2.
       When two elements compare equal, the element from List1 is picked.
       Lte(A, B) should return true if A compares less than or equal to B in
       the ordering, false otherwise.
       Returned lists are sorted according to Lte and contain no duplicates.</p>
</div></div>
<div class="function">
<h3 id="split_unique/4-1">split_unique(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean(), EqSelect::(X, X) -&gt; X) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that are equal in both lists (according to the ordering
       function Lte) and a list of elements unique to L2.
       When two elements compare equal, EqSelect(element(L1), element(L2))
       chooses which of them to take.
       Lte(A, B) should return true if A compares less than or equal to B in
       the ordering, false otherwise.
       Returned lists are sorted according to Lte and contain no duplicates.</p>
</div></div>
<div class="function">
<h3 id="ssplit_unique/2">ssplit_unique(L1::[X], L2::[X]) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that both lists share and a list of elements unique to L2.
       Both lists must be sorted. Returned lists are sorted as well.</p>
</div></div>
<div class="function">
<h3 id="ssplit_unique/4">ssplit_unique(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean()) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that are equal in both lists (according to the ordering
       function Lte) and a list of elements unique to L2.
       When two elements compare equal, the element from List1 is picked.
       Both lists must be sorted according to Lte. Lte(A, B) should return
       true if A compares less than or equal to B in the ordering, false
       otherwise.
       Returned lists are sorted according to Lte.</p>
</div></div>
<div class="function">
<h3 id="ssplit_unique/4-1">ssplit_unique(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean(), EqSelect::(X, X) -&gt; X) -&gt; {UniqueL1::[X], Shared::[X], UniqueL2::[X]}</h3>


<div class="description">

<p>Splits L1 into a list of elements that are not contained in L2, a list
       of elements that are equal in both lists (according to the ordering
       function Lte) and a list of elements unique to L2.
       When two elements compare equal, EqSelect(element(L1), element(L2))
       chooses which of them to take.
       Both lists must be sorted according to Lte. Lte(A, B) should return true
       if A compares less than or equal to B in the ordering, false otherwise.
       Returned lists are sorted according to Lte.</p>
</div></div>
<div class="function">
<h3 id="smerge2/2">smerge2(L1::[X], L2::[X]) -&gt; MergedList::[X]</h3>


<div class="description">

<p>Merges two unique sorted lists into a single list.</p>
</div></div>
<div class="function">
<h3 id="smerge2/4">smerge2(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean()) -&gt; MergedList::[X]</h3>


<div class="description">

<p>Merges two unique Lte-sorted lists into a single list.</p>
</div></div>
<div class="function">
<h3 id="smerge2/4-1">smerge2(L1::[X], L2::[X], Lte::(X, X) -&gt; boolean(), EqSelect::(X, X) -&gt; [X]) -&gt; MergedList::[X]</h3>


<div class="description">

<p>Merges two unique Lte-sorted lists into a single list.</p>
</div></div>
<div class="function">
<h3 id="is_unittest/0">is_unittest() -&gt; boolean()</h3>


<div class="description">

<p>Try to check whether common-test is running.</p>
</div></div>
<div class="function">
<h3 id="make_filename/1">make_filename(Name::[byte()]) -&gt; string()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="app_get_env/1">app_get_env(Var::atom(), Default::T) -&gt; T</h3>


<div class="description">

<p>Get an application environment variable. If it is undefined, Default is
       returned.</p>
</div></div>
<div class="function">
<h3 id="time_plus_us/1">time_plus_us(Time::time(), Delta_MicroSeconds::integer()) -&gt; time()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="time_plus_ms/1">time_plus_ms(Time::time(), Delta_MilliSeconds::integer()) -&gt; time()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="time_plus_s/1">time_plus_s(Time::time(), Delta_Seconds::integer()) -&gt; time()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="readable_utc_time_feeder/3">readable_utc_time_feeder(X1::{0..1000, 0..1000, 0..1000}) -&gt; {erlang_timestamp()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="readable_utc_time/1">readable_utc_time(TimeTriple::erlang_timestamp()) -&gt; tuple()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="for_to_fold/1">for_to_fold(I::integer(), N::integer(), Fun::(integer()) -&gt; X, AccFun::(X, Acc) -&gt; Acc, AccIn::Acc) -&gt; Acc</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="for_to/1">for_to(I::integer(), N::integer(), Fun::(integer()) -&gt; any()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="for_to_ex/1">for_to_ex(I::integer(), N::integer(), Fun::(integer()) -&gt; T, T::[T]) -&gt; [T]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="for_to_ex/1-1">for_to_ex(I::integer(), N::integer(), Fun::(integer()) -&gt; T) -&gt; [T]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="map_with_nr_feeder/2">map_with_nr_feeder(X1::1..2, List::[number()], StartNr::integer()) -&gt; {Fun::(number(), integer()) -&gt; number(), List::[number()], integer()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="map_with_nr/2">map_with_nr(F::(A, integer()) -&gt; B, List::[A], StartNr::integer()) -&gt; [B]</h3>


<div class="description">

<p>Similar to lists:map/2 but also passes the current number to the fun:
       <code>[a, b, c,...]</code> maps to
       <code>[fun(a, StartNr), fun(b, StartNr+1), fun(c, StartNr+2),...]</code></p>
</div></div>
<div class="function">
<h3 id="par_map_feeder/2">par_map_feeder(X1::1..2, List::[number()]) -&gt; {Fun::(number()) -&gt; number(), List::[number()]}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="par_map/1">par_map(Fun::(A) -&gt; B, List::[A]) -&gt; [B]</h3>


<div class="description">

<p>Parallel version of lists:map/2. Spawns a new process for each element
       in the list!</p>
</div></div>
<div class="function">
<h3 id="par_map_feeder/2-1">par_map_feeder(FunNr::1..2, List::[number()], MaxThreads::1..50) -&gt; {Fun::(number()) -&gt; number(), List::[number()], 1..50}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="par_map/1-1">par_map(Fun::(A) -&gt; B, List::[A], MaxThreads::pos_integer()) -&gt; [B]</h3>


<div class="description">

<p>Parallel version of lists:map/2 with the possibility to limit the
       maximum number of processes being spawned.</p>
</div></div>
<div class="function">
<h3 id="lists_split/2">lists_split(A::[A], Partitions::pos_integer()) -&gt; [[A]]</h3>


<div class="description">

<p>Splits the given list into several partitions, returning a list of parts
       of the original list. Both the parts and their contents are reversed
       compared to the original list!</p>
</div></div>
<div class="function">
<h3 id="lists_keystore2/1">lists_keystore2(Key::term(), NC::pos_integer(), List::[tuple()], NS::pos_integer(), NewValue::term()) -&gt; [tuple()]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lists_partition3_feeder/1">lists_partition3_feeder(List::[integer()]) -&gt; {(integer()) -&gt; 1..3, [integer()]}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="lists_partition3/1">lists_partition3(Pred::(Elem::T) -&gt; 1..3, List::[T]) -&gt; {Pred1::[T], Pred2::[T], Pred3::[T]}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="repeat/1">repeat(Fun::function(), Args::args(), Times::pos_integer()) -&gt; ok</h3>


<div class="description">

<p>Sequencial (default) or parallel run of function FUN with arguments ARGS TIMES-fold.
       Options as list/propertylist: collect, parallel, accumulate
           * collect (atom): all results of FUN will returned as a list
           * accumulate (tuple): {accumulate, accFun, accInit}
                                 all results will be accumulated with accFun
           * parallel (atom): FUN will be called TIMES-fold in parallel.
                              Combination with collect and accumulate is supported.</p>
</div></div>
<div class="function">
<h3 id="repeat/1-1">repeat(Fun::function(), Args::args(), Times::pos_integer(), Params::[repeat_params()]) -&gt; ok | any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="parallel_run/1">parallel_run(SrcPid::pid(), Fun::function(), Args::args(), DoAnswer::boolean(), Id::any()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="collect_while/1">collect_while(GatherFun::(non_neg_integer()) -&gt; {boolean(), T} | boolean()) -&gt; [T]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="list_set_nth/2">list_set_nth(A::[A], Pos::pos_integer(), B) -&gt; [A | B]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="debug_info/0">debug_info() -&gt; [[{string(), term()}]]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="debug_info/1">debug_info(PidName::pid()) -&gt; [{string(), term()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="empty/1">empty(X1::any()) -&gt; []</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="print_bits/1">print_bits(FormatFun::(string(), [term()]) -&gt; Result, Binary::binary()) -&gt; Result</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="if_verbose/1">if_verbose(String::string()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="if_verbose/1-1">if_verbose(String::string(), Fmt::list()) -&gt; ok</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="bin_xor/1">bin_xor(Binary1::binary(), Binary2::binary()) -&gt; binary()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="extint2atom/1">extint2atom(X::atom() | integer()) -&gt; atom()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="sets_map/1">sets_map(Fun::(A::any()) -&gt; B::any(), Set::set()) -&gt; [any()]</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Thorsten Schuett</aname>
<email>schuett@zib.de</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
