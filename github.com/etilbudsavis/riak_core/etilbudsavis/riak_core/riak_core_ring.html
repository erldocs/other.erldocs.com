<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>riak_core_ring (riak_core) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>riak_core_ring</h1>
<h2 class="modsummary">riak_core_ring manages a riak node's local view of partition ownership.</h2>
<div class="description">
<p>riak_core_ring manages a riak node's local view of partition ownership.
       The functions in this module revolve around use of the chstate record,
       which should be treated as opaque by other modules.  Riak nodes exchange
       instances of these records via gossip in order to converge on a common
       view of node/partition ownership.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-chstate">chstate() = <a href="#type-riak_core_ring" class="seealso">riak_core_ring()</a></h3></div>
    <div class="type"><h3 id="type-member_status">member_status() = joining<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| valid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| invalid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| leaving<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| exiting<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| down</h3></div>
    <div class="type"><h3 id="type-pending_change">pending_change() = {Owner :: node(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NextOwner :: node(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awaiting | complete}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| {undefined, undefined, undefined}</h3></div>
    <div class="type"><h3 id="type-riak_core_ring">riak_core_ring() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#chstate_v2{nodename = undefined | term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vclock = <a href="vclock.html#type-vclock" class="seealso">vclock:vclock()</a> | undefined,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chring = undefined | <a href="chash.html#type-chash" class="seealso">chash:chash()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta = <a href="dict.html#type-dict" class="seealso">dict:dict()</a> | undefined,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clustername = undefined | {term(), term()},<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next = undefined<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [{integer(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[module()],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awaiting | complete}],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;members = undefined<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [{node(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<a href="#type-member_status" class="seealso">member_status()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="vclock.html#type-vclock" class="seealso">vclock:vclock()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{atom(), term()}]}}],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;claimant = undefined | term(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seen = undefined | [{term(), <a href="vclock.html#type-vclock" class="seealso">vclock:vclock()</a>}],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvsn = undefined | <a href="vclock.html#type-vclock" class="seealso">vclock:vclock()</a>}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="legacy_ring/1">legacy_ring(Chstate) -&gt; term()
</h3>


<div class="description">

<p>Returns true if the given ring is a legacy ring.</p>
</div></div>
<div class="function">
<h3 id="upgrade/1">upgrade(Old) -&gt; term()
</h3>


<div class="description">

<p>Upgrade old ring structures to the latest format.</p>
</div></div>
<div class="function">
<h3 id="downgrade/2">downgrade(X1, Chstate_v2) -&gt; term()
</h3>


<div class="description">

<p>Downgrade the latest ring structure to a specified version.</p>
</div></div>
<div class="function">
<h3 id="set_tainted/1">set_tainted(Ring) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="check_tainted/2">check_tainted(Chstate, Msg) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="nearly_equal/1">nearly_equal(RingA::chstate(), RingB::chstate()) -&gt; boolean()</h3>


<div class="description">

<p>Verify that the two rings are identical expect that metadata can
       differ and RingB's vclock is allowed to be equal or a direct
       descendant of RingA's vclock. This matches the changes that the
       fix-up logic may make to a ring.</p>
</div></div>
<div class="function">
<h3 id="is_primary/1">is_primary(Ring::chstate(), IdxNode::{index_as_int() (see module chash), node()}) -&gt; boolean()</h3>


<div class="description">

<p>Determine if a given Index/Node <code>IdxNode</code> combination is a
       primary.</p>
</div></div>
<div class="function">
<h3 id="chash/1">chash(Chstate_v2::chstate()) -&gt; CHash::chash() (see module chash)</h3>


<div class="description">

<p>Return the <code>CHash</code> of the ring.</p>
</div></div>
<div class="function">
<h3 id="set_chash/2">set_chash(State, CHash) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="all_members/1">all_members(State::chstate()) -&gt; [Node::term()]</h3>


<div class="description">

<p>Produce a list of all nodes that are members of the cluster</p>
</div></div>
<div class="function">
<h3 id="members/2">members(Chstate_v2, Types) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="active_members/1">active_members(Chstate_v2) -&gt; term()
</h3>


<div class="description">

<p>Produce a list of all active (not marked as down) cluster members</p>
</div></div>
<div class="function">
<h3 id="ready_members/1">ready_members(Chstate_v2) -&gt; term()
</h3>


<div class="description">

<p>Returns a list of members guaranteed safe for requests</p>
</div></div>
<div class="function">
<h3 id="all_owners/1">all_owners(State::chstate()) -&gt; [{Index::integer(), Node::term()}]</h3>


<div class="description">

<p>Provide all ownership information in the form of {Index,Node} pairs.</p>
</div></div>
<div class="function">
<h3 id="all_preflists/1">all_preflists(State::chstate(), N::integer()) -&gt; [[{Index::integer(), Node::term()}]]</h3>


<div class="description">

<p>Provide every preflist in the ring, truncated at N.</p>
</div></div>
<div class="function">
<h3 id="diff_nodes/1">diff_nodes(State1::chstate(), State2::chstate()) -&gt; [node()]</h3>


<div class="description">

<p>For two rings, return the list of owners that have differing ownership.</p>
</div></div>
<div class="function">
<h3 id="equal_rings/1">equal_rings(A::chstate(), B::chstate()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="fresh/0">fresh() -&gt; chstate()</h3>


<div class="description">

<p>This is used only when this node is creating a brand new cluster.</p>
</div></div>
<div class="function">
<h3 id="fresh/1">fresh(NodeName::term()) -&gt; chstate()</h3>


<div class="description">

<p>Equivalent to fresh/0 but allows specification of the local node name.
       Called by fresh/0, and otherwise only intended for testing purposes.</p>
</div></div>
<div class="function">
<h3 id="fresh/1-1">fresh(RingSize::integer(), NodeName::term()) -&gt; chstate()</h3>


<div class="description">

<p>Equivalent to fresh/1 but allows specification of the ring size.
       Called by fresh/1, and otherwise only intended for testing purposes.</p>
</div></div>
<div class="function">
<h3 id="resize/1">resize(State::chstate(), NewRingSize::pos_integer()) -&gt; chstate()</h3>


<div class="description">

<p>change the size of the ring to <code>NewRingSize</code>. If the ring
       is larger than the current ring any new indexes will be owned
       by a dummy host</p>
</div></div>
<div class="function">
<h3 id="get_meta/1">get_meta(Key::term(), State::chstate()) -&gt; {ok, term()} | undefined</h3>


<div class="description">

<p>Return a value from the cluster metadata dict</p>
</div></div>
<div class="function">
<h3 id="get_buckets/1">get_buckets(State::chstate()) -&gt; [term()]</h3>


<div class="description">

<p>return the names of all the custom buckets stored in the ring.</p>
</div></div>
<div class="function">
<h3 id="index_owner/1">index_owner(State::chstate(), Idx::index_as_int() (see module chash)) -&gt; Node::term()</h3>


<div class="description">

<p>Return the node that owns the given index.</p>
</div></div>
<div class="function">
<h3 id="future_owner/1">future_owner(State::chstate(), Idx::index_as_int() (see module chash)) -&gt; term()</h3>


<div class="description">

<p>Return the node that will own this index after transtions have completed
       this function will error if the ring is shrinking and Idx no longer exists
       in it</p>
</div></div>
<div class="function">
<h3 id="my_indices/1">my_indices(State::chstate()) -&gt; [index_as_int() (see module chash)]</h3>


<div class="description">

<p>Return all partition indices owned by the node executing this function.</p>
</div></div>
<div class="function">
<h3 id="num_partitions/1">num_partitions(State::chstate()) -&gt; pos_integer()</h3>


<div class="description">

<p>Return the number of partitions in this Riak ring.</p>
</div></div>
<div class="function">
<h3 id="future_num_partitions/1">future_num_partitions(State::chstate()) -&gt; pos_integer()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="owner_node/1">owner_node(State::chstate()) -&gt; Node::term()</h3>


<div class="description">

<p>Return the node that is responsible for a given chstate.</p>
</div></div>
<div class="function">
<h3 id="preflist/1">preflist(Key::binary(), State::chstate()) -&gt; [{Index::index_as_int() (see module chash), Node::term()}]</h3>


<div class="description">

<p>For a given object key, produce the ordered list of
       {partition,node} pairs that could be responsible for that object.</p>
</div></div>
<div class="function">
<h3 id="random_node/1">random_node(State::chstate()) -&gt; Node::term()</h3>


<div class="description">

<p>Return a randomly-chosen node from amongst the owners.</p>
</div></div>
<div class="function">
<h3 id="random_other_index/1">random_other_index(State::chstate()) -&gt; index_as_int() (see module chash)</h3>


<div class="description">

<p>Return a partition index not owned by the node executing this function.
       If this node owns all partitions, return any index.</p>
</div></div>
<div class="function">
<h3 id="random_other_index/1-1">random_other_index(State::chstate(), Exclude::[term()]) -&gt; index_as_int() (see module chash) | no_indices</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="random_other_node/1">random_other_node(State::chstate()) -&gt; Node::term() | no_node</h3>


<div class="description">

<p>Return a randomly-chosen node from amongst the owners other than this one.</p>
</div></div>
<div class="function">
<h3 id="random_other_active_node/1">random_other_active_node(State::chstate()) -&gt; Node::term() | no_node</h3>


<div class="description">

<p>Return a randomly-chosen active node other than this one.</p>
</div></div>
<div class="function">
<h3 id="reconcile/1">reconcile(ExternState::chstate(), MyState::chstate()) -&gt; {no_change | new_ring, chstate()}</h3>


<div class="description">

<p>Incorporate another node's state into our view of the Riak world.</p>
</div></div>
<div class="function">
<h3 id="rename_node/1">rename_node(State::chstate(), OldNode::atom(), NewNode::atom()) -&gt; chstate()</h3>


<div class="description">

<p> Rename OldNode to NewNode in a Riak ring.</p>
</div></div>
<div class="function">
<h3 id="responsible_index/1">responsible_index(ChashKey::binary(), Chstate_v2::chstate()) -&gt; integer()</h3>


<div class="description">

<p>Determine the integer ring index responsible
       for a chash key.</p>
</div></div>
<div class="function">
<h3 id="future_index/1">future_index(CHashKey::index() (see module chash), OrigIdx::integer(), State::chstate()) -&gt; integer() | undefined</h3>


<div class="description">

<p>Given a key and an index in the current ring, determine
       which index will own the key in the future ring. <code>OrigIdx</code>
       may or may not be the responsible index for that key
       (<code>OrigIdx</code> may not be the first index in <code>CHashKey</code>'s preflist).
       The returned index will be in the same position in the preflist
       for <code>CHashKey</code> in the future ring. For regular transitions
       the returned index will always be <code>OrigIdx</code>. If the ring is
       resizing the index may be different</p>
</div></div>
<div class="function">
<h3 id="future_index/1-1">future_index(CHashKey::index() (see module chash), OrigIdx::integer(), NValCheck::undefined | integer(), State::chstate()) -&gt; integer() | undefined</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="future_index/5">future_index(CHashKey, OrigIdx, NValCheck, OrigCount, NextCount) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_future_index/1">is_future_index(CHashKey::index() (see module chash), OrigIdx::integer(), TargetIdx::integer(), State::chstate()) -&gt; boolean()</h3>


<div class="description">
 <p><em>See also:</em> <a href="#future_index/4" class="seealso">future_index/4</a>.</p>
</div></div>
<div class="function">
<h3 id="transfer_node/1">transfer_node(Idx::integer(), Node::term(), MyState::chstate()) -&gt; chstate()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update_meta/1">update_meta(Key::term(), Val::term(), State::chstate()) -&gt; chstate()</h3>


<div class="description">

<p>Set a key in the cluster metadata dict</p>
</div></div>
<div class="function">
<h3 id="remove_meta/1">remove_meta(Key::term(), State::chstate()) -&gt; chstate()</h3>


<div class="description">

<p>Logical delete of a key in the cluster metadata dict</p>
</div></div>
<div class="function">
<h3 id="claimant/1">claimant(State::chstate()) -&gt; node()</h3>


<div class="description">

<p>Return the current claimant.</p>
</div></div>
<div class="function">
<h3 id="set_claimant/2">set_claimant(State, Claimant) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="cluster_name/1">cluster_name(State::chstate()) -&gt; term()</h3>


<div class="description">

<p>Returns the unique identifer for this cluster.</p>
</div></div>
<div class="function">
<h3 id="set_cluster_name/2">set_cluster_name(State, Name) -&gt; term()
</h3>


<div class="description">

<p>Sets the unique identifer for this cluster.</p>
</div></div>
<div class="function">
<h3 id="reconcile_names/2">reconcile_names(RingA, RingB) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="increment_vclock/2">increment_vclock(Node, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="ring_version/1">ring_version(Chstate_v2) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="increment_ring_version/2">increment_ring_version(Node, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="member_status/1">member_status(Chstate_v2::chstate() | [node()], Node::node()) -&gt; member_status()</h3>


<div class="description">

<p>Returns the current membership status for a node in the cluster.</p>
</div></div>
<div class="function">
<h3 id="all_member_status/1">all_member_status(State::chstate()) -&gt; [{node(), member_status()}]</h3>


<div class="description">

<p>Returns the current membership status for all nodes in the cluster.</p>
</div></div>
<div class="function">
<h3 id="get_member_meta/3">get_member_meta(State, Member, Key) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="update_member_meta/5">update_member_meta(Node, State, Member, Key, Val) -&gt; term()
</h3>


<div class="description">

<p>Set a key in the member metadata orddict</p>
</div></div>
<div class="function">
<h3 id="clear_member_meta/3">clear_member_meta(Node, State, Member) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="add_member/3">add_member(PNode, State, Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="remove_member/3">remove_member(PNode, State, Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="leave_member/3">leave_member(PNode, State, Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="exit_member/3">exit_member(PNode, State, Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="down_member/3">down_member(PNode, State, Node) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_member/4">set_member(Node, CState, Member, Status) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_member/5">set_member(Node, CState, Member, Status, X5) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="claiming_members/1">claiming_members(State::chstate()) -&gt; [Node::node()]</h3>


<div class="description">

<p>Return a list of all members of the cluster that are eligible to
       claim partitions.</p>
</div></div>
<div class="function">
<h3 id="down_members/1">down_members(State::chstate()) -&gt; [Node::node()]</h3>


<div class="description">

<p>Return a list of all members of the cluster that are marked as down.</p>
</div></div>
<div class="function">
<h3 id="set_owner/1">set_owner(State::chstate(), Node::node()) -&gt; chstate()</h3>


<div class="description">

<p>Set the node that is responsible for a given chstate.</p>
</div></div>
<div class="function">
<h3 id="indices/1">indices(State::chstate(), Node::node()) -&gt; [integer()]</h3>


<div class="description">

<p>Return all partition indices owned by a node.</p>
</div></div>
<div class="function">
<h3 id="future_indices/1">future_indices(State::chstate(), Node::node()) -&gt; [integer()]</h3>


<div class="description">

<p>Return all partition indices that will be owned by a node after all
       pending ownership transfers have completed.</p>
</div></div>
<div class="function">
<h3 id="all_next_owners/1">all_next_owners(CState::chstate()) -&gt; [{integer(), term()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="disowning_indices/2">disowning_indices(State, Node) -&gt; term()
</h3>


<div class="description">

<p>Return all indices that a node is scheduled to give to another.</p>
</div></div>
<div class="function">
<h3 id="pending_changes/1">pending_changes(State) -&gt; term()
</h3>


<div class="description">

<p>Returns a list of all pending ownership transfers.</p>
</div></div>
<div class="function">
<h3 id="set_pending_changes/2">set_pending_changes(State, Transfers) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_pending_resize/1">set_pending_resize(Resizing::chstate(), Orig::chstate()) -&gt; chstate()</h3>


<div class="description">

<p>Given a ring, <code>Resizing</code>, that has been resized (and presumably rebalanced)
       schedule a resize transition for <code>Orig</code>.</p>
</div></div>
<div class="function">
<h3 id="maybe_abort_resize/1">maybe_abort_resize(State::chstate()) -&gt; {boolean(), chstate()}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_pending_resize_abort/1">set_pending_resize_abort(State::chstate()) -&gt; chstate()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="schedule_resize_transfer/1">schedule_resize_transfer(State::chstate(), Source::{integer(), term()}, TargetIdx::integer() | {integer(), term()}) -&gt; chstate()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="reschedule_resize_transfers/1">reschedule_resize_transfers(State::chstate(), Node::term(), NewNode::term()) -&gt; chstate()</h3>


<div class="description">

<p>reassign all outbound and inbound resize transfers from <code>Node</code> to <code>NewNode</code></p>
</div></div>
<div class="function">
<h3 id="awaiting_resize_transfer/1">awaiting_resize_transfer(State::chstate(), Source::{integer(), term()}, Mod::atom()) -&gt; {integer(), term()} | undefined</h3>


<div class="description">

<p>returns the first awaiting resize_transfer for a {SourceIdx, SourceNode}
       pair. If all transfers for the pair are complete, undefined is returned</p>
</div></div>
<div class="function">
<h3 id="resize_transfer_status/1">resize_transfer_status(State::chstate(), Source::{integer(), term()}, Target::{integer(), term()}, Mod::atom()) -&gt; awaiting | complete | undefined</h3>


<div class="description">

<p>return the status of a resize_transfer for <code>Source</code> (an index-node pair). undefined
       is returned if no such transfer is scheduled. complete is returned if the transfer
       is marked as such or <code>Mod</code> is contained in the completed modules set. awaiting is
       returned otherwise</p>
</div></div>
<div class="function">
<h3 id="resize_transfer_complete/1">resize_transfer_complete(State::chstate(), Source::{integer(), term()}, Target::{integer(), term()}, Mod::atom()) -&gt; chstate()</h3>


<div class="description">

<p>mark a resize_transfer from <code>Source</code> to <code>Target</code> for <code>Mod</code> complete.
       if all transfers for <code>Source</code> are complete, the corresponding entry
       in next is marked complete. This requires any other resize_transfers
       for <code>Source</code> that need to be started to be scheduled before calling
       this fuction</p>
</div></div>
<div class="function">
<h3 id="is_resizing/1">is_resizing(State::chstate()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_post_resize/1">is_post_resize(State::chstate()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="is_resize_complete/1">is_resize_complete(Chstate_v2::chstate()) -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="complete_resize_transfers/1">complete_resize_transfers(State::chstate(), Source::{integer(), term()}, Mod::atom()) -&gt; [{integer(), term()}]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="deletion_complete/1">deletion_complete(State::chstate(), Idx::integer(), Mod::atom()) -&gt; chstate()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="resized_ring/1">resized_ring(State::chstate()) -&gt; {ok, chash() (see module chash)} | undefined</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="set_resized_ring/1">set_resized_ring(State::chstate(), FutureCHash::chash() (see module chash)) -&gt; chstate()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="vnode_type/1">vnode_type(State::chstate(), Idx::integer()) -&gt; primary | {fallback, term()} | future_primary | resized_primary</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="next_owner/1">next_owner(State::chstate(), Idx::integer()) -&gt; pending_change()</h3>


<div class="description">

<p>Return details for a pending partition ownership change.</p>
</div></div>
<div class="function">
<h3 id="next_owner/1-1">next_owner(State::chstate(), Idx::integer(), Mod::module()) -&gt; pending_change()</h3>


<div class="description">

<p>Return details for a pending partition ownership change.</p>
</div></div>
<div class="function">
<h3 id="completed_next_owners/2">completed_next_owners(Mod, Chstate_v2) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="ring_ready/1">ring_ready(State::chstate()) -&gt; boolean()</h3>


<div class="description">

<p>Returns true if all cluster members have seen the current ring.</p>
</div></div>
<div class="function">
<h3 id="ring_ready/0">ring_ready() -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="ring_ready_info/1">ring_ready_info(State0) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="handoff_complete/1">handoff_complete(State::chstate(), Idx::integer(), Mod::module()) -&gt; chstate()</h3>


<div class="description">

<p>Marks a pending transfer as completed.</p>
</div></div>
<div class="function">
<h3 id="ring_changed/2">ring_changed(Node, State) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="future_ring/1">future_ring(State::chstate()) -&gt; chstate()</h3>


<div class="description">

<p>Return the ring that will exist after all pending ownership transfers
       have completed.</p>
</div></div>
<div class="function">
<h3 id="pretty_print/2">pretty_print(Ring, Opts) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="cancel_transfers/1">cancel_transfers(Ring) -&gt; term()
</h3>


<div class="description">

<p>Return a ring with all transfers cancelled - for claim sim</p>
</div></div>
<div class="function">
<h3 id="legacy_reconcile/2">legacy_reconcile(ExternState, MyState) -&gt; term()
</h3>


<div class="description">

<p>Incorporate another node's state into our view of the Riak world.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
