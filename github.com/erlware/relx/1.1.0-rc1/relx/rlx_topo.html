<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>rlx_topo (relx) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>rlx_topo</h1>
<h2 class="modsummary">    
This is a pretty simple topological sort for erlang.</h2>
<div class="description">
<p>    
This is a pretty simple topological sort for erlang. It was    
originally written for ermake by Joe Armstrong back in '98. It    
has been pretty heavily modified by Eric Merritt since '06 and modified again for Relx.</p>
  
    <p>A partial order on the set S is a set of pairs {Xi,Xj} such that    
some relation between Xi and Xj is obeyed.</p>
  
    A topological sort of a partial order is a sequence of elements
    [X1, X2, X3 ...] such that if whenever {Xi, Xj} is in the partial
    order i &lt; j</div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-pair">pair() = {DependentApp :: atom(), PrimaryApp :: atom()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="sort_apps/1">sort_apps(Apps::[t() (see module rlx_app_info)]) -&gt; {ok, [t() (see module rlx_app_info)]} | error() (see module relx)</h3>


<div class="description">

<p>This only does a topo sort on the list of applications and
  assumes that there is only *one* version of each app in the list of
  applications. This implies that you have already done the
  constraint solve before you pass the list of apps here to be
  sorted.</p>
</div></div>
<div class="function">
<h3 id="sort/1">sort(Pairs::[pair()]) -&gt; {ok, [atom()]} | error() (see module relx)</h3>


<div class="description">

<p>Do a topological sort on the list of pairs.</p>
</div></div>
<div class="function">
<h3 id="format_error/1">format_error(Reason::term()) -&gt; iolist()</h3>


<div class="description">

<p>nicely format the error from the sort.</p>
</div></div></div>

<authors>

<aname>Joe Armstrong</aname>
<email> </email>
<aname>Eric Merritt</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
