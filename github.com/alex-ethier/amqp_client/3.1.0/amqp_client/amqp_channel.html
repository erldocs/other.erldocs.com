<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>amqp_channel (amqp_client) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>amqp_channel</h1>
<h2 class="modsummary">This module encapsulates the client's view of an AMQP
  channel.</h2>
<div class="description">
<p>This module encapsulates the client's view of an AMQP
  channel. Each server side channel is represented by an amqp_channel
  process on the client side. Channel processes are created using the
  <url href="/home/pete/wefwefwef/docs/other/4218966869/repo/3.1.0/.xml/amqp_client/./amqp_connection.xml">amqp_connection</url> module. Channel processes are supervised
  under amqp_client's supervision tree.<br />
  <br />
  In case of a failure or an AMQP error, the channel process exits with a
  meaningful exit reason:<br />
  <br />
  </p>
    
      <em>Cause</em>
      <em>Exit reason</em>
    <br />
    
      Any reason, where Code would have been 200 otherwise
      <pre class="sh_erlang">  normal</pre>
    <br />
    
      User application calls amqp_channel:close/3
      <pre class="sh_erlang">  close_reason(app_initiated_close)</pre>
    <br />
    
      Server closes channel (soft error)
      <pre class="sh_erlang">  close_reason(server_initiated_close)</pre>
    <br />
    
      Server misbehaved (did not follow protocol)
      <pre class="sh_erlang">  close_reason(server_misbehaved)</pre>
    <br />
    
      Connection is closing (causing all channels to cleanup and
          close)
      <pre class="sh_erlang">  {shutdown, {connection_closing, amqp_reason(atom())}}</pre>
    <br />
    
      Other error
      (various error reasons, causing more detailed logging)
    <br />
  <p>
  <br />
  See type definitions below.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-amqp_method">amqp_method()</h3></div>
    <div class="type"><h3 id="type-amqp_msg">amqp_msg() = #amqp_msg{}</h3></div>
    <div class="type"><h3 id="type-amqp_reason">amqp_reason(Type) = {Type, Code, Text}</h3></div>
    <div class="type"><h3 id="type-close_reason">close_reason(Type) = {shutdown, amqp_reason(Type)}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="call/2">call(Channel, Method) -&gt; Result</h3>


<div class="description">

<p>This is equivalent to amqp_channel:call(Channel, Method, none).</p>
</div></div>
<div class="function">
<h3 id="call/3">call(Channel, Method, Content) -&gt; Result</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Method = amqp_method()</code></li><li><code>Content = amqp_msg() | none</code></li><li><code>Result = amqp_method() | ok | blocked | closing</code></li></ul>
<div class="description">

<p>This sends an AMQP method on the channel.
  For content bearing methods, Content has to be an amqp_msg(), whereas
  for non-content bearing methods, it needs to be the atom 'none'.<br />
  In the case of synchronous methods, this function blocks until the
  corresponding reply comes back from the server and returns it.
  In the case of asynchronous methods, the function blocks until the method
  gets sent on the wire and returns the atom 'ok' on success.<br />
  This will return the atom 'blocked' if the server has
  throttled the  client for flow control reasons. This will return the
  atom 'closing' if the channel is in the process of shutting down.<br />
  Note that for asynchronous methods, the synchronicity implied by
  'call' only means that the client has transmitted the method to
  the broker. It does not necessarily imply that the broker has
  accepted responsibility for the message.</p>
</div></div>
<div class="function">
<h3 id="cast/2">cast(Channel, Method) -&gt; ok</h3>


<div class="description">

<p>This is equivalent to amqp_channel:cast(Channel, Method, none).</p>
</div></div>
<div class="function">
<h3 id="cast/3">cast(Channel, Method, Content) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Method = amqp_method()</code></li><li><code>Content = amqp_msg() | none</code></li></ul>
<div class="description">

<p>This function is the same as <a href="#call/3" class="seealso">call/3</a>, except that it returns
  immediately with the atom 'ok', without blocking the caller process.
  This function is not recommended with synchronous methods, since there is no
  way to verify that the server has received the method.</p>
</div></div>
<div class="function">
<h3 id="cast_flow/3">cast_flow(Channel, Method, Content) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Method = amqp_method()</code></li><li><code>Content = amqp_msg() | none</code></li></ul>
<div class="description">

<p>Like cast/3, with flow control.</p>
</div></div>
<div class="function">
<h3 id="close/1">close(Channel) -&gt; ok | closing</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Closes the channel, invokes
  close(Channel, 200, &lt;&lt;"Goodbye"&gt;&gt;).</p>
</div></div>
<div class="function">
<h3 id="close/3">close(Channel, Code, Text) -&gt; ok | closing</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Code = integer()</code></li><li><code>Text = binary()</code></li></ul>
<div class="description">

<p>Closes the channel, allowing the caller to supply a reply code and
  text. If the channel is already closing, the atom 'closing' is returned.</p>
</div></div>
<div class="function">
<h3 id="next_publish_seqno/1">next_publish_seqno(Channel) -&gt; integer()</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>When in confirm mode, returns the sequence number of the next
  message to be published.</p>
</div></div>
<div class="function">
<h3 id="wait_for_confirms/1">wait_for_confirms(Channel) -&gt; boolean() | timeout</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Wait until all messages published since the last call have
  been either ack'd or nack'd by the broker.  Note, when called on a
  non-Confirm channel, waitForConfirms returns an error.</p>
</div></div>
<div class="function">
<h3 id="wait_for_confirms/2">wait_for_confirms(Channel, Timeout) -&gt; boolean() | timeout</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Timeout = non_neg_integer() | infinity</code></li></ul>
<div class="description">

<p>Wait until all messages published since the last call have
  been either ack'd or nack'd by the broker or the timeout expires.
  Note, when called on a non-Confirm channel, waitForConfirms throws
  an exception.</p>
</div></div>
<div class="function">
<h3 id="wait_for_confirms_or_die/1">wait_for_confirms_or_die(Channel) -&gt; true</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Behaves the same as wait_for_confirms/1, but if a nack is
  received, the calling process is immediately sent an
  exit(nack_received).</p>
</div></div>
<div class="function">
<h3 id="wait_for_confirms_or_die/2">wait_for_confirms_or_die(Channel, Timeout) -&gt; true</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Timeout = non_neg_integer() | infinity</code></li></ul>
<div class="description">

<p>Behaves the same as wait_for_confirms/1, but if a nack is
  received, the calling process is immediately sent an
  exit(nack_received). If the timeout expires, the calling process is
  sent an exit(timeout).</p>
</div></div>
<div class="function">
<h3 id="register_return_handler/2">register_return_handler(Channel, ReturnHandler) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>ReturnHandler = pid()</code></li></ul>
<div class="description">

<p>This registers a handler to deal with returned messages. The
  registered process will receive #basic.return{} records.</p>
</div></div>
<div class="function">
<h3 id="unregister_return_handler/1">unregister_return_handler(Channel) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Removes the return handler, if it exists. Does nothing if there is no
  such handler.</p>
</div></div>
<div class="function">
<h3 id="register_confirm_handler/2">register_confirm_handler(Channel, ConfirmHandler) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>ConfirmHandler = pid()</code></li></ul>
<div class="description">

<p>This registers a handler to deal with confirm-related
  messages. The registered process will receive #basic.ack{} and
  #basic.nack{} commands.</p>
</div></div>
<div class="function">
<h3 id="unregister_confirm_handler/1">unregister_confirm_handler(Channel) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Removes the confirm handler, if it exists. Does nothing if there is no
  such handler.</p>
</div></div>
<div class="function">
<h3 id="register_flow_handler/2">register_flow_handler(Channel, FlowHandler) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>FlowHandler = pid()</code></li></ul>
<div class="description">

<p>This registers a handler to deal with channel flow notifications.
  The registered process will receive #channel.flow{} records.</p>
</div></div>
<div class="function">
<h3 id="unregister_flow_handler/1">unregister_flow_handler(Channel) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li></ul>
<div class="description">

<p>Removes the flow handler, if it exists. Does nothing if there is no
  such handler.</p>
</div></div>
<div class="function">
<h3 id="call_consumer/2">call_consumer(Channel, Msg) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>Msg = any()</code></li></ul>
<div class="description">

<p>This causes the channel to invoke Consumer:handle_call/2,
  where Consumer is the amqp_gen_consumer implementation registered with
  the channel.</p>
</div></div>
<div class="function">
<h3 id="subscribe/3">subscribe(Channel, BasicConsume, Subscriber) -&gt; ok</h3>

<ul class="type">
<li><code>Channel = pid()</code></li><li><code>BasicConsume = amqp_method()</code></li><li><code>Subscriber = pid()</code></li></ul>
<div class="description">

<p>Subscribe the given pid to a queue using the specified
  basic.consume method.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
