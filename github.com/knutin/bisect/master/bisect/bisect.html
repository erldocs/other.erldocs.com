<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>bisect (bisect) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>bisect</h1>
<h2 class="modsummary"> Space-efficient dictionary implemented using a binary.</h2>
<div class="description">
<p> Space-efficient dictionary implemented using a binary</p>
 
  <p>This module implements a space-efficient dictionary with no  
overhead per entry. Read and write access is O(log n).</p>
 
  <p>Keys and values are fixed size binaries stored ordered in a larger  
binary which acts as a sparse array. All operations are implemented  
using a binary search.</p>
 
  <p>As large binaries can be shared among processes, there can be  
multiple concurrent readers of an instance of this structure.</p>
 
  <p>serialize/1 and deserialize/1</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-bindict">bindict() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#bindict{key_size = undefined | <a href="#type-key_size" class="seealso">key_size()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value_size = undefined | <a href="#type-value_size" class="seealso">value_size()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block_size = undefined | <a href="#type-block_size" class="seealso">block_size()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = undefined | binary()}</h3></div>
    <div class="type"><h3 id="type-block_size">block_size() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-key">key() = binary()</h3></div>
    <div class="type"><h3 id="type-key_size">key_size() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-value">value() = binary()</h3></div>
    <div class="type"><h3 id="type-value_size">value_size() = integer() &gt;= 1</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/1">new(KeySize::key_size(), ValueSize::value_size()) -&gt; bindict()</h3>


<div class="description">

<p> Returns a new empty dictionary where where the keys and
  values will always be of the given size.</p>
</div></div>
<div class="function">
<h3 id="new/1-1">new(KeySize::key_size(), ValueSize::value_size(), Data::binary()) -&gt; bindict()</h3>


<div class="description">

<p> Returns a new dictionary with the given data</p>
</div></div>
<div class="function">
<h3 id="insert/1">insert(B::bindict(), K::key(), V::value()) -&gt; bindict()</h3>


<div class="description">

<p> Inserts the key and value into the dictionary. If the size of
  key and value is wrong, throws badarg. If the key is already in the
  array, the value is updated.</p>
</div></div>
<div class="function">
<h3 id="update/4">update(B, K, Initial, F) -&gt; term()
</h3>


<div class="description">

<p> Update the value stored under the key by calling F on the old
  value to get a new value. If the key is not present, initial will
  be stored as the first value. Same as dict:update/4. Note: find and
  insert requires two binary searches in the binary, while update
  only needs one. It's as close to in-place update we can get in pure
  Erlang.</p>
</div></div>
<div class="function">
<h3 id="append/1">append(B::bindict(), K::key(), V::value()) -&gt; bindict()</h3>


<div class="description">

<p> Append a key and value. This is only useful if the key is known
  to be larger than any other key. Otherwise it will corrupt the bindict.</p>
</div></div>
<div class="function">
<h3 id="cas/1">cas(B::bindict(), K::key(), OldV::value() | not_found, V::value()) -&gt; bindict()</h3>


<div class="description">

<p> Check-and-set operation. If 'not_found' is specified as the
  old value, the key should not exist in the array. Provided for use
  by bisect_server.</p>
</div></div>
<div class="function">
<h3 id="find/1">find(B::bindict(), K::key()) -&gt; value() | not_found</h3>


<div class="description">

<p> Returns the value associated with the key or 'not_found' if
  there is no such key.</p>
</div></div>
<div class="function">
<h3 id="find_many/1">find_many(B::bindict(), Keys::[key()]) -&gt; [value() | not_found]</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="delete/1">delete(B::bindict(), K::key()) -&gt; bindict()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="next/1">next(B::bindict(), K::key()) -&gt; {key(), value()} | not_found</h3>


<div class="description">

<p> Returns the next larger key and value associated with it or
  'not_found' if no larger key exists.</p>
</div></div>
<div class="function">
<h3 id="next_nth/1">next_nth(B::bindict(), K::key(), Steps::non_neg_integer()) -&gt; value() | not_found</h3>


<div class="description">

<p> Returns the nth next larger key and value associated with it
  or 'not_found' if it does not exist.</p>
</div></div>
<div class="function">
<h3 id="first/1">first(B::bindict()) -&gt; {key(), value()} | not_found</h3>


<div class="description">

<p> Returns the first key-value pair or 'not_found' if the dict is empty</p>
</div></div>
<div class="function">
<h3 id="last/1">last(B::bindict()) -&gt; {key(), value()} | not_found</h3>


<div class="description">

<p> Returns the last key-value pair or 'not_found' if the dict is empty</p>
</div></div>
<div class="function">
<h3 id="foldl/1">foldl(B::bindict(), F::function(), Acc::any()) -&gt; any()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="compact/1">compact(B) -&gt; term()
</h3>


<div class="description">

<p> Compacts the internal binary used for storage, by creating a
  new copy where all the data is aligned in memory. Writes will cause
  fragmentation.</p>
</div></div>
<div class="function">
<h3 id="expected_size/2">expected_size(B, NumKeys) -&gt; term()
</h3>


<div class="description">

<p> Returns how many bytes would be used by the structure if it
  was storing NumKeys.</p>
</div></div>
<div class="function">
<h3 id="expected_size_mb/2">expected_size_mb(B, NumKeys) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="num_keys/1">num_keys(B::bindict()) -&gt; integer()</h3>


<div class="description">

<p> Returns the number of keys in the dictionary</p>
</div></div>
<div class="function">
<h3 id="size/1">size(Bindict) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="serialize/1">serialize(Bindict::bindict()) -&gt; binary()</h3>


<div class="description">

<p> Returns a binary representation of the dictionary which can
  be deserialized later to recreate the same structure.</p>
</div></div>
<div class="function">
<h3 id="deserialize/1">deserialize(Bin::binary()) -&gt; bindict()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="bulk_insert/2">bulk_insert(Bindict, Orddict) -&gt; term()
</h3>


<div class="description">

<p> Insert a batch of key-value pairs into the dictionary. A new
  binary is only created once, making it much cheaper than individual
  calls to insert/2. The input list must be sorted.</p>
</div></div>
<div class="function">
<h3 id="merge/2">merge(Small, Big) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="intersection/1">intersection(Bs) -&gt; term()
</h3>


<div class="description">

<p> Intersect two or more bindicts by key. The resulting bindict
  contains keys found in all input bindicts.</p>
</div></div>
<div class="function">
<h3 id="intersection/2">intersection(Bs, X2) -&gt; term()
</h3>


<div class="description">

<p> SvS set intersection algorithm, as described in
  http://www.cs.toronto.edu/~tl/papers/fiats.pdf</p>
</div></div>
<div class="function">
<h3 id="from_orddict/2">from_orddict(Bindict, Orddict) -&gt; term()
</h3>


<div class="description">

<p> Populates the dictionary with data from the orddict, taking
  advantage of the fact that it is already ordered. The given bindict
  must be empty, but contain size parameters.</p>
</div></div>
<div class="function">
<h3 id="to_orddict/1">to_orddict(Bindict) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
