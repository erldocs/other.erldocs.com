<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>gossip_load (scalaris) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>gossip_load</h1>
<h2 class="modsummary">Gossip based aggregation of load information.</h2>
<div class="description">
<p>Gossip based aggregation of load information.
       This module implements the symmetric push-sum protocol. The algorithm is
       used to compute aggregates of the load information, which is measured as
       the count of items currently in a node's key range. <br />
       The aggregation of load information is used in Scalaris for two purposes:
       First, for passive load balancing. When a node  joins, the gossiped load
       information is used to decide where to place the new node. The node will
       be placed so that the standard deviation of the load is reduced the most.
       Second, the gossiping is used for system monitoring. The local estimates
       of the gossiping can be viewed for example in the Web Interface of every
       Scalaris node. <br />
       Different metrics are computed on the load information:
       </p><list>
           <item><p> average load, the arithmetic mean of all nodes load information </p></item>
           <item><p> the maximum load </p></item>
           <item><p> the minimum load </p></item>
           <item><p> standard deviation of the average load </p></item>
           <item><p> leader based size, based on counting </p></item>
           <item><p> key range bases size, calculated as address space of keys / average key range per node </p></item>
           <item><p> histogram of load per key range (load measured as number of items per node) </p></item>
       </list><p>
       The module is initialised during the startup of the gossiping framework,
       continuously aggregating load information in the background. Additionally,
       is it possible to start instances of the module for the purpose of computing
       different sizes histograms, request_histogram/1.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-avg">avg() = {Value :: float(), Weight :: float()}</h3></div>
    <div class="type"><h3 id="type-avg_kr">avg_kr() = {Value :: number(), Weight :: float()}</h3></div>
    <div class="type"><h3 id="type-bucket">bucket() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Interval :: <a href="intervals.html#type-interval" class="seealso">intervals:interval()</a>, Avg :: <a href="#type-avg" class="seealso">avg()</a> | unknown}</h3></div>
    <div class="type"><h3 id="type-data">data() = {<a href="#type-load_data_list" class="seealso">load_data_list()</a>, <a href="#type-ring_data" class="seealso">ring_data()</a>}</h3></div>
    <div class="type"><h3 id="type-full_state">full_state() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{PrevState :: unknown | <a href="#type-state" class="seealso">state()</a>, CurrentState :: <a href="#type-state" class="seealso">state()</a>}</h3></div>
    <div class="type"><h3 id="type-histogram">histogram() = [<a href="#type-bucket" class="seealso">bucket()</a>]</h3></div>
    <div class="type"><h3 id="type-histogram_size">histogram_size() = integer() &gt;= 1</h3></div>
    <div class="type"><h3 id="type-instance">instance() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Module :: gossip_load, Id :: atom() | <a href="uid.html#type-global_uid" class="seealso">uid:global_uid()</a>}</h3></div>
    <div class="type"><h3 id="type-load_data">load_data() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{load_data,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name :: atom(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avg :: <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avg2 :: <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Min :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Max :: integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Histogram :: <a href="#type-histogram" class="seealso">histogram()</a>}</h3></div>
    <div class="type"><h3 id="type-load_data_list">load_data_list() = [<a href="#type-load_data" class="seealso">load_data()</a> | <a href="#type-load_data_skipped" class="seealso">load_data_skipped()</a>, ...]</h3></div>
    <div class="type"><h3 id="type-load_data_list2">load_data_list2() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<a href="#type-load_data_uninit" class="seealso">load_data_uninit()</a> | <a href="#type-load_data_skipped" class="seealso">load_data_skipped()</a> | <a href="#type-load_data" class="seealso">load_data()</a>, ...]</h3></div>
    <div class="type"><h3 id="type-load_data_skipped">load_data_skipped() = {load_data, atom(), skip}</h3></div>
    <div class="type"><h3 id="type-load_data_uninit">load_data_uninit() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#load_data{name = atom(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg = unknown | <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg2 = unknown | <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = unknown | <a href="#type-min" class="seealso">min()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max = unknown | <a href="#type-max" class="seealso">max()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;histo = unknown | <a href="#type-histogram" class="seealso">histogram()</a>}</h3></div>
    <div class="type"><h3 id="type-load_info">load_info()</h3></div>
    <div class="type"><h3 id="type-max">max() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-min">min() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-ring_data">ring_data() = {ring_data, SizeInv :: <a href="#type-avg" class="seealso">avg()</a>, AvgKr :: <a href="#type-avg_kr" class="seealso">avg_kr()</a>}</h3></div>
    <div class="type"><h3 id="type-ring_data2">ring_data2() = <a href="#type-ring_data_uninit" class="seealso">ring_data_uninit()</a> | <a href="#type-ring_data" class="seealso">ring_data()</a></h3></div>
    <div class="type"><h3 id="type-ring_data_uninit">ring_data_uninit() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ring_data{size_inv = unknown | <a href="#type-avg" class="seealso">avg()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avg_kr = unknown | <a href="#type-avg_kr" class="seealso">avg_kr()</a>}</h3></div>
    <div class="type"><h3 id="type-round">round() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-state">state() = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#state{status = <a href="#type-status" class="seealso">status()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance = <a href="#type-instance" class="seealso">instance()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load_data_list = <a href="#type-load_data_list/2" class="seealso">load_data_list2()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring_data = <a href="#type-ring_data/2" class="seealso">ring_data2()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leader = unknown | boolean(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range = unknown | <a href="intervals.html#type-interval" class="seealso">intervals:interval()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request = boolean(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestor = none | <a href="comm.html#type-mypid" class="seealso">comm:mypid()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no_of_buckets = integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;round = <a href="#type-round" class="seealso">round()</a>,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merged = integer() >= 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convergence_count = integer() >= 0}</h3></div>
    <div class="type"><h3 id="type-status">status() = init | uninit</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="trigger_interval/0">trigger_interval() -&gt; pos_integer()</h3>


<div class="description">

<p>The time interval in ms after which a new cycle is trigger by the behaviour
       module.</p>
</div></div>
<div class="function">
<h3 id="fanout/0">fanout() -&gt; pos_integer()</h3>


<div class="description">

<p>The fanout (number of peers contacted per cycle).</p>
</div></div>
<div class="function">
<h3 id="min_cycles_per_round/0">min_cycles_per_round() -&gt; non_neg_integer()</h3>


<div class="description">

<p>The minimum number of cycles per round.
       Only full cycles (i.e. received replies) are counted (ignored triggers
       do not count as cycle).
       Only relevant for leader, all other nodes enter rounds when told to do so.</p>
</div></div>
<div class="function">
<h3 id="max_cycles_per_round/0">max_cycles_per_round() -&gt; pos_integer()</h3>


<div class="description">

<p>The maximum number of cycles per round.
       Only full cycles (i.e. received replies) are counted (ignored triggers
       do not count as cycle).
       Only relevant for leader, all other nodes enter rounds when told to do so.</p>
</div></div>
<div class="function">
<h3 id="check_config/0">check_config() -&gt; boolean()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_values_best/1">get_values_best(Options::[property() (see module proplists)]) -&gt; ok</h3>


<div class="description">

<p>Sends a (local) message to the gossip module of the requesting process'
       group asking for the best aggregation results.
       The response in the form {gossip_get_values_best_response, BestValues}
       will be send (local) to the requesting process.
       BestValues are either the aggregation restult from the current or previous round,
       depending on convergence_count_best_values.
       If the option {instance, Instance} is present, the Instance is used.
       Otherwise {gossip_load, default} is used as instance.
       If the option {source_pid, SourcePid} is present, response is sent to
       the SourcePid instead of the pid of the requesting process.
       If the option {delay, Seconds} is present, the request is delayed for (at
       least) Seconds seconds.
       If the option {send_after, Milliseconds} is present, the request is delayed
       for excatly Milliseconds milliseconds.</p>
</div></div>
<div class="function">
<h3 id="request_histogram/1">request_histogram(Size::histogram_size(), SourcePid::mypid() (see module comm)) -&gt; ok</h3>


<div class="description">

<p>Request a histogram with Size number of Buckets. <br />
       The resulting histogram will be sent to SourceId, when all values have
       properly converged.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(Args::[property() (see module proplists)]) -&gt; {ok, full_state()}</h3>


<div class="description">

<p>Initiate the gossip_load module. <br />
       Instance (mandatory) makes the module aware of its own instance id, which
       is saved in the state of the module.
       NoOfBuckets (optional) defines the size of the histogram calculated.
       Requestor (optinal) defines to whom the calculated histogram will be sent
       (used for request_histogram/1, called through the gossip module).</p>
</div></div>
<div class="function">
<h3 id="select_node/1">select_node(FullState::full_state()) -&gt; {boolean(), full_state()}</h3>


<div class="description">

<p>Returns false, i.e. peer selection is done by gossip module.
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="select_data/1">select_data(FullState::full_state()) -&gt; {ok, full_state()}</h3>


<div class="description">

<p>Select and prepare the load information to be sent to the peer. <br />
       Called by the gossip module at the beginning of every cycle. <br />
       The selected exchange data is sent back to the gossip module as a message
       of the form {selected_data, Instance, ExchangeData}.
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="select_reply_data/1">select_reply_data(PData::data(), Ref::pos_integer(), Round::round(), FullState::full_state()) -&gt; {discard_msg | ok | retry | send_back, full_state()}</h3>


<div class="description">

<p>Process the data from the requestor and select reply data. <br />
       Called by the behaviour module upon a p2p_exch message. <br />
       PData: exchange data from the p2p_exch request <br />
       Ref: used by the gossip module to identify the request <br />
       RoundStatus / Round: round information used for special handling of
           messages from previous rounds <br />
       State: the state of the gossip_load module</p>
</div></div>
<div class="function">
<h3 id="integrate_data/1">integrate_data(QData::data(), Round::round(), FullState::full_state()) -&gt; {discard_msg | ok | retry | send_back, full_state()}</h3>


<div class="description">

<p>Integrate the reply data. <br />
       Called by the behaviour module upon a p2p_exch_reply message. <br />
       QData: the reply data from the peer <br />
       RoundStatus / Round: round information used for special handling of
           messages from previous rounds <br />
       State: the state of the gossip_load module <br />
       Upon finishing the processing of the data, a message of the form
       {integrated_data, Instance, RoundStatus} is to be sent to the gossip module.</p>
</div></div>
<div class="function">
<h3 id="handle_msg/2">handle_msg(Message::{get_node_details_response, node_details() (see module node_details)}, FullState::full_state()) -&gt; {ok, full_state()}</h3>


<div class="description">

<p>Handle get_state_response messages from the dht_node. <br />
       The received load information is stored and the status is set to init,
       allowing the start of a new gossip round.
       State: the state of the gossip_load module <br /></p>
</div></div>
<div class="function">
<h3 id="round_has_converged/1">round_has_converged(FullState::full_state()) -&gt; {boolean(), full_state()}</h3>


<div class="description">

<p>Checks if the current round has converged yet <br />
       Returns true if the round has converged, false otherwise.</p>
</div></div>
<div class="function">
<h3 id="notify_change/2">notify_change(Keyword::new_round, NewRound::round(), FullState::full_state()) -&gt; {ok, full_state()}</h3>


<div class="description">

<p>Notifies the gossip_load module about changes. <br />
       Changes can be one of the following:
       </p><list>
           <item> new_round <br />
                Notifies the the callback module about the beginning of round </item>
           <item> leader <br />
                Notifies the the callback module about a change in the key range
                of the node. The MsgTag indicates whether the node is a leader
                or not, the NewRange is the new key range of the node. </item>
           <item> exch_failure <br />
                Notifies the the callback module about a failed message delivery,
                including the exchange data and round from the original message. </item>
       </list>
</div></div>
<div class="function">
<h3 id="web_debug_info/1">web_debug_info(FullState::full_state()) -&gt; {KeyValueList::[{Key::string(), Value::any()}, ...], full_state()}</h3>


<div class="description">

<p>Returns a key-value list of debug infos for the Web Interface. <br />
       Called by the gossip module upon {web_debug_info} messages.
       State: the state of the gossip_load module.</p>
</div></div>
<div class="function">
<h3 id="shutdown/1">shutdown(State::full_state()) -&gt; {ok, shutdown}</h3>


<div class="description">

<p>Shutd down the gossip_load module. <br />
       Called by the gossip module upon stop_gossip_task(CBModule).</p>
</div></div>
<div class="function">
<h3 id="load_info_get/2">load_info_get(Key::avgLoad, LoadInfoRecord::load_info()) -&gt; unknown | float()</h3>


<div class="description">

<p>Gets the value to the given key from the given load_info record.</p>
</div></div>
<div class="function">
<h3 id="load_info_other_get/2">load_info_other_get(Key::avgLoad, Module::atom(), LoadInfoRecord::load_info()) -&gt; unknown | float()</h3>


<div class="description">

<p>Gets values from a load_info_other record which can be found in the load_info record.</p>
</div></div>
<div class="function">
<h3 id="tester_create_state/1">tester_create_state(Status::status(), Instance::instance(), LoadDataList::load_data_list(), RingData::ring_data(), Leader::boolean(), Range::non_empty_interval() (see module intervals), Request::boolean(), NoOfBuckets::histogram_size(), Round::round(), Merged::non_neg_integer(), ConvergenceCount::non_neg_integer()) -&gt; state()</h3>


<div class="description">

<p>Creates a state record with greatly reduced variety in the round numbers
       to reduce warings.
       Used as value_creator in tester.erl (property testing).</p>
</div></div>
<div class="function">
<h3 id="tester_create_round/1">tester_create_round(Round::0..10) -&gt; round()</h3>


<div class="description">

<p>Creates round values with greatly reduces variance, so that more rounds
       are valid rounds (i.e. rounds from messages and from the state match).</p>
</div></div>
<div class="function">
<h3 id="tester_create_histogram/1">tester_create_histogram(ListOfAvgs::[avg() | unknown]) -&gt; histogram()</h3>


<div class="description">

<p>Creates a histogram() within the specifications of this modules, i.e.
       in particular that all histograms need to have the same keys
       (keyrange/no_of_buckets).</p>
</div></div>
<div class="function">
<h3 id="tester_create_histogram_size/1">tester_create_histogram_size(Size::1..50) -&gt; histogram_size()</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="tester_create_load_data_list/1">tester_create_load_data_list(LoadDataTuple::{load_data(), load_data(), load_data(), load_data()}) -&gt; load_data_list()</h3>


<div class="description">

<p>Creates a fixed sized list of load_data every time. Size must not change once created.
  Tester fails with massive memory leak here when input type is load_data_list().</p>
</div></div>
<div class="function">
<h3 id="is_histogram/1">is_histogram(Histogram::[{interval() (see module intervals), avg()}]) -&gt; boolean()</h3>


<div class="description">

<p>Checks if a given list is a valid histogram.
       Used as type_checker in tester.erl (property testing).</p>
</div></div>
<div class="function">
<h3 id="init_feeder/1">init_feeder(X1::{NoOfBuckets::non_neg_integer(), Requestor::mypid() (see module comm), Random1::boolean(), Random2::boolean()}) -&gt; {[property() (see module proplists)]}</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="get_values_best_feeder/1">get_values_best_feeder(X1::{Options::[property() (see module proplists)], Secs::0..1, Millisecs::0..1000}) -&gt; {[property() (see module proplists)]}</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Jens V. Fischer</aname>
<email>jensvfischer@gmail.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
