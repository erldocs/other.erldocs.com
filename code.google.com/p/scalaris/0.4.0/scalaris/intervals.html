<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>intervals (scalaris) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>intervals</h1>
<h2 class="modsummary">Interval data structure and handling functions.</h2>
<div class="description">
<p>Interval data structure and handling functions.</p>
 
  <p>All intervals created by methods of this module are normalized, i.e. simple
  intervals having unambiguous representations and complex intervals being
  lists of simple intervals sorted by the order given by interval_sort/2.
  Such a list contains no adjacent intervals except for those wrapping around,
  i.e. the first and the last element of the list. This representation is
  thus unambiguous as well.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-interval">interval()</h3></div>
    <div class="type"><h3 id="type-key">key() = <a href="rt_chord.html#type-key" class="seealso">rt_chord:key()</a> | 0</h3></div>
    <div class="type"><h3 id="type-left_bracket">left_bracket() = '(' | '['</h3></div>
    <div class="type"><h3 id="type-right_bracket">right_bracket() = ')' | ']'</h3></div>
    <div class="type"><h3 id="type-simple_interval">simple_interval() = {element, key()} | {interval, left_bracket(), key(), key(), right_bracket()} | all</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="empty/0">empty() -&gt; interval()</h3>


<div class="description">

<p>Creates an empty interval.</p>
</div></div>
<div class="function">
<h3 id="all/0">all() -&gt; interval()</h3>


<div class="description">

<p>Creates an interval covering the whole key space.</p>
</div></div>
<div class="function">
<h3 id="new/1">new(X::key()) -&gt; interval()</h3>


<div class="description">

<p>Creates an interval covering a single element.</p>
</div></div>
<div class="function">
<h3 id="new/1-1">new(LeftBr::left_bracket(), A::key(), B::key(), RightBr::right_bracket()) -&gt; interval()</h3>


<div class="description">

<p>Creates a new interval depending on the given brackets, i.e.:
       - closed interval [A, B],
       - half-open interval (A, B], aka ]A, B]
       - half-open interval [A, B), aka [A, B[
       - open interval (A, B), aka ]A, B[
       The new interval may wrap around, e.g. if A &gt; B.
       If '[A,A]' is given, an interval with the element A is created.
       The special cases '(A,A)', '[A,A)', '(A,A]' and
       '(?PLUS_INFINITY,?MINUS_INFINITY,)' translate to an empty interval.
       '[?MINUS_INFINITY,?PLUS_INFINITY)' translates to 'all'.
  -spec new(LeftBr::left_bracket(), A::key(), B::key(), RightBr::right_bracket()) -&gt; interval();
           (LeftBr::left_bracket(), A::key(), B::?PLUS_INFINITY, RightBr::')') -&gt; interval().</p>
</div></div>
<div class="function">
<h3 id="from_elements/1">from_elements(Elements::[key()]) -&gt; interval()</h3>


<div class="description">

<p>Creates an interval from a list of elements.</p>
</div></div>
<div class="function">
<h3 id="is_empty/1">is_empty(X1::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Checks whether the given interval is empty.</p>
</div></div>
<div class="function">
<h3 id="is_all/1">is_all(X1::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Checks whether the given interval is covering everything.</p>
</div></div>
<div class="function">
<h3 id="intersection/1">intersection(A::interval(), B::interval()) -&gt; interval()</h3>


<div class="description">

<p>Creates the intersection of two intervals.
       Precondition: is_well_formed(A) andalso is_well_formed(B).</p>
</div></div>
<div class="function">
<h3 id="is_subset/1">is_subset(A::interval(), B::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Returns true if A is a subset of B, i.e. the intersection of both is A.
       Precondition: is_well_formed(A) andalso is_well_formed(B).</p>
</div></div>
<div class="function">
<h3 id="in/1">in(X::key(), I::interval()) -&gt; boolean()</h3>


<div class="description">

<p>X \in I. Precondition: is_well_formed(I).</p>
</div></div>
<div class="function">
<h3 id="normalize/1">normalize(List::interval()) -&gt; interval()</h3>


<div class="description">

<p>Brings a list of intervals into normal form, i.e. sort, eliminate empty
       intervals from the list, convert intervals that wrap around into a set
       of intervals not wrapping around, merge adjacent intervals.
       Note: Outside this module, use only for testing - all intervals
       generated by this module are normalized!
       Note: This function also corrects values which are to small, i.e. less
       than ?MINUS_INFINITY, or too large, i.e. greater than or equal to
       ?PLUS_INFINITY which is only needed if types are created based on
       (potentially) inprecise type defs, e.g. in the unit tests. For internal
       use prefer normalize_internal/1 which does not fix values and is thus
       faster.</p>
</div></div>
<div class="function">
<h3 id="is_well_formed/1">is_well_formed(List::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Checks whether the given interval is normalized, i.e. not wrapping
       around and no 'interval' with equal borders (see normalize/1).
       Use only for testing - all intervals generated by this module are
       well-formed, i.e. normalized!</p>
</div></div>
<div class="function">
<h3 id="union/1">union(A::interval(), B::interval()) -&gt; interval()</h3>


<div class="description">

<p>Creates the union of two intervals.</p>
</div></div>
<div class="function">
<h3 id="is_continuous/1">is_continuous(X1::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Checks whether the given interval is a continuous interval, i.e. simple
       intervals are always continuous, complex intervals are continuous if
       they contain 2 simple intervals which are adjacent and wrap around.
       Note: empty intervals are not continuous!</p>
</div></div>
<div class="function">
<h3 id="get_bounds/1">get_bounds(T::interval()) -&gt; {left_bracket(), key(), key(), right_bracket()} | {left_bracket(), key(), 340282366920938463463374607431768211456, ')'}</h3>


<div class="description">

<p>Gets the outer bounds of a given non-empty interval including
       brackets. Note that here
       'all' transfers to {'[', ?MINUS_INFINITY, ?PLUS_INFINITY, ')'},
       {element, Key} to {'[', Key, Key, ']'} and
       [{interval,'[',?MINUS_INFINITY,Key,')'},{interval,'(',Key,?PLUS_INFINITY,')'}] to {'(', Key, Key, ')'}.
       Other continuous normalized intervals that wrap around (as well as the
       first two) are returned the same way they can be constructed with new/4.
       Note: the bounds of non-continuous intervals are not optimal!
       Note: this method will only work on non-empty intervals
       and will throw an exception otherwise!</p>
</div></div>
<div class="function">
<h3 id="get_elements/1">get_elements(I::interval()) -&gt; {Elements::[key()], RestInt::interval()}</h3>


<div class="description">

<p>Gets all elements inside the interval and returnes a "rest"-interval,
       i.e. the interval without the elements.</p>
</div></div>
<div class="function">
<h3 id="is_adjacent/1">is_adjacent(A::interval(), B::interval()) -&gt; boolean()</h3>


<div class="description">

<p>Checks whether two intervals are adjacent, i.e. the intervals are both
       continuous, their union is continuous and their intersection is empty,
       e.g. ('(A,B]', '(B,C)') with A=/=B and B=/=C.
       Note: intervals like (A,B), (B,C) are not considered adjacent because
       the element b would be between these two.</p>
</div></div>
<div class="function">
<h3 id="minus/1">minus(A::interval(), B::interval()) -&gt; interval()</h3>


<div class="description">

<p>Subtracts the second from the first interval.</p>
</div></div>
<div class="function">
<h3 id="is_left_of/1">is_left_of(X::interval(), Y::interval()) -&gt; boolean()</h3>


<div class="description">

<p>X and Y are adjacent and Y follows X</p>
</div></div>
<div class="function">
<h3 id="is_right_of/1">is_right_of(X::interval(), Y::interval()) -&gt; boolean()</h3>


<div class="description">

<p>X and Y are adjacent and X follows Y</p>
</div></div>
<div class="function">
<h3 id="split/1">split(I::interval(), Parts::pos_integer()) -&gt; [interval()]</h3>


<div class="description">

<p>Splits an continuous interval in X equally sized subintervals
       Returns: List of adjacent intervals</p>
</div></div></div>

<authors>

<aname>Thorsten Schuett</aname>
<email>schuett@zib.de</email>
<aname>Florian Schintke</aname>
<email>schintke@zib.de</email>
<aname>Nico Kruber</aname>
<email>kruber@zib.de</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
