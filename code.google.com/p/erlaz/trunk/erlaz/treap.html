<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>treap (erlaz) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>treap</h1>
<h2 class="modsummary">A Treap is a tree data structure in which each node has a priority assigned at insertion.</h2>
<div class="description">
<p>A <url href="http://en.wikipedia.org/wiki/Treap">Treap</url> is a tree data structure in which each node has a priority assigned at insertion.<br />
   While nodes in the tree are still sorted by their keys, they are also kept vertically sorted by
   their priority (i.e. a higher priority is closer to the root). <br />
   By ensuring that the generated priorities are uniformly spread the treap's tree can be kept well
   ballanced, which avoids the need of rebalancing it regularly.</p>
   <p>This implementation uses random:uniform(MAX) to generate the priority of each node.
   The treap module was written as a drop-in replacement for the standard Erlang module <em>dict</em> and implements all its methods,
   but with the corresponding performance differences.<br />
   It also provides additional methods for querying and manipulating a treap in a sorted order
   (both ascending and descending), for splitting a treap (so that one of the resulting treaps contains only
   keys smaller and the other keys only greater than a given key), for exporting a treap to a dict, list, JSON and
   XML string etc.
   </p></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/0">new() -&gt; Treap::treap()</h3>


<div class="description">

<p>Returns a new empty treap.
 </p>
</div></div>
<div class="function">
<h3 id="append/1">append(Key::any(), Value::any(), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>This function appends a new Value to the current list of values associated with Key
  (or inserts a new list containing Value if the Key was not found).</p>
</div></div>
<div class="function">
<h3 id="append_list/1">append_list(Key::any(), Values::[any()], Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>This function appends a list of values Values to the current list of values associated with Key.
  (or inserts the new list if the Key was not found).
 </p>
</div></div>
<div class="function">
<h3 id="erase/1">erase(Key::any(), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>This function erases all items with a given key from a dictionary.</p>
</div></div>
<div class="function">
<h3 id="store/1">store(Key::any(), Value::any(), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>This function stores a Key - Value pair in a treap.<br />
  If the Key already exists in Treap, the associated list of values is replaced by [Value].
 </p>
</div></div>
<div class="function">
<h3 id="find/1">find(Key::any(), Treap::treap()) -&gt; error | {ok, Values::[any()]}</h3>


<div class="description">

<p>This function searches for a key in a treap. <br />
  Returns {ok, Values} where Values is a list of the values associated with Key,
  or error if the key is not present in the treap.
 </p>
</div></div>
<div class="function">
<h3 id="fetch/1">fetch(Key::any(), Treap::treap()) -&gt; Values::[any()]</h3>


<div class="description">

<p>This function returns the value associated with Key in the treap Treap.<br />
  <em>fetch</em> assumes that the Key is present in the treap and an exception
  is generated if Key is not in the treap.</p>
</div></div>
<div class="function">
<h3 id="fetch_keys/1">fetch_keys(Treap::treap()) -&gt; Values::[any()]</h3>


<div class="description">

<p>This function returns a list of all keys in the treap.</p>
</div></div>
<div class="function">
<h3 id="fetch_keysl/1">fetch_keysl(Treap::treap()) -&gt; Values::[any()]</h3>


<div class="description">

<p>This function returns a list of all keys in the treap in an <em>ascending</em> order.</p>
</div></div>
<div class="function">
<h3 id="fetch_keysr/1">fetch_keysr(Treap::treap()) -&gt; Values::[any()]</h3>


<div class="description">

<p>This function returns a list of all keys in the treap in a <em>descending</em> order.</p>
</div></div>
<div class="function">
<h3 id="split/1">split(Key::any(), Treap::treap()) -&gt; {Treap1::treap(), Treap2::treap()}</h3>


<div class="description">

<p>This function splits the Treap in 2 separate treaps:
  </p><list>
  <item><p>Treap1, containing all keys smaller or equal to Key.</p></item>
  <item><p>Treap2 containing all keys greater than Key.</p></item>
  </list>
</div></div>
<div class="function">
<h3 id="unsplit/1">unsplit(Treap1::treap(), Treap2::treap()) -&gt; Treap3::treap()</h3>


<div class="description">

<p>This function merges two treaps that meet the requirement that the largest
  key in one of the treaps is smaller than the smallest key in the other
  (i.e. they could have been produced by calling split/2).<br />
  <i>eThis is equivalent to undoing split/2</i>
 </p>
</div></div>
<div class="function">
<h3 id="filter/1">filter(Pred::function(Key::any(), Value::[any()]), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Returns NewTreap, which is a treap of only the keys and values in Treap for which Pred(Key, Value) is true.
 </p>
</div></div>
<div class="function">
<h3 id="is_key/1">is_key(Key::any(), Treap::treap()) -&gt; TrueOrFalse::boolean()</h3>


<div class="description">

<p>This function tests if Key is contained in the treap Treap.
 </p>
</div></div>
<div class="function">
<h3 id="map/1">map(Fun::function(Key::any(), Values::[any()]), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Returns a new treap NewTreap, build by mapping the result from calling Fun(Key, OldValues) to Key for each key of Treap.
  If the result of the function is a non-empty list it's put as the new value, else the result is first enclosed in a list.
 </p>
</div></div>
<div class="function">
<h3 id="merge/1">merge(Fun::function(Value1::[any()], Value2::[any()]), Treap1::treap(), Treap2::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Merges two treaps, Treap1 and Treap2, to create a new treap.
  All the Key - Value pairs from both treaps are included in the new treap.
  If a key occurs in both treaps then Fun is called with the key and both values to return a new value.
 </p>
</div></div>
<div class="function">
<h3 id="to_list/1">to_list(Treap::treap()) -&gt; [{Key::any(), Values::[any()]}]</h3>


<div class="description">

<p>Converts the treap to a key/value (unordered) list.</p>
</div></div>
<div class="function">
<h3 id="to_listl/1">to_listl(Treap::treap()) -&gt; [{Key::any(), Values::[any()]}]</h3>


<div class="description">

<p>Converts the treap to a key/value list sorted by the keys in ascending order.</p>
</div></div>
<div class="function">
<h3 id="to_listr/1">to_listr(Treap::treap()) -&gt; [{Key::any(), Values::[any()]}]</h3>


<div class="description">

<p>Converts the treap to a key/value list sorted by the keys in descending order.</p>
</div></div>
<div class="function">
<h3 id="from_list/1">from_list(List::[{Key::any(), Value::any()}]) -&gt; treap()</h3>


<div class="description">

<p>Converts a key/value list to a treap.</p>
</div></div>
<div class="function">
<h3 id="foreach/1">foreach(Fun::function(Key::any(), Values::[any()]), Treap::treap()) -&gt; ok</h3>


<div class="description">

<p>Do a level-order traversal and call Fun for every node ignoring its result.</p>
</div></div>
<div class="function">
<h3 id="foreachl/1">foreachl(Fun::function(Key::any(), Values::[any()]), Treap::treap()) -&gt; ok</h3>


<div class="description">

<p>Traverse Treap in ascending order of the keys and call Fun on every node ignoring its result.</p>
</div></div>
<div class="function">
<h3 id="foreachr/1">foreachr(Fun::function(Key::any(), Values::[any()]), Treap::treap()) -&gt; ok</h3>


<div class="description">

<p>Traverse Treap in descending order of the keys and call Fun on every node ignoring its result.</p>
</div></div>
<div class="function">
<h3 id="foreach_spawn/1">foreach_spawn(Fun::function(Key::any(), Values::[any()]), Treap::treap()) -&gt; ok</h3>


<div class="description">

<p>Traverse Treap by starting a new process for every node and running Fun inside it.</p>
</div></div>
<div class="function">
<h3 id="fold/1">fold(Fun::function(Key::any(), Values::[any()], OldAcc::any()), Acc::any(), Treap::treap()) -&gt; NextAcc::any()</h3>


<div class="description">

<p>Call Fun on successive keys and values of Treap together with an extra argument Acc (short for accumulator).
  Fun must return a new accumulator which is passed to the next call.
  Acc is returned if the list is empty, else the result of the last call of Fun.
  The order of the handled keys is undefined (the treap is traversed in a level-order,
  which avoids using a stack and would use less memory than foldl and foldr for large treaps).
 </p>
</div></div>
<div class="function">
<h3 id="foldl/1">foldl(Fun::function(Key::any(), Values::[any()], OldAcc::any()), Acc::any(), Treap::treap()) -&gt; NextAcc::any()</h3>


<div class="description">

<p>Call Fun on successive keys and values of Treap together with an extra argument Acc (short for accumulator).
  Fun must return a new accumulator which is passed to the next call.
  Acc is returned if the list is empty, else the result of the last call of Fun.
  The keys are handled in ascending order.
 </p>
</div></div>
<div class="function">
<h3 id="foldr/1">foldr(Fun::function(Key::any(), Values::[any()], OldAcc::any()), Acc::any(), Treap::treap()) -&gt; NextAcc::any()</h3>


<div class="description">

<p>Call Fun on successive keys and values of Treap together with an extra argument Acc (short for accumulator).
  Fun must return a new accumulator which is passed to the next call.
  Acc is returned if the list is empty, else the result of the last call of Fun.
  The keys are handled in descending order.
 </p>
</div></div>
<div class="function">
<h3 id="to_xml/1">to_xml(Treap::treap()) -&gt; XML::iolist()</h3>


<div class="description">

<p>Returns a printable XML represnetation of the treap as an IoList  
The keys in the returned XML are sorted in ascending order.</p>
 
  <p>WARNING! This is an experimental function and may have issues with complex
  key or value types.
 </p>
</div></div>
<div class="function">
<h3 id="to_json/1">to_json(Treap::treap()) -&gt; JSON::iolist()</h3>


<div class="description">

<p>Returns a printable JSON represnetation of the treap as an IoList  
The keys in the returned JSON are sorted in ascending order.</p>
 
  <p>WARNING! This is an experimental function and may have issues with complex
  key or value types.
 </p>
</div></div>
<div class="function">
<h3 id="to_dict/1">to_dict(Treap::treap()) -&gt; Dict::dictionary() (see module dict)</h3>


<div class="description">

<p>Returns a new dictionary containing the same key/values mappings as Treap.</p>
</div></div>
<div class="function">
<h3 id="to_dict/1-1">to_dict(Treap::treap(), Dict::dictionary() (see module dict)) -&gt; NewDict::dictionary() (see module dict)</h3>


<div class="description">

<p>Returns a dictionary resulting from adding all the key/values mappings
  from Treap to the existing dictionary Dict. If a key is already present
  the behavior is like calling dict:append_list(Key, treap::fetch(Key, Treap)).
 </p>
</div></div>
<div class="function">
<h3 id="from_dict/1">from_dict(Dict::dictionary() (see module dict)) -&gt; Treap::treap()</h3>


<div class="description">

<p>Returns a new treap containing the same key/values mappings as Dict.</p>
</div></div>
<div class="function">
<h3 id="from_dict/1-1">from_dict(Dict::dictionary() (see module dict), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Returns a treap resulting from adding all the key/values mappings
  from Dict to the existing treap Treap. If a key is already present
  the behavior is like calling treap:append_list(Key, dict::fetch(Key, Dict)).
 </p>
</div></div>
<div class="function">
<h3 id="size/1">size(Treap::treap()) -&gt; Size::integer()</h3>


<div class="description">

<p>Returns the number of elements in dict.</p>
</div></div>
<div class="function">
<h3 id="count_values/1">count_values(Treap::treap()) -&gt; Count::integer()</h3>


<div class="description">

<p>Returns the the total number of all items stored in the treap.</p>
</div></div>
<div class="function">
<h3 id="update/1">update(Key::any(), Fun::function(Values::[any()]), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Update the a value in a treap by calling Fun on the value to get a new value.
  An exception is generated if Key is not present in the treap.
  If Fun returns a non-empty list it is directly used as the new value, else
  the result is enclosed in a list.
 </p>
</div></div>
<div class="function">
<h3 id="update/1-1">update(Key::any(), Fun::function(Values::[any()]), Initial::any(), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Update the a value in a treap by calling Fun on the value to get a new value.
  If Key is not present in the treap then Initial will be stored as the first value.
  If Fun returns a non-empty list it is directly used as the new value, else
  the result is enclosed in a list.
 </p>
</div></div>
<div class="function">
<h3 id="update_counter/1">update_counter(Key::any(), Inc::number(), Treap::treap()) -&gt; NewTreap::treap()</h3>


<div class="description">

<p>Add Inc to the value associated with Key and store the new value.
  If Key is not present in the treap then Inc will be stored as the first value.
 </p>
</div></div>
<div class="function">
<h3 id="debug_tree/1">debug_tree(X1) -&gt; term()
</h3>


<div class="description">
 </div></div></div>

<authors>

<aname>Plamen Dragozov</aname>
<email>plamen@dragozov.com</email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
