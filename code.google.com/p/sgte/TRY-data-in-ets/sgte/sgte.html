<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>sgte (sgte) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>sgte</h1>
<h2 class="modsummary">.</h2>
<div class="description">
<p>The <em>SGTE</em> module is a library implementing a Template Engine
   The template system is inspired on <url href="http://www.stringtemplate.org">String Template</url>
   </p><p>
   The use of the Engine is as simple as (from the command line):
   </p><pre class="sh_erlang">
   &gt; {ok, Compiled} = sgte:compile(TmplStr),
   &gt; sgte:render(Compiled, Data).
   or:
   &gt; {ok, Compiled} = sgte:compile_file(FileName),
   &gt; sgte:render(Compiled, Data).
   </pre><p>
   Data can be a Dict or a list of tuple (e.g. [{attr1, Val1}, {attr2, Val2}])
   Values can be a simple value or a function/1. In this case the function is
   called with Data as an argument.
   </p>
   <em>Template Features</em>
   Below some of the template features.
   <em>Attribute reference</em>
   Attribute reference is written as:
   <pre class="sh_erlang">
   $name$
   </pre> Here is an example:
   <pre class="sh_erlang">
   &gt; {ok, C} = sgte:compile("Hello $name$!"),
   &gt; sgte:render(C, [{name, "Filippo").
   "Hello Filippo!"
   </pre>
   You can also use attribute references to access nested structures. Eg.:
   <pre class="sh_erlang">
   &gt; {ok, C} = sgte:compile("$foo.bar.baz$"),
   &gt; sgte:render(C, [{foo, [{bar, [{baz, "a string"}]}]}]),
   "a string"
   </pre>
   <em>Template reference</em>
   <pre class="sh_erlang">
   $include tmpl$
   </pre> Includes an external template.
   <em>Application of an attribute to another</em>
   <pre class="sh_erlang">
   $apply myFun aVar$
   </pre> When the first attribute is callable you get the
   result of myFun(aVar). Otherwhise the result is the value of
   myFun.
   <em>Conditional evaluation</em>
     <pre class="sh_erlang">
     $if title$
         &lt;h1&gt;$title$&lt;/h1&gt;
     $else$
         &lt;h1&gt;default title&lt;/h1&gt;
     $end if$
     </pre>
   <em>Template application to a list of elements</em>
   if names is a list [{username, name1}, {username, name2}]
   <pre class="sh_erlang">
   $map li names$
   </pre>
   map li template to names. Each element in names is passed to the template with name attr.
   If li is the template:
   <pre class="sh_erlang">
   &lt;li&gt;&lt;b&gt;$username$&lt;/b&gt;&lt;/li&gt;</pre>
   We get the result:
   <pre class="sh_erlang">
   &lt;li&gt;&lt;b&gt;name1&lt;/b&gt;&lt;/li&gt;
   &lt;li&gt;&lt;b&gt;name2&lt;/b&gt;&lt;/li&gt;
   </pre>
   Another way to express the same template inline is:
   <pre class="sh_erlang">
   $map:{&lt;li&gt;&lt;b&gt;$username$&lt;/b&gt;&lt;/li&gt;} names$
   </pre>
   <em>Join of items using a separator</em>
   <pre class="sh_erlang">
   SELECT $join:{,} columns$ FROM $table$;
   </pre>
   <em>Internationalization support using gettext</em>
   Gettext is a package that can be found in jungerl. It
   supports internationalization using the GNU Gettext format.
   <pre class="sh_erlang">
   $txt:{Hello World}$
   </pre>
   Here's an example supposing you already have .po files containing
   translated strings:
   <pre class="sh_erlang">
   &gt; {ok, C} = sgte:compile("$txt:{Hello World}$"),
   &gt; sgte:render(C, [{options, [{gettext_lc, "en"}]}]).
   "Hello World"
   &gt; sgte:render(C, [{options, [{gettext_lc, "it"}]}]).
   "Ciao Mondo"
   </pre>
  </div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-compiled">compiled() = [char() | token()]</h3></div>
    <div class="type"><h3 id="type-data">data() = [tuple()] | dict()</h3></div>
    <div class="type"><h3 id="type-domain">domain() = string()</h3></div>
    <div class="type"><h3 id="type-gettext_tuple">gettext_tuple() = {Key, LineNo}</h3></div>
    <div class="type"><h3 id="type-options">options() = [option()]</h3></div>
    <div class="type"><h3 id="type-src_files">src_files() = [string()]</h3></div>
    <div class="type"><h3 id="type-target_dir">target_dir() = string()</h3></div>
    <div class="type"><h3 id="type-template">template() = string() | binary()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="compile/1">compile(T::template()) -&gt; {ok, C::compiled()} | {error, Reason}</h3>


<div class="description">

<p>Compiles the template string T and returns the compiled
  template or an error.</p>
</div></div>
<div class="function">
<h3 id="compile_file/1">compile_file(FileName) -&gt; {ok, C::compiled()} | {error, Reason}</h3>


<div class="description">

<p>Compiles the template file FileName and returns the compiled
  template or an error.</p>
</div></div>
<div class="function">
<h3 id="render/1">render(C::compiled(), Data::data(), Options::options()) -&gt; string()</h3>


<div class="description">

<p>Renders the compiled template.</p>
</div></div>
<div class="function">
<h3 id="render/1-1">render(C::compiled(), Data::data()) -&gt; string()</h3>


<div class="description">

<p>Renders the compiled template.</p>
</div></div>
<div class="function">
<h3 id="gettext_strings/1">gettext_strings(T::template()) -&gt; [gettext_tuple()]</h3>


<div class="description">

<p>Extracts from template T the list of gettext keys
  with associated line numbers.
  This is a utility function to use in cojunction with gettext
  to create initial .po files.</p>
</div></div>
<div class="function">
<h3 id="gettext_init/1">gettext_init(SrcFiles::src_files()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Creates the gettext template file (.pot).
  SrcFiles is the list of files to be parsed for gettext strings.
  Each gettext string found will be written to the .pot file.
  The default name of the generated file will be messages.pot.</p>
</div></div>
<div class="function">
<h3 id="gettext_init/1-1">gettext_init(TargetDir::target_dir(), SrcFiles::src_files()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Creates the gettext template file (.pot).
  TargetDir is the directory where the file will be created.
  If TargetDir doesn't exists it will be created.
  SrcFiles is the list of files to be parsed for gettext strings.
  Each gettext string found will be written to the .pot file.
  The file name of the generated file will be messages.pot.</p>
</div></div>
<div class="function">
<h3 id="gettext_init/1-2">gettext_init(TargetDir::target_dir(), SrcFiles::src_files(), Domain::domain()) -&gt; ok | {error, Reason}</h3>


<div class="description">

<p>Creates the gettext template file (.pot).
  TargetDir is the directory where the file will be created.
  If TargetDir doesn't exists it will be created.
  SrcFiles is the list of files to be parsed for gettext strings.
  Each gettext string found will be written to the .pot file.
  Domain (when present) is the name of the file to generate.
  If no Domain is defined the default name will be messages.pot.</p>
</div></div>
<div class="function">
<h3 id="rec_to_name_kv/2">rec_to_name_kv(RecordTuple, Keys::[atom()]) -&gt; sgte_record() | {error, not_enough_keys} | {error, too_much_keys}</h3>


<div class="description">

<p>TODO: write doc</p>
</div></div>
<div class="function">
<h3 id="rec_to_kv/2">rec_to_kv(RecordTuple, Keys::[atom()]) -&gt; sgte_record() | {error, not_enough_keys} | {error, too_much_keys}</h3>


<div class="description">

<p>TODO: write doc</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
