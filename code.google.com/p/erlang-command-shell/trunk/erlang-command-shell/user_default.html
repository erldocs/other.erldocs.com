<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>user_default (erlang-command-shell) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>user_default</h1>
<h2 class="modsummary">Erlang Command Shell.</h2>
<div class="description">
<p>Erlang Command Shell</p>
 
  <p>The Erlang Command Shell is a module intended to be installed as
  <code>user_default</code>. Doing so will enhance the commands available in  
the shell, replacing some Unix-style command shell functionality.  
The intention is not so much to replace a Unix shell in all circumstances  
but to provide benefits where basic shell tasks can be carried out from  
within the Erlang shell.</p>
 
  <p>Some functions are inspired by Perl, as well, as, for example, the
  Perl <code>chomp</code> and <code>split</code> functions are superior to or have no equivalent
  in shell languages.
 </p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-command">command() = string()</h3></div>
    <div class="type"><h3 id="type-fileinfo">fileinfo() = #file_info{} | [{atom(), term()}]</h3></div>
    <div class="type"><h3 id="type-filename">filename() = string() | atom()</h3></div>
    <div class="type"><h3 id="type-filespec">filespec() = globpattern() | filename() | [filename()]</h3></div>
    <div class="type"><h3 id="type-globpattern">globpattern() = string() | atom()</h3></div>
    <div class="type"><h3 id="type-joberror">joberror() = {job_server_timeout, term()}</h3></div>
    <div class="type"><h3 id="type-option">option() = atom() | {atom(), term()}</h3></div>
    <div class="type"><h3 id="type-options">options() = [option()]</h3></div>
    <div class="type"><h3 id="type-results">results() = [{string(), ok | {error, term()}}]</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="stat/1">stat(F::filename()) -&gt; fileinfo()</h3>


<div class="description">

<p>Gets the file_info structure (see <a href="file.html#read_file_info/1" class="seealso">file:read_file_info/1</a>) for
  the file.</p>
</div></div>
<div class="function">
<h3 id="stat/1-1">stat(F::filename(), Opt::options()) -&gt; fileinfo()</h3>


<div class="description">

<p>Gets the file_info structure (see <a href="file.html#read_file_info/1" class="seealso">file:read_file_info/1</a>) for
  the file. If the <code>filist</code> option is present, returns the value as a
  keylist rather than a <code>file_info</code> record.</p>
</div></div>
<div class="function">
<h3 id="r/0">r() -&gt; {ok, user_default} | error</h3>


<div class="description">

<p>Recompiles and reloads the user_default module. Convenient when
  changing. Think <code>alias r=. ~/.bashrc</code>.</p>
</div></div>
<div class="function">
<h3 id="chomp/1">chomp(X::string()) -&gt; string()</h3>


<div class="description">

<p>Chomps the line ending from the string. Note that this is hardcoded
  to Unix line-ending convention.</p>
</div></div>
<div class="function">
<h3 id="chomp/2">chomp(X, Opt) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="cat/1">cat(Files::filespec()) -&gt; [string()]</h3>


<div class="description">

<p>The cat function returns a list of lines in the specified file(s).
  The line endings are stripped with the <a href="#chomp/1" class="seealso">chomp/1</a> function.
  If this is not desired, use <a href="#chomp/2" class="seealso">chomp/2</a>.</p>
 
  <p>The files may be specified as an atom, a list of atoms, a string or
  list of strings. Any wildcard globbing patterns in any of the specifications
  are expanded (see <a href="filelib.html#wildcard/1" class="seealso">filelib:wildcard/1</a>).</p>
</div></div>
<div class="function">
<h3 id="cat/1-1">cat(Files::filespec(), Opts::options()) -&gt; [string()]</h3>


<div class="description">

<p>As <a href="#cat/1" class="seealso">cat/1</a>, but you can specify the <code>nochomp</code> option to avoid
  the line-endings being chomped.</p>
</div></div>
<div class="function">
<h3 id="printf/1">printf(Format::string(), Exprs::[term()]) -&gt; string()</h3>


<div class="description">

<p>Returns a formatted list (using the same formatting specification
  as <a href="io.html#format/2" class="seealso">io:format/2</a>).</p>
</div></div>
<div class="function">
<h3 id="printf/3">printf(Format, Exprs, Opt) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="grep/1">grep(Pattern::string(), Lines) -&gt; Lines</h3>

<ul class="type">
<li><code>Lines = [string()] | bool()</code></li></ul>
<div class="description">

<p>Matches the regular expression pattern against the list of strings
  given, returning a list of matching lines (see <a href="regexp.html" class="seealso">regexp</a>).</p>
</div></div>
<div class="function">
<h3 id="grep/1-1">grep(Pattern::string(), Lines::ScanList, Opt::options()) -&gt; Lines | FileLines</h3>

<ul class="type">
<li><code>ScanList = filespec() | [string()]</code></li><li><code>Lines = [string()] | [{File, Lines}] | bool() | [File]</code></li><li><code>File = string()</code></li></ul>
<div class="description">

<p>By default, matches the regular expression against the list of
  strings, returning a list of matching lines (see <a href="regexp.html" class="seealso">regexp</a>). If
  the <code>files</code> option is given, interprets the scan list to be a list
  of file specifications (see <a href="#cat/1" class="seealso">cat/1</a>). Matching lines from each  
file are returned in a list, as the second element of a tuple whose  
first element is the filename.</p>
 
  <p>If the <code>quiet</code> option is given, merely returns <code>true</code> if any of the
  lines match (or, when a list of files is given, a list of the names
  of the files with any matching line). This short-circuits unnecessary
  scanning.</p>
</div></div>
<div class="function">
<h3 id="grepf/1">grepf(Pattern::string(), Files::filespec()) -&gt; [{File, Lines}] | [File]</h3>

<ul class="type">
<li><code>File = string()</code></li><li><code>Lines = [string()]</code></li></ul>
<div class="description">

<p>As <a href="#grep/3" class="seealso">grep/3</a>, without having to specify the <code>files</code> option.</p>
</div></div>
<div class="function">
<h3 id="grepf/1-1">grepf(Pattern::string(), Files::filespec(), Opt::options()) -&gt; [{File, Lines}] | [File]</h3>

<ul class="type">
<li><code>File = string()</code></li><li><code>Lines = [string()]</code></li></ul>
<div class="description">
 </div></div>
<div class="function">
<h3 id="wc/1">wc(L::Lines) -&gt; Count</h3>

<ul class="type">
<li><code>Lines = [string()]</code></li><li><code>Count = {Linecount, Wordcount, Bytecount}</code></li><li><code>Linecount = integer()</code></li><li><code>Wordcount = integer()</code></li><li><code>Bytecount = integer()</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#wc/2" class="seealso">wc/2</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="wc/2">wc(Lines::ScanList, Opt::options()) -&gt; Count</h3>

<ul class="type">
<li><code>ScanList = [string()] | filespec()</code></li><li><code>Count = SimpleCount | [{File, SimpleCount}]</code></li><li><code>SimpleCount = {integer(), integer(), integer()} | {integer(), integer()} | integer()</code></li></ul>
<div class="description">

<p>Count the lines, words and bytes in the input. The input can be
  specified as a list of lines (the default) or as a file specification
  (see <a href="#cat/1" class="seealso">cat/1</a>) if the <code>files</code> option is given. When scanning files,
  <code>wc/2</code> keeps a running total of the counted attributes, and includes
  a "total" tuple in the result. If this is not desired, use the <code>nototal</code>  
option.</p>
 
  <p>By default, lines, words (see <a href="string.html#words/1" class="seealso">string:words/1</a>) and bytes are
  counted, and returned as three-tuples. If two of <code>lines</code>, <code>words</code> or
  <code>characters</code> are given, two-tuples are returned instead, with the
  applicable attributes. If only one of these options is given, results
  are returned as integers (not 1-tuples).</p>
</div></div>
<div class="function">
<h3 id="wcf/1">wcf(Files::filespec()) -&gt; Count</h3>

<ul class="type">
<li><code>Count = [{File, Simplecount}]</code></li><li><code>File = string()</code></li><li><code>Simplecount = {integer(), integer(), integer()}</code></li></ul>
<div class="description">

<p>Shorthand for <a href="#wc/2" class="seealso">wc/2</a> with the <code>files</code> option.</p>
</div></div>
<div class="function">
<h3 id="wcf/1-1">wcf(Files::filespec(), Opt::options()) -&gt; Count</h3>

<ul class="type">
<li><code>Count = [{File, Simplecount}]</code></li><li><code>File = string()</code></li><li><code>Simplecount = {integer(), integer(), integer()} | {integer(), integer()} | integer()</code></li></ul>
<div class="description">

<p>Shorthand for <a href="#wc/2" class="seealso">wc/2</a> with the <code>files</code> option.</p>
</div></div>
<div class="function">
<h3 id="lsl/0">lsl() -&gt; [File]</h3>

<ul class="type">
<li><code>File = string()</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#ls/1" class="seealso">ls/1</a> with <code>long</code> option.</p>
</div></div>
<div class="function">
<h3 id="lsl/1">lsl(Opt::OptOrFiles) -&gt; [{File, fileinfo()}]</h3>

<ul class="type">
<li><code>OptOrFiles = filespec() | options()</code></li><li><code>File = string()</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#ls/2" class="seealso">ls/2</a> with defaults of <code>long</code> option
  and current directory (<code>"."</code>).</p>
</div></div>
<div class="function">
<h3 id="lsl/1-1">lsl(Paths::filespec(), Opt::options()) -&gt; [{File, fileinfo()}]</h3>

<ul class="type">
<li><code>File = string()</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#ls/2" class="seealso">ls/2</a> with <code>long</code> option.</p>
</div></div>
<div class="function">
<h3 id="ls/0">ls() -&gt; [File]</h3>

<ul class="type">
<li><code>File = string()</code></li></ul>
<div class="description">

<p>Eqivalent to <a href="#ls/2" class="seealso">ls/2</a> with no options and a file specification
  of <code>"."</code>.</p>
</div></div>
<div class="function">
<h3 id="ls/1">ls(Opt::OptOrFiles) -&gt; Listing</h3>

<ul class="type">
<li><code>OptOrFiles = filespec() | options()</code></li><li><code>Listing = [File] | [{File, fileinfo()}]</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#ls/2" class="seealso">ls/2</a> with no default options and a default
  file specification of <code>"."</code>.</p>
</div></div>
<div class="function">
<h3 id="ls/1-1">ls(Path::filespec(), Opt::options()) -&gt; Listing</h3>

<ul class="type">
<li><code>Listing = [File] | [{File, fileinfo()}]</code></li></ul>
<div class="description">

<p>List the specified file, or the files in the specified directory. If
  the <code>long</code> option is given, produces a "long" listing including the file
  info (you may also specify the <code>filist</code> option: see <a href="#stat/2" class="seealso">stat/2</a>).</p>
</div></div>
<div class="function">
<h3 id="tee/1">tee(Expr::term(), File::filespec()) -&gt; term()</h3>


<div class="description">

<p>Writes the term to the file(s) specified, and returns it.</p>
</div></div>
<div class="function">
<h3 id="tee/3">tee(Expr, File, Opt) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="rm/1">rm(Files::filespec()) -&gt; Results</h3>


<div class="description">

<p>Equivalent to <a href="#rm/2" class="seealso">rm/2</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="rm/1-1">rm(Files::filespec(), Opt::options()) -&gt; results()</h3>


<div class="description">

<p>Remove the specified files. If the <code>verbose</code> option is given, a result
  is returned for every file removed. Otherwise, only files which encountered
  an error have entries in the result list.</p>
</div></div>
<div class="function">
<h3 id="mv/1">mv(From::filespec(), Destination::filename()) -&gt; results()</h3>


<div class="description">

<p>Equivalent to <a href="#mv/3" class="seealso">mv/3</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="cp/1">cp(From::filespec(), Destination::filename()) -&gt; results()</h3>


<div class="description">

<p>Equivalent to <a href="#cp/3" class="seealso">cp/3</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="mv/1-1">mv(From::filespec(), Destination::filename(), Opt::options()) -&gt; results()</h3>


<div class="description">

<p>Moves the specified files to their destination. If the destination is
  a new filename, only one file may be specified. The <code>verbose</code> option
  may be given with the same effect as with <a href="#rm/2" class="seealso">rm/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cp/1-1">cp(From::filespec(), Destination::filename(), Opt::options()) -&gt; results()</h3>


<div class="description">

<p>Copies the specified files to their destination. If the destination is
  a new filename, only one file may be specified. The <code>verbose</code> option
  may be given with the same effect as with <a href="#rm/2" class="seealso">rm/2</a>.</p>
</div></div>
<div class="function">
<h3 id="glob/1">glob(Files::filespec()) -&gt; [File]</h3>

<ul class="type">
<li><code>File = string()</code></li></ul>
<div class="description">

<p>Given the atom, string, list of atoms, list of strings, expand any
  wildcards found and return the result as a list of strings.</p>
</div></div>
<div class="function">
<h3 id="mkdir/1">mkdir(Directory::filename()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Equivalent to <a href="#mkdir/2" class="seealso">mkdir/2</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="mkdir/1-1">mkdir(Directory::filename(), Opt::options()) -&gt; ok | {error, term()}</h3>


<div class="description">

<p>Makes the specified directory. If the <code>path</code> option is given, also
  creates leading directory components.</p>
</div></div>
<div class="function">
<h3 id="output/1">output(Command::string()) -&gt; term()</h3>


<div class="description">

<p>Return the saved output from the completed background command
  (see <a href="#bg/1" class="seealso">bg/1</a>).</p>
</div></div>
<div class="function">
<h3 id="start_job_server/0">start_job_server() -&gt; ok | joberror()</h3>


<div class="description">

<p>Starts the background job server, required for background command
  invocation (see <a href="#bg/1" class="seealso">bg/1</a>).</p>
</div></div>
<div class="function">
<h3 id="stop_job_server/0">stop_job_server() -&gt; stop</h3>


<div class="description">

<p>Stops job server.</p>
</div></div>
<div class="function">
<h3 id="bg/1">bg(Cmd::command()) -&gt; Job</h3>

<ul class="type">
<li><code>Job = {job, JobId, command()}</code></li><li><code>JobId = term()</code></li></ul>
<div class="description">

<p>Submit a background command for execution. The returned JobId can be
  used to kill the job if necessary.</p>
</div></div>
<div class="function">
<h3 id="jobs/0">jobs() -&gt; [Job]</h3>

<ul class="type">
<li><code>Job = {job, JobId, command()}</code></li><li><code>JobId = term()</code></li></ul>
<div class="description">

<p>List currently executing background commands. Note: completed
  jobs will not be reflected in this list. Once a command is complete its
  output can be returned with the <a href="#output/1" class="seealso">output/1</a> command.</p>
</div></div>
<div class="function">
<h3 id="kill/1">kill(Job::JobId) -&gt; {killed, Job} | joberror()</h3>

<ul class="type">
<li><code>JobId = term()</code></li><li><code>Job = {job, term(), command()}</code></li></ul>
<div class="description">

<p>Kill a currently executing background command.</p>
</div></div>
<div class="function">
<h3 id="system/1">system(Cmd::command()) -&gt; Lines</h3>

<ul class="type">
<li><code>Lines = [string()]</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#system/2" class="seealso">system/2</a> with no options.</p>
</div></div>
<div class="function">
<h3 id="system/1-1">system(Cmd::command(), Opt::options()) -&gt; Lines</h3>

<ul class="type">
<li><code>Lines = [string()]</code></li></ul>
<div class="description">

<p>Execute the given shell (real shell) command, returning the
  output as a list of lines. The <code>nochomp</code> option can be specified
  (see <a href="#cat/2" class="seealso">cat/2</a>). If the <code>background</code> option is specified this
  command is equivalent to <a href="#bg/1" class="seealso">bg/1</a>.</p>
</div></div>
<div class="function">
<h3 id="split/2">split(Pred::Separator, List::string()) -&gt; [string()]</h3>


<div class="description">

<p>Equivalent to <a href="#split/3" class="seealso">split/3</a> with no limit on the number of strings
  returned.</p>
</div></div>
<div class="function">
<h3 id="split/2-1">split(Pred::Separator, List::string(), Limit::integer()) -&gt; [string()]</h3>

<ul class="type">
<li><code>Separator = char() | string() | {regex, string()} | '_' | ',' | function()</code></li></ul>
<div class="description">

<p>Splits the given string with the supplied separator, generating  
at most the number of substrings indicated as the limit.</p>
 
  <p>The separator may be a single character (integer) value, a substring
  (the string will be split on this substring), a tuple indicating
  a string to be applied as a regular expression (the string will be
  split on the matching sections), a function (the string will be
  split on the single character (list element) for which the fun
  returns <code>true</code>.</p>
 
  <p>The separator can also be a "magic" atom. The single-space atom
  (<code>' '</code> or <code>space</code>) splits the string on a run of
  whitespace similar to %% <a href="string.html#words/1" class="seealso">string:words/1</a>. The comma atom
  (<code>','</code> or <code>comma</code>) splits the string on a comma,
  optionally surrounded by spaces.</p>
</div></div>
<div class="function">
<h3 id="chop/1">chop(L::list()) -&gt; list()</h3>


<div class="description">

<p>Removes the list element of the list.</p>
</div></div>
<div class="function">
<h3 id="join/2">join(S::Separator, L::[string()]) -&gt; string()</h3>

<ul class="type">
<li><code>Separator = char() | string()</code></li></ul>
<div class="description">

<p>Joins the list of strings with the supplied separator. This is
  different from <a href="string.html#join/2" class="seealso">string:join/2</a> in that the separator can be
  a character, and the order is reversed (and thereby aligned with
  Perl <code>join()</code>.</p>
</div></div>
<div class="function">
<h3 id="clock/1">clock(F::function()) -&gt; {Timing, term()}</h3>

<ul class="type">
<li><code>Timing = [{Attribute, term()}]</code></li><li><code>Attribute = io | reductions | runtime | real</code></li></ul>
<div class="description">

<p>This is the equivalent of the <code>time</code> command. It runs the specified
  function, taking statistics, and returns a tuple containing timing
  information such as the bytes of I/O (input and output), the approximate
  number of reductions, the run time and the real (elapsed) time--both in
  milliseconds.</p>
</div></div>
<div class="function">
<h3 id="find/1">find(Dir::filespec()) -&gt; [File]</h3>

<ul class="type">
<li><code>File = string()</code></li></ul>
<div class="description">

<p>Equivalent to <a href="#find/2" class="seealso">find/2</a> with no find-arguments.</p>
</div></div>
<div class="function">
<h3 id="find/1-1">find(Dir::filespec(), Args::FindArgs) -&gt; [Result]</h3>

<ul class="type">
<li><code>FindArgs = [FindArg]</code></li><li><code>FindArg = {Predicate, Value::term()} | function() | {exec, function()}</code></li><li><code>Predicate = mtime | type | access | atime | ctime | mode | links | major_device | minor_device | inode | uid | gid</code></li></ul>
<div class="description">

<p>Descends the filesystem hierarchy rooted at the given directory/ies,
  applying the predicates (if any) to identify matching files. The predicate
  can be one of standard file attributes (interpreted in one or two cases
  as the Unix command <code>find</code> does, notably <code>mtime</code>) or it can be a fun,
  in which case the file is included in the result if the fun (taking
  the one argument of the filename) returns <code>true</code>. All of the predicates  
must be true to include the file.</p>
 
  <p>Normally, the file is included in the result list. However, if one or more
  argument of the form <code>{exec, Function}</code> is specified, the function is run
  instead (with the one argument of the filename) and its return value
  included. The filename is not automatically included if one of these exec
  functions is run, so if this is desired the fun will need to arrange for
  the filename to be indicated in the return value.
 </p>
</div></div></div>

<authors>

<aname>partdavid at gmail.com</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
