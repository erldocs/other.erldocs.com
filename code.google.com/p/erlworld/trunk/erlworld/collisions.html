<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>collisions (erlworld) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>collisions</h1>
<h2 class="modsummary">This defines the interface for the collisions modules.</h2>
<div class="description">
<p>This defines the interface for the collisions modules.   
How they actually is entirely down to the implementor, this just defines   
the protocols and some boiler plate to connect the update, add, remove and   
collision detection functions to your code.</p>
  
   <p>To implement you pass in functions that define the actions to perform when   
those protocols are run. This is literally just a series of funs.</p>
  
   <p>It is intended that the user will never use this directly. Instead the World   
will pass calls on to this automatically at the appropriate time.</p>
  
   <p>All of the messages are one way messages where the response is to be   
performed by the fun provided. This allows the funs provided to pass work   
out to seperate processes.</p>
  
   Implementors should also take care to ensure that implementing collisions
   modules do not include actors intersecting against themselves (which should
   always be true).
  </div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/1">new(State::term(), AddFun, RemoveFun, RemoveAllFun, ApplyToIntersectingActorsFun, ApplyToIntersectingActorFun) -&gt; Collisions::collisions()</h3>


<div class="description">

<p>This creates a new Collisions object defined by the functions given.  
The state is the internal state of the collisions object. The funs provided  
implement each of the functions required by the collisions object.</p>
 
  <p>To implement a new type of collisions you only need to call this function and
  pass in the required values. No more then that.
 </p>
</div></div>
<div class="function">
<h3 id="add/1">add(Colls::collisions(), Actor::actor()) -&gt; ok</h3>


<div class="description">

<p>This is called to add an actor to the collisions object.
  Any future check for an intersection should now include the actor given.</p>
</div></div>
<div class="function">
<h3 id="remove/1">remove(Colls::collisions(), Actor::actor()) -&gt; ok</h3>


<div class="description">

<p>This is called whenever an Actor is to be removed from the collisions object.
  From now on when an actor is checked for collisions, the actor provided should
  not be included as a part of the intersecting actors.</p>
</div></div>
<div class="function">
<h3 id="remove_all/1">remove_all(Colls::collisions()) -&gt; ok</h3>


<div class="description">

<p>This removes all actors stored inside of this collisions object.</p>
</div></div>
<div class="function">
<h3 id="apply_to_intersecting_actors/5">apply_to_intersecting_actors(Colls, Sender, Actor, CheckFun, OnCollFun) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="apply_to_intersecting_actors/6">apply_to_intersecting_actors(Colls, Sender, OtherName, Actor, CheckFun, OnCollFun) -&gt; term()
</h3>


<div class="description">

<p>This will search for all actors that intersect the given actor.
  All of the intersecting actors will be run on the OnCollFunc, and then a true
  or false will be sent back to the Sender.
  Note that this returns directly and the result will be sent to the Sender
  process id.</p>
</div></div>
<div class="function">
<h3 id="apply_to_intersecting_actor/5">apply_to_intersecting_actor(Colls, Sender, Actor, CheckFun, OnCollFun) -&gt; term()
</h3>


<div class="description">
 </div></div>
<div class="function">
<h3 id="apply_to_intersecting_actor/6">apply_to_intersecting_actor(Colls, Sender, OtherName, Actor, CheckFun, OnCollFun) -&gt; term()
</h3>


<div class="description">

<p>This will search for one actors that intersect the given actor.
  The intersecting actor will be passed into the OnCollFunc, and then a true
  or false will be sent back to the Sender.
  Note that this returns directly and the result will be sent to the Sender
  process id.</p>
</div></div></div>

<authors>

<aname>Joseph Lenton</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
