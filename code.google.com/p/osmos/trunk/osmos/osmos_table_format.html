<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>osmos_table_format (osmos) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>osmos_table_format</h1>
<h2 class="modsummary">A table format controls the on-disk format of keys and values in  
a table, and the rules for updating, querying, and deleting records  
from the table.</h2>
<div class="description">
<p>A table format controls the on-disk format of keys and values in  
a table, and the rules for updating, querying, and deleting records  
from the table.</p>
 
  <p>An #osmos_table_format{} record has the following fields:
  </p><list>
  <item><p>block_size (<code>integer()</code>): block size of the table in bytes,
      controlling the size of disk reads (which are always whole blocks),
      and the fanout of the on-disk search trees. The block size should
      be at least several times larger than the average record in the
      table. If it is too small, there will be more wasted space, and
      more seeks and reads will be required to search the table. If it is
      too large, the table will consume more i/o bandwidth and CPU than
      necessary.</p></item>
  <item><p>key_format (<code>#osmos_format{}</code>): on-disk format for keys.</p></item>
  <item><p>key_less (<code>(KeyA, KeyB) -&gt; bool()</code>): comparison function
      defining the order of keys in the table. Takes two native-format
      keys, and returns true if the first argument is less than the
      second argument.</p></item>
  <item><p>value_format (<code>#osmos_format{}</code>): on-disk format for
      values.</p></item>
  <item><p>merge (<code>(Key, EarlierValue, LaterValue) -&gt; MergedValue</code>):      
function providing a rule for merging records with identical      
keys. Takes the key and the two values in the order they were      
written to the table, and returns a new value for the merged      
record.</p>
 
      <p>The merge function must be associative, i.e.,
      </p><pre class="sh_erlang">
      Merge (K, Merge (K, V1, V2), V3) =:= Merge (K, V1, Merge (K, V2, V3))
      </pre><p>
      for any sequence of values V1, V2, V3 for a particular key K.
      That is, the final result of merging a sequence of values
      by temporally adjacent pairs must be the same no matter in which
      order the pairs are chosen.</p></item>
  <item><p>short_circuit (<code>(Key, Value) -&gt; bool()</code>): function
      which allows searches of the table to be terminated early
      (short-circuited) if it can be determined from a record that
      any earlier records with the same key are irrelevant. For
      example, if the merge function always returns the later
      value, so that a later value simply replaces an earlier
      value, then short_circuit should always return true. Or if
      there is a special value that indicates deletion of any
      previous record, then short_circuit should return true for that
      value.</p></item>
  <item><p>delete (<code>(Key, Value) -&gt; bool()</code>): function
      controlling when records are deleted from the table. If,
      after all merging is done for a particular key, this
      function returns true for the key's final record, the record
      will be deleted from the table, and reads will return
      not_found.</p></item>
  </list></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="new/3">new(KeyType, ValueType, BlockSize::integer()) -&gt; #osmos_table_format{}</h3>

<ul class="type">
<li><code>KeyType = binary | term | string_vector</code></li><li><code>ValueType = term_replace | binary_replace | uint64_sum_delete | uint64_vector_sum_delete</code></li></ul>
<div class="description">

<p>Return a table format with the given key and value types, and  
the given block size in bytes.</p>
 
  <p>The key type controls the ordering of keys and their on-disk format.
  The recognized key types are:
  </p><list>
  <item><p>term: keys are any Erlang term, compared using the term order;
      on-disk format is the external term format</p></item>
  <item><p>binary: keys are binaries, compared lexically;
      on-disk format is the identical binary</p></item>
  <item><p>string_vector: keys are tuples of strings represented as binaries,
      which may not contain ASCII NUL, and are compared lexically
      element by element; on-disk format is the strings NUL-terminated
      and concatenated.</p></item>
  </list>
 
  <p>The value type controls the on-disk format of values and the semantics
  of writing to the table. The recognized value types are:
  </p><list>
  <item><p>term_replace: values are any Erlang term, and the on-disk format is
      the external term format; a write replaces any previous value for
      the key, and deletions are not supported.</p></item>
  <item><p>binary_replace: values are binaries, and the on-disk format is the
      identical binary; a write replaces any previous value for the key,
      and deletions are not supported.</p></item>
  <item><p>uint64_sum_delete: values are integers in [0,2^64), and the on-disk
      format is 64-bit big-endian; writing an integer adds to the existing
      value if any, while writing the atom 'delete' deletes any existing
      value.</p></item>
  <item><p>uint64_vector_sum_delete: values are tuples of integers in [0,2^64),
      and the on-disk format is 64-bit big-endian concatenated; writing
      a vector adds to the existing value if any, while writing the atom
      'delete' deletes any existing value.</p></item>
  </list>
 
  <p>The block size controls the size of reads from disk. It should be at  
least several times larger than the average record in the table. (If it  
is too small, there will be more wasted space, and more seeks and reads  
will be required to search the table. If it is too large, the table will  
consume more i/o bandwidth and CPU than necessary.)</p>
 
  <p>Note that you are free to build your own #osmos_table_format{} record
  if these canned options don't meet your needs.</p>
</div></div>
<div class="function">
<h3 id="valid/1">valid(Format::#osmos_table_format{}) -&gt; bool()</h3>


<div class="description">

<p>Returns true if the argument appears to be a valid table format,
  false otherwise.</p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
