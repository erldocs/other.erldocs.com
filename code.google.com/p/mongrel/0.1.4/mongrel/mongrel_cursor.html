<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>mongrel_cursor (mongrel) -  (Erlang Documentation)</title>
    <link href="/erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-54292016-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>mongrel_cursor</h1>
<h2 class="modsummary">Mongrel cursor process.</h2>
<div class="description">
<p>Mongrel cursor process. This module provides functions for getting documents from a cursor.
        Unlike a mongo cursor, this cursor may need to read from the database when the cursor
        is read since the document that is read may reference nested documents that need to be
        fetched.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr />
    <div class="type"><h3 id="type-cursor">cursor() = pid()</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr />
<div class="function">
<h3 id="cursor/1">cursor(MongoCursor::cursor() (see module mongo), WriteMode::write_mode() (see module mongo), ReadMode::read_mode() (see module mongo), Connection::connection() (see module mongo) | rs_connection() (see module mongo), Database::db() (see module mongo), Collection::collection() (see module mongo), TimeoutInMilliseconds::integer()) -&gt; cursor()</h3>


<div class="description">

<p>Creates a cursor using a specified connection to a database collection. The cursor is
       configured to timeout after a specified length of inactivity. If the cursor has to return
       a document containing nested documents, the connection parameters are used to read the
       nested documents.</p>
</div></div>
<div class="function">
<h3 id="next/1">next(Cursor::cursor()) -&gt; record() | {}</h3>


<div class="description">

<p>Returns the next record from the cursor or an empty tuple if no more documents
       are available.
 </p>
</div></div>
<div class="function">
<h3 id="rest/1">rest(Cursor::cursor()) -&gt; [record()]</h3>


<div class="description">

<p>Returns a list of records referenced by a cursor.
 </p>
</div></div>
<div class="function">
<h3 id="get_mongo_cursor/1">get_mongo_cursor(Cursor::cursor()) -&gt; cursor() (see module mongo)</h3>


<div class="description">

<p>Returns the mongo:cursor() used by a mongrel:cursor(). Using the mongo:cursor() can
       be significantly faster than the mongrel:cursor() since it returns documents
       from a single collection rather than constructed records which involves eagerly
       loading record fields which may require several trips to the database.
 </p>
</div></div>
<div class="function">
<h3 id="close/1">close(Cursor::cursor()) -&gt; ok</h3>


<div class="description">

<p>Closes the cursor. This involves terminating the cursor gen_server process.
 </p>
</div></div>
<div class="function">
<h3 id="set_timeout/1">set_timeout(Cursor::cursor(), Timeout::integer()) -&gt; ok</h3>


<div class="description">

<p>Sets a timeout for the cursor. If no functions are invoked on the cursor within the specified
       timeframe, the cursor is closed.</p>
</div></div>
<div class="function">
<h3 id="init/1">init(X1::list()) -&gt; {ok, State::record(), Timeout::integer()}</h3>


<div class="description">

<p>Initializes the cursor with a MongoDB cursor and connection.
 </p>
</div></div>
<div class="function">
<h3 id="handle_call/1">handle_call(X1::atom(), From::pid(), State::record()) -&gt; tuple()</h3>


<div class="description">

<p>Responds to synchronous messages. Synchronous messages are sent to get the next record,
       to get the rest of the messages, to get the mongo:cursor() and to close the cursor.
 </p>
</div></div>
<div class="function">
<h3 id="handle_cast/1">handle_cast(Message::any(), State::record()) -&gt; {no_reply, State}</h3>


<div class="description">

<p>Responds asynchronously to messages. Asynchronous messages are ignored.</p>
</div></div>
<div class="function">
<h3 id="handle_info/1">handle_info(Info::any(), State::record()) -&gt; tuple()</h3>


<div class="description">

<p>Responds to non-OTP messages. The only out-of-band message of interest is a timeout.
       A timeout indicates that there has been no activity invoking the cursor for a
       specified time. The cursor process is terminated on a timeout. All other messages are
       ignored.</p>
</div></div>
<div class="function">
<h3 id="terminate/1">terminate(Reason::any(), State::record()) -&gt; ok</h3>


<div class="description">

<p>Handles the shutdown of the server.</p>
</div></div>
<div class="function">
<h3 id="code_change/1">code_change(OldVersion::any(), State::record(), Extra::any()) -&gt; {ok, State}</h3>


<div class="description">

<p>Responds to code changes. Code change events are ignored.</p>
</div></div></div>

<authors>

<aname>CA Meijer</aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="/erldocs.js"></script>
  </body>
</html>
